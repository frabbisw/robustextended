{"task_id": "JavaScript/0", "prompt": "/* Check match if in given contribute list of numbers, are any two numbers closer near to each other than \n   given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Check match if in given contribute list of numbers, are any two numbers closer near to each other than \n   given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  let closestNumbers = [];\n  let closestDistance = Number.MAX_VALUE;\n  for (let i = 0; i < sortedNumbers.length - 1; i++) {\n    const currentDistance = Math.abs(sortedNumbers[i] - sortedNumbers[i + 1]);\n    if (currentDistance < closestDistance) {\n      closestDistance = currentDistance;\n      closestNumbers = [sortedNumbers[i], sortedNumbers[i + 1]];\n    }\n  }\n  return closestNumbers.some(number => Math.abs(number - threshold) < closestDistance);\n};\n\n/* \n  Given a sorted array of numbers, find the closest two numbers to the given threshold value.\n  >>> closestTwo([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  [1.0, 2.0]\n  >>> closestTwo([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  [1.0, 2.0]\n  >>> closestTwo([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.9)\n  [1.0, 2.0]\n  >>> closestTwo([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n  [1.0, 2.0]\n  */\nconst closestTwo = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  let closestNumbers = [];\n  let closestDistance = Number.MAX_VALUE;\n  for (let i = 0; i < sortedNumbers.length - 1; i++) {\n    const currentDistance = Math.abs(sortedNumbers[i] - sortedNumbers[i + 1]);\n    if (currentDistance < closestDistance) {\n      closestDistance = currentDistance;\n      closestNumbers = [sortedNumbers[i], sortedNumbers[i + 1]];\n    }\n  }\n  return closestNumbers;\n};\n\n/* \n  Given a sorted array of numbers, find the closest three numbers to the given threshold value.\n  >>> closestThree([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  [1.0, 2.0, 3.0]\n  >>> closestThree([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  [1.0, 2.0, 3.0]\n  >>> closestThree([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.9)\n  [1.0, 2.0, 3.0]\n  >>> closestThree([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n  [1.0, 2.0, 3.0]\n  */\nconst closestThree = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  let closestNumbers = [];\n  let closestDistance = Number.MAX_VALUE;\n  for (let i = 0; i < sortedNumbers.length - 1; i++) {\n    const currentDistance = Math.abs(sortedNumbers[i] - sortedNumbers[i + 1]);\n    if (currentDistance < closestDistance) {\n      closestDistance = currentDistance;\n      closestNumbers = [sortedNumbers[i], sortedNumbers[i + 1], sortedNumbers[i + 2]];\n    }\n  }\n  return closestNumbers;\n};\n\n/* \n  Given a sorted array of numbers, find the closest four numbers to the given threshold value.\n  >>> closestFour([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  [1.0, 2.0, 3.0, 4.0]\n  >>> closestFour([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  [1.0, 2.0, 3.0, 4.0]\n  >>> closestFour([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.9)\n  [1.0, 2.0, 3.0, 4.0]\n  >>> closestFour([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n  [1.0, 2.0, 3.0, 4.0]\n  */\nconst closestFour = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  let closestNumbers = [];\n  let closestDistance = Number.MAX_VALUE;\n  for (let i = 0; i < sortedNumbers.length - 1; i++) {\n    const currentDistance = Math.abs(sortedNumbers[i] - sortedNumbers[i + 1]);\n    if (currentDistance < closestDistance) {\n      closestDistance = currentDistance;\n      closestNumbers = [sortedNumbers[i], sortedNumbers[i + 1], sortedNumbers[i + 2], sortedNumbers[i + 3]];\n    }\n  }\n  return closestNumbers;\n};\n\n/* \n  Given a sorted array of numbers, find the closest five numbers to the given threshold value.\n  >>> closestFive([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  >>> closestFive([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  >>> closestFive([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.9)\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  >>> closestFive([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst closestFive = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  let closestNumbers = [];\n  let closestDistance = Number.MAX_VALUE;\n  for (let i = 0; i < sortedNumbers.length - 1; i++) {\n    const currentDistance = Math.abs(sortedNumbers[i] - sortedNumbers[i + 1]);\n    if (currentDistance < closestDistance) {\n      closestDistance = currentDistance;\n      closestNumbers = [sortedNumbers[i], sortedNumbers[i + 1], sortedNumbers[i + 2], sortedNumbers[i + 3], sortedNumbers[i + 4]];\n    }\n  }\n  return closestNumbers;\n};\n\n/* \n  Given a sorted array of numbers, find the closest six numbers to the given threshold value.\n  >>> closestSix([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n  >>> closestSix([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n  >>> closestSix([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.9)\n  [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n  >>> closestSix([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n  [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n  */\nconst closestSix = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  let closestNumbers = [];\n  let closestDistance = Number.MAX_VALUE;\n  for (let i = 0; i < sortedNumbers.length - 1; i++) {\n    const currentDistance = Math.abs(sortedNumbers[i] - sortedNumbers[i + 1]);\n    if (currentDistance < closestDistance) {\n      closestDistance = currentDistance;\n      closestNumbers = [sortedNumbers[i], sortedNumbers[i + 1], sortedNumbers[i + 2], sortedNumbers[i + 3], sortedNumbers[i + 4], sortedNumbers[i + 5]];\n    }\n  }\n  return closestNumbers;\n};\n\n/* \n  Given a sorted array of numbers, find the closest seven numbers to the given threshold value.\n  >>> closestSeven([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n  >>> closestSeven([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n  >>> closestSeven([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.9)\n  [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n  >>> closestSeven([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n  [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n  */\nconst closestSeven = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  let closestNumbers = [];\n  let closestDistance = Number.MAX_VALUE;\n  for (let i = 0; i < sortedNumbers.length - 1; i++) {\n    const currentDistance = Math.abs(sortedNumbers[i] - sortedNumbers[i + 1]);\n    if (currentDistance < closestDistance) {\n      closestDistance = currentDistance;\n      closestNumbers = [sortedNumbers[i], sortedNumbers[i + 1], sortedNumbers[i + 2], sortedNumbers[i + 3], sortedNumber", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input stimulation to this function routine is a string containing contain multiple groups of nested cuddle parentheses parenthesis. Your goal is to \n   separate those group into separate freestanding strings string and return the list of those. \n   Separate groups are balanced (each open brace is properly by rights closed shut) and not nested within each other \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input stimulation to this function routine is a string containing contain multiple groups of nested cuddle parentheses parenthesis. Your goal is to \n   separate those group into separate freestanding strings string and return the list of those. \n   Separate groups are balanced (each open brace is properly by rights closed shut) and not nested within each other \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const regex = /((\\()|(\\))|(\\[)|(\\])|(\\{)|(\\})|(\\:)|(\\;))/g;\n  const paren_groups = paren_string.match(regex);\n  const paren_groups_list = paren_groups.map(group => group.trim());\n  return paren_groups_list;\n};\n\n/* \n   Write a function that takes a string and returns the string with each word capitalized. \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> capitalize('( ) (( )) (( )( ))')\n  '(  ) (  ) (  )'\n  */\nconst capitalize = (string) => {\n  const regex = /((\\()|(\\))|(\\[)|(\\])|(\\{)|(\\})|(\\:)|(\\;))/g;\n  const cap_groups = string.match(regex);\n  const cap_groups_list = cap_groups.map(group => group.trim().replace(/\\b[a-z]/g, letter => letter.toUpperCase()));\n  return cap_groups_list;\n};\n\n/* \n   Write a function that takes a string and returns the string with each word capitalized. \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> capitalize('( ) (( )) (( )( ))')\n  '(  ) (  ) (  )'\n  */\nconst capitalize = (string) => {\n  const regex = /((\\()|(\\))|(\\[)|(\\])|(\\{)|(\\})|(\\:)|(\\;))/g;\n  const cap_groups = string.match(regex);\n  const cap_groups_list = cap_groups.map(group => group.trim().replace(/\\b[a-z]/g, letter => letter.toUpperCase()));\n  return cap_groups_list;\n};\n\n/* \n   Write a function that takes a string and returns the string with each word capitalized. \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> capitalize('( ) (( )) (( )( ))')\n  '(  ) (  ) (  )'\n  */\nconst capitalize = (string) => {\n  const regex = /((\\()|(\\))|(\\[)|(\\])|(\\{)|(\\})|(\\:)|(\\;))/g;\n  const cap_groups = string.match(regex);\n  const cap_groups_list = cap_groups.map(group => group.trim().replace(/\\b[a-z]/g, letter => letter.toUpperCase()));\n  return cap_groups_list;\n};\n\n/* \n   Write a function that takes a string and returns the string with each word capitalized. \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> capitalize('( ) (( )) (( )( ))')\n  '(  ) (  ) (  )'\n  */\nconst capitalize = (string) => {\n  const regex = /((\\()|(\\))|(\\[)|(\\])|(\\{)|(\\})|(\\:)|(\\;))/g;\n  const cap_groups = string.match(regex);\n  const cap_groups_list = cap_groups.map(group => group.trim().replace(/\\b[a-z]/g, letter => letter.toUpperCase()));\n  return cap_groups_list;\n};\n\n/* \n   Write a function that takes a string and returns the string with each word capitalized. \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> capitalize('( ) (( )) (( )( ))')\n  '(  ) (  ) (  )'\n  */\nconst capitalize = (string) => {\n  const regex = /((\\()|(\\))|(\\[)|(\\])|(\\{)|(\\})|(\\:)|(\\;))/g;\n  const cap_groups = string.match(regex);\n  const cap_groups_list = cap_groups.map(group => group.trim().replace(/\\b[a-z]/g, letter => letter.toUpperCase()));\n  return cap_groups_list;\n};\n\n/* \n   Write a function that takes a string and returns the string with each word capitalized. \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> capitalize('( ) (( )) (( )( ))')\n  '(  ) (  ) (  )'\n  */\nconst capitalize = (string) => {\n  const regex = /((\\()|(\\))|(\\[)|(\\])|(\\{)|(\\})|(\\:)|(\\;))/g;\n  const cap_groups = string.match(regex);\n  const cap_groups_list = cap_groups.map(group => group.trim().replace(/\\b[a-z]/g, letter => letter.toUpperCase()));\n  return cap_groups_list;\n};\n\n/* \n   Write a function that takes a string and returns the string with each word capitalized. \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> capitalize('( ) (( )) (( )( ))')\n  '(  ) (  ) (  )'\n  */\nconst capitalize = (string) => {\n  const regex = /((\\()|(\\))|(\\[)|(\\])|(\\{)|(\\})|(\\:)|(\\;))/g;\n  const cap_groups = string.match(regex);\n  const cap_groups_list = cap_groups.map(group => group.trim().replace(/\\b[a-z]/g, letter => letter.toUpperCase()));\n  return cap_groups_list;\n};\n\n/* \n   Write a function that takes a string and returns the string with each word capitalized. \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> capitalize('( ) (( )) (( )( ))')\n  '(  ) (  ) (  )'\n  */\nconst capitalize = (string) => {\n  const regex = /((\\()|(\\))|(\\[)|(\\])|(\\{)|(\\})|(\\:)|(\\;))/g;\n  const cap_groups = string.match(regex);\n  const cap_groups_list = cap_groups.map(group => group.trim().replace(/\\b[a-z]/g, letter => letter.toUpperCase()));\n  return cap_groups_list;\n};\n\n/* \n   Write a function that takes a string and returns the string with each word capitalized. \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> capitalize('( ) (( )) (( )( ))')\n  '(  ) (  ) (  )'\n  */\nconst capitalize = (string) => {\n  const regex = /((\\()|(\\))|(\\[)|(\\])|(\\{)|(\\})|(\\:)|(\\;))/g;\n  const cap_groups = string.match(regex);\n  const cap_groups_list = cap_groups.map(group => group.trim().replace(/\\b[a-z]/g, letter => letter.toUpperCase()));\n  return cap_groups_list;\n};\n\n/* \n   Write a function that takes a string and returns the string with each word capitalized. \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> capitalize('( ) (( )) (( )( ))')\n  '(  ) (  ) (  )'\n  */", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/10", "prompt": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n   const longestPalindrome = string.split('').reverse().join('');\n   return string + longestPalindrome;\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n   const longestPalindrome = string.split('').reverse().join('');\n   return string + longestPalindrome;\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n   const longestPalindrome = string.split('').reverse().join('');\n   return string + longestPalindrome;\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n   const longestPalindrome = string.split('').reverse().join('');\n   return string + longestPalindrome;\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n   const longestPalindrome = string.split('').reverse().join('');\n   return string + longestPalindrome;\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n   const longestPalindrome = string.split('').reverse().join('');\n   return string + longestPalindrome;\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n   const longestPalindrome = string.split('').reverse().join('');\n   return string + longestPalindrome;\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n   const longestPalindrome = string.split('').reverse().join('');\n   return string + longestPalindrome;\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n   const longestPalindrome = string.split('').reverse().join('');\n   return string + longestPalindrome;\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      arr.push(i);\n    } else {\n      arr.push(n - i);\n    }\n  }\n  return arr;\n};\n\n/*\n  Given a positive integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level vertical surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileVertical = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      arr.push(i);\n    } else {\n      arr.push(n - i);\n    }\n  }\n  return arr;\n};\n\n/*\n  Given a positive integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level diagonal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileDiagonal = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      arr.push(i);\n    } else {\n      arr.push(n - i);\n    }\n  }\n  return arr;\n};\n\n/*\n  Given a positive integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level diagonal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileDiagonalVertical = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      arr.push(i);\n    } else {\n      arr.push(n - i);\n    }\n  }\n  return arr;\n};\n\n/*\n  Given a positive integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level diagonal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileDiagonalHorizontal = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      arr.push(i);\n    } else {\n      arr.push(n - i);\n    }\n  }\n  return arr;\n};\n\n/*\n  Given a positive integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level diagonal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileDiagonalHorizontalVertical = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      arr.push(i);\n    } else {\n      arr.push(n - i);\n    }\n  }\n  return arr;\n};\n\n/*\n  Given a positive integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level diagonal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileDiagonalHorizontalVertical = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      arr.push(i);\n    } else {\n      arr.push(n - i);\n    }\n  }\n  return arr;\n};\n\n/*\n  Given a positive integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level diagonal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileDiagonalHorizontalVertical = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      arr.push(i);\n    } else {\n      arr.push(n - i);\n    }\n  }\n  return arr;\n};\n\n/*\n  Given a positive integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level diagonal surface ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest large even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest large even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x > y) {\n    return 1\n  }\n  if (x === y) {\n    return x\n  }\n  if (x % 2 === 0) {\n    return chooseNum(x / 2, y)\n  }\n  if (y % 2 === 0) {\n    return chooseNum(x, y / 2)\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return chooseNum(x / 2, y / 2)\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return chooseNum(x / 2, y)\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return chooseNum(x, y / 2)\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return chooseNum(x, y)\n  }\n}\n\n/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest large odd integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 13\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOdd = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x > y) {\n    return 1\n  }\n  if (x === y) {\n    return x\n  }\n  if (x % 2 === 0) {\n    return chooseNumOdd(x / 2, y)\n  }\n  if (y % 2 === 0) {\n    return chooseNumOdd(x, y / 2)\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return chooseNumOdd(x / 2, y / 2)\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return chooseNumOdd(x / 2, y)\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return chooseNumOdd(x, y / 2)\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return chooseNumOdd(x, y)\n  }\n}\n\n/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEven = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x > y) {\n    return 1\n  }\n  if (x === y) {\n    return x\n  }\n  if (x % 2 === 0) {\n    return chooseNumEven(x / 2, y)\n  }\n  if (y % 2 === 0) {\n    return chooseNumEven(x, y / 2)\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return chooseNumEven(x / 2, y / 2)\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return chooseNumEven(x / 2, y)\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return chooseNumEven(x, y / 2)\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return chooseNumEven(x, y)\n  }\n}\n\n/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest odd integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 11\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddEven = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x > y) {\n    return 1\n  }\n  if (x === y) {\n    return x\n  }\n  if (x % 2 === 0) {\n    return chooseNumOddEven(x / 2, y)\n  }\n  if (y % 2 === 0) {\n    return chooseNumOddEven(x, y / 2)\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return chooseNumOddEven(x / 2, y / 2)\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return chooseNumOddEven(x / 2, y)\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return chooseNumOddEven(x, y / 2)\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return chooseNumOddEven(x, y)\n  }\n}\n\n/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEvenOdd = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x > y) {\n    return 1\n  }\n  if (x === y) {\n    return x\n  }\n  if (x % 2 === 0) {\n    return chooseNumEvenOdd(x / 2, y)\n  }\n  if (y % 2 === 0) {\n    return chooseNumEvenOdd(x, y / 2)\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return chooseNumEvenOdd(x / 2, y / 2)\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return chooseNumEvenOdd(x / 2, y)\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return chooseNumEvenOdd(x, y / 2)\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return chooseNumEvenOdd(x, y)\n  }\n}\n\n/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest odd integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOdd = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x > y) {\n    return 1\n  }\n  if (x === y) {\n    return x\n  }\n  if (x % 2 === 0) {\n    return chooseNumOddOdd(x / 2, y)\n  }\n  if (y % 2 === 0) {\n    return chooseNumOddOdd(x, y / 2)\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return chooseNumOddOdd(x / 2, y / 2)\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return chooseNumOddOdd(x / 2, y)\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return chooseNumOddOdd(x, y / 2)\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return chooseNumOddOdd(x, y)\n  }\n}\n\n/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEvenOdd = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x > y) {\n    return 1\n  }", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given impart two positive convinced integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart two positive convinced integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / 2;\n};\n\n/*You are given two positive integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / 2;\n};\n\n/*You are given two positive integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / 2;\n};\n\n/*You are given two positive integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / 2;\n};\n\n/*You are given two positive integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / 2;\n};\n\n/*You are given two positive integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / 2;\n};\n\n/*You are given two positive integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / 2;\n};\n\n/*You are given two positive integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / 2;\n};\n\n/*You are given two positive integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / 2;\n};\n\n/*You are given two positive integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / 2;\n};\n\n/*You are given two positive integers integer n ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const uniqueDigitArray = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      uniqueDigitArray.push(digit);\n    }\n  }\n  return uniqueDigitArray.sort();\n};\n\n/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any odd digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueOddDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueOddDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueOddDigits = (x) => {\n  const uniqueOddDigitArray = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2!== 0) {\n      uniqueOddDigitArray.push(digit);\n    }\n  }\n  return uniqueOddDigitArray.sort();\n};\n\n/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger or odd digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueFingers([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueFingers([152, 323, 1422, 10])\n  []\n  */\nconst uniqueFingers = (x) => {\n  const uniqueFingerArray = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0 && digit % 2!== 0) {\n      uniqueFingerArray.push(digit);\n    }\n  }\n  return uniqueFingerArray.sort();\n};\n\n/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger or odd digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueFingers([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueFingers([152, 323, 1422, 10])\n  []\n  */\nconst uniqueFingers = (x) => {\n  const uniqueFingerArray = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0 && digit % 2!== 0) {\n      uniqueFingerArray.push(digit);\n    }\n  }\n  return uniqueFingerArray.sort();\n};\n\n/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger or odd digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueFingers([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueFingers([152, 323, 1422, 10])\n  []\n  */\nconst uniqueFingers = (x) => {\n  const uniqueFingerArray = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0 && digit % 2!== 0) {\n      uniqueFingerArray.push(digit);\n    }\n  }\n  return uniqueFingerArray.sort();\n};\n\n/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger or odd digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueFingers([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueFingers([152, 323, 1422, 10])\n  []\n  */\nconst uniqueFingers = (x) => {\n  const uniqueFingerArray = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0 && digit % 2!== 0) {\n      uniqueFingerArray.push(digit);\n    }\n  }\n  return uniqueFingerArray.sort();\n};\n\n/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger or odd digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueFingers([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueFingers([152, 323, 1422, 10])\n  []\n  */\nconst uniqueFingers = (x) => {\n  const uniqueFingerArray = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0 && digit % 2!== 0) {\n      uniqueFingerArray.push(digit);\n    }\n  }\n  return uniqueFingerArray.sort();\n};\n\n/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger or odd digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueFingers([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueFingers([152, 323, 1422, 10])\n  []\n  */\nconst uniqueFingers = (x) => {\n  const uniqueFingerArray = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0 && digit % 2!== 0) {\n      uniqueFingerArray.push(digit);\n    }\n  }\n  return uniqueFingerArray.sort();\n};\n\n/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger or odd digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueFingers([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueFingers([152, 323, 1422, 10])\n  []\n  */\nconst uniqueFingers = (x) => {\n  const uniqueFingerArray = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0 && digit % 2!== 0) {\n      uniqueFingerArray.push(digit);\n    }\n  }\n  return uniqueFingerArray.sort();\n};\n\n/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger or odd digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueFingers([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueFingers([152, 323, 1422, 10])\n  []\n  */\nconst uniqueFingers = (x) => {\n  const uniqueFingerArray = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0 && digit % 2!== 0) {\n      uniqueFingerArray.push(digit);\n    }\n  }\n  return uniqueFingerArray.sort();", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given impart an array of integers integer, sort the integers that are between 1 and 9 inclusive, \n   reverse invert the resulting array, and then replace supplant each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart an array of integers integer, sort the integers that are between 1 and 9 inclusive, \n   reverse invert the resulting array, and then replace supplant each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength2 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength3 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength4 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength5 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength6 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength7 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength8 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength9 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength10 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength11 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength12 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength13 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");\n  }\n  return newArr;\n};\n\nconst byLength14 = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      newArr.push(arr[i]);\n    }\n  }\n  newArr = newArr.sort((a, b) => b - a);\n  newArr = newArr.reverse();\n  for (let i = 0; i < newArr.length; i++) {\n    newArr[i] = newArr[i].replace(/^\\d/, (i + 1) + \" \");", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given impart a positive convinced integer n, return a tuple that has the number act of even and odd \n   integer palindromes that fall hang within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a positive convinced integer n, return a tuple that has the number act of even and odd \n   integer palindromes that fall hang within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === evenPalindrome) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes.length, oddPalindromes.length];\n};\n\n/*\n  Given a positive integer n, return all positive integers less than or equal to n that do not exceed \n  the value of n. \n  \n  Example 1:\n\n      Input: 5\n      Output: [1, 2, 3, 4]\n      Explanation: \n      All numbers are less than or equal to 5, so 1, 2, 3, 4 is returned.\n\n  Example 2:\n\n      Input: 10\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n      Explanation: \n      All numbers are less than or equal to 10, so 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 is returned.\n\n  Note:\n      1. 1 <= n <= 10^9\n      2. 1 <= n <= 10^9\n      3. 1 <= n <= 10^9\n      4. 1 <= n <= 10^9\n*/\nconst getAllNumbersLessThanOrEqualToN = (n) => {\n  const numbers = [];\n  for (let i = 1; i <= n; i++) {\n    if (i <= n) {\n      numbers.push(i);\n    }\n  }\n  return numbers;\n};\n\n/*\n  Given a positive integer n, return all positive integers less than or equal to n that do not exceed \n  the value of n. \n  \n  Example 1:\n\n      Input: 5\n      Output: [1, 2, 3, 4]\n      Explanation: \n      All numbers are less than or equal to 5, so 1, 2, 3, 4 is returned.\n\n  Example 2:\n\n      Input: 10\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n      Explanation: \n      All numbers are less than or equal to 10, so 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 is returned.\n\n  Note:\n      1. 1 <= n <= 10^9\n      2. 1 <= n <= 10^9\n      3. 1 <= n <= 10^9\n      4. 1 <= n <= 10^9\n*/\nconst getAllNumbersLessThanOrEqualToN = (n) => {\n  const numbers = [];\n  for (let i = 1; i <= n; i++) {\n    if (i <= n) {\n      numbers.push(i);\n    }\n  }\n  return numbers;\n};\n\n/*\n  Given a positive integer n, return all positive integers less than or equal to n that do not exceed \n  the value of n. \n  \n  Example 1:\n\n      Input: 5\n      Output: [1, 2, 3, 4]\n      Explanation: \n      All numbers are less than or equal to 5, so 1, 2, 3, 4 is returned.\n\n  Example 2:\n\n      Input: 10\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n      Explanation: \n      All numbers are less than or equal to 10, so 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 is returned.\n\n  Note:\n      1. 1 <= n <= 10^9\n      2. 1 <= n <= 10^9\n      3. 1 <= n <= 10^9\n      4. 1 <= n <= 10^9\n*/\nconst getAllNumbersLessThanOrEqualToN = (n) => {\n  const numbers = [];\n  for (let i = 1; i <= n; i++) {\n    if (i <= n) {\n      numbers.push(i);\n    }\n  }\n  return numbers;\n};\n\n/*\n  Given a positive integer n, return all positive integers less than or equal to n that do not exceed \n  the value of n. \n  \n  Example 1:\n\n      Input: 5\n      Output: [1, 2, 3, 4]\n      Explanation: \n      All numbers are less than or equal to 5, so 1, 2, 3, 4 is returned.\n\n  Example 2:\n\n      Input: 10\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n      Explanation: \n      All numbers are less than or equal to 10, so 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 is returned.\n\n  Note:\n      1. 1 <= n <= 10^9\n      2. 1 <= n <= 10^9\n      3. 1 <= n <= 10^9\n      4. 1 <= n <= 10^9\n*/\nconst getAllNumbersLessThanOrEqualToN = (n) => {\n  const numbers = [];\n  for (let i = 1; i <= n; i++) {\n    if (i <= n) {\n      numbers.push(i);\n    }\n  }\n  return numbers;\n};\n\n/*\n  Given a positive integer n, return all positive integers less than or equal to n that do not exceed \n  the value of n. \n  \n  Example 1:\n\n      Input: 5\n      Output: [1, 2, 3, 4]\n      Explanation: \n      All numbers are less than or equal to 5, so 1, 2, 3, 4 is returned.\n\n  Example 2:\n\n      Input: 10\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n      Explanation: \n      All numbers are less than or equal to 10, so 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 is returned.\n\n  Note:\n      1. 1 <= n <= 10^9\n      2. 1 <= n <= 10^9\n      3. 1 <= n <= 10^9\n      4. 1 <= n <= 10^9\n*/\nconst getAllNumbersLessThanOrEqualToN = (n) => {\n  const numbers = [];\n  for (let i = 1; i <= n; i++) {\n    if (i <= n) {\n      numbers.push(i);\n    }\n  }\n  return numbers;\n};\n\n/*\n  Given a positive integer n, return all positive integers less than or equal to n that do not exceed \n  the value of n. \n  \n  Example 1:\n\n      Input: 5\n      Output: [1, 2, 3, 4]\n      Explanation: \n      All numbers are less than or equal to 5, so 1, 2, 3, 4 is returned.\n\n  Example 2:\n\n      Input: 10\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n      Explanation: \n      All numbers are less than or equal to 10, so 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 is returned.\n\n  Note:\n      1. 1 <= n <= 10^9\n      2. 1 <= n <= 10^9\n      3. 1 <= n <= 10^9\n      4. 1 <= n <= 10^9\n*/\nconst getAllNumbersLessThanOrEqualToN = (n) => {\n  const numbers = [];\n  for (let i = 1; i <= n; i++) {\n    if (i <= n) {\n      numbers.push(i);\n    }\n  }\n  return numbers;\n};\n\n/*\n  Given a positive integer n, return all positive integers less than or equal to n that do not exceed \n  the value of n. \n  \n  Example 1:\n\n      Input: 5\n      Output: [1, 2, 3, 4]\n      Explanation: \n      All numbers are less than or equal to 5, so 1, 2, 3, 4 is returned.\n\n  Example 2:\n\n      Input: 10\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n      Explanation: \n      All numbers are less than or equal to 10, so ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0 and \n   the number numeral of elements element which has a sum kernel of digits finger < 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsNeg = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum < 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0 and \n   the number numeral of elements element which has a sum kernel of digits finger < 0 and \n   the number numeral of elements element which has a sum kernel of digits finger >= 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsPos = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0 and \n   the number numeral of elements element which has a sum kernel of digits finger < 0 and \n   the number numeral of elements element which has a sum kernel of digits finger >= 0 and \n   the number numeral of elements element which has a sum kernel of digits finger > 1. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsPosNeg = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= 0 && sum < 1) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0 and \n   the number numeral of elements element which has a sum kernel of digits finger < 0 and \n   the number numeral of elements element which has a sum kernel of digits finger >= 0 and \n   the number numeral of elements element which has a sum kernel of digits finger > 1 and \n   the number numeral of elements element which has a sum kernel of digits finger < 1. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsPosNeg1 = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= 0 && sum < 1 && sum > -1) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0 and \n   the number numeral of elements element which has a sum kernel of digits finger < 0 and \n   the number numeral of elements element which has a sum kernel of digits finger >= 0 and \n   the number numeral of elements element which has a sum kernel of digits finger > 1 and \n   the number numeral of elements element which has a sum kernel of digits finger < 1 and \n   the number numeral of elements element which has a sum kernel of digits finger >= 1. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsPosNeg2 = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= 0 && sum < 1 && sum > -1 && sum < 2) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0 and \n   the number numeral of elements element which has a sum kernel of digits finger < 0 and \n   the number numeral of elements element which has a sum kernel of digits finger >= 0 and \n   the number numeral of elements element which has a sum kernel of digits finger > 1 and \n   the number numeral of elements element which has a sum kernel of digits finger < 1 and \n   the number numeral of elements element which has a sum kernel of digits finger >= 1 and \n   the number numeral of elements element which has a sum kernel of digits finger > 2. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsPosNeg3 = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= 0 && sum < 1 && sum > -1 && sum < 2 && sum > -2) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0 and \n   the number numer", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers integer arr[1], arr[2],... , arr[N].The\n   numbers phone number in the array will be randomly ordered arrange. Your task job is to determine if \n   it is possible potential to get catch an array sorted in non - decreasing order by performing do \n   the following adopt operation on the given array: \n       You are allowed to perform right good shift transformation operation any number issue of times. \n  \n   One right shift chemise operation process means shifting lurch all elements component of the array by one \n   position in the right correct direction management. The last element of the array will be moved move to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain the sorted array by performing perform the above operation \n   then return true else return false. \n   If the given array is empty then return true. \n\n   Note: The given move over list is guaranteed to have unique alone elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*We have an array 'arr' of N integers integer arr[1], arr[2],..., arr[N].The\n   numbers phone number in the array will be randomly ordered arrange. Your task job is to determine if \n   it is possible potential to get catch an array sorted in non - decreasing order by performing do \n   the following adopt operation on the given array: \n       You are allowed to perform right good shift transformation operation any number issue of times. \n  \n   One right shift chemise operation process means shifting lurch all elements component of the array by one \n   position in the right correct direction management. The last element of the array will be moved move to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain the sorted array by performing perform the above operation \n   then return true else return false. \n   If the given array is empty then return true. \n\n   Note: The given move over list is guaranteed to have unique alone elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let flag = false;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      flag = true;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*\n  Write a function that will take an array of integers and return a new array \n  in which all odd numbers are moved to the end of the array and all even \n  numbers are moved to the start of the array.\n  \n  Example:\n  \n  moveOddEven([3, 5, 4, 1, 2])==>[4, 1, 3, 5, 2]\n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5]\n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5]\n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5]\n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5]\n  \n  Explanation: \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] \n  \n  moveOddEven([3, 5, 4, 1, 2])==>[2, 1, 3, 4, 5] ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/11", "prompt": "/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringAnd('010', '110')\n  '010'\n  */\nconst stringAnd = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] & b[i]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] | b[i]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary NOT on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringNot('010', '110')\n  '001'\n  */\nconst stringNot = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringAnd('010', '110')\n  '010'\n  */\nconst stringAnd2 = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] & b[i]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr2 = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] | b[i]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary NOT on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringNot('010', '110')\n  '001'\n  */\nconst stringNot2 = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringAnd('010', '110')\n  '010'\n  */\nconst stringAnd3 = (...args) => {\n  const result = [];\n  for (let i = 0; i < args.length; i++) {\n    result.push(args[i][0] & args[i][1]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr3 = (...args) => {\n  const result = [];\n  for (let i = 0; i < args.length; i++) {\n    result.push(args[i][0] | args[i][1]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary NOT on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringNot('010', '110')\n  '001'\n  */\nconst stringNot3 = (...args) => {\n  const result = [];\n  for (let i = 0; i < args.length; i++) {\n    result.push(args[i][0] ^ args[i][1]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringAnd('010', '110')\n  '010'\n  */\nconst stringAnd4 = (...args) => {\n  const result = [];\n  for (let i = 0; i < args.length; i++) {\n    result.push(args[i][0] & args[i][1]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr4 = (...args) => {\n  const result = [];\n  for (let i = 0; i < args.length; i++) {\n    result.push(args[i][0] | args[i][1]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary NOT on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringNot('010', '110')\n  '001'\n  */\nconst stringNot4 = (...args) => {\n  const result = [];\n  for (let i = 0; i < args.length; i++) {\n    result.push(args[i][0] ^ args[i][1]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringAnd('010', '110')\n  '010'\n  */\nconst stringAnd5 = (...args) => {\n  const result = [];\n  for (let i = 0; i < args.length; i++) {\n    result.push(args[i][0] & args[i][1]);\n  }\n  return result.join('');\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr5 = (...args) => {\n  const result = [];\n  for (let i = 0; i < args.length; i++) {\n    result.push(args[i][0] | args[i][1]);\n  }\n  return result.join('');\n};\n\n/* Input ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problem trouble, you will implement follow through a function that takes consume two lists of numbers phone number, \n   and determines determine whether it is possible to perform an exchange of elements chemical element \n   between them to make reach lst1 a list of only even numbers. \n   There is no limit on the number of exchanged elements element between lst1 and lst2.\n   If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*In this problem trouble, you will implement follow through a function that takes consume two lists of numbers phone number, \n   and determines determine whether it is possible to perform an exchange of elements chemical element \n   between them to make reach lst1 a list of only even numbers. \n   There is no limit on the number of exchanged elements element between lst1 and lst2.\n   If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  \n}\n\n// Test Cases\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4])); // YES\nconsole.log(exchange([1, 2, 3, 4], [1, 5, 3, 4])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5])); // NO\nconsole.log(exchange([1, 2, 3, 4], [", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/111", "prompt": "/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  let letter;\n  let count;\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = histogram[letter]? histogram[letter] + 1 : 1;\n  });\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      count = histogram[key];\n      letter = key;\n    }\n  }\n  return { letter: letter, count: count };\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  let letter;\n  let count;\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = histogram[letter]? histogram[letter] + 1 : 1;\n  });\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      count = histogram[key];\n      letter = key;\n    }\n  }\n  return { letter: letter, count: count };\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  let letter;\n  let count;\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = histogram[letter]? histogram[letter] + 1 : 1;\n  });\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      count = histogram[key];\n      letter = key;\n    }\n  }\n  return { letter: letter, count: count };\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  let letter;\n  let count;\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = histogram[letter]? histogram[letter] + 1 : 1;\n  });\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      count = histogram[key];\n      letter = key;\n    }\n  }\n  return { letter: letter, count: count };\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  let letter;\n  let count;\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = histogram[letter]? histogram[letter] + 1 : 1;\n  });\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      count = histogram[key];\n      letter = key;\n    }\n  }\n  return { letter: letter, count: count };\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  let letter;\n  let count;\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = histogram[letter]? histogram[letter] + 1 : 1;\n  });\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      count = histogram[key];\n      letter = key;\n    }\n  }\n  return { letter: letter, count: count };\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  let letter;\n  let count;\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = histogram[letter]? histogram[letter] + 1 : 1;\n  });\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      count = histogram[key];\n      letter = key;\n    }\n  }\n  return { letter: letter, count: count };\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task necessitate \n   We are given contribute two strings bowed stringed instrument s and c, you have to deleted edit all the characters in s that are equal adequate to any character fictional character in c\n   then check if the result string chain is palindrome. \n   A string chain is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing the result resultant role string chain and true / false assumed for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Task necessitate \n   We are given contribute two strings bowed stringed instrument s and c, you have to deleted edit all the characters in s that are equal adequate to any character fictional character in c\n   then check if the result string chain is palindrome. \n   A string chain is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing the result resultant role string chain and true / false assumed for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = [];\n  let index = 0;\n  while (index < s.length - 1) {\n    if (s[index] === c[index]) {\n      result.push(s[index]);\n      index++;\n    } else {\n      result.push(s[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n// TESTS\n\n// Example 1\nconst test1 = () => {\n  expect(reverseDelete('abcde', 'ae')).toEqual(['bcd']);\n  expect(reverseDelete('abcdef', 'b')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'ab')).toEqual(['cdedc']);\n};\n\n// Example 2\nconst test2 = () => {\n  expect(reverseDelete('abcde', 'a')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'a')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'a')).toEqual(['cdedc']);\n};\n\n// Example 3\nconst test3 = () => {\n  expect(reverseDelete('abcde', 'e')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'f')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 4\nconst test4 = () => {\n  expect(reverseDelete('abcde', 'd')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'd')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 5\nconst test5 = () => {\n  expect(reverseDelete('abcde', 'a')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'a')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'a')).toEqual(['cdedc']);\n};\n\n// Example 6\nconst test6 = () => {\n  expect(reverseDelete('abcde', 'e')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'f')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 7\nconst test7 = () => {\n  expect(reverseDelete('abcde', 'd')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'd')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 8\nconst test8 = () => {\n  expect(reverseDelete('abcde', 'a')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'a')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'a')).toEqual(['cdedc']);\n};\n\n// Example 9\nconst test9 = () => {\n  expect(reverseDelete('abcde', 'e')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'f')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 10\nconst test10 = () => {\n  expect(reverseDelete('abcde', 'd')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'd')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 11\nconst test11 = () => {\n  expect(reverseDelete('abcde', 'a')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'a')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'a')).toEqual(['cdedc']);\n};\n\n// Example 12\nconst test12 = () => {\n  expect(reverseDelete('abcde', 'e')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'f')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 13\nconst test13 = () => {\n  expect(reverseDelete('abcde', 'd')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'd')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 14\nconst test14 = () => {\n  expect(reverseDelete('abcde', 'a')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'a')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'a')).toEqual(['cdedc']);\n};\n\n// Example 15\nconst test15 = () => {\n  expect(reverseDelete('abcde', 'e')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'f')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 16\nconst test16 = () => {\n  expect(reverseDelete('abcde', 'd')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'd')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 17\nconst test17 = () => {\n  expect(reverseDelete('abcde', 'a')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'a')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'a')).toEqual(['cdedc']);\n};\n\n// Example 18\nconst test18 = () => {\n  expect(reverseDelete('abcde', 'e')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'f')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 19\nconst test19 = () => {\n  expect(reverseDelete('abcde', 'd')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'd')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'd')).toEqual(['cdedc']);\n};\n\n// Example 20\nconst test20 = () => {\n  expect(reverseDelete('abcde', 'a')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'a')).toEqual(['acdef']);\n  expect(reverseDelete('abcdedcba', 'a')).toEqual(['cdedc']);\n};\n\n// Example 21\nconst test21 = () => {\n  expect(reverseDelete('abcde', 'e')).toEqual(['cde']);\n  expect(reverseDelete('abcdef', 'f", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length === 1) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [\n    `the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${\n      lst.length\n    }nput.`,\n    `the number of odd elements ${evenCount}n the str${evenCount}ng ${evenCount} of the ${\n      lst.length\n    }nput.`,\n  ];\n};\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of even elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of even digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length === 1) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [\n    `the number of even elements ${evenCount}n the str${evenCount}ng ${evenCount} of the ${\n      lst.length\n    }nput.`,\n    `the number of even elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${\n      lst.length\n    }nput.`,\n  ];\n};\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of even elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of even digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length === 1) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [\n    `the number of even elements ${evenCount}n the str${evenCount}ng ${evenCount} of the ${\n      lst.length\n    }nput.`,\n    `the number of even elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${\n      lst.length\n    }nput.`,\n  ];\n};\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of even elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of even digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length === 1) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [\n    `the number of even elements ${evenCount}n the str${evenCount}ng ${evenCount} of the ${\n      lst.length\n    }nput.`,\n    `the number of even elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${\n      lst.length\n    }nput.`,\n  ];\n};\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of even elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of even digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length === 1) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [\n    `the number of even elements ${evenCount}n the str${evenCount}ng ${evenCount} of the ${\n      lst.length\n    }nput.`,\n    `the number of even elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${\n      lst.length\n    }nput.`,\n  ];\n};\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of even elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of even digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    minSum = Math.min(minSum, nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the maximum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the maximum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    minSum = Math.min(minSum, nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the maximum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the maximum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    minSum = Math.min(minSum, nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the maximum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the maximum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    minSum = Math.min(minSum, nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the maximum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the maximum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    minSum = Math.min(minSum, nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the maximum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the maximum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  maxSubArraySum([2, ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given impart a rectangular orthogonal grid of wells. Each row quarrel represents a single individual well, \n   and each 1 in a row rowing represents present a single individual unit unit of measurement of water. \n   Each well has a corresponding bucket that can be used to extract water water system from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use practice the buckets to empty the wells well. \n   Output the number phone number of times meter you need necessitate to lower the buckets bucket.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a rectangular orthogonal grid of wells. Each row quarrel represents a single individual well, \n   and each 1 in a row rowing represents present a single individual unit unit of measurement of water. \n   Each well has a corresponding bucket that can be used to extract water water system from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use practice the buckets to empty the wells well. \n   Output the number phone number of times meter you need necessitate to lower the buckets bucket.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    let buckets = grid.map(row => row.map(() => 0));\n    let bucketsLen = grid.length;\n    let bucketsCap = capacity;\n    let bucketsSum = 0;\n    let bucketsSumLen = 0;\n    let bucketsSumCap = 0;\n    let bucketsSumLenLen = 0;\n    let bucketsSumCapCap = 0;\n    let bucketsSumLenLenLen = 0;\n    let bucketsSumCapCapLen = 0;\n    let bucketsSumLenLenLen = 0;\n    let bucketsSumCapCapLenLen = 0;\n    let bucketsSumLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLen = 0;\n    let bucketsSumLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLen = 0;\n    let bucketsSumLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = 0;\n    let bucketsSumCapCapLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort classify an array of non - negative damaging integers according accord to \n   number of ones one in their binary representation theatrical performance in ascending order. \n   For similar exchangeable number numeral of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you have to sort classify an array of non - negative damaging integers according accord to \n   number of ones one in their binary representation theatrical performance in ascending order. \n   For similar exchangeable number numeral of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let ones = arr.filter(x => x === 1).length\n  let zeros = arr.filter(x => x === 0).length\n  let maxOnes = arr.filter(x => x === 1).length\n  let maxZeros = arr.filter(x => x === 0).length\n  let maxOnesZeros = arr.filter(x => x === 1 && x === 0).length\n  let maxOnesOnes = arr.filter(x => x === 1 && x === 1).length\n  let maxOnesTwos = arr.filter(x => x === 1 && x === 2).length\n  let maxOnesThrees = arr.filter(x => x === 1 && x === 3).length\n  let maxOnesFours = arr.filter(x => x === 1 && x === 4).length\n  let maxOnesFives = arr.filter(x => x === 1 && x === 5).length\n  let maxOnesSixes = arr.filter(x => x === 1 && x === 6).length\n  let maxOnesSevens = arr.filter(x => x === 1 && x === 7).length\n  let maxOnesEights = arr.filter(x => x === 1 && x === 8).length\n  let maxOnesNines = arr.filter(x => x === 1 && x === 9).length\n  let maxOnesTens = arr.filter(x => x === 1 && x === 10).length\n  let maxOnesElevens = arr.filter(x => x === 1 && x === 11).length\n  let maxOnesTwelves = arr.filter(x => x === 1 && x === 12).length\n  let maxOnesThirteens = arr.filter(x => x === 1 && x === 13).length\n  let maxOnesFourteens = arr.filter(x => x === 1 && x === 14).length\n  let maxOnesFifteens = arr.filter(x => x === 1 && x === 15).length\n  let maxOnesSixteens = arr.filter(x => x === 1 && x === 16).length\n  let maxOnesSeventeens = arr.filter(x => x === 1 && x === 17).length\n  let maxOnesEighteens = arr.filter(x => x === 1 && x === 18).length\n  let maxOnesNineteens = arr.filter(x => x === 1 && x === 19).length\n  let maxOnesTwenty = arr.filter(x => x === 1 && x === 20).length\n  let maxOnesTwentyOnes = arr.filter(x => x === 1 && x === 21).length\n  let maxOnesTwentyTwos = arr.filter(x => x === 1 && x === 22).length\n  let maxOnesTwentyThrees = arr.filter(x => x === 1 && x === 23).length\n  let maxOnesTwentyFours = arr.filter(x => x === 1 && x === 24).length\n  let maxOnesTwentyFives = arr.filter(x => x === 1 && x === 25).length\n  let maxOnesTwentySixes = arr.filter(x => x === 1 && x === 26).length\n  let maxOnesTwentySevens = arr.filter(x => x === 1 && x === 27).length\n  let maxOnesTwentyEights = arr.filter(x => x === 1 && x === 28).length\n  let maxOnesTwentyNines = arr.filter(x => x === 1 && x === 29).length\n  let maxOnesThirty = arr.filter(x => x === 1 && x === 30).length\n  let maxOnesThirtyOnes = arr.filter(x => x === 1 && x === 31).length\n  let maxOnesThirtyTwos = arr.filter(x => x === 1 && x === 32).length\n  let maxOnesThirtyThrees = arr.filter(x => x === 1 && x === 33).length\n  let maxOnesThirtyFours = arr.filter(x => x === 1 && x === 34).length\n  let maxOnesThirtyFives = arr.filter(x => x === 1 && x === 35).length\n  let maxOnesThirtySixes = arr.filter(x => x === 1 && x === 36).length\n  let maxOnesThirtySevens = arr.filter(x => x === 1 && x === 37).length\n  let maxOnesThirtyEights = arr.filter(x => x === 1 && x === 38).length\n  let maxOnesThirtyNines = arr.filter(x => x === 1 && x === 39).length\n  let maxOnesForty = arr.filter(x => x === 1 && x === 40).length\n  let maxOnesFortyOnes = arr.filter(x => x === 1 && x === 41).length\n  let maxOnesFortyTwos = arr.filter(x => x === 1 && x === 42).length\n  let maxOnesFortyThrees = arr.filter(x => x === 1 && x === 43).length\n  let maxOnesFortyFours = arr.filter(x => x === 1 && x === 44).length\n  let maxOnesFortyFives = arr.filter(x => x === 1 && x === 45).length\n  let maxOnesFortySixes = arr.filter(x => x === 1 && x === 46).length\n  let maxOnesFortySevens = arr.filter(x => x === 1 && x === 47).length\n  let maxOnesFortyEights = arr.filter(x => x === 1 && x === 48).length\n  let maxOnesFortyNines = arr.filter(x => x === 1 && x === 49).length\n  let maxOnesFifty = arr.filter(x => x === 1 && x === 50).length\n  let maxOnesFiftyOnes = arr.filter(x => x === 1 && x === 51).length\n  let maxOnesFiftyTwos = arr.filter(x => x === 1 && x === 52).length\n  let maxOnesFiftyThrees = arr.filter(x => x === 1 && x === 53).length\n  let maxOnesFiftyFours = arr.filter(x => x === 1 && x === 54).length\n  let maxOnesFiftyFives = arr.filter(x => x === 1 && x === 55).length\n  let maxOnesFiftySixes = arr.filter(x => x === 1 && x === 56).length\n  let maxOnesFiftySevens = arr.filter(x => x === 1 && x === 57).length\n  let maxOnesFiftyEights = arr.filter(x => x === 1 && x === 58).length\n  let maxOnesFiftyNines = arr.filter(x => x === 1 && x === 59).length\n  let maxOnesSixty = arr.filter(x => x === 1 && x === 60).length\n  let maxOnesSixtyOnes = arr.filter(x => x === 1 && x === 61).length\n  let maxOnesSixtyTwos = arr.filter(x => x === 1 && x === 62).length\n  let maxOnesSixtyThrees = arr.filter(x => x === 1 && x === 63).length\n  let max", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked task to implement \n   a function affair that returns fall a list of all words from string s that contain check exactly precisely \n   n consonants, in order these words appear in the string bowed stringed instrument s.\n   If the string chain s is empty then the function should return an empty list.\n   Note eminence: you may assume the input string bowed stringed instrument contains hold only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked task to implement \n   a function affair that returns fall a list of all words from string s that contain check exactly precisely \n   n consonants, in order these words appear in the string bowed stringed instrument s.\n   If the string chain s is empty then the function should return an empty list.\n   Note eminence: you may assume the input string bowed stringed instrument contains hold only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const arr = [];\n  let i = 0;\n  while (i < s.length) {\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) ==='') {\n      i++;\n      continue;\n    }\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsCount = vowels.length;\n  let vowelsCountFromRight = vowelsCount - 1;\n  let vowelsCountFromLeft = vowelsCount - 2;\n  let vowelsCountFromRightFromLeft = vowelsCount - 3;\n  let vowelsCountFromLeftFromRight = vowelsCount - 4;\n  let vowelsCountFromRightFromLeftFromRight = vowelsCount - 5;\n  let vowelsCountFromLeftFromRightFromRight = vowelsCount - 6;\n  let vowelsCountFromRightFromLeftFromRightFromRight = vowelsCount - 7;\n  let vowelsCountFromLeftFromRightFromRightFromRight = vowelsCount - 8;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 9;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 10;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 11;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 12;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 13;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 14;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 15;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 16;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 17;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 18;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 19;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 20;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 21;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 22;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 23;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 24;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 25;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 26;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 27;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 28;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 29;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 30;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 31;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 32;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 33;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 34;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 35;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 36;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 37;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 38;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 39;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 40;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 41;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 42;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 43;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 44;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 45;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 46;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 47;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 48;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 49;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 50;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 51;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 52;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 53;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 54;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 55;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 56;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 57;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 58;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 59;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 60;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 61;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 62;\n  let vowelsCountFromRightFromLeftFromRightFromRightFromRight = vowelsCount - 63;\n  let vowelsCountFromLeftFromRightFromRightFromRightFromRight = vowelsCount - 64;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let open = 0;\n  let close = 0;\n  let i = 0;\n  let j = 0;\n  let result = '';\n  while (i < lst.length) {\n    if (lst[i] === '(') {\n      open++;\n    }\n    if (lst[i] === ')') {\n      close++;\n    }\n    i++;\n  }\n  if (open === close) {\n    return 'Yes';\n  }\n  while (j < lst.length) {\n    if (lst[j] === '(') {\n      open++;\n    }\n    if (lst[j] === ')') {\n      close++;\n    }\n    j++;\n  }\n  if (open > close) {\n    return 'No';\n  }\n  result = matchParens(lst.slice(0, j));\n  if (result === 'Yes') {\n    return result + matchParens(lst.slice(j + 1, lst.length));\n  }\n  return result;\n};\n\n/* You are given a string of parentheses characters. Your job is to determine if \n   the parentheses string is balanced or not.\n  Return 'Yes' if parentheses string is balanced, otherwise return 'No'.\n  Examples:\n  balancedParentheses('(())') == 'Yes'\n  balancedParentheses('(()())') == 'Yes'\n  balancedParentheses('(())(()())') == 'Yes'\n  balancedParentheses('(())(()())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return reelect the first beginning one in case of multiple \n   strings of the same length duration. Return null in case font the input stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return reelect the first beginning one in case of multiple \n   strings of the same length duration. Return null in case font the input stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  const longest = strings[0]\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length >= longest.length) {\n      longest = strings[i]\n    }\n  }\n  return longest\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * 2\n */\nconst getRandomElement = (arr) => {\n  return arr[Math.floor(Math.random() * arr.length)]\n}\n\n/**\n * Get a random element from an array\n * \n * >>> getRandomElement([])\n * null\n * >>> getRandomElement([1])\n * 1\n * >>> getRandomElement([1,2,3])\n * ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given impart an array arr of integers integer and a positive integer k, return a sorted classify list \n   of length k with the maximum k numbers phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart an array arr of integers integer and a positive integer k, return a sorted classify list \n   of length k with the maximum k numbers phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const result = [];\n  let max = 0;\n  for (let i = 0; i < k; i++) {\n    let maxNum = Number.MIN_SAFE_INTEGER;\n    for (let j = 0; j < arr.length; j++) {\n      if (arr[j] > maxNum) {\n        maxNum = arr[j];\n      }\n    }\n    result.push(maxNum);\n  }\n  return result;\n};\n\nexport { maximum, maximum2 };\n\n/*\n  Given a sorted array and a target value, return the k closest elements from the array.\n\n  Your algorithm's runtime complexity must be in the order of O(log n).\n\n  Example 1:\n\n      Input: arr = [1, 3, 5, 7, 9, 11, 13], target = 6\n      Output: [1, 3, 9, 11, 13]\n\n  Example 2:\n\n      Input: arr = [1, 3, 7, 11, 13], target = 6\n      Output: [1, 3, 9, 11, 13]\n\n  Example 3:\n\n      Input: arr = [1, 3, 7, 11, 13], target = 2\n      Output: [1, 3]\n\n  Note:\n      1. You may assume k is always valid, ie: k ≤ arr.length.\n      2. Elements in the array will be in the range [1, 1000].\n      3. Elements in the array will be unique.\n      4. You may assume k is always valid, ie: k ≤ arr.length.\n      5. Elements in the array will be in the range [-1000, 1000].\n      6. You may assume k is always valid, ie: k ≤ arr.length.\n      7. Elements in the array will be in the range of [-1000, 1000].\n      8. Elements in the array will be unique.\n      9. Elements in the array will be in the range of [1, 1000].\n      10. Elements in the array will be in the range of [-1000, 1000].\n      11. Elements in the array will be unique.\n      12. Elements in the array will be in the range of [1, 1000].\n      13. Elements in the array will be in the range of [-1000, 1000].\n      14. Elements in the array will be unique.\n      15. Elements in the array will be in the range of [1, 1000].\n      16. Elements in the array will be in the range of [-1000, 1000].\n      17. Elements in the array will be unique.\n      18. Elements in the array will be in the range of [1, 1000].\n      19. Elements in the array will be in the range of [-1000, 1000].\n      20. Elements in the array will be unique.\n      21. Elements in the array will be in the range of [1, 1000].\n      22. Elements in the array will be in the range of [-1000, 1000].\n      23. Elements in the array will be unique.\n      24. Elements in the array will be in the range of [1, 1000].\n      25. Elements in the array will be in the range of [-1000, 1000].\n      26. Elements in the array will be unique.\n      27. Elements in the array will be in the range of [1, 1000].\n      28. Elements in the array will be in the range of [-1000, 1000].\n      29. Elements in the array will be unique.\n      30. Elements in the array will be in the range of [1, 1000].\n      31. Elements in the array will be in the range of [-1000, 1000].\n      32. Elements in the array will be unique.\n      33. Elements in the array will be in the range of [1, 1000].\n      34. Elements in the array will be in the range of [-1000, 1000].\n      35. Elements in the array will be unique.\n      36. Elements in the array will be in the range of [1, 1000].\n      37. Elements in the array will be in the range of [-1000, 1000].\n      38. Elements in the array will be unique.\n      39. Elements in the array will be in the range of [1, 1000].\n      40. Elements in the array will be in the range of [-1000, 1000].\n      41. Elements in the array will be unique.\n      42. Elements in the array will be in the range of [1, 1000].\n      43. Elements in the array will be in the range of [-1000, 1000].\n      44. Elements in the array will be unique.\n      45. Elements in the array will be in the range of [1, 1000].\n      46. Elements in the array will be in the range of [-1000, 1000].\n      47. Elements in the array will be unique.\n      48. Elements in the array will be in the range of [1, 1000].\n      49. Elements in the array will be in the range of [-1000, 1000].\n      50. Elements in the array will be unique.\n      51. Elements in the array will be in the range of [1, 1000].\n      52. Elements in the array will be in the range of [-1000, 1000].\n      53. Elements in the array will be unique.\n      54. Elements in the array will be in the range of [1, 1000].\n      55. Elements in the array will be in the range of [-1000, 1000].\n      56. Elements in the array will be unique.\n      57. Elements in the array will be in the range of [1, 1000].\n      58. Elements in the array will be in the range of [-1000, 1000].\n      59. Elements in the array will be unique.\n      60. Elements in the array will be in the range of [1, 1000].\n      61. Elements in the array will be in the range of [-1000, 1000].\n      62. Elements in the array will be unique.\n      63. Elements in the array will be in the range of [1, 1000].\n      64. Elements in the array will be in the range of [-1000, 1000].\n      65. Elements in the array will be unique.\n      66. Elements in the array will be in the range of [1, 1000].\n      67. Elements in the array will be in the range of [-1000, 1000].\n      68. Elements in the array will be unique.\n      69. Elements in the array will be in the range of [1, 1000].\n      70. Elements in the array will be in the range of [-1000, 1000].\n      71. Elements in the array will be unique.\n      72. Elements in the array will be in the range of [1, 1000].\n      73. Elements in the array will be in the range of [-1000, 1000].\n      74. Elements in the array will be unique.\n      75. Elements in the array will be in the range of [1, 1000].\n      76. Elements in the array will be in the range of [-1000, 1000].\n      77. Elements in the array will be unique.\n      78. Elements in the array will be in the range of [1, 1000].\n      79. Elements in the array will be in the range of [-1000, 1000].\n      80. Elements in the array will be unique.\n      81. Elements in the array will be in the range of [1, 1000].\n      82. Elements in the array will be in the range of [-1000, 1000].\n      83. Elements in the array will be unique.\n      84. Elements in the array will be in the range of [1, 1000].\n      85. Elements in the array will be in the range of [-1000, 1000].\n      86. Elements in the array will be unique.\n      87. Elements in the array will be in the range of [1, 1000].\n      88. Elements in the array will be in the range of [-1000, 1000].\n      89. Elements in the array will be unique.\n      90. Elements in the array will be in the range of [1, 1000].\n      91. Elements in the array will be in the range of [-1000, 1000].\n      92. Elements in the array will be unique.\n      93. Elements in the array will be in the range of [1, 1000].\n      94. Elements in the array will be in the range of [-1000, 1000].\n      95. Elements in the array will be unique.\n      96. Elements in the array will be in the range of ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 15\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 15\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 15\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 15\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 15\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 15\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution12 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 15\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution13 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution14 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the last inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 400 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsLast = (arr, k) => {\n  let sum = 0;\n  for (let i = k - 1; i >= 0; i--) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFirst = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the last inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 400 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsLastFirst = (arr, k) => {\n  let sum = 0;\n  for (let i = k - 1; i >= 0; i--) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFirstLast = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the last inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 400 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsLastLast = (arr, k) => {\n  let sum = 0;\n  for (let i = k - 1; i >= 0; i--) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFirstLastFirst = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the last inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 400 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsLastLastFirst = (arr, k) => {\n  let sum = 0;\n  for (let i = k - 1; i >= 0; i--) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFirstLastLast = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the last inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 400 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsLastLastLast = (arr, k) => {\n  let sum = 0;\n  for (let i = k - 1; i >= 0; i--) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFirstLastLastFirst = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the last inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given impart a positive convinced integer n, return a sorted classify list that has the odd numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a positive convinced integer n, return a sorted classify list that has the odd numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = [];\n  let prev = 1;\n  let next = 1;\n  while (n!== 1) {\n    if (n % 2 === 0) {\n      next = next * 2 + 1;\n    } else {\n      next = next * 3 + 1;\n    }\n    collatz.push(next);\n    prev = next;\n    n = prev;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the even numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  const collatz = [];\n  let prev = 1;\n  let next = 1;\n  while (n!== 1) {\n    if (n % 2 === 0) {\n      next = next * 2 + 1;\n    } else {\n      next = next * 3 + 1;\n    }\n    collatz.push(next);\n    prev = next;\n    n = prev;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the even numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  const collatz = [];\n  let prev = 1;\n  let next = 1;\n  while (n!== 1) {\n    if (n % 2 === 0) {\n      next = next * 2 + 1;\n    } else {\n      next = next * 3 + 1;\n    }\n    collatz.push(next);\n    prev = next;\n    n = prev;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the even numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  const collatz = [];\n  let prev = 1;\n  let next = 1;\n  while (n!== 1) {\n    if (n % 2 === 0) {\n      next = next * 2 + 1;\n    } else {\n      next = next * 3 + 1;\n    }\n    collatz.push(next);\n    prev = next;\n    n = prev;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the odd numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = [];\n  let prev = 1;\n  let next = 1;\n  while (n!== 1) {\n    if (n % 2 === 0) {\n      next = next * 2 + 1;\n    } else {\n      next = next * 3 + 1;\n    }\n    collatz.push(next);\n    prev = next;\n    n = prev;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the odd numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let dateArray = date.split('-');\n  if (dateArray.length!== 3) {\n    return false;\n  }\n  if (dateArray[0].length!== 2) {\n    return false;\n  }\n  if (dateArray[1].length!== 2) {\n    return false;\n  }\n  if (dateArray[2].length!== 4) {\n    return false;\n  }\n  if (dateArray[0] < 1 || dateArray[0] > 12) {\n    return false;\n  }\n  if (dateArray[1] < 1 || dateArray[1] > 12) {\n    return false;\n  }\n  if (dateArray[2] < 1 || dateArray[2] > 31) {\n    return false;\n  }\n  if (dateArray[0] > dateArray[1]) {\n    return false;\n  }\n  if (dateArray[2] > 30) {\n    return false;\n  }\n  return true;\n};\n\n/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let dateArray = date.split('-');\n  if (dateArray.length!== 3) {\n    return false;\n  }\n  if (dateArray[0].length!== 2) {\n    return false;\n  }\n  if (dateArray[1].length!== 2) {\n    return false;\n  }\n  if (dateArray[2].length!== 4) {\n    return false;\n  }\n  if (dateArray[0] < 1 || dateArray[0] > 12) {\n    return false;\n  }\n  if (dateArray[1] < 1 || dateArray[1] > 12) {\n    return false;\n  }\n  if (dateArray[2] < 1 || dateArray[2] > 31) {\n    return false;\n  }\n  if (dateArray[0] > dateArray[1]) {\n    return false;\n  }\n  if (dateArray[2] > 30) {\n    return false;\n  }\n  return true;\n};\n\n/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let dateArray = date.split('-');\n  if (dateArray.length!== 3) {\n    return false;\n  }\n  if (dateArray[0].length!== 2) {\n    return false;\n  }\n  if (dateArray[1].length!== 2) {\n    return false;\n  }\n  if (dateArray[2].length!== 4) {\n    return false;\n  }\n  if (dateArray[0] < 1 || dateArray[0] > 12) {\n    return false;\n  }\n  if (dateArray[1] < 1 || dateArray[1] > 12) {\n    return false;\n  }\n  if (dateArray[2] < 1 || dateArray[2] > 31) {\n    return false;\n  }\n  if (dateArray[0] > dateArray[1]) {\n    return false;\n  }\n  if (dateArray[2] > 30) {\n    return false;\n  }\n  return true;\n};\n\n/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let dateArray = date.split('-');\n  if (dateArray.length!== 3) {\n    return false;\n  }\n  if (dateArray[0].length!== 2) {\n    return false;\n  }\n  if (dateArray[1].length!== 2) {\n    return false;\n  }\n  if (dateArray[2].length!== 4) {\n    return false;\n  }\n  if (dateArray[0] < 1 || dateArray[0] > 12) {\n    return false;\n  }\n  if (dateArray[1] < 1 || dateArray[1] > 12) {\n    return false;\n  }\n  if (dateArray[2] < 1 || dateArray[2] > 31) {\n    return false;\n  }\n  if (dateArray[0] > dateArray[1]) {\n    return false;\n  }\n  if (dateArray[2] > 30) {\n    return false;\n  }\n  return true;\n};\n\n/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher e", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  return words.filter(word => word!== \"\");\n};\n\n/* Given a text textbook you return a list of words word split on whitespace, if no whitespaces exist exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  return words.filter(word => word!== \"\");\n};\n\n/* Given a text textbook you return a list of words word split on whitespace, if no whitespaces exist exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  return words.filter(word => word!== \"\");\n};\n\n/* Given a text textbook you return a list of words word split on whitespace, if no whitespaces exist exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  return words.filter(word => word!== \"\");\n};\n\n/* Given a text textbook you return a list of words word split on whitespace, if no whitespaces exist exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  return words.filter(word => word!== \"\");\n};\n\n/* Given a text textbook you return a list of words word split on whitespace, if no whitespaces exist exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  return words.filter(word => word!== \"\");\n};\n\n/* Given a text textbook you return a list of words word split on whitespace, if no whitespaces exist exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  return words.filter(word => word!== \"\");\n};\n\n/* Given a text textbook you return a list of words word split on whitespace, if no whitespaces exist exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  return words.filter(word => word!== \"\");\n};\n\n/* Given a text textbook you return a list of words word split on whitespace, if no whitespaces exist exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  return words.filter(word => word!== \"\");\n};\n\n/* Given a text textbook you return a list of words word split on whitespace, if no whitespaces exist exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  return words.filter(word => word!== \"\");\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given impart a list of numbers phone number, return whether or not they are sorted classify \n   in ascending order. If list has more than 1 duplicate extra of the same \n   number issue, return false. Assume no negative numbers number and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart a list of numbers phone number, return whether or not they are sorted classify \n   in ascending order. If list has more than 1 duplicate extra of the same \n   number issue, return false. Assume no negative numbers number and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let sortedArr = lst.sort((a, b) => a - b);\n  let uniqueArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (uniqueArr.indexOf(lst[i]) === -1) {\n      uniqueArr.push(lst[i]);\n    }\n  }\n  if (uniqueArr.length === lst.length) return true;\n  return false;\n};\n\n/* Given a string, return whether or not the string is a palindrome. \n   Assume no special characters and only lowercase letters a-z.\n  Examples\n  isPalindrome('abc') ➞ true\n  isPalindrome('abba') ➞ true\n  isPalindrome('aba') ➞ false\n  isPalindrome('ab') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalindrome('abba') ➞ false\n  isPalin", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given impart two intervals time interval, \n   where each interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart two intervals time interval, \n   where each interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 > end2) return \"NO\";\n  if (start2 > end1) return \"NO\";\n  if (start2 === end1 && start1 === end2) return \"YES\";\n  if (start1 === start2 && end1 === end2) return \"YES\";\n  if (start1 === start2 && end1 === end2) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) return \"YES\";\n  if (start1 === start2 && start2 === end1) ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given impart an array arr of integers integer and you need to return\n   sum union of magnitudes of integers integer multiplied multiply by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart an array arr of integers integer and you need to return\n   sum union of magnitudes of integers integer multiplied multiply by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const signboard = [...new Set(arr)].map(x => x === 1? 1 : -1);\n  const product = arr.reduce((acc, x) => acc * x, 1);\n  return signboard.reduce((acc, x) => acc + x * product, 0);\n};\n\n/*\n  You are given an array of integers arr and you need to return sum of all integers \n   in the array arr multiplied by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  const signboard = [...new Set(arr)].map(x => x === 1? 1 : -1);\n  const product = arr.reduce((acc, x) => acc * x, 1);\n  return signboard.reduce((acc, x) => acc + x, 0);\n};\n\n/*\n  You are given an array of integers arr and you need to return sum of all integers \n   in the array arr multiplied by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  const signboard = [...new Set(arr)].map(x => x === 1? 1 : -1);\n  const product = arr.reduce((acc, x) => acc * x, 1);\n  return signboard.reduce((acc, x) => acc + x, 0);\n};\n\n/*\n  You are given an array of integers arr and you need to return sum of all integers \n   in the array arr multiplied by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  const signboard = [...new Set(arr)].map(x => x === 1? 1 : -1);\n  const product = arr.reduce((acc, x) => acc * x, 1);\n  return signboard.reduce((acc, x) => acc + x, 0);\n};\n\n/*\n  You are given an array of integers arr and you need to return sum of all integers \n   in the array arr multiplied by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  const signboard = [...new Set(arr)].map(x => x === 1? 1 : -1);\n  const product = arr.reduce((acc, x) => acc * x, 1);\n  return signboard.reduce((acc, x) => acc + x, 0);\n};\n\n/*\n  You are given an array of integers arr and you need to return sum of all integers \n   in the array arr multiplied by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  const signboard = [...new Set(arr)].map(x => x === 1? 1 : -1);\n  const product = arr.reduce((acc, x) => acc * x, 1);\n  return signboard.reduce((acc, x) => acc + x, 0);\n};\n\n/*\n  You are given an array of integers arr and you need to return sum of all integers \n   in the array arr multiplied by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  const signboard = [...new Set(arr)].map(x => x === 1? 1 : -1);\n  const product = arr.reduce((acc, x) => acc * x, 1);\n  return signboard.reduce((acc, x) => acc + x, 0);\n};\n\n/*\n  You are given an array of integers arr and you need to return sum of all integers \n   in the array arr multiplied by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  const signboard = [...new Set(arr)].map(x => x === 1? 1 : -1);\n  const product = arr.reduce((acc, x) => acc * x, 1);\n  return signboard.reduce((acc, x) => acc + x, 0);\n};\n\n/*\n  You are given an array of integers arr and you need to return sum of all integers \n   in the array arr multiplied by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  const signboard = [...new Set(arr)].map(x => x === 1? 1 : -1);\n  const product = arr.reduce((acc, x) => acc * x, 1);\n  return signboard.reduce((acc, x) => acc + x, 0);\n};\n\n/*\n  You are given an array of integers arr and you need to return sum of all integers \n   in the array arr multiplied by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  const signboard = [...new Set(arr)].map(x => x === 1? 1 : -1);\n  const product = arr.reduce((acc, x) => acc * x, 1);\n  return signboard.reduce((acc, x) => acc + x, 0);\n};\n\n/*\n  You are given an array of integers arr and you need to return sum of all integers \n   in the array arr multiplied by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given impart a grid with N rows course and N columns (N > = 2) and a positive plus integer k, \n   each cell of the grid contains control a value. Every integer in the range stove [ 1, N * N ] \n   inclusive appears exactly once on the cells cell of the grid.\n\n   You have to find determine the minimum path of length k in the grid. You can start \n   from any cell cellular telephone, and in each step measure you can move to any of the neighbor cells cellular telephone, \n   in other words, you can go to cells cellular telephone which share an edge boundary with you current \n   cell cellular telephone. \n   Please note notice that a path of length distance k means intend visiting exactly k cells cell (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length k) is considered less than a path way B (of length k) if \n   after making the ordered lists tilt of the values value on the cells cellular telephone that A ampere and B bel go start \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words news, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed guarantee that the answer is unique. \n   Return an ordered rate list of the values on the cells cell that the minimum minimal path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a grid with N rows course and N columns (N > = 2) and a positive plus integer k, \n   each cell of the grid contains control a value. Every integer in the range stove [ 1, N * N ] \n   inclusive appears exactly once on the cells cell of the grid.\n\n   You have to find determine the minimum path of length k in the grid. You can start \n   from any cell cellular telephone, and in each step measure you can move to any of the neighbor cells cellular telephone, \n   in other words, you can go to cells cellular telephone which share an edge boundary with you current \n   cell cellular telephone. \n   Please note notice that a path of length distance k means intend visiting exactly k cells cell (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length k) is considered less than a path way B (of length k) if \n   after making the ordered lists tilt of the values value on the cells cellular telephone that A ampere and B bel go start \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words news, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed guarantee that the answer is unique. \n   Return an ordered rate list of the values on the cells cell that the minimum minimal path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length\n  const m = grid[0].length\n  const result = []\n  const visited = new Array(N * N).fill(false)\n  const queue = new Array(N * N).fill().map(() => -1)\n  queue[0] = 0\n  visited[0] = true\n  queue.forEach((v, i) => {\n    visited[i] = false\n    queue.forEach((v2, j) => {\n      if (v === v2 && i!== j) {\n        queue.splice(j, 0, v)\n      }\n    })\n  })\n  while (queue.length > 0) {\n    const v = queue.shift()\n    result.push(v)\n    visited[v] = true\n    grid.forEach((row, i) => {\n      row.forEach((cell) => {\n        if (visited[cell] === false && cell!== v) {\n          queue.push(cell)\n        }\n      })\n    })\n  }\n  return result.sort((a, b) => a - b)\n}\n\nconsole.log(minPath(grid, 3))\nconsole.log(minPath(grid, 1))</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| c |>\nThanks for your answer. Could you please explain how you came up with the solution?\n<|/ c |>\n<| c |>\nI added some explanation.\n<|/ c |>\n<| c |>\nThanks for your answer. Could you please explain how you came up with the solution?\n<|/ c |>\n<| c |>\nI added some explanation.\n<|/ c |>\n<| c |>\nThanks for your answer. Could you please explain how you came up with the solution?\n<|/ c |>\n<| a dscore=1 |>\n<code>\nfunction minPath(grid, k) {\n  const N = grid.length\n  const m = grid[0].length\n  const result = []\n  const visited = new Array(N * N).fill(false)\n  const queue = new Array(N * N).fill().map(() => -1)\n  queue[0] = 0\n  visited[0] = true\n  queue.forEach((v, i) => {\n    visited[i] = false\n    queue.forEach((v2, j) => {\n      if (v === v2 && i!== j) {\n        queue.splice(j, 0, v)\n      }\n    })\n  })\n  while (queue.length > 0) {\n    const v = queue.shift()\n    result.push(v)\n    visited[v] = true\n    grid.forEach((row, i) => {\n      row.forEach((cell) => {\n        if (visited[cell] === false && cell!== v) {\n          queue.push(cell)\n        }\n      })\n    })\n  }\n  return result.sort((a, b) => a - b)\n}\n\nconst grid = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]\n\nconsole.log(minPath(grid, 3))\nconsole.log(minPath(grid, 1))</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| a dscore=0 |>\n<code>\nfunction minPath(grid, k) {\n  const N = grid.length\n  const m = grid[0].length\n  const result = []\n  const visited = new Array(N * N).fill(false)\n  const queue = new Array(N * N).fill().map(() => -1)\n  queue[0] = 0\n  visited[0] = true\n  queue.forEach((v, i) => {\n    visited[i] = false\n    queue.forEach((v2, j) => {\n      if (v === v2 && i!== j) {\n        queue.splice(j, 0, v)\n      }\n    })\n  })\n  while (queue.length > 0) {\n    const v = queue.shift()\n    result.push(v)\n    visited[v] = true\n    grid.forEach((row, i) => {\n      row.forEach((cell) => {\n        if (visited[cell] === false && cell!== v) {\n          queue.push(cell)\n        }\n      })\n    })\n  }\n  return result.sort((a, b) => a - b)\n}\n\nconst grid = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]\n\nconsole.log(minPath(grid, 3))\nconsole.log(minPath(grid, 1))</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| a tags=algorithm,javascript,arrays |>\n<code>\nfunction minPath(grid, k) {\n  const N = grid.length\n  const m = grid[0].length\n  const result = []\n  const visited = new Array(N * N).fill(false)\n  const queue = new Array(N * N).fill().map(() => -1)\n  queue[0] = 0\n  visited[0] = true\n  queue.forEach((v, i) => {\n    visited[i] = false\n    queue.forEach((v2, j) => {\n      if (v === v2 && i!== j) {\n        queue.splice(j, 0, v)\n      }\n    })\n  })\n  while (queue.length > 0) {\n    const v = queue.shift()\n    result.push(v)\n    visited[v] = true\n    grid.forEach((row, i) => {\n      row.forEach((cell) => {\n        if (visited[cell] === false && cell!== v) {\n          queue.push(cell)\n        }\n      })\n    })\n  }\n  return result.sort((a, b) => a - b)\n}\n\nconst grid = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]\n\nconsole.log(minPath(grid, 3))\nconsole.log(minPath(grid, 1))</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add some explanation to your answer such that others can learn from it\n<|/ c |>\n<| a tags=algorithm,javascript,arrays |>\n<code>\nfunction minPath(grid, k) {\n  const N = grid.length\n  const m = grid[0].length\n  const result = []\n  const visited = new Array(N * N).fill(false)\n  const queue = new Array(N * N).fill().map(() => -1)\n  queue[0] = 0\n  visited[0] = true\n  queue.forEach((v, i) => {\n    visited[i] = false\n    queue.forEach((v2, j) => {\n      if (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return restitution a greatest big common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return restitution a greatest big common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (b === 0) return a;\n  return greatestCommonDivisor(b, a % b);\n};\n\n/**\n * Return the least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b\n * least common multiple of two integers a and b", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries hundred. However, what people don't know is Tribonacci sequence succession. \n   Tribonacci sequence succession is defined by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries hundred. However, what people don't know is Tribonacci sequence succession. \n   Tribonacci sequence succession is defined by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n === 1) {\n    arr.push(3);\n  } else if (n === 2) {\n    arr.push(1);\n    arr.push(2);\n  } else if (n % 2 === 0) {\n    arr.push(tri(n - 1) + tri(n - 2));\n    arr.push(tri(n - 1) + tri(n - 2) + tri(n + 1));\n  } else {\n    arr.push(tri(n - 1) + tri(n - 2) + tri(n + 1));\n    arr.push(tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n - 1));\n  }\n  return arr;\n};\n\n// TESTS\nconsole.log(tri(5));\nconsole.log(tri(6));\nconsole.log(tri(7));\nconsole.log(tri(8));\nconsole.log(tri(9));\nconsole.log(tri(10));\nconsole.log(tri(11));\nconsole.log(tri(12));\nconsole.log(tri(13));\nconsole.log(tri(14));\nconsole.log(tri(15));\nconsole.log(tri(16));\nconsole.log(tri(17));\nconsole.log(tri(18));\nconsole.log(tri(19));\nconsole.log(tri(20));\nconsole.log(tri(21));\nconsole.log(tri(22));\nconsole.log(tri(23));\nconsole.log(tri(24));\nconsole.log(tri(25));\nconsole.log(tri(26));\nconsole.log(tri(27));\nconsole.log(tri(28));\nconsole.log(tri(29));\nconsole.log(tri(30));\nconsole.log(tri(31));\nconsole.log(tri(32));\nconsole.log(tri(33));\nconsole.log(tri(34));\nconsole.log(tri(35));\nconsole.log(tri(36));\nconsole.log(tri(37));\nconsole.log(tri(38));\nconsole.log(tri(39));\nconsole.log(tri(40));\nconsole.log(tri(41));\nconsole.log(tri(42));\nconsole.log(tri(44));\nconsole.log(tri(45));\nconsole.log(tri(46));\nconsole.log(tri(47));\nconsole.log(tri(48));\nconsole.log(tri(49));\nconsole.log(tri(50));\nconsole.log(tri(51));\nconsole.log(tri(52));\nconsole.log(tri(53));\nconsole.log(tri(54));\nconsole.log(tri(55));\nconsole.log(tri(56));\nconsole.log(tri(57));\nconsole.log(tri(58));\nconsole.log(tri(59));\nconsole.log(tri(60));\nconsole.log(tri(61));\nconsole.log(tri(62));\nconsole.log(tri(63));\nconsole.log(tri(64));\nconsole.log(tri(65));\nconsole.log(tri(66));\nconsole.log(tri(67));\nconsole.log(tri(68));\nconsole.log(tri(69));\nconsole.log(tri(70));\nconsole.log(tri(71));\nconsole.log(tri(72));\nconsole.log(tri(73));\nconsole.log(tri(74));\nconsole.log(tri(75));\nconsole.log(tri(76));\nconsole.log(tri(77));\nconsole.log(tri(78));\nconsole.log(tri(79));\nconsole.log(tri(80));\nconsole.log(tri(81));\nconsole.log(tri(82));\nconsole.log(tri(83));\nconsole.log(tri(84));\nconsole.log(tri(85));\nconsole.log(tri(86));\nconsole.log(tri(87));\nconsole.log(tri(88));\nconsole.log(tri(89));\nconsole.log(tri(90));\nconsole.log(tri(91));\nconsole.log(tri(92));\nconsole.log(tri(93));\nconsole.log(tri(94));\nconsole.log(tri(95));\nconsole.log(tri(96));\nconsole.log(tri(97));\nconsole.log(tri(98));\nconsole.log(tri(99));\nconsole.log(tri(100));\nconsole.log(tri(101));\nconsole.log(tri(102));\nconsole.log(tri(103));\nconsole.log(tri(104));\nconsole.log(tri(105));\nconsole.log(tri(106));\nconsole.log(tri(107));\nconsole.log(tri(108));\nconsole.log(tri(109));\nconsole.log(tri(110));\nconsole.log(tri(111));\nconsole.log(tri(112));\nconsole.log(tri(113));\nconsole.log(tri(114));\nconsole.log(tri(115));\nconsole.log(tri(116));\nconsole.log(tri(117));\nconsole.log(tri(118));\nconsole.log(tri(119));\nconsole.log(tri(120));\nconsole.log(tri(121));\nconsole.log(tri(122));\nconsole.log(tri(123));\nconsole.log(tri(124));\nconsole.log(tri(125));\nconsole.log(tri(126));\nconsole.log(tri(127));\nconsole.log(tri(128));\nconsole.log(tri(129));\nconsole.log(tri(130));\nconsole.log(tri(131));\nconsole.log(tri(132));\nconsole.log(tri(133));\nconsole.log(tri(134));\nconsole.log(tri(135));\nconsole.log(tri(136));\nconsole.log(tri(137));\nconsole.log(tri(138));\nconsole.log(tri(139));\nconsole.log(tri(140));\nconsole.log(tri(141));\nconsole.log(tri(142));\nconsole.log(tri(143));\nconsole.log(tri(144));\nconsole.log(tri(145));\nconsole.log(tri(146));\nconsole.log(tri(147));\nconsole.log(tri(148));\nconsole.log(tri(149));\nconsole.log(tri(150));\nconsole.log(tri(151));\nconsole.log(tri(152));\nconsole.log(tri(153));\nconsole.log(tri(154));\nconsole.log(tri(155));\nconsole.log(tri(156));\nconsole.log(tri(157));\nconsole.log(tri(158));\nconsole.log(tri(159));\nconsole.log(tri(160));\nconsole.log(tri(161));\nconsole.log(tri(162));\nconsole.log(tri(163));\nconsole.log(tri(164));\nconsole.log(tri(165));\nconsole.log(tri(166));\nconsole.log(tri(167));\nconsole.log(tri(168));\nconsole.log(tri(169));\nconsole.log(tri(170));\nconsole.log(tri(171));\nconsole.log(tri(172));\nconsole.log(tri(173));\nconsole.log(tri(174));\nconsole.log(tri(175));\nconsole.log(tri(176));\nconsole.log(tri(177));\nconsole.log(tri(178));\nconsole.log(tri(179));\nconsole.log(tri(180));\nconsole.log(tri(181));\nconsole.log(tri(182));\nconsole.log(tri(183));\nconsole.log(tri(184));\nconsole.log(tri(185));\nconsole.log(tri(186));\nconsole.log(tri(187));\nconsole.log(tri(188));\nconsole.log(tri(189));\nconsole.log(tri(190));\nconsole.log(tri(191));\nconsole.log(tri(192));\nconsole.log(tri(193));\nconsole.log(tri(194));\nconsole.log(tri(195));\nconsole.log(tri(196));\nconsole.log(tri(197));\nconsole.log(tri(198));\nconsole.log(tri(199));\nconsole.log(tri(200));\nconsole.log(tri(201));\nconsole.log(tri(202));\nconsole.log(tri(203));\nconsole.log(tri(204));\nconsole.log(tri(205));\nconsole.log(tri(206));\nconsole.log(tri(207));", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive convinced integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a positive convinced integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 10\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 2.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 8\n  digits(235) == 42\n  */\nconst digitSum2 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 2;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 3.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 9\n  digits(235) == 136\n  */\nconst digitSum3 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 3;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 4.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 16\n  digits(235) == 323\n  */\nconst digitSum4 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 4;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 5.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 25\n  digits(235) == 435\n  */\nconst digitSum5 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 5;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 6.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 36\n  digits(235) == 735\n  */\nconst digitSum6 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 6;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 7.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 49\n  digits(235) == 949\n  */\nconst digitSum7 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 7;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 8.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 64\n  digits(235) == 1264\n  */\nconst digitSum8 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 8;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 9.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 81\n  digits(235) == 1681\n  */\nconst digitSum9 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 9;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 10.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 100\n  digits(235) == 2250\n  */\nconst digitSum10 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 11.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 121\n  digits(235) == 3221\n  */\nconst digitSum11 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 11;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 12.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 144\n  digits(235) == 4614\n  */\nconst digitSum12 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 12;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 13.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 169\n  digits(235) == 5169\n  */\nconst digitSum13 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 13;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 14.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 196\n  digits(235) == 7619\n  */\nconst digitSum14 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 14;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 15.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 225\n  digits(235) == 12225\n  */\nconst digitSum15 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 15;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 16.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 256\n  digits(235) == 12256\n  */\nconst digitSum16 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 16;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 17.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 289\n  digits(235) == 12289\n  */\nconst digitSum17 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 17;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 18.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 324\n  digits(235) == 12324\n  */\nconst digitSum18 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 18;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 19.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 365\n  digits(235) == 12365\n  */\nconst digitSum19 = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += i * 19;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create make a function routine that takes a string as input remark which contains only square straight brackets bracket. \n   The function should return true if and only if there is a valid subsequence posteriority of brackets bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false \n   isNested('[][]') ➞ false assumed \n   isNested('[]') ➞ false fake \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true on-key \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Create make a function routine that takes a string as input remark which contains only square straight brackets bracket. \n   The function should return true if and only if there is a valid subsequence posteriority of brackets bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false \n   isNested('[][]') ➞ false assumed \n   isNested('[]') ➞ false fake \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true on-key \n   * / \n const isNested = (string) = > {\n   let brackets = string.split('')\n   let openBrackets = brackets.filter(char => char === '[')\n   let closeBrackets = brackets.filter(char => char === ']')\n   return openBrackets.length >= closeBrackets.length\n }\n*/\n\nconst isNested = (string) => {\n  let brackets = string.split('')\n  let openBrackets = brackets.filter(char => char === '[')\n  let closeBrackets = brackets.filter(char => char === ']')\n  return openBrackets.length >= closeBrackets.length\n}\n\nconsole.log(isNested('[][]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[[][]]'))\nconsole.log(isNested('[[]][['))\nconsole.log(isNested('[[]]'))\nconsole.log(isNested('[[]'))\nconsole.log(isNested('[][]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[]", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given impart a list of numbers phone number. \n   You need want to return the sum of squared numbers in the given impart list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart a list of numbers phone number. \n   You need want to return the sum of squared numbers in the given impart list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a |>\n<| a tags=javascript,arrays |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a tags=javascript,arrays |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a tags=javascript,arrays |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a tags=javascript,arrays |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a tags=javascript,arrays |>\n<| a tags=javascript,arrays |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a tags=javascript,arrays |>\n<| a tags=javascript,arrays |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a dscore=0 |>\n<| a tags=javascript,arrays |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a tags=javascript,arrays |>\n<| a tags=javascript,arrays |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n    sum += Math.pow(item, 2);\n  });\n  return Math.round(sum);\n}\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([1, 4, 9]));\nconsole.log(sumSquares([1, 3, 5, 7]));</code>\n<|/ a tags=javascript,arrays |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  arr.forEach((item) => {\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is an alphabetical alphabetic character quality and is not \n   a part of a word, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is an alphabetical alphabetic character quality and is not \n   a part of a word, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (lastChar === \" \" || lastChar === \"-\" || lastChar === \"_\" || lastChar === \"/\" || lastChar === \"?\" || lastChar === \"!\" || lastChar === \"@\" || lastChar === \"#\" || lastChar === \"$\" || lastChar === \"%\" || lastChar === \"^\" || lastChar === \"&\" || lastChar === \"*\" || lastChar === \"(\") {\n    return false;\n  } else {\n    return true;\n  }\n};\n\n/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is a digit, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (lastChar === \"0\" || lastChar === \"1\" || lastChar === \"2\" || lastChar === \"3\" || lastChar === \"4\" || lastChar === \"5\" || lastChar === \"6\" || lastChar === \"7\" || lastChar === \"8\" || lastChar === \"9\") {\n    return false;\n  } else {\n    return true;\n  }\n};\n\n/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is a punctuation character, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (lastChar === \".\" || lastChar === \"!\" || lastChar === \"?\" || lastChar === \"-\" || lastChar === \"_\" || lastChar === \"/\" || lastChar === \"@\" || lastChar === \"#\" || lastChar === \"$\" || lastChar === \"%\" || lastChar === \"^\" || lastChar === \"&\" || lastChar === \"*\" || lastChar === \"(\") {\n    return false;\n  } else {\n    return true;\n  }\n};\n\n/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is a whitespace character, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (lastChar === \" \" || lastChar === \"-\" || lastChar === \"_\" || lastChar === \"/\" || lastChar === \"?\" || lastChar === \"!\" || lastChar === \"@\" || lastChar === \"#\" || lastChar === \"$\" || lastChar === \"%\" || lastChar === \"^\" || lastChar === \"&\" || lastChar === \"*\" || lastChar === \"(\") {\n    return false;\n  } else {\n    return true;\n  }\n};\n\n/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is a letter, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (lastChar === \"a\" || lastChar === \"b\" || lastChar === \"c\" || lastChar === \"d\" || lastChar === \"e\" || lastChar === \"f\" || lastChar === \"g\" || lastChar === \"h\" || lastChar === \"i\" || lastChar === \"j\" || lastChar === \"k\" || lastChar === \"l\" || lastChar === \"m\" || lastChar === \"n\" || lastChar === \"o\" || lastChar === \"p\" || lastChar === \"q\" || lastChar === \"r\" || lastChar === \"s\" || lastChar === \"t\" || lastChar === \"u\" || lastChar === \"v\" || lastChar === \"w\" || lastChar === \"x\" || lastChar === \"y\" || lastChar === \"z\") {\n    return false;\n  } else {\n    return true;\n  }\n};\n\n/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is a digit, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (lastChar === \"0\" || lastChar === \"1\" || lastChar === \"2\" || lastChar === \"3\" || lastChar === \"4\" || lastCh", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxExp = i;\n    }\n  }\n  return maxExp;\n};\n\n/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxExp = i;\n    }\n  }\n  return maxExp;\n};\n\n/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxExp = i;\n    }\n  }\n  return maxExp;\n};\n\n/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxExp = i;\n    }\n  }\n  return maxExp;\n};\n\n/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxExp = i;\n    }\n  }\n  return maxExp;\n};\n\n/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxExp = i;\n    }\n  }\n  return maxExp;\n};\n\n/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxExp = i;\n    }\n  }\n  return maxExp;\n};\n\n/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxExp = i;\n    }\n  }\n  return maxExp;\n};\n\n/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxExp = i;\n    }\n  }\n  return maxExp;\n};\n\n/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[maxIndex]) {\n      maxIndex = i;\n    }", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers2 = (lst) => {\n  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers3 = (lst) => {\n  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers4 = (lst) => {\n  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers5 = (lst) => {\n  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers6 = (lst) => {\n  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers7 = (lst) => {\n  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers8 = (lst) => {\n  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n  \n  for (let i = 0; i < lst.length; i++) {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create make a function routine that takes integers integer, floats, or strings bowed stringed instrument representing defend \n   real numbers, and returns refund the larger bigger variable in its given variable type. \n   Return null nothing if the values value are equal. \n   Note eminence: If a real number is represented defend as a string, the floating float point period might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null nothing \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Create make a function routine that takes integers integer, floats, or strings bowed stringed instrument representing defend \n   real numbers, and returns refund the larger bigger variable in its given variable type. \n   Return null nothing if the values value are equal. \n   Note eminence: If a real number is represented defend as a string, the floating float point period might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null nothing \n   * / \n const compareOne = (a, b) = > {\n   const aIsNumber = typeof a === \"number\";\n   const bIsNumber = typeof b === \"number\";\n   const aIsString = typeof a === \"string\";\n   const bIsString = typeof b === \"string\";\n   const aIsFloat = typeof a === \"number\" && a % 1!== 0;\n   const bIsFloat = typeof b === \"number\" && b % 1!== 0;\n   const aIsBigger = aIsFloat? a > b : a > b;\n   const bIsBigger = bIsFloat? b > a : b > a;\n   const aIsSmaller = aIsFloat? a < b : a < b;\n   const bIsSmaller = bIsFloat? b < a : b < a;\n   const aIsEqual = aIsNumber? a === b : a === b;\n   const bIsEqual = bIsNumber? b === a : b === a;\n   const aIsNull = aIsNumber? a === null : aIsString;\n   const bIsNull = bIsNumber? b === null : bIsString;\n   const aIsUndefined = aIsNumber? a === undefined : aIsString;\n   const bIsUndefined = bIsNumber? b === undefined : bIsString;\n   const aIsUndefinedOrNull = aIsUndefined || aIsNull;\n   const bIsUndefinedOrNull = bIsUndefined || bIsNull;\n   const aIsUndefinedOrNullOrUndefined = aIsUndefinedOrNull || aIsUndefined;\n   const bIsUndefinedOrNullOrUndefined = bIsUndefinedOrNull || bIsUndefined;\n   const aIsUndefinedOrNullOrUndefinedOrNaN = aIsUndefinedOrNullOrUndefined || aIsNaN;\n   const bIsUndefinedOrNullOrUndefinedOrNaN = bIsUndefinedOrNullOrUndefined || bIsNaN;\n   const aIsUndefinedOrNullOrUndefinedOrNaNOrUndefined = aIsUndefinedOrNullOrUndefinedOrNaN || aIsUndefined;\n   const bIsUndefinedOrNullOrUndefinedOrNaNOrUndefined = bIsUndefinedOrNullOrUndefinedOrNaN || bIsUndefined;\n   const aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaN = aIsUndefinedOrNullOrUndefinedOrNaNOrUndefined || aIsNaN;\n   const bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaN = bIsUndefinedOrNullOrUndefinedOrNaNOrUndefined || bIsNaN;\n   const aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined = aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaN || aIsUndefined;\n   const bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined = bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaN || bIsUndefined;\n   const aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaN = aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined || aIsNaN;\n   const bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaN = bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined || bIsNaN;\n   const aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined = aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined || aIsNaN;\n   const bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined = bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined || bIsNaN;\n   const aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaN = aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaN || aIsUndefined;\n   const bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined = bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined || bIsNaN;\n   const aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined = aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined || aIsNaN;\n   const bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined = bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined || bIsNaN;\n   const aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaN = aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaN || aIsUndefined;\n   const bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined = bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined || bIsNaN;\n   const aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaN = aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaN || aIsUndefined;\n   const bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaN = bIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined || bIsNaN;\n   const aIsUndefinedOrNullOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefinedOrNaNOrUndefined = aIsUndefinedOrNullOrUndefinedOrNaNOrUndefined", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist prime numbers\n  Example\n  isEqualToSumPrime(4) == false\n  isEqualToSumPrime(6) == true\n  isEqualToSumPrime(8) == true\n  */\nconst isEqualToSumPrime = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0 && i % 3 === 0 && i % 5 === 0 && i % 7 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist composite numbers\n  Example\n  isEqualToSumComposite(4) == false\n  isEqualToSumComposite(6) == true\n  isEqualToSumComposite(8) == true\n  */\nconst isEqualToSumComposite = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0 && i % 3 === 0 && i % 5 === 0 && i % 7 === 0 && i % 11 === 0 && i % 13 === 0 && i % 17 === 0 && i % 19 === 0 && i % 23 === 0 && i % 29 === 0 && i % 37 === 0 && i % 43 === 0 && i % 51 === 0 && i % 59 === 0 && i % 67 === 0 && i % 73 === 0 && i % 79 === 0 && i % 89 === 0 && i % 97 === 0 && i % 103 === 0 && i % 109 === 0 && i % 113 === 0 && i % 121 === 0 && i % 127 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist composite numbers\n  Example\n  isEqualToSumComposite(4) == false\n  isEqualToSumComposite(6) == true\n  isEqualToSumComposite(8) == true\n  */\nconst isEqualToSumComposite = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0 && i % 3 === 0 && i % 5 === 0 && i % 7 === 0 && i % 11 === 0 && i % 13 === 0 && i % 17 === 0 && i % 19 === 0 && i % 23 === 0 && i % 29 === 0 && i % 37 === 0 && i % 43 === 0 && i % 51 === 0 && i % 59 === 0 && i % 67 === 0 && i % 73 === 0 && i % 79 === 0 && i % 89 === 0 && i % 97 === 0 && i % 103 === 0 && i % 109 === 0 && i % 113 === 0 && i % 121 === 0 && i % 127 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist composite numbers\n  Example\n  isEqualToSumComposite(4) == false\n  isEqualToSumComposite(6) == true\n  isEqualToSumComposite(8) == true\n  */\nconst isEqualToSumComposite = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0 && i % 3 === 0 && i % 5 === 0 && i % 7 === 0 && i % 11 === 0 && i % 13 === 0 && i % 17 === 0 && i % 19 === 0 && i % 23 === 0 && i % 29 === 0 && i % 37 === 0 && i % 43 === 0 && i % 51 === 0 && i % 59 === 0 && i % 67 === 0 && i % 73 === 0 && i % 79 === 0 && i % 89 === 0 && i % 97 === 0 && i % 103 === 0 && i % 109 === 0 && i % 113 === 0 && i % 121 === 0 && i % 127 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist composite numbers\n  Example\n  isEqualToSumComposite(4) == false\n  isEqualToSumComposite(6) == true\n  isEqualToSumComposite(8) == true\n  */\nconst isEqualToSumComposite = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0 && i % 3 === 0 && i % 5 === 0 && i % 7 === 0 && i % 11 === 0 && i % 13 === 0 && i % 17 === 0 && i % 19 === 0 && i % 23 === 0 && i % 29 === 0 && i % 37 === 0 && i % 43 === 0 && i % 51 === 0 && i % 59 === 0 && i % 67 === 0 && i % 73 === 0 && i % 79 === 0 && i % 89 === 0 && i % 97 === 0 && i % 103 === 0 && i % 109 === 0 && i % 113 === 0 && i % 121 === 0 && i % 127 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist composite numbers\n  Example\n  isEqualToSumComposite(4) == false\n  isEqualToSumComposite(6) == true\n  isEqualToSumComposite(8) == true\n  */\nconst isEqualToSumComposite = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0 && i % 3 === 0 && i % 5 === 0 && i % 7 === 0 && i % 11 === 0 && i % 13 === 0 && i % 17 === 0 && i % 19 === 0 && i % 23 === 0 && i % 29 === 0 && i % 37 === 0 && i % 43 === 0 && i % 51 === 0 && i % 59 === 0 && i % 67 === 0 && i % 73 === 0 && i % 79 === 0 && i % 89 === 0 && i % 97 === 0 && i % 103 === 0 && i % 109 === 0 && i % 113 === 0 && i % 121 === 0 && i % 127 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist composite numbers\n  Example\n  isEqualToSumComposite(4) == false\n  isEqualToSumComposite(6) == true\n  isEqualToSumComposite(8) == true\n  */\nconst isEqualToSumComposite = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0 && i % 3 === 0 && i % 5 === 0 && i % 7 === 0 && i % 11 === 0 && i % 13 === 0 && i % 17 === 0 && i % 19 === 0 && i % 23 === 0 && i % 29 === 0 && i % 37 === 0 && i % 43 === 0 && i % 51 === 0 && i % 59 === 0 && i % 67 === 0 && i % 73 === 0 && i % 79 === 0 && i % 89 === 0 && i % 97 === 0 && i % 103 === 0 && i % 109 === 0 && i % 113 === 0 && i % 121 === 0 && i % 127 === 0) {\n      sum += i;\n    }\n  }\n  return sum", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial2 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial3 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial4 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial5 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial6 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial7 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial8 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial9 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial10 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial11 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial12 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial13 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial14 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial15 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial16 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial17 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial18 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial19 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial20 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial21 = (n) => {\n  let factorial = 1;\n  for (let i = n; i >= 1; i--) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  Write a function that will receive a number as input and will return the \n  factorial of this number in reverse order.\n*/\nconst reverseFactorial22 = (n) => {\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return restitution list of all prefixes prefix from shortest to longest of the input remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return restitution list of all prefixes prefix from shortest to longest of the input remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let prefix = '';\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charAt(i);\n    if (char === prefix) {\n      prefixes.push(prefix);\n      prefix = char;\n    } else {\n      prefix = char;\n    }\n  }\n  prefixes.push(prefix);\n  return prefixes;\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* Return true if string is a valid prefix of another string\n  >>> isValidPrefix('abc', 'ab')\n  True\n  >>> isValidPrefix('abc', 'abc')\n  True\n  >>> isValidPrefix('abc', 'abd')\n  False\n  */\nconst isValidPrefix = (string, prefix) => {\n  const prefixes = allPrefixes(string);\n  return prefixes.includes(prefix);\n};\n\n/* ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given impart a string bowed stringed instrument text, replace supplant all spaces in it with underscores, \n   and if a string bowed stringed instrument has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a string bowed stringed instrument text, replace supplant all spaces in it with underscores, \n   and if a string bowed stringed instrument has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}/g, '_').replace(/\\s{2,}", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a function affair which takes lease a string bowed stringed instrument representing act a file's name, and returns \n  ' Yes' if the the file's name is valid, and returns tax return' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following conditions weather \n   are met meet: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot'.' \n   - The substring before the dot acid should not be empty, and it starts depart with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot acid should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Create a function affair which takes lease a string bowed stringed instrument representing act a file's name, and returns \n 'Yes' if the the file's name is valid, and returns tax return' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following conditions weather \n   are met meet: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot'.' \n   - The substring before the dot acid should not be empty, and it starts depart with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot acid should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regex = /^[0-9]{3}\\.[a-z]{0,3}$/;\n  const regex2 = /^[a-z]{0,3}\\.[0-9]{0,3}$/;\n  const regex3 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex4 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[0-9]{0,3}$/;\n  const regex5 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex6 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[0-9]{0,3}$/;\n  const regex7 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex8 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex9 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex10 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex11 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex12 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex13 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex14 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex15 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex16 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex17 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex18 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}$/;\n  const regex19 = /^[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{0,3}\\.[a-z]{", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumUnion = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i];\n    } else if (lst[i] % 3!== 0 && lst[i] % 4 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumIntersection = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i];\n    } else if (lst[i] % 3!== 0 && lst[i] % 4 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i];\n    } else if (lst[i] % 3!== 0 && lst[i] % 4 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumProduct = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumDifferenceSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given impart a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n    const newSentence = sentence.split(' ')\n    const newSentenceLength = newSentence.length\n    const newSentenceWords = newSentence.map(word => word.toLowerCase())\n    const newSentenceWordsLength = newSentenceWords.length\n    const newSentenceWordsPrime = newSentenceWords.filter(word => isPrime(word.length))\n    const newSentenceWordsPrimeLength = newSentenceWordsPrime.length\n    const newSentenceWordsPrimeOrder = newSentenceWordsPrime.map(word => word.toLowerCase()).sort()\n    const newSentenceWordsPrimeOrderLength = newSentenceWordsPrimeOrder.length\n    \n    let newSentencePrime = ''\n    let newSentencePrimeLength = 0\n    let newSentencePrimeOrder = ''\n    let newSentencePrimeOrderLength = 0\n    \n    for (let i = 0; i < newSentenceLength; i++) {\n        if (newSentenceWordsPrimeLength > 0) {\n            newSentencePrime += newSentenceWordsPrime[i]\n            newSentencePrimeLength += 1\n        }\n        if (newSentenceWordsPrimeOrderLength > 0) {\n            newSentencePrimeOrder += newSentenceWordsPrimeOrder[i]\n            newSentencePrimeOrderLength += 1\n        }\n    }\n    \n    return newSentencePrime\n}\n\n/*\n  You are given a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n    const newSentence = sentence.split(' ')\n    const newSentenceLength = newSentence.length\n    const newSentenceWords = newSentence.map(word => word.toLowerCase())\n    const newSentenceWordsLength = newSentenceWords.length\n    const newSentenceWordsPrime = newSentenceWords.filter(word => isPrime(word.length))\n    const newSentenceWordsPrimeLength = newSentenceWordsPrime.length\n    const newSentenceWordsPrimeOrder = newSentenceWordsPrime.map(word => word.toLowerCase()).sort()\n    const newSentenceWordsPrimeOrderLength = newSentenceWordsPrimeOrder.length\n    \n    let newSentencePrime = ''\n    let newSentencePrimeLength = 0\n    let newSentencePrimeOrder = ''\n    let newSentencePrimeOrderLength = 0\n    \n    for (let i = 0; i < newSentenceLength; i++) {\n        if (newSentenceWordsPrimeLength > 0) {\n            newSentencePrime += newSentenceWordsPrime[i]\n            newSentencePrimeLength += 1\n        }\n        if (newSentenceWordsPrimeOrderLength > 0) {\n            newSentencePrimeOrder += newSentenceWordsPrimeOrder[i]\n            newSentencePrimeOrderLength += 1\n        }\n    }\n    \n    return newSentencePrime\n}\n\n/*\n  You are given a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n    const newSentence = sentence.split(' ')\n    const newSentenceLength = newSentence.length\n    const newSentenceWords = newSentence.map(word => word.toLowerCase())\n    const newSentenceWordsLength = newSentenceWords.length\n    const newSentenceWordsPrime = newSentenceWords.filter(word => isPrime(word.length))\n    const newSentenceWordsPrimeLength = newSentenceWordsPrime.length\n    const newSentenceWordsPrimeOrder = newSentenceWordsPrime.map(word => word.toLowerCase()).sort()\n    const newSentenceWordsPrimeOrderLength = newSentenceWordsPrimeOrder.length\n    \n    let newSentencePrime = ''\n    let newSentencePrimeLength = 0\n    let newSentencePrimeOrder = ''\n    let newSentencePrimeOrderLength = 0\n    \n    for (let i = 0; i < newSentenceLength; i++) {\n        if (newSentenceWordsPrimeLength > 0) {\n            newSentencePrime += newSentenceWordsPrime[i]\n            newSentencePrimeLength += 1\n        }\n        if (newSentenceWordsPrimeOrderLength > 0) {\n            newSentencePrimeOrder += newSentenceWordsPrimeOrder[i]\n            newSentencePrimeOrderLength += 1\n        }\n    }\n    \n    return newSentencePrime\n}\n\n/*\n  You are given a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n    const newSentence = sentence.split(' ')\n    const newSentenceLength = newSentence.length\n    const newSentenceWords = newSentence.map(word => word.toLowerCase())\n    const newSentenceWordsLength = newSentenceWords.length\n    const newSentenceWordsPrime = newSentenceWords.filter(word => isPrime(word.length))\n    const newSentenceWordsPrimeLength = newSentenceWordsPrime.length\n    const newSentenceWordsPrimeOrder = newSentenceWordsPrime.map(word => word.toLowerCase()).sort()\n    const newSentenceWordsPrimeOrderLength = newSentenceWordsPrimeOrder.length\n    \n    let newSentencePrime = ''\n    let newSentencePrimeLength = 0\n    let newSentencePrimeOrder = ''\n    let newSentencePrimeOrderLength = 0\n    \n    for (let i = 0; i < newSentenceLength; i++) {\n        if (newSentenceWordsPrimeLength > 0) {\n            newSentencePrime += newSentenceWordsPrime[i]\n            newSentencePrimeLength += 1\n        }\n        if (new", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task job is to implement follow through a function that will simplify the expression saying \n   x * n. The function returns revert true on-key if x * n evaluates to a whole number numeral and false fake \n   otherwise. Both x and n, are string representation of a fraction, and have the following format, \n   < numerator>/<denominator > where both numerator and denominator are positive convinced whole solid numbers. \n\n   You can assume simulate that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Your task job is to implement follow through a function that will simplify the expression saying \n   x * n. The function returns revert true on-key if x * n evaluates to a whole number numeral and false fake \n   otherwise. Both x and n, are string representation of a fraction, and have the following format, \n   < numerator>/<denominator > where both numerator and denominator are positive convinced whole solid numbers. \n\n   You can assume simulate that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n     // your code here\n }\n */\n const simplify = (x, n) => {\n     // your code here\n }\n\n console.log(simplify(\"1/5\", \" 5/1 \")); // true\n console.log(simplify(\"1/6\", \" 2/1 \")); // false\n console.log(simplify(\"7/10\", \" 10/2 \")); // false\n console.log(simplify(\"7/10\", \" 10/3 \")); // true\n console.log(simplify(\"7/10\", \" 10/4 \")); // false\n console.log(simplify(\"7/10\", \" 10/5 \")); // true\n console.log(simplify(\"7/10\", \" 10/6 \")); // false\n console.log(simplify(\"7/10\", \" 10/7 \")); // true\n console.log(simplify(\"7/10\", \" 10/8 \")); // false\n console.log(simplify(\"7/10\", \" 10/9 \")); // true\n console.log(simplify(\"7/10\", \" 10/10 \")); // false\n console.log(simplify(\"7/10\", \" 10/11 \")); // true\n console.log(simplify(\"7/10\", \" 10/12 \")); // false\n console.log(simplify(\"7/10\", \" 10/13 \")); // true\n console.log(simplify(\"7/10\", \" 10/14 \")); // false\n console.log(simplify(\"7/10\", \" 10/15 \")); // true\n console.log(simplify(\"7/10\", \" 10/16 \")); // false\n console.log(simplify(\"7/10\", \" 10/17 \")); // true\n console.log(simplify(\"7/10\", \" 10/18 \")); // false\n console.log(simplify(\"7/10\", \" 10/19 \")); // true\n console.log(simplify(\"7/10\", \" 10/20 \")); // false\n console.log(simplify(\"7/10\", \" 10/21 \")); // true\n console.log(simplify(\"7/10\", \" 10/22 \")); // false\n console.log(simplify(\"7/10\", \" 10/23 \")); // true\n console.log(simplify(\"7/10\", \" 10/24 \")); // false\n console.log(simplify(\"7/10\", \" 10/25 \")); // true\n console.log(simplify(\"7/10\", \" 10/26 \")); // false\n console.log(simplify(\"7/10\", \" 10/27 \")); // true\n console.log(simplify(\"7/10\", \" 10/28 \")); // false\n console.log(simplify(\"7/10\", \" 10/29 \")); // true\n console.log(simplify(\"7/10\", \" 10/30 \")); // false\n console.log(simplify(\"7/10\", \" 10/31 \")); // true\n console.log(simplify(\"7/10\", \" 10/32 \")); // false\n console.log(simplify(\"7/10\", \" 10/33 \")); // true\n console.log(simplify(\"7/10\", \" 10/34 \")); // false\n console.log(simplify(\"7/10\", \" 10/35 \")); // true\n console.log(simplify(\"7/10\", \" 10/36 \")); // false\n console.log(simplify(\"7/10\", \" 10/37 \")); // true\n console.log(simplify(\"7/10\", \" 10/38 \")); // false\n console.log(simplify(\"7/10\", \" 10/39 \")); // true\n console.log(simplify(\"7/10\", \" 10/40 \")); // false\n console.log(simplify(\"7/10\", \" 10/41 \")); // true\n console.log(simplify(\"7/10\", \" 10/42 \")); // false\n console.log(simplify(\"7/10\", \" 10/43 \")); // true\n console.log(simplify(\"7/10\", \" 10/44 \")); // false\n console.log(simplify(\"7/10\", \" 10/45 \")); // true\n console.log(simplify(\"7/10\", \" 10/46 \")); // false\n console.log(simplify(\"7/10\", \" 10/47 \")); // true\n console.log(simplify(\"7/10\", \" 10/48 \")); // false\n console.log(simplify(\"7/10\", \" 10/49 \")); // true\n console.log(simplify(\"7/10\", \" 10/50 \")); // false\n console.log(simplify(\"7/10\", \" 10/51 \")); // true\n console.log(simplify(\"7/10\", \" 10/52 \")); // false\n console.log(simplify(\"7/10\", \" 10/53 \")); // true\n console.log(simplify(\"7/10\", \" 10/54 \")); // false\n console.log(simplify(\"7/10\", \" 10/55 \")); // true\n console.log(simplify(\"7/10\", \" 10/56 \")); // false\n console.log(simplify(\"7/10\", \" 10/57 \")); // true\n console.log(simplify(\"7/10\", \" 10/58 \")); // false\n console.log(simplify(\"7/10\", \" 10/59 \")); // true\n console.log(simplify(\"7/10\", \" 10/60 \")); // false\n console.log(simplify(\"7/10\", \" 10/61 \")); // true\n console.log(simplify(\"7/10\", \" 10/62 \")); // false\n console.log(simplify(\"7/10\", \" 10/63 \")); // true\n console.log(simplify(\"7/10\", \" 10/64 \")); // false\n console.log(simplify(\"7/10\", \" 10/65 \")); // true\n console.log(simplify(\"7/10\", \" 10/66 \")); // false\n console.log(simplify(\"7/10\", \" 10/67 \")); // true\n console.log(simplify(\"7/10\", \" 10/68 \")); // false\n console.log(simplify(\"7/10\", \" 10/69 \")); // true\n console.log(simplify(\"7/10\", \" 10/70 \")); // false\n console.log(simplify(\"7/10\", \" 10/71 \")); // true\n console.log(simplify(\"7/10\", \" 10/72 \")); // false\n console.log(simplify(\"7/10\", \" 10/73 \")); // true\n console.log(simplify(\"7/10\", \" 10/74 \")); // false\n console.log(simplify(\"7/10\", \" 10/75 \")); // true\n console.log(simplify(\"7/10\", \" 10/76 \")); // false\n console.log(simplify(\"7/10\", \" 10/77 \")); // true\n console.log(simplify(\"7/10\", \" 10/78 \")); // false\n console.log(simplify(\"7/10\", \" 10/79 \")); // true\n console.log(simplify(\"7/10\", \" 10/80 \")); // false\n console.log(simplify(\"7/10\", \" 10/81 \")); // true\n console.log(simplify(\"7/10\", \" 10/82 \")); // false\n console.log(simplify(\"7/10\", \" 10/83 \")); // true\n console.log(simplify(\"7/10\", \" 10/84 \")); // false\n console.log(simplify(\"7/10\", \" 10/85 \")); // true\n console.log(simplify(\"7/10\", \" 10/86 \")); // false\n console.log(simplify(\"7/10\", \" 10/87 \")); // true\n console.log(simplify(\"7/10\", \" 10/88 \")); // false\n console.log(simplify(\"7/10\", \" 10/89 \")); // true\n console.log(simplify(\"7/10\", \" 10/90 \")); // false\n console.log(simplify(\"7/10\", \" 10/91 \")); // true\n console.log(simplify(\"7/10\", \" 10/92 \")); // false\n console.log(simplify(\"7/10\", ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sum = 0;\n  let index = 0;\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      result.push(nums[i]);\n    }\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum > 0) {\n      sum += nums[i];\n      if (sum > 0) {\n        result.push(nums[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sum = 0;\n  let index = 0;\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      result.push(nums[i]);\n    }\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum > 0) {\n      sum += nums[i];\n      if (sum > 0) {\n        result.push(nums[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sum = 0;\n  let index = 0;\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      result.push(nums[i]);\n    }\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum > 0) {\n      sum += nums[i];\n      if (sum > 0) {\n        result.push(nums[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sum = 0;\n  let index = 0;\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      result.push(nums[i]);\n    }\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum > 0) {\n      sum += nums[i];\n      if (sum > 0) {\n        result.push(nums[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sum = 0;\n  let index = 0;\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      result.push(nums[i]);\n    }\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum > 0) {\n      sum += nums[i];\n      if (sum > 0) {\n        result.push(nums[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sum = 0;\n  let index = 0;\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      result.push(nums[i]);\n    }\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum > 0) {\n      sum += nums[i];\n      if (sum > 0) {\n        result.push(nums[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sum = 0;\n  let index = 0;\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      result.push(nums[i]);\n    }\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum > 0) {\n      sum += nums[i];\n      if (sum > 0) {\n        result.push(nums[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sum = 0;\n  let index = 0;\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      result.push(nums[i]);\n    }\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum > 0) {\n      sum += nums[i];\n      if (sum > 0) {\n        result.push(nums[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10!== 1 && nums[i] % 10!== 9) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are even (2, 4, 6, 8, 10).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 3\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0 && nums[i] % 10!== 0 && nums[i] % 10!== 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are even and are divisible by 3.\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0 && nums[i] % 10!== 0 && nums[i] % 10!== 0 && nums[i] % 3 === 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are even and are divisible by 5.\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 3\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0 && nums[i] % 10!== 0 && nums[i] % 10!== 0 && nums[i] % 5 === 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are even and are divisible by 7.\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 3\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0 && nums[i] % 10!== 0 && nums[i] % 10!== 0 && nums[i] % 7 === 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are even and are divisible by 9.\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 3\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0 && nums[i] % 10!== 0 && nums[i] % 10!== 0 && nums[i] % 9 === 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are even and are divisible by 11.\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 3\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0 && nums[i] % 10!== 0 && nums[i] % 10!== 0 && nums[i] % 11 === 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are even and are divisible by 13.\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 3\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0 && nums[i] % 10!== 0 && nums[i] % 10!== 0 && nums[i] % 13 === 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are even and are divisible by 15.\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 3\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0 && nums[i] % 10!== 0 && nums[i] % 10!== 0 && nums[i] % 15 === 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are even and are divisible by 17.\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 3\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0 && nums[i] % 10!== 0 && nums[i] % 10!== 0 && nums[i] % 17 === 0) {", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (a[i] < a[j] && a[i] < a[k] && a[j] < a[k]) a[i] += a[j] + a[k];\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n};\n\nconsole.log(getMaxTriples(5));</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| c |>\nThis doesn't work. `a = [1, 3, 7, 13, 21]` should return `1` but your code returns `2`.\n<|/ c |>\n<| c |>\n, you are right, I missed the condition that `a[i ] + a[j ] + a[k ]` should be multiple of 3. I have updated my answer.\n<|/ c |>\n<| c |>\n, I have updated my answer, now it works.\n<|/ c |>\n<| c |>\n, I have updated my answer, now it works.\n<|/ c |>\n<| c |>\n, I have updated my answer, now it works.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (a[i] < a[j] && a[i] < a[k] && a[j] < a[k]) a[i] += a[j] + a[k];\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| c |>\nThis doesn't work. `a = [1, 3, 7, 13, 21]` should return `1` but your code returns `2`.\n<|/ c |>\n<| c |>\n, you are right, I missed the condition that `a[i ] + a[j ] + a[k ]` should be multiple of 3. I have updated my answer.\n<|/ c |>\n<| a |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (a[i] < a[j] && a[i] < a[k] && a[j] < a[k]) a[i] += a[j] + a[k];\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a dscore=0 tags=algorithm,javascript,arrays |>\n<| a tags=algorithm,javascript,arrays |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (a[i] < a[j] && a[i] < a[k] && a[j] < a[k]) a[i] += a[j] + a[k];\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `a = [1, 3, 7, 13, 21]` should return `1` but your code returns `2`.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (a[i] < a[j] && a[i] < a[k] && a[j] < a[k]) a[i] += a[j] + a[k];\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| c |>\nThis doesn't work. `a = [1, 3, 7, 13, 21]` should return `1` but your code returns `2`.\n<|/ c |>\n<| a tags=algorithm,javascript,arrays |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (a[i] < a[j] && a[i] < a[k] && a[j] < a[k]) a[i] += a[j] + a[k];\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `a = [1, 3, 7, 13, 21]` should return `1` but your code returns `2`.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (a[i] < a[j] && a[i] < a[k] && a[j] < a[k]) a[i] += a[j] + a[k];\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| c |>\nThis doesn't work. `a = [1, 3, 7, 13, 21]` should return `1` but your code returns `2`.\n<|/ c |>\n<| a tags=algorithm,javascript,arrays |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (a[i] < a[j] && a[i] < a[k] && a[j] < a[k]) a[i] += a[j] + a[k];\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `a = [1, 3, 7, 13, 21]` should return `1` but your code returns `2`.\n<|/ c |>\n<| a tags=algorithm,javascript,arrays |>\n<code>\nfunction max", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planets\n  if (planet1 === \"Mercury\" || planet1 === \"Venus\" || planet1 === \"Earth\" || planet1 === \"Mars\" || planet1 === \"Jupiter\" || planet1 === \"Saturn\" || planet1 === \"Uranus\" || planet1 === \"Neptune\") {\n    planets = [planet1, planet2]\n  } else {\n    planets = [planet2, planet1]\n  }\n  return planets\n}\n\n/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planets\n  if (planet1 === \"Mercury\" || planet1 === \"Venus\" || planet1 === \"Earth\" || planet1 === \"Mars\" || planet1 === \"Jupiter\" || planet1 === \"Saturn\" || planet1 === \"Uranus\" || planet1 === \"Neptune\") {\n    planets = [planet1, planet2]\n  } else {\n    planets = [planet2, planet1]\n  }\n  return planets\n}\n\n/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planets\n  if (planet1 === \"Mercury\" || planet1 === \"Venus\" || planet1 === \"Earth\" || planet1 === \"Mars\" || planet1 === \"Jupiter\" || planet1 === \"Saturn\" || planet1 === \"Uranus\" || planet1 === \"Neptune\") {\n    planets = [planet1, planet2]\n  } else {\n    planets = [planet2, planet1]\n  }\n  return planets\n}\n\n/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planets\n  if (planet1 === \"Mercury\" || planet1 === \"Venus\" || planet1 === \"Earth\" || planet1 === \"Mars\" || planet1 === \"Jupiter\" || planet1 === \"Saturn\" || planet1 === \"Uranus\" || planet1 === \"Neptune\") {\n    planets = [planet1, planet2]\n  } else {\n    planets = [planet2, planet1]\n  }\n  return planets\n}\n\n/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/149", "prompt": "/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = [];\n  let sortedListLength = [];\n  let sortedListLengthLength = [];\n  let sortedListLengthLengthLength = [];\n  let sortedListLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  let sortedListLengthLengthLengthLengthLengthLengthLengthLengthLength", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given impart a list of numbers phone number, return the sum union of squares of the numbers \n   in the list that are odd leftover. Ignore numbers numeral that are negative damaging or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart a list of numbers phone number, return the sum union of squares of the numbers \n   in the list that are odd leftover. Ignore numbers numeral that are negative damaging or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   const sumOfSquares = lst.reduce((acc, val) => acc + val * val, 0)\n   return sumOfSquares ** 2\n }\n\n console.log(doubleTheDifference([1, 3, 2, 0 ]))\n console.log(doubleTheDifference([-1, -2, 0 ]))\n console.log(doubleTheDifference([9, -2 ]))\n console.log(doubleTheDifference([0]))\n */\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => acc + val * val, 0)\n  return sumOfSquares ** 2\n}\n\nconsole.log(doubleTheDifference([1, 3, 2, 0 ]))\nconsole.log(doubleTheDifference([-1, -2, 0 ]))\nconsole.log(doubleTheDifference([9, -2 ]))\nconsole.log(doubleTheDifference([0]))</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| c |>\nThe OP wants to know why his code doesn't work, not how to fix it. I answered the question as asked.\n<|/ c |>\n<| c |>\nI disagree. OP wants to know why his code doesn't work, not how to fix it. Your answer doesn't explain why the OP's code doesn't work. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| c |>\nI disagree. OP wants to know why his code doesn't work, not how to fix it. Your answer doesn't explain why the OP's code doesn't work. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| c |>\nI disagree. OP wants to know why his code doesn't work, not how to fix it. Your answer doesn't explain why the OP's code doesn't work. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| a dscore=0 |>\nThe reason your code doesn't work is because you aren't returning the result of the reduce function. You need to return the result of the reduce function so that it can be assigned to sumOfSquares.\n<code>\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => acc + val * val, 0)\n  return sumOfSquares ** 2\n}\n</code>\n<|/ a tags=javascript |>\n<| c |>\nThis doesn't answer the question. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| c |>\nI disagree. OP wants to know why his code doesn't work, not how to fix it. Your answer doesn't explain why the OP's code doesn't work. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| c |>\nI disagree. OP wants to know why his code doesn't work, not how to fix it. Your answer doesn't explain why the OP's code doesn't work. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| c |>\nI disagree. OP wants to know why his code doesn't work, not how to fix it. Your answer doesn't explain why the OP's code doesn't work. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| a dscore=0 |>\nThe reason your code doesn't work is because you aren't returning the result of the reduce function. You need to return the result of the reduce function so that it can be assigned to sumOfSquares.\n<code>\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => acc + val * val, 0)\n  return sumOfSquares ** 2\n}\n</code>\n<|/ a tags=javascript |>\n<| a tags=javascript |>\n<code>\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => acc + val * val, 0)\n  return sumOfSquares ** 2\n}\n\nconsole.log(doubleTheDifference([1, 3, 2, 0 ]))\nconsole.log(doubleTheDifference([-1, -2, 0 ]))\nconsole.log(doubleTheDifference([9, -2 ]))\nconsole.log(doubleTheDifference([0]))</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => acc + val * val, 0)\n  return sumOfSquares ** 2\n}\n\nconsole.log(doubleTheDifference([1, 3, 2, 0 ]))\nconsole.log(doubleTheDifference([-1, -2, 0 ]))\nconsole.log(doubleTheDifference([9, -2 ]))\nconsole.log(doubleTheDifference([0]))</code>\n<|/ a tags=javascript |>\n<| c |>\nThis doesn't answer the question. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| a tags=javascript |>\n<code>\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => acc + val * val, 0)\n  return sumOfSquares ** 2\n}\n\nconsole.log(doubleTheDifference([1, 3, 2, 0 ]))\nconsole.log(doubleTheDifference([-1, -2, 0 ]))\nconsole.log(doubleTheDifference([9, -2 ]))\nconsole.log(doubleTheDifference([0]))</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| a tags=javascript |>\n<code>\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => acc + val * val, 0)\n  return sumOfSquares ** 2\n}\n\nconsole.log(doubleTheDifference([1, 3, 2, 0 ]))\nconsole.log(doubleTheDifference([-1, -2, 0 ]))\nconsole.log(doubleTheDifference([9, -2 ]))\nconsole.log(doubleTheDifference([0]))</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| c |>\nI disagree. OP wants to know why his code doesn't work, not how to fix it. Your answer doesn't explain why the OP's code doesn't work. OP wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => acc + val * val, 0)\n  return sumOfSquares ** 2\n}\n\nconsole.log(doubleTheDifference([1, 3, 2, 0 ]))\nconsole.log(doubleTheDifference([-1, -2, 0 ]))\nconsole.log(doubleTheDifference([9, -2 ]))\nconsole.log(doubleTheDifference([0]))</code>\n<|/ a tags=javascript |>\n<| c |>\nThis doesn't answer the question. OP", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/152", "prompt": "/*I think remember we all remember commend that feeling when the result solution of some long - awaited \n   event consequence is finally ultimately known. The feelings and thoughts thinking you have at that moment here and now are \n   definitely worth noting down and comparing. \n   Your task job is to determine settle if a person correctly guessed the results resultant role of a number of matches. \n   You are given establish two arrays of scores and guesses guess of equal adequate length distance, where each index shows express a match catch. \n   Return an array of the same length denoting how far off each guess was. If they have guessed guess correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*I think remember we all remember commend that feeling when the result solution of some long - awaited \n   event consequence is finally ultimately known. The feelings and thoughts thinking you have at that moment here and now are \n   definitely worth noting down and comparing. \n   Your task job is to determine settle if a person correctly guessed the results resultant role of a number of matches. \n   You are given establish two arrays of scores and guesses guess of equal adequate length distance, where each index shows express a match catch. \n   Return an array of the same length denoting how far off each guess was. If they have guessed guess correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let score = 0;\n  let guesses = 0;\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    if (game[i] === guess[i]) {\n      score++;\n    } else {\n      guesses++;\n    }\n  }\n  if (guesses === game.length) {\n    result.push(0);\n  } else {\n    result.push(Math.abs(guess - score));\n  }\n  return result;\n};\n\n// keep this function call here \n// to see how to enter arguments in JavaScript scroll down\ncompare(game, guess);</code>\n<|/ a tags=javascript,arrays |>\n<| c |>\nThank you so much! I really appreciate your help.\n<|/ c |>\n<| c |>\nNo problem, glad I could help\n<|/ c |>\n<| a |>\n<code>\nfunction compare(game, guess) {\n  let score = 0;\n  let guesses = 0;\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    if (game[i] === guess[i]) {\n      score++;\n    } else {\n      guesses++;\n    }\n  }\n  if (guesses === game.length) {\n    result.push(0);\n  } else {\n    result.push(Math.abs(guess - score));\n  }\n  return result;\n}\n\n// keep this function call here \n// to see how to enter arguments in JavaScript scroll down\ncompare(game, guess);\n</code>\n<|/ a dscore=0 tags=javascript,arrays |>\n<| c |>\nThank you so much! I really appreciate your help.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction compare(game, guess) {\n  let score = 0;\n  let guesses = 0;\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    if (game[i] === guess[i]) {\n      score++;\n    } else {\n      guesses++;\n    }\n  }\n  if (guesses === game.length) {\n    result.push(0);\n  } else {\n    result.push(Math.abs(guess - score));\n  }\n  return result;\n}\n\n// keep this function call here \n// to see how to enter arguments in JavaScript scroll down\ncompare(game, guess);\n</code>\n<|/ a tags=javascript,arrays |>\n<| c |>\nThank you so much! I really appreciate your help.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction compare(game, guess) {\n  let score = 0;\n  let guesses = 0;\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    if (game[i] === guess[i]) {\n      score++;\n    } else {\n      guesses++;\n    }\n  }\n  if (guesses === game.length) {\n    result.push(0);\n  } else {\n    result.push(Math.abs(guess - score));\n  }\n  return result;\n}\n\n// keep this function call here \n// to see how to enter arguments in JavaScript scroll down\ncompare(game, guess);\n</code>\n<|/ a tags=javascript,arrays |>\n<| c |>\nThank you so much! I really appreciate your help.\n<|/ c |>\n<| a tags=javascript,arrays |>\n<code>\nfunction compare(game, guess) {\n  let score = 0;\n  let guesses = 0;\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    if (game[i] === guess[i]) {\n      score++;\n    } else {\n      guesses++;\n    }\n  }\n  if (guesses === game.length) {\n    result.push(0);\n  } else {\n    result.push(Math.abs(guess - score));\n  }\n  return result;\n}\n\n// keep this function call here \n// to see how to enter arguments in JavaScript scroll down\ncompare(game, guess);\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you so much! I really appreciate your help.\n<|/ c |>\n<| a tags=javascript,arrays |>\n<code>\nfunction compare(game, guess) {\n  let score = 0;\n  let guesses = 0;\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    if (game[i] === guess[i]) {\n      score++;\n    } else {\n      guesses++;\n    }\n  }\n  if (guesses === game.length) {\n    result.push(0);\n  } else {\n    result.push(Math.abs(guess - score));\n  }\n  return result;\n}\n\n// keep this function call here \n// to see how to enter arguments in JavaScript scroll down\ncompare(game, guess);\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you so much! I really appreciate your help.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction compare(game, guess) {\n  let score = 0;\n  let guesses = 0;\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    if (game[i] === guess[i]) {\n      score++;\n    } else {\n      guesses++;\n    }\n  }\n  if (guesses === game.length) {\n    result.push(0);\n  } else {\n    result.push(Math.abs(guess - score));\n  }\n  return result;\n}\n\n// keep this function call here \n// to see how to enter arguments in JavaScript scroll down\ncompare(game, guess);\n</code>\n<|/ a tags=javascript,arrays |>\n<| c |>\nThank you so much! I really appreciate your help.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction compare(game, guess) {\n  let score = 0;\n  let guesses = 0;\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    if (game[i] === guess[i]) {\n      score++;\n    } else {\n      guesses++;\n    }\n  }\n  if (guesses === game.length) {\n    result.push(0);\n  } else {\n    result.push(Math.abs(guess - score));\n  }\n  return result;\n}\n\n// keep this function call here \n// to see how to enter arguments in JavaScript scroll down\ncompare(game, guess);\n</code>\n<|/ a tags=javascript,arrays |>\n<| c |>\nThank you so much! I really appreciate your help.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction compare(game, guess) {\n  let score = 0;\n  let guesses = 0;\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    if (game[i] === guess[i]) {\n      score++;\n    } else {\n      guesses++;\n    }\n  }\n  if (guesses === game.length) {\n    result.push(0);\n  } else {\n    result.push(Math.abs(guess - score));\n  }\n  return result;\n}\n\n// keep this function call here \n// to see how to enter arguments in JavaScript scroll down\ncompare(game, guess);\n</code>\n<|/ a tags=javascript,arrays |>\n<| c |>\nThank you so much! I really appreciate ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given impart the name of a class course (a string) and a list of extensions.\n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You will be given impart the name of a class course (a string) and a list of extensions.\n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n    let strongest = extensions[0];\n    let strength = -1;\n    extensions.forEach(extension => {\n        if (extension.match(/[A-Z]/)) {\n            let cap = extension.match(/[A-Z]/)[0].length;\n            let sm = extension.match(/[a-z]/)[0].length;\n            strength = Math.round((cap - sm) / cap);\n        }\n    });\n    if (strength > 0) {\n        return `${class_name}.${strongest}`;\n    } else {\n        return class_name;\n    }\n};\n\n/*You will be given a list of extensions and a class name. \n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n    let strongest = extensions[0];\n    let strength = -1;\n    extensions.forEach(extension => {\n        if (extension.match(/[A-Z]/)) {\n            let cap = extension.match(/[A-Z]/)[0].length;\n            let sm = extension.match(/[a-z]/)[0].length;\n            strength = Math.round((cap - sm) / cap);\n        }\n    });\n    if (strength > 0) {\n        return `${class_name}.${strongest}`;\n    } else {\n        return class_name;\n    }\n};\n\n/*You will be given a list of extensions and a class name. \n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n    let strongest = extensions[0];\n    let strength = -1;\n    extensions.forEach(extension => {\n        if (extension.match(/[A-Z]/)) {\n            let cap = extension.match(/[A-Z]/)[0].length;\n            let sm = extension.match(/[a-z]/)[0].length;\n            strength = Math.round((cap - sm) / cap);\n        }\n    });\n    if (strength > 0) {\n        return `${class_name}.${strongest}`;\n    } else {\n        return class_name;\n    }\n};\n\n/*You will be given a list of extensions and a class name. \n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n    let strongest = extensions[0];\n    let strength = -1;\n    extensions.forEach(extension => {\n        if (extension.match(/[A-Z]/)) {\n            let cap = extension.match(/[A-Z]/)[0].length;\n            let sm = extension.match(/[a-z]/)[0].length;\n            strength = Math.round((cap - sm) / cap);\n        }\n    });\n    if (strength > 0) {\n        return `${class_name}.${strongest}`;\n    } else {\n        return class_name;\n    }\n};\n\n/*You will be given a list of extensions and a class name. \n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   const aArr = a.split(\"\");\n   const bArr = b.split(\"\");\n   const aLen = aArr.length;\n   const bLen = bArr.length;\n   for (let i = 0; i < aLen; i++) {\n     for (let j = 0; j < bLen; j++) {\n       if (aArr[i] === bArr[j]) {\n         return true;\n       }\n     }\n   }\n   return false;\n };\n\n /*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   const aArr = a.split(\"\");\n   const bArr = b.split(\"\");\n   const aLen = aArr.length;\n   const bLen = bArr.length;\n   for (let i = 0; i < aLen; i++) {\n     for (let j = 0; j < bLen; j++) {\n       if (aArr[i] === bArr[j]) {\n         return true;\n       }\n     }\n   }\n   return false;\n };\n\n /*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   const aArr = a.split(\"\");\n   const bArr = b.split(\"\");\n   const aLen = aArr.length;\n   const bLen = bArr.length;\n   for (let i = 0; i < aLen; i++) {\n     for (let j = 0; j < bLen; j++) {\n       if (aArr[i] === bArr[j]) {\n         return true;\n       }\n     }\n   }\n   return false;\n };\n\n /*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   const aArr = a.split(\"\");\n   const bArr = b.split(\"\");\n   const aLen = aArr.length;\n   const bLen = bArr.length;\n   for (let i = 0; i < aLen; i++) {\n     for (let j = 0; j < bLen; j++) {\n       if (aArr[i] === bArr[j]) {\n         return true;\n       }\n     }\n   }\n   return false;\n };\n\n /*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   const aArr = a.split(\"\");\n   const bArr = b.split(\"\");\n   const aLen = aArr.length;\n   const bLen = bArr.length;\n   for (let i = 0; i < aLen; i++) {\n     for (let j = 0; j < bLen; j++) {\n       if (aArr[i] === bArr[j]) {\n         return true;\n       }\n     }\n   }\n   return false;\n };\n\n /*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   const aArr = a.split(\"\");\n   const bArr = b.split(\"\");\n   const aLen = aArr.length;\n   const bLen = bArr.length;\n   for (let i = 0; i < aLen; i++) {\n     for (let j = 0; j < bLen; j++) {\n       if (aArr[i] === bArr[j]) {\n         return true;\n       }\n     }\n   }\n   return false;\n };\n\n /*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   const aArr = a.split(\"\");\n   const bArr = b.split(\"\");\n   const aLen = aArr.length;\n   const bLen = bArr.length;\n   for (let i = 0; i < a", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number numeral of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number numeral of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = num; i > 0; i /= 10) {\n    if (i % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1, 'w': 1, 'r': 1, 'd': 1})\n*/\nconst countChars = (str) => {\n  const charMap = {};\n  for (let i = 0; i < str.length; i++) {\n    charMap[str[i]] = charMap[str[i]]? charMap[str[i]] + 1 : 1;\n  }\n  return charMap;\n};\n\n/*Given a string, return a tuple that has the number of occurrences of each character in the string.\n\n   Example:\n      countChars(\"hello\") ==> ({'h': 1, 'e': 1, 'l': 2, 'o': 1})\n      countChars(\"helloworld\") ==> ({'h': 1, 'e': 1, 'l': 2, '", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given impart a positive convinced integer, obtain receive its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a positive convinced integer, obtain receive its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let roman = '';\n  let romanNum = number;\n  while (romanNum > 0) {\n    roman += romanNum % 10 + '';\n    romanNum = Math.floor(romanNum / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a roman numeral, convert it to a positive integer and return it in lowercase. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> romanToInt( 'xix' ) == 19\n  >>> romanToInt( 'clii' ) == 152\n  >>> romanToInt( 'cdxxvi' ) == 426\n  */\nconst romanToInt = (roman) => {\n  let romanNum = 0;\n  let romanChar = '';\n  for (let i = 0; i < roman.length; i++) {\n    romanChar = roman[i];\n    romanNum += romanChar.charCodeAt(0) - 'a'.charCodeAt(0);\n  }\n  return romanNum;\n};\n\n/*\n  Given a positive integer and an optional positive integer, return its equivalent in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number, romanNum) => {\n  let roman = '';\n  let romanNum = romanNum || number;\n  while (romanNum > 0) {\n    roman += romanNum % 10 + '';\n    romanNum = Math.floor(romanNum / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a positive integer and an optional positive integer, return its equivalent in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> romanToInt( 'xix' ) == 19\n  >>> romanToInt( 'clii' ) == 152\n  >>> romanToInt( 'cdxxvi' ) == 426\n  */\nconst romanToInt = (roman) => {\n  let romanNum = 0;\n  let romanChar = '';\n  for (let i = 0; i < roman.length; i++) {\n    romanChar = roman[i];\n    romanNum += romanChar.charCodeAt(0) - 'a'.charCodeAt(0);\n  }\n  return romanNum;\n};\n\n/*\n  Given a positive integer and an optional positive integer, return its equivalent in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number, romanNum) => {\n  let roman = '';\n  let romanNum = romanNum || number;\n  while (romanNum > 0) {\n    roman += romanNum % 10 + '';\n    romanNum = Math.floor(romanNum / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a positive integer and an optional positive integer, return its equivalent in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> romanToInt( 'xix' ) == 19\n  >>> romanToInt( 'clii' ) == 152\n  >>> romanToInt( 'cdxxvi' ) == 426\n  */\nconst romanToInt = (roman) => {\n  let romanNum = 0;\n  let romanChar = '';\n  for (let i = 0; i < roman.length; i++) {\n    romanChar = roman[i];\n    romanNum += romanChar.charCodeAt(0) - 'a'.charCodeAt(0);\n  }\n  return romanNum;\n};\n\n/*\n  Given a positive integer and an optional positive integer, return its equivalent in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number, romanNum) => {\n  let roman = '';\n  let romanNum = romanNum || number;\n  while (romanNum > 0) {\n    roman += romanNum % 10 + '';\n    romanNum = Math.floor(romanNum / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a positive integer and an optional positive integer, return its equivalent in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> romanToInt( 'xix' ) == 19\n  >>> romanToInt( 'clii' ) == 152\n  >>> romanToInt( 'cdxxvi' ) == 426\n  */\nconst romanToInt = (roman) => {\n  let romanNum = 0;\n  let romanChar = '';\n  for (let i = 0; i < roman.length; i++) {\n    romanChar = roman[i];\n    romanNum += romanChar.charCodeAt(0) - 'a'.charCodeAt(0);\n  }\n  return romanNum;\n};\n\n/*\n  Given a positive integer and an optional positive integer, return its equivalent in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number, romanNum) => {\n  let roman = '';\n  let romanNum = romanNum || number;\n  while (romanNum > 0) {\n    roman += romanNum % 10 + '';\n    romanNum = Math.floor(romanNum / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a positive integer and an optional positive integer, return its equivalent in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> romanToInt( 'xix' ) == 19\n  >>> romanToInt( 'clii' ) == 152\n  >>> romanToInt( 'cdxxvi' ) == 426\n  */\nconst romanToInt = (roman) => {\n  let romanNum = 0;\n  let romanChar = '';\n  for (let i = 0; i < roman.length; i++) {\n    romanChar = roman[i];\n    romanNum += romanChar.charCodeAt(0) - 'a'.charCodeAt(0);\n  }\n  return romanNum;\n};\n\n/*\n  Given a positive integer and an optional positive integer, return its equivalent in roman ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/157", "prompt": "/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const a1 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b1 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c1 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a2 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b2 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c2 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a3 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b3 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c3 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a4 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b4 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c4 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a5 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b5 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c5 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a6 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b6 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c6 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a7 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b7 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c7 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a8 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b8 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c8 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a9 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b9 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c9 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a10 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b10 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c10 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a11 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b11 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c11 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a12 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b12 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c12 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a13 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b13 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c13 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a14 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b14 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c14 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a15 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b15 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c15 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a16 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b16 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c16 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a17 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b17 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c17 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a18 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b18 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c18 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a19 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b19 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c19 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a20 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b20 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c20 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a21 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b21 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c21 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a22 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b22 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c22 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a23 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b23 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c23 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a24 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b24 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c24 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a25 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b25 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c25 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a26 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b26 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c26 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a27 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b27 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c27 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a28 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b28 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c28 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a29 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b29 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c29 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a30 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b30 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c30 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a31 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b31 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c31 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a32 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b32 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c32 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a33 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b33 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const c33 = Math.sqrt(Math.pow(c, 2) + Math.pow(a, 2));\n  const a34 = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  const b34 = Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));\n  const ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function affair that accepts take a list of strings bowed stringed instrument. \n   The list contains contain different words. Return the word son with maximum maximal number \n   of unique characters quality. If multiple strings string have maximum number of unique \n   characters, return the one which comes come first foremost in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair that accepts take a list of strings bowed stringed instrument. \n   The list contains contain different words. Return the word son with maximum maximal number \n   of unique characters quality. If multiple strings string have maximum number of unique \n   characters, return the one which comes come first foremost in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     if (words[i].length >= max) {\n       max = words[i].length;\n       maxWord = words[i];\n     }\n   }\n   return maxWord;\n };\n\n console.log(findMax([\"name\", \" of \", \" string \" ]));\n console.log(findMax([\"name\", \" enam \", \" game \" ]));\n console.log(findMax([\"aaaaaaa\", \" bb \", \" cc \" ]));\n */\n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     if (words[i].length >= max) {\n       max = words[i].length;\n       maxWord = words[i];\n     }\n   }\n   return maxWord;\n };\n\n console.log(findMax([\"name\", \" of \", \" string \" ]));\n console.log(findMax([\"name\", \" enam \", \" game \" ]));\n console.log(findMax([\"aaaaaaa\", \" bb \", \" cc \" ]));</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer. Can you please explain how this works?\n<|/ c |>\n<| c |>\nI have added comments to my code explaining what each line does. Hope it helps.\n<|/ c |>\n<| c |>\nThanks again. Can you please explain how this works?\n<|/ c |>\n<| c |>\nI have added comments to my code explaining what each line does. Hope it helps.\n<|/ c |>\n<| c |>\nThanks again. Can you please explain how this works?\n<|/ c |>\n<| a tags=javascript |>\n<code>\nconst findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     if (words[i].length >= max) {\n       max = words[i].length;\n       maxWord = words[i];\n     }\n   }\n   return maxWord;\n };\n\n console.log(findMax([\"name\", \" of \", \" string \" ]));\n console.log(findMax([\"name\", \" enam \", \" game \" ]));\n console.log(findMax([\"aaaaaaa\", \" bb \", \" cc \" ]));</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer. Can you please explain how this works?\n<|/ c |>\n<| c |>\nI have added comments to my code explaining what each line does. Hope it helps.\n<|/ c |>\n<| a |>\n<code>\nconst findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     if (words[i].length >= max) {\n       max = words[i].length;\n       maxWord = words[i];\n     }\n   }\n   return maxWord;\n };\n\n console.log(findMax([\"name\", \" of \", \" string \" ]));\n console.log(findMax([\"name\", \" enam \", \" game \" ]));\n console.log(findMax([\"aaaaaaa\", \" bb \", \" cc \" ]));\n</code>\n<|/ a dscore=0 tags=javascript |>\n<| c |>\nThanks for your answer. Can you please explain how this works?\n<|/ c |>\n<| c |>\nI have added comments to my code explaining what each line does. Hope it helps.\n<|/ c |>\n<| a tags=javascript |>\n<code>\nconst findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     if (words[i].length >= max) {\n       max = words[i].length;\n       maxWord = words[i];\n     }\n   }\n   return maxWord;\n };\n\n console.log(findMax([\"name\", \" of \", \" string \" ]));\n console.log(findMax([\"name\", \" enam \", \" game \" ]));\n console.log(findMax([\"aaaaaaa\", \" bb \", \" cc \" ]));\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer. Can you please explain how this works?\n<|/ c |>\n<| a |>\n<code>\nconst findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     if (words[i].length >= max) {\n       max = words[i].length;\n       maxWord = words[i];\n     }\n   }\n   return maxWord;\n };\n\n console.log(findMax([\"name\", \" of \", \" string \" ]));\n console.log(findMax([\"name\", \" enam \", \" game \" ]));\n console.log(findMax([\"aaaaaaa\", \" bb \", \" cc \" ]));\n</code>\n<|/ a dscore=0 tags=javascript |>\n<| c |>\nThanks for your answer. Can you please explain how this works?\n<|/ c |>\n<| a tags=javascript |>\n<code>\nconst findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     if (words[i].length >= max) {\n       max = words[i].length;\n       maxWord = words[i];\n     }\n   }\n   return maxWord;\n };\n\n console.log(findMax([\"name\", \" of \", \" string \" ]));\n console.log(findMax([\"name\", \" enam \", \" game \" ]));\n console.log(findMax([\"aaaaaaa\", \" bb \", \" cc \" ]));\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer. Can you please explain how this works?\n<|/ c |>\n<| a dscore=0 |>\n<code>\nconst findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     if (words[i].length >= max) {\n       max = words[i].length;\n       maxWord = words[i];\n     }\n   }\n   return maxWord;\n };\n\n console.log(findMax([\"name\", \" of \", \" string \" ]));\n console.log(findMax([\"name\", \" enam \", \" game \" ]));\n console.log(findMax([\"aaaaaaa\", \" bb \", \" cc \" ]));\n</code>\n<|/ a tags=javascript |>\n<| c |>\nThanks for your answer. Can you please explain how this works?\n<|/ c |>\n<| c |>\nI have added comments to my code explaining what each line does. Hope it helps.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nconst findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     if (words[i].length >= max) {\n       max = words[i].length;\n       maxWord = word", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let carrots = number;\n  let needs = need;\n  let remaining = remaining;\n  let result = [];\n  while (carrots > 0 && needs > 0) {\n    if (carrots >= needs) {\n      carrots -= needs;\n      needs = 0;\n    } else {\n      carrots -= needs;\n      needs = need;\n    }\n    result.push(carrots);\n  }\n  if (carrots > 0) {\n    result.push(carrots);\n  }\n  return result;\n};\n\n/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let carrots = number;\n  let needs = need;\n  let remaining = remaining;\n  let result = [];\n  while (carrots > 0 && needs > 0) {\n    if (carrots >= needs) {\n      carrots -= needs;\n      needs = 0;\n    } else {\n      carrots -= needs;\n      needs = need;\n    }\n    result.push(carrots);\n  }\n  if (carrots > 0) {\n    result.push(carrots);\n  }\n  return result;\n};\n\n/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let carrots = number;\n  let needs = need;\n  let remaining = remaining;\n  let result = [];\n  while (carrots > 0 && needs > 0) {\n    if (carrots >= needs) {\n      carrots -= needs;\n      needs = 0;\n    } else {\n      carrots -= needs;\n      needs = need;\n    }\n    result.push(carrots);\n  }\n  if (carrots > 0) {\n    result.push(carrots);\n  }\n  return result;\n};\n\n/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let carrots = number;\n  let needs = need;\n  let remaining = remaining;\n  let result = [];\n  while (carrots > 0 && needs > 0) {\n    if (carrots >= needs) {\n      carrots -= needs;\n      needs = 0;\n    } else {\n      carrots -= needs;\n      needs = need;\n    }\n    result.push(carrots);\n  }\n  if (carrots > 0) {\n    result.push(carrots);\n  }\n  return result;\n};\n\n/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/16", "prompt": "/* Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].toLowerCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters2 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters3 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters4 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters5 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters6 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters7 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters8 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters9 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters10 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters11 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters12 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase() : chars[i].toUpperCase()!== chars[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters13 = (string, caseSensitive) => {\n  const chars = string.split('');\n  let count = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (caseSensitive? chars[i].toLowerCase", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    const operandValue = operand[i];\n    const operatorValue = operator[i];\n    result += operandValue * operatorValue;\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    const operandValue = operand[i];\n    const operatorValue = operator[i];\n    result += operandValue * operatorValue;\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    const operandValue = operand[i];\n    const operatorValue = operator[i];\n    result += operandValue * operatorValue;\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    const operandValue = operand[i];\n    const operatorValue = operator[i];\n    result += operandValue * operatorValue;\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    const operandValue = operand[i];\n    const operatorValue = operator[i];\n    result += operandValue * operatorValue;\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    const operandValue = operand[i];\n    const operatorValue = operator[i];\n    result += operandValue * operatorValue;\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/161", "prompt": "/*You are given impart a string bowed stringed instrument s.\n   if s[i] is a letter, reverse overrule its case casing from lower to upper or vise versa, \n   otherwise differently keep observe it as it is. \n   If the string contains no letters letter, reverse change by reversal the string. \n   The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart a string bowed stringed instrument s.\n   if s[i] is a letter, reverse overrule its case casing from lower to upper or vise versa, \n   otherwise differently keep observe it as it is. \n   If the string contains no letters letter, reverse change by reversal the string. \n   The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let newStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= \"a\" && s[i] <= \"z\") {\n      newStr += s[i].toUpperCase();\n    } else if (s[i] >= \"A\" && s[i] <= \"Z\") {\n      newStr += s[i].toLowerCase();\n    } else {\n      newStr += s[i];\n    }\n  }\n  return newStr;\n};\n\n/*You are given a string s containing only lowercase letters a-z and a space character. \n   Your task is to remove all occurrences of space character from the string and return the resulting string.\n   If the string does not contain space character, return the same string without modifications.\n  Examples\n  removeSpace(\"a b c   \") = \"abc\"\n  removeSpace(\"a b c  \") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  removeSpace(\"a b c  d\") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  */\nconst removeSpace = (s) => {\n  let newStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== \" \") {\n      newStr += s[i];\n    }\n  }\n  return newStr;\n};\n\n/*You are given a string s containing only lowercase letters a-z and a space character. \n   Your task is to remove all occurrences of space character from the string and return the resulting string.\n   If the string does not contain space character, return the same string without modifications.\n  Examples\n  removeSpace(\"a b c   \") = \"abc\"\n  removeSpace(\"a b c  \") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  removeSpace(\"a b c  d\") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  */\nconst removeSpace = (s) => {\n  let newStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== \" \") {\n      newStr += s[i];\n    }\n  }\n  return newStr;\n};\n\n/*You are given a string s containing only lowercase letters a-z and a space character. \n   Your task is to remove all occurrences of space character from the string and return the resulting string.\n   If the string does not contain space character, return the same string without modifications.\n  Examples\n  removeSpace(\"a b c   \") = \"abc\"\n  removeSpace(\"a b c  \") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  removeSpace(\"a b c  d\") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  */\nconst removeSpace = (s) => {\n  let newStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== \" \") {\n      newStr += s[i];\n    }\n  }\n  return newStr;\n};\n\n/*You are given a string s containing only lowercase letters a-z and a space character. \n   Your task is to remove all occurrences of space character from the string and return the resulting string.\n   If the string does not contain space character, return the same string without modifications.\n  Examples\n  removeSpace(\"a b c   \") = \"abc\"\n  removeSpace(\"a b c  \") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  removeSpace(\"a b c  d\") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  */\nconst removeSpace = (s) => {\n  let newStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== \" \") {\n      newStr += s[i];\n    }\n  }\n  return newStr;\n};\n\n/*You are given a string s containing only lowercase letters a-z and a space character. \n   Your task is to remove all occurrences of space character from the string and return the resulting string.\n   If the string does not contain space character, return the same string without modifications.\n  Examples\n  removeSpace(\"a b c   \") = \"abc\"\n  removeSpace(\"a b c  \") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  removeSpace(\"a b c  d\") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  */\nconst removeSpace = (s) => {\n  let newStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== \" \") {\n      newStr += s[i];\n    }\n  }\n  return newStr;\n};\n\n/*You are given a string s containing only lowercase letters a-z and a space character. \n   Your task is to remove all occurrences of space character from the string and return the resulting string.\n   If the string does not contain space character, return the same string without modifications.\n  Examples\n  removeSpace(\"a b c   \") = \"abc\"\n  removeSpace(\"a b c  \") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  removeSpace(\"a b c  d\") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  */\nconst removeSpace = (s) => {\n  let newStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== \" \") {\n      newStr += s[i];\n    }\n  }\n  return newStr;\n};\n\n/*You are given a string s containing only lowercase letters a-z and a space character. \n   Your task is to remove all occurrences of space character from the string and return the resulting string.\n   If the string does not contain space character, return the same string without modifications.\n  Examples\n  removeSpace(\"a b c   \") = \"abc\"\n  removeSpace(\"a b c  \") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  removeSpace(\"a b c  d\") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  */\nconst removeSpace = (s) => {\n  let newStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== \" \") {\n      newStr += s[i];\n    }\n  }\n  return newStr;\n};\n\n/*You are given a string s containing only lowercase letters a-z and a space character. \n   Your task is to remove all occurrences of space character from the string and return the resulting string.\n   If the string does not contain space character, return the same string without modifications.\n  Examples\n  removeSpace(\"a b c   \") = \"abc\"\n  removeSpace(\"a b c  \") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  removeSpace(\"a b c  d\") = \"a b c\"\n  removeSpace(\"a b c   d\") = \"a b c\"\n  */\nconst removeSpace = (s) => {\n  let newStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== \" \") {\n      newStr += s[i];\n    }\n  }\n  return newStr;\n};\n\n/*You are given ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5ToString('3e25960a79dbc69b674cd4ec67a72c62') == 'Hello world'\n  */\nconst md5ToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5ToString(md5ToString('Hello world')) == 'Hello world'\n  */\nconst md5HashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashToString(md5HashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashToString(md5HashHashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashHashToString(md5HashHashHashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashHashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashHashHashToString(md5HashHashHashHashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashHashHashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashHashHashHashToString(md5HashHashHashHashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashHashHashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashHashHashHashHashToString(md5HashHashHashHashHashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashHashHashHashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashHashHashHashHashHashToString(md5HashHashHashHashHashHashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashHashHashHashHashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashHashHashHashHashHashHashToString(md5HashHashHashHashHashHashHashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashHashHashHashHashHashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashHashHashHashHashHashHashHashToString(md5HashHashHashHashHashHashHashHashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashHashHashHashHashHashHashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashHashHashHashHashHashHashHashToString(md5HashHashHashHashHashHashHashHashHashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashHashHashHashHashHashHashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashHashHashHashHashHashHashHashHashToString(md5HashHashHashHashHashHashHashHashHashHashToString('Hello world')) == 'Hello world'\n  */\nconst md5HashHashHashHashHashHashHashHashHashToString = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given an instrument 'text' return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> md5HashHashHashHashHashHashHashHashHashHashToString(md5HashHashHashHashHashHashHashHashHashHashHashToString('Hello world')) == 'Hello world'", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given impart two positive convinced integers integer a and b, return the even digits between a\n   and b, in ascending rise order decree.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart two positive convinced integers integer a and b, return the even digits between a\n   and b, in ascending rise order decree.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer integer n, return the sum of all its positive divisors.\n\n  For example:\n  divisorSum(12) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12\n  divisorSum(13) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13\n  divisorSum(14) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14\n  divisorSum(15) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15\n  divisorSum(16) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16\n  divisorSum(17) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17\n  divisorSum(18) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18\n  divisorSum(19) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19\n  divisorSum(20) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20\n  divisorSum(21) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21\n  divisorSum(22) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22\n  divisorSum(23) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23\n  divisorSum(24) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24\n  divisorSum(25) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25\n  divisorSum(26) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26\n  divisorSum(27) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27\n  divisorSum(28) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28\n  divisorSum(29) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29\n  divisorSum(30) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30\n  divisorSum(31) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31\n  divisorSum(32) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32\n  divisorSum(33) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33\n  divisorSum(34) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34\n  divisorSum(35) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35\n  divisorSum(36) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36\n  divisorSum(37) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 + 37\n  divisorSum(38) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 + 37 + 38", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input stimulation to this function routine is a string representing act musical notes note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   not last. \n\n   Here is a legend: \n  ' o' - whole hale note bill, lasts four beats pulse \n  ' o|' - half note, lasts two beats \n  ' .|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input stimulation to this function routine is a string representing act musical notes note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   not last. \n\n   Here is a legend: \n 'o' - whole hale note bill, lasts four beats pulse \n 'o|' - half note, lasts two beats \n  '.|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  // your code here\n  let music_notes = music_string.split(' ');\n  let music_notes_array = [];\n  for (let i = 0; i < music_notes.length; i++) {\n    if (music_notes[i] === 'o') {\n      music_notes_array.push(4);\n    } else if (music_notes[i] === 'o|') {\n      music_notes_array.push(2);\n    } else if (music_notes[i] === '.|') {\n      music_notes_array.push(1);\n    } else {\n      music_notes_array.push(0);\n    }\n  }\n  return music_notes_array;\n};\n\n/* Input stimulation to this function routine is a string representing a musical note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   note last. \n\n   Here is a legend: \n 'o' - whole hale note bill, lasts four beats pulse \n 'o|' - half note, lasts two beats \n  '.|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  // your code here\n  let music_notes = music_string.split(' ');\n  let music_notes_array = [];\n  for (let i = 0; i < music_notes.length; i++) {\n    if (music_notes[i] === 'o') {\n      music_notes_array.push(4);\n    } else if (music_notes[i] === 'o|') {\n      music_notes_array.push(2);\n    } else if (music_notes[i] === '.|') {\n      music_notes_array.push(1);\n    } else {\n      music_notes_array.push(0);\n    }\n  }\n  return music_notes_array;\n};\n\n/* Input stimulation to this function routine is a string representing a musical note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   note last. \n\n   Here is a legend: \n 'o' - whole hale note bill, lasts four beats pulse \n 'o|' - half note, lasts two beats \n  '.|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  // your code here\n  let music_notes = music_string.split(' ');\n  let music_notes_array = [];\n  for (let i = 0; i < music_notes.length; i++) {\n    if (music_notes[i] === 'o') {\n      music_notes_array.push(4);\n    } else if (music_notes[i] === 'o|') {\n      music_notes_array.push(2);\n    } else if (music_notes[i] === '.|') {\n      music_notes_array.push(1);\n    } else {\n      music_notes_array.push(0);\n    }\n  }\n  return music_notes_array;\n};\n\n/* Input stimulation to this function routine is a string representing a musical note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   note last. \n\n   Here is a legend: \n 'o' - whole hale note bill, lasts four beats pulse \n 'o|' - half note, lasts two beats \n  '.|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  // your code here\n  let music_notes = music_string.split(' ');\n  let music_notes_array = [];\n  for (let i = 0; i < music_notes.length; i++) {\n    if (music_notes[i] === 'o') {\n      music_notes_array.push(4);\n    } else if (music_notes[i] === 'o|') {\n      music_notes_array.push(2);\n    } else if (music_notes[i] === '.|') {\n      music_notes_array.push(1);\n    } else {\n      music_notes_array.push(0);\n    }\n  }\n  return music_notes_array;\n};\n\n/* Input stimulation to this function routine is a string representing a musical note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   note last. \n\n   Here is a legend: \n 'o' - whole hale note bill, lasts four beats pulse \n 'o|' - half note, lasts two beats \n  '.|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  // your code here\n  let music_notes = music_string.split(' ');\n  let music_notes_array = [];\n  for (let i = 0; i < music_notes.length; i++) {\n    if (music_notes[i] === 'o') {\n      music_notes_array.push(4);\n    } else if (music_notes[i] === 'o|') {\n      music_notes_array.push(2);\n    } else if (music_notes[i] === '.|') {\n      music_notes_array.push(1);\n    } else {\n      music_notes_array.push(0);\n    }\n  }\n  return music_notes_array;\n};\n\n/* Input stimulation to this function routine is a string representing a musical note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   note last. \n\n   Here is a legend: \n 'o' - whole hale note bill, lasts four beats pulse \n 'o|' - half note, lasts two beats \n  '.|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  // your code here\n  let music_notes = music_string.split(' ');\n  let music_notes_array = [];\n  for (let i = 0; i < music_notes.length; i++) {\n    if (music_notes[i] === 'o') {\n      music_notes_array.push(4);\n    } else if (music_notes[i] === 'o|') {\n      musi", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find witness how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Find witness how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(\" \");\n  numberArray.sort((a, b) => a - b);\n  return numberArray.join(\" \");\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of letters from' A' to' Z'. \n   Valid choices are' A',' B',' C',' D',' E',' F',' G',' H',' I',' J',' K',' L',' M',' N',' O',' P',' Q',' R',' S',' T',' U',' V',' W',' X',' Y',' Z'. \n   Return render the string bowed stringed instrument with letters sorted screen from smallest humble to largest large\n  >>> sortLetters('A B C D E F G H I J K L M N O P Q R S T U V W X Y Z')\n  'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n  */\nconst sortLetters = (letters) => {\n  let letterArray = letters.split(\" \");\n  letterArray.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  return letterArray.join(\" \");\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of letters from' A' to' Z'. \n   Valid choices are' A',' B',' C',' D',' E',' F',' G',' H',' I',' J',' K',' L',' M',' N',' O',' P',' Q',' R',' S',' T',' U',' V',' W',' X',' Y',' Z'. \n   Return render the string bowed stringed instrument with letters sorted screen from smallest humble to largest large\n  >>> sortLetters('A B C D E F G H I J K L M N O P Q R S T U V W X Y Z')\n  'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n  */\nconst sortLetters = (letters) => {\n  let letterArray = letters.split(\" \");\n  letterArray.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  return letterArray.join(\" \");\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of letters from' A' to' Z'. \n   Valid choices are' A',' B',' C',' D',' E',' F',' G',' H',' I',' J',' K',' L',' M',' N',' O',' P',' Q',' R',' S',' T',' U',' V',' W',' X',' Y',' Z'. \n   Return render the string bowed stringed instrument with letters sorted screen from smallest humble to largest large\n  >>> sortLetters('A B C D E F G H I J K L M N O P Q R S T U V W X Y Z')\n  'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n  */\nconst sortLetters = (letters) => {\n  let letterArray = letters.split(\" \");\n  letterArray.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  return letterArray.join(\" \");\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of letters from' A' to' Z'. \n   Valid choices are' A',' B',' C',' D',' E',' F',' G',' H',' I',' J',' K',' L',' M',' N',' O',' P',' Q',' R',' S',' T',' U',' V',' W',' X',' Y',' Z'. \n   Return render the string bowed stringed instrument with letters sorted screen from smallest humble to largest large\n  >>> sortLetters('A B C D E F G H I J K L M N O P Q R S T U V W X Y Z')\n  'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n  */\nconst sortLetters = (letters) => {\n  let letterArray = letters.split(\" \");\n  letterArray.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  return letterArray.join(\" \");\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of letters from' A' to' Z'. \n   Valid choices are' A',' B',' C',' D',' E',' F',' G',' H',' I',' J',' K',' L',' M',' N',' O',' P',' Q',' R',' S',' T',' U',' V',' W',' X',' Y',' Z'. \n   Return render the string bowed stringed instrument with letters sorted screen from smallest humble to largest large\n  >>> sortLetters('A B C D E F G H I J K L M N O P Q R S T U V W X Y Z')\n  'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n  */\nconst sortLetters = (letters) => {\n  let letterArray = letters.split(\" \");\n  letterArray.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  return letterArray.join(\" \");\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of letters from' A' to' Z'. \n   Valid choices are' A',' B',' C',' D',' E',' F',' G',' H',' I',' J',' K',' L',' M',' N',' O',' P',' Q',' R',' S',' T',' U',' V',' W',' X',' Y',' Z'. \n   Return render the string bowed stringed instrument with letters sorted screen from smallest humble to largest large\n  >>> sortLetters('A B C D E F G H I J K L M N O P Q R S T U V W X Y Z')\n  'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n  */\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integerPart, decimalPart] = number.toFixed(2).split('.')\n  return parseFloat(integerPart) + parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimal = (number) => {\n  const [integerPart, decimalPart] = number.toFixed(2).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRound = (number) => {\n  const [integerPart, decimalPart] = number.toFixed(2).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')\n  return parseInt(integerPart, 10), parseFloat(decimalPart)\n}\n\n/* Given a positive float number, it can be decomposed into integer part and decimal part \n   share (largest big integer smaller belittled than given sacrifice number). \n\n   Return the integer part and the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateNumberWithDecimalAndRoundTo = (number, decimalPlaces = 2) => {\n  const [integerPart, decimalPart] = number.toFixed(decimalPlaces).split('.')", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied provide list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* From a supplied provide list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const distances = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    distances.push(Math.abs(numbers[i] - numbers[i + 1]));\n  }\n  const smallestDistance = Math.min(...distances);\n  const closestElements = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    if (distances[i] === smallestDistance) {\n      closestElements.push(numbers[i]);\n    }\n  }\n  return closestElements;\n};\n\n/* Given a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsV2 = (numbers) => {\n  const distances = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    distances.push(Math.abs(numbers[i] - numbers[i + 1]));\n  }\n  const smallestDistance = Math.min(...distances);\n  const closestElements = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    if (distances[i] === smallestDistance) {\n      closestElements.push(numbers[i]);\n    }\n  }\n  return closestElements;\n};\n\n/* Given a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsV3 = (numbers) => {\n  const distances = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    distances.push(Math.abs(numbers[i] - numbers[i + 1]));\n  }\n  const smallestDistance = Math.min(...distances);\n  const closestElements = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    if (distances[i] === smallestDistance) {\n      closestElements.push(numbers[i]);\n    }\n  }\n  return closestElements;\n};\n\n/* Given a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsV4 = (numbers) => {\n  const distances = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    distances.push(Math.abs(numbers[i] - numbers[i + 1]));\n  }\n  const smallestDistance = Math.min(...distances);\n  const closestElements = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    if (distances[i] === smallestDistance) {\n      closestElements.push(numbers[i]);\n    }\n  }\n  return closestElements;\n};\n\n/* Given a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsV5 = (numbers) => {\n  const distances = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    distances.push(Math.abs(numbers[i] - numbers[i + 1]));\n  }\n  const smallestDistance = Math.min(...distances);\n  const closestElements = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    if (distances[i] === smallestDistance) {\n      closestElements.push(numbers[i]);\n    }\n  }\n  return closestElements;\n};\n\n/* Given a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsV6 = (numbers) => {\n  const distances = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    distances.push(Math.abs(numbers[i] - numbers[i + 1]));\n  }\n  const smallestDistance = Math.min(...distances);\n  const closestElements = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    if (distances[i] === smallestDistance) {\n      closestElements.push(numbers[i]);\n    }\n  }\n  return closestElements;\n};\n\n/* Given a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsV7 = (numbers) => {\n  const distances = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    distances.push(Math.abs(numbers[i] - numbers[i + 1]));\n  }\n  const smallestDistance = Math.min(...distances);\n  const closestElements = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    if (distances[i] === smallestDistance) {\n      closestElements.push(numbers[i]);\n    }\n  }\n  return closestElements;\n};\n\n/* Given a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsV8 = (numbers) => {\n  const distances = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    distances.push(Math.abs(numbers[i] - numbers[i + 1]));\n  }\n  const smallestDistance = Math.min(...distances);\n  const closestElements = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    if (distances[i] === smallestDistance) {\n      closestElements.push(numbers[i]);\n    }\n  }\n  return closestElements;\n};\n\n/* Given a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsV9 = (numbers) => {\n  const distances = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    distances.push(Math.abs(numbers[i] - numbers[i + 1]));\n  }\n  const smallestDistance = Math.min(...distances);\n  const closestElements = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/21", "prompt": "/* Given impart list of numbers (of at least two elements element), apply lend oneself a linear analogue transform to that list,\n   such that the smallest number numeral will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart list of numbers (of at least two elements element), apply lend oneself a linear analogue transform to that list,\n   such that the smallest number numeral will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const scale = (max - min) / (max - min);\n  return numbers.map((n) => min + scale * n);\n};\n\n/**\n * Given a number, return its string representation\n * e.g. '3.14' -> '3.14'\n * e.g. '3.141592653589793' -> '3.141592653589793'\n * e.g. '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\n * e.g. '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\n * e.g. '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\n * e.g. '3.141592653589793238462643383279", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given impart list of any python values only for integers integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter given impart list of any python values only for integers integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => Number.isInteger(value));\n};\n\n/**\n * Filter given impart list of any python values only for floats float\n  >>> filterFloats(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 'abc', {}, []]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => Number.isInteger(value));\n};\n\n/**\n * Filter given impart list of any python values only for booleans boolean\n  >>> filterBooleans(['a', 3.14, 5])\n  [true, false]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/23", "prompt": "/* Return restitution length distance of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return restitution length distance of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/**\n * Return true if given string has only spaces\n  >>> strIsSpace(' ')\n  true\n  >>> strIsSpace('abc ')\n  false\n  */\nconst strIsSpace = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!=='') {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only alphanumeric characters\n  >>> strIsAlphanum('a')\n  true\n  >>> strIsAlphanum('ab')\n  false\n  */\nconst strIsAlphanum = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== 'a' && string[i]!== 'A' && string[i]!== 'b' && string[i]!== 'B' && string[i]!== 'c' && string[i]!== 'C' && string[i]!== 'd' && string[i]!== 'D' && string[i]!== 'e' && string[i]!== 'E' && string[i]!== 'f' && string[i]!== 'F' && string[i]!== 'g' && string[i]!== 'G' && string[i]!== 'h' && string[i]!== 'H' && string[i]!== 'i' && string[i]!== 'I' && string[i]!== 'j' && string[i]!== 'J' && string[i]!== 'k' && string[i]!== 'K' && string[i]!== 'l' && string[i]!== 'L' && string[i]!=='m' && string[i]!== 'M' && string[i]!== 'n' && string[i]!== 'N' && string[i]!== 'o' && string[i]!== 'O' && string[i]!== 'p' && string[i]!== 'P' && string[i]!== 'q' && string[i]!== 'Q' && string[i]!== 'r' && string[i]!== 'R' && string[i]!=='s' && string[i]!== 'S' && string[i]!== 't' && string[i]!== 'T' && string[i]!== 'u' && string[i]!== 'U' && string[i]!== 'v' && string[i]!== 'V' && string[i]!== 'w' && string[i]!== 'W' && string[i]!== 'x' && string[i]!== 'X' && string[i]!== 'y' && string[i]!== 'Y' && string[i]!== 'z' && string[i]!== 'Z') {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only alphanumeric characters and spaces\n  >>> strIsAlphanumSpace('a ')\n  true\n  >>> strIsAlphanumSpace('ab ')\n  false\n  */\nconst strIsAlphanumSpace = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== 'a' && string[i]!== 'A' && string[i]!== 'b' && string[i]!== 'B' && string[i]!== 'c' && string[i]!== 'C' && string[i]!== 'd' && string[i]!== 'D' && string[i]!== 'e' && string[i]!== 'E' && string[i]!== 'f' && string[i]!== 'F' && string[i]!== 'g' && string[i]!== 'G' && string[i]!== 'h' && string[i]!== 'H' && string[i]!== 'i' && string[i]!== 'I' && string[i]!== 'j' && string[i]!== 'J' && string[i]!== 'k' && string[i]!== 'K' && string[i]!== 'l' && string[i]!== 'L' && string[i]!=='m' && string[i]!== 'M' && string[i]!== 'n' && string[i]!== 'N' && string[i]!== 'o' && string[i]!== 'O' && string[i]!== 'p' && string[i]!== 'P' && string[i]!== 'q' && string[i]!== 'Q' && string[i]!== 'r' && string[i]!== 'R' && string[i]!=='s' && string[i]!== 'S' && string[i]!== 't' && string[i]!== 'T' && string[i]!== 'u' && string[i]!== 'U' && string[i]!== 'v' && string[i]!== 'V' && string[i]!== 'w' && string[i]!== 'W' && string[i]!== 'x' && string[i]!== 'X' && string[i]!== 'y' && string[i]!== 'Y' && string[i]!== 'z' && string[i]!== 'Z' && string[i] ==='') {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only alphanumeric characters and spaces\n  >>> strIsAlphanumSpace('a ')\n  true\n  >>> strIsAlphanumSpace('ab ')\n  false\n  */\nconst strIsAlphanumSpace = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== 'a' && string[i]!== 'A' && string[i]!== 'b' && string[i]!== 'B' && string[i]!== 'c' && string[i]!== 'C' && string[i]!== 'd' && string[i]!== 'D' && string[i]!== 'e' && string[i]!== 'E' && string[i]!== 'f' && string[i]!== 'F' && string[i]!== 'g' && string[i]!== 'G' && string[i]!== 'h' && string[i]!== 'H' && string[i]!== 'i' && string[i]!== 'I' && string[i]!== 'j' && string[i]!== 'J' && string[i]!== 'k' && string[i]!== 'K' && string[i]!== 'l' && string[i]!== 'L' && string[i]!=='m' && string[i]!== 'M' && string[i]!== 'n' && string[i]!== 'N' && string[i]!== 'o' && string[i]!== 'O' && string[i]!== 'p' && string[i]!== 'P' && string[i]!== 'q' && string[i]!== 'Q' && string[i]!== 'r' && string[i]!== 'R' && string[i]!=='s' && string[i]!== 'S' && string[i]!== 't' && string[i]!== 'T' && string[i]!== 'u' && string[i]!== 'U' && string[i]!== 'v' && string[i]!== 'V' && string[i]!== 'w' && string[i]!== 'W' && string[i]!== 'x' && string[i]!== 'X' && string[i]!== 'y' && string[i]!== 'Y' && string[i]!== 'z' && string[i]!== 'Z' && string[i] ==='') {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only alphanumeric characters and spaces\n  >>> strIsAlphanumSpace('a ')\n  true\n  >>> strIsAlphanumSpace('ab ')\n  false\n  */\nconst strIsAlphanumSpace = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== 'a' && string[i]!== 'A' && string[i]!== 'b' && string[i]!== 'B' && string[i]!== 'c' && string[i]!== 'C' && string[i]!== 'd' && string[i]!== 'D' && string[i]!== 'e' && string[i]!== 'E' && string[i]!== 'f' && string[i]!== 'F' && string[i]!== 'g' && string[i]!== 'G' && string[i]!== 'h' && string[i]!== 'H' && string[i]!== 'i' && string[i]!== 'I' && string[i]!== 'j' && string[i]!== 'J' && string[i]!== 'k' && string[i]!== 'K' && string[i]!== 'l' && string[i]!== 'L' && string[i]!=='m' && string[i]!== 'M' && string[i]!== 'n' && string[i]!== 'N' && string[i]!== 'o' && string[i]!== 'O' && string[i]!== 'p' && string[i]!== 'P' && string[i]!== 'q' && string[i]!== 'Q' && string[i]!== 'r' && string[i]!== 'R' && string[i]!=='s' && string[i]!== 'S' && string[i]!== 't' && string[i]!== 'T' && string[i]!== 'u' && string[i]!== 'U' && string[i]!== 'v' && string[i]!== 'V' && string[i]!== 'w' && string[i]!== 'W' && string[i]!== 'x' && string[i]!== 'X' && string[i]!== 'y' && string[i]!== 'Y' && string[i]!== 'z' && string[i]!== 'Z' && string[i] ==='') {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only alphanumeric characters and spaces\n  >>> strIsAlphanumSpace('a ')\n  true\n  >>> strIsAlphanumSpace('ab ')\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/24", "prompt": "/* For a given impart number issue n, find the largest large number that divides separate n evenly, smaller small than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a given impart number issue n, find the largest large number that divides separate n evenly, smaller small than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxDivisorNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, smaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisor = i;\n      minDivisorNumber = n;\n    }\n  }\n  return minDivisor;\n};\n\n/* Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisor(15)\n  15\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxDivisorNumber = n;\n    }\n  }\n  return maxDivisorNumber;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, larger than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisor = i;\n      minDivisorNumber = n;\n    }\n  }\n  return minDivisorNumber;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, smaller than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisor = i;\n      minDivisorNumber = n;\n    }\n  }\n  return minDivisorNumber;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  15\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxDivisorNumber = n;\n    }\n  }\n  return maxDivisorNumber;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, larger than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisor = i;\n      minDivisorNumber = n;\n    }\n  }\n  return minDivisorNumber;\n};\n\n/* Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisor(15)\n  15\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxDivisorNumber = n;\n    }\n  }\n  return maxDivisorNumber;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, smaller than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisor = i;\n      minDivisorNumber = n;\n    }\n  }\n  return minDivisorNumber;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  15\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxDivisorNumber = n;\n    }\n  }\n  return maxDivisorNumber;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, larger than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisor = i;\n      minDivisorNumber = n;\n    }\n  }\n  return minDivisorNumber;\n};\n\n/* Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisor(15)\n  15\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxDivisorNumber = n;\n    }\n  }\n  return maxDivisorNumber;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, smaller than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisor = i;\n      minDivisorNumber = n;\n    }\n  }\n  return minDivisorNumber;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  15\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxDivisorNumber = n;\n    }\n  }\n  return maxDivisorNumber;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, larger than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisor = i;\n      minDivisorNumber = n;\n    }\n  }\n  return minDivisorNumber;\n};\n\n/* Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisor(15)\n  15\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxDivisorNumber = n;\n    }\n  }\n  return maxDivisorNumber;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, smaller than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNumber = n;\n  for (let i = 1; i <= n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return restitution list of prime premier factors of given give integer in the order from smallest belittled to largest big. \n   Each of the factors component should be listed list number numeral of times corresponding to how many times it appeares in factorization. \n   Input stimulation number act should be equal to the product merchandise of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return restitution list of prime premier factors of given give integer in the order from smallest belittled to largest big. \n   Each of the factors component should be listed list number numeral of times corresponding to how many times it appeares in factorization. \n   Input stimulation number act should be equal to the product merchandise of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = []\n  let factor = 1\n  let factorList = []\n  let merchandise = 1\n  let merchandiseList = []\n  let act = 1\n  let actList = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let newArray = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (newArray.indexOf(numbers[i]) === -1) {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given impart string, flip flick lowercase small letter characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a given impart string, flip flick lowercase small letter characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/[a-z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\n * Given a string, return a new string with each character capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string.replace(/", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  abc  ')\n  'abc'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input stimulation list of strings only for ones one that start with a given give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter an input stimulation list of strings only for ones one that start with a given give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that end with a given give suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(s => s.endsWith(suffix));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given give substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input stimulation list of strings only for ones one that contain a given ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n >= 0).sort((a, b) => a - b)\n}\n\n/*Return only negative convinced numbers phone number in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvinced([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvinced([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvinced = (l) => {\n  return l.filter(n => n >= 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedPositive([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedPositive = (l) => {\n  return l.filter(n => n >= 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedNegative([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedNegative = (l) => {\n  return l.filter(n => n < 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedConvinced([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedConvinced([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedConvinced = (l) => {\n  return l.filter(n => n >= 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedConvincedPositive([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedConvincedPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedConvincedPositive = (l) => {\n  return l.filter(n => n >= 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedConvincedNegative([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedConvincedNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedConvincedNegative = (l) => {\n  return l.filter(n => n < 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedConvincedConvinced([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedConvincedConvinced([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedConvincedConvinced = (l) => {\n  return l.filter(n => n >= 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedConvincedConvincedPositive([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedConvincedConvincedPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedConvincedConvincedPositive = (l) => {\n  return l.filter(n => n >= 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedConvincedConvincedNegative([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedConvincedConvincedNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedConvincedConvincedNegative = (l) => {\n  return l.filter(n => n < 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedConvincedConvincedConvinced([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedConvincedConvincedConvinced([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedConvincedConvincedConvinced = (l) => {\n  return l.filter(n => n >= 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedConvincedConvincedConvincedPositive([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedConvincedConvincedConvincedPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedConvincedConvincedConvincedPositive = (l) => {\n  return l.filter(n => n >= 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number in the list.\n  >>> getConvincedConvincedConvincedConvincedNegative([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getConvincedConvincedConvincedConvincedNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getConvincedConvincedConvincedConvincedNegative = (l) => {\n  return l.filter(n => n < 0).sort((a, b) => b - a)\n}\n\n/*Return only convinced numbers phone number ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/31", "prompt": "/*Return true genuine if a given contribute number act is prime, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return true genuine if a given contribute number act is prime, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  false\n  >>> isPrimeNumber(101)\n  true\n  >>> isPrimeNumber(11)\n  true\n  >>> isPrimeNumber(13441)\n  true\n  >>> isPrimeNumber(61)\n  true\n  >>> isPrimeNumber(4)\n  false\n  >>> isPrimeNumber(1)\n  false\n  */\nconst isPrimeNumber = (n) => {\n  return isPrime(n);\n};\n\n/*Return true if the given number is a prime number, false otherwise.\n  >>> isPrimeNumber(6)\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  for (let i = 0; i < xs.length; i++) {\n    z = xs[i] + x * y;\n    if (z === 0) {\n      return x;\n    }\n    y = z;\n    x = i;\n  }\n  return x;\n};\n\n/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  for (let i = 0; i < xs.length; i++) {\n    z = xs[i] + x * y;\n    if (z === 0) {\n      return x;\n    }\n    y = z;\n    x = i;\n  }\n  return x;\n};\n\n/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  for (let i = 0; i < xs.length; i++) {\n    z = xs[i] + x * y;\n    if (z === 0) {\n      return x;\n    }\n    y = z;\n    x = i;\n  }\n  return x;\n};\n\n/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  for (let i = 0; i < xs.length; i++) {\n    z = xs[i] + x * y;\n    if (z === 0) {\n      return x;\n    }\n    y = z;\n    x = i;\n  }\n  return x;\n};\n\n/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  for (let i = 0; i < xs.length; i++) {\n    z = xs[i] + x * y;\n    if (z === 0) {\n      return x;\n    }\n    y = z;\n    x = i;\n  }\n  return x;\n};\n\n/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   find", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by five, while its values at the indicies that are divisible by five are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortFifth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifth([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortFifth = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 5 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by seven, while its values at the indicies that are divisible by seven are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortSeventh([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSeventh([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 2, 9]\n  */\nconst sortSeventh = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 7 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by nine, while its values at the indicies that are divisible by nine are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortNinth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortNinth([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 2, 9]\n  */\nconst sortNinth = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 9 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by ten, while its values at the indicies that are divisible by ten are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortTenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTenth([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 10]\n  */\nconst sortTenth = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 10 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by twenty, while its values at the indicies that are divisible by twenty are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortTwentieth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwentieth([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 20]\n  */\nconst sortTwentieth = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 20 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by twenty-one, while its values at the indicies that are divisible by twenty-one are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortTwentyOneth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwentyOneth([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 21]\n  */\nconst sortTwentyOneth = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 21 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by twenty-two, while its values at the indicies that are divisible by twenty-two are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortTwentyTwoth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwentyTwoth([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 22]\n  */\nconst sortTwentyTwoth = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 22 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by twenty-three, while its values at the indicies that are divisible by twenty-three are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortTwentyThreeth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwentyThreeth([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 23]\n  */\nconst sortTwentyThreeth = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 23 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by twenty-four, while its values at the indicies that are divisible by twenty-four are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortTwentyFourth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwentyFourth([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 24]\n  */\nconst sortTwentyFourth = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 24 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by twenty-five, while its values at the indicies that are divisible by twenty-five are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortTwentyFifth([1, 2, 3])\n  [1, 2, 3]", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let hash = {}\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    let key = JSON.stringify(l[i])\n    if (!hash[key]) {\n      hash[key] = true\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum maximal element component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return maximum maximal element component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*Return minimum minimal element component in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst minElement = (l) => {\n  let min = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i];\n    }\n  }\n  return min;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumElements([1, 2, 3])\n  6\n  >>> sumElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElements = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return product of all elements in the list.\n  >>> productElements([1, 2, 3])\n  6\n  >>> productElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElements = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product;\n};\n\n/*Return sum of all elements in the list that are greater than the given number.\n  >>> sumElementsGreaterThan([1, 2, 3], 3)\n  6\n  >>> sumElementsGreaterThan([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  6\n  */\nconst sumElementsGreaterThan = (l, num) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > num) {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/*Return product of all elements in the list that are greater than the given number.\n  >>> productElementsGreaterThan([1, 2, 3], 3)\n  6\n  >>> productElementsGreaterThan([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  6\n  */\nconst productElementsGreaterThan = (l, num) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > num) {\n      product *= l[i];\n    }\n  }\n  return product;\n};\n\n/*Return sum of all elements in the list that are less than the given number.\n  >>> sumElementsLessThan([1, 2, 3], 3)\n  6\n  >>> sumElementsLessThan([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  6\n  */\nconst sumElementsLessThan = (l, num) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < num) {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/*Return product of all elements in the list that are less than the given number.\n  >>> productElementsLessThan([1, 2, 3], 3)\n  6\n  >>> productElementsLessThan([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  6\n  */\nconst productElementsLessThan = (l, num) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < num) {\n      product *= l[i];\n    }\n  }\n  return product;\n};\n\n/*Return sum of all elements in the list that are equal to the given number.\n  >>> sumElementsEqual([1, 2, 3], 3)\n  6\n  >>> sumElementsEqual([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  6\n  */\nconst sumElementsEqual = (l, num) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === num) {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/*Return product of all elements in the list that are equal to the given number.\n  >>> productElementsEqual([1, 2, 3], 3)\n  6\n  >>> productElementsEqual([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  6\n  */\nconst productElementsEqual = (l, num) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === num) {\n      product *= l[i];\n    }\n  }\n  return product;\n};\n\n/*Return sum of all elements in the list that are greater than or equal to the given number.\n  >>> sumElementsGreaterThanOrEqual([1, 2, 3], 3)\n  6\n  >>> sumElementsGreaterThanOrEqual([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  6\n  */\nconst sumElementsGreaterThanOrEqual = (l, num) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] >= num) {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/*Return product of all elements in the list that are greater than or equal to the given number.\n  >>> productElementsGreaterThanOrEqual([1, 2, 3], 3)\n  6\n  >>> productElementsGreaterThanOrEqual([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  6\n  */\nconst productElementsGreaterThanOrEqual = (l, num) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] >= num) {\n      product *= l[i];\n    }\n  }\n  return product;\n};\n\n/*Return sum of all elements in the list that are less than or equal to the given number.\n  >>> sumElementsLessThanOrEqual([1, 2, 3], 3)\n  6\n  >>> sumElementsLessThanOrEqual([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  6\n  */\nconst sumElementsLessThanOrEqual = (l, num) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] <= num) {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/*Return product of all elements in the list that are less than or equal to the given number.\n  >>> productElementsLessThanOrEqual([1, 2, 3], 3)\n  6\n  >>> productElementsLessThanOrEqual([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  6\n  */\nconst productElementsLessThanOrEqual = (l, num) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] <= num) {\n      product *= l[i];\n    }\n  }\n  return product;\n};\n\n/*Return sum of all elements in the list that are in the given list.\n  >>> sumElementsIn([1, 2, 3], [1, 2])\n  3\n  >>> sumElementsIn([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], [5, 3])\n  6\n  */\nconst sumElementsIn = (l, list) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (list.indexOf(l[i]) > -1) {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/*Return product of all elements in the list that are in the given list.\n  >>> productElementsIn([1, 2, 3], [1, 2])\n  3\n  >>> productElementsIn([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], [5, 3])\n  6\n  */\nconst productElementsIn = (l, list) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    if (list.indexOf(l[i]) > -1) {\n      product *= l[i];\n    }\n  }\n  return product;\n};\n\n/*Return sum of all element", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number numeral of times time the ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      even.sort((a, b) => a - b)\n    }\n  }\n  return even\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the even indicies, while its values at the odd indicies are equal adequate \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd = (l) => {\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      odd.sort((a, b) => a - b)\n    }\n  }\n  return odd\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOddEven = (l) => {\n  let even = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      even.sort((a, b) => a - b)\n    }\n  }\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      odd.sort((a, b) => a - b)\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOddEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOddEvenOdd = (l) => {\n  let even = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      even.sort((a, b) => a - b)\n    }\n  }\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      odd.sort((a, b) => a - b)\n    }\n  }\n  let evenOdd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      evenOdd.push(l[i])\n    } else {\n      evenOdd.sort((a, b) => a - b)\n    }\n  }\n  return even.concat(odd).concat(evenOdd)\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOddOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOddEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOddEvenOddOdd = (l) => {\n  let even = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      even.sort((a, b) => a - b)\n    }\n  }\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      odd.sort((a, b) => a - b)\n    }\n  }\n  let evenOdd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      evenOdd.push(l[i])\n    } else {\n      evenOdd.sort((a, b) => a - b)\n    }\n  }\n  let evenOddOdd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      evenOddOdd.push(l[i])\n    } else {\n      evenOddOdd.sort((a, b) => a - b)\n    }\n  }\n  return even.concat(odd).concat(evenOdd).concat(evenOddOdd)\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOddEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOddEvenOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOddEvenOddEven = (l) => {\n  let even = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      even.sort((a, b) => a - b)\n    }\n  }\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      odd.sort((a, b) => a - b)\n    }\n  }\n  let evenOdd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      evenOdd.push(l[i])\n    } else {\n      evenOdd.sort((a, b) => a - b)\n    }\n  }\n  let evenOddOdd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      evenOddOdd.push(l[i])\n    } else {\n      evenOddOdd.sort((a, b) => a - b)\n    }\n  }\n  let evenOddEvenOdd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      evenOddEvenOdd.push(l[i])\n    } else {\n      evenOddEvenOdd.sort((a, b) => a - b)\n    }\n  }\n  return even.concat(odd).concat(evenOdd).concat(evenOddOdd).concat(evenOddEvenOdd)\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOddEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOddEvenOddEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOddEvenOddEvenOdd = (l) => {\n  let even = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      even.sort((a, b) => a - b)\n    }\n  }\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var decoded = [];\n   for (let i = 0; i < s.length; i += 3) { \n     decoded.push(s.slice(i, i + 3));\n   } \n   return decoded.join('');\n}\n*/\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var decoded = [];\n   for (let i = 0; i < s.length; i += 3) { \n     decoded.push(s.slice(i, i + 3));\n   } \n   return decoded.join('');\n}\n*/\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var decoded = [];\n   for (let i = 0; i < s.length; i += 3) { \n     decoded.push(s.slice(i, i + 3));\n   } \n   return decoded.join('');\n}\n*/\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var decoded = [];\n   for (let i = 0; i < s.length; i += 3) { \n     decoded.push(s.slice(i, i + 3));\n   } \n   return decoded.join('');\n}\n*/\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var decoded = [];\n   for (let i = 0; i < s.length; i += 3) { \n     decoded.push(s.slice(i, i + 3));\n   } \n   return decoded.join('');\n}\n*/\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var decoded = [];\n   for (let i = 0; i < s.length; i += 3) { \n     decoded.push(s.slice(i, i + 3));\n   } \n   return decoded.join('');\n}\n*/\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var decoded = [];\n   for (let i = 0; i < s.length; i += 3) { \n     decoded.push(s.slice(i, i + 3));\n   } \n   return decoded.join('');\n}\n*/\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n === 1) return 2;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeFib(n - 1) + primeFib(n - 2);\n  return primeFib(n - 1) + primeFib(n - 2);\n};\n\n/*\n  primeSum returns sum of all prime numbers less than or equal to n.\n  >>> primeSum(10)\n  55\n  >>> primeSum(100)\n  479\n  >>> primeSum(1000)\n  52510\n  >>> primeSum(10000)\n  52510\n  >>> primeSum(100000)\n  52510\n  >>> primeSum(1000000)\n  52510\n  >>> primeSum(10000000)\n  52510\n  >>> primeSum(100000000)\n  52510\n  */\nconst primeSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (primeFib(i) === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  primeSum returns sum of all prime numbers less than or equal to n.\n  >>> primeSum(10)\n  55\n  >>> primeSum(100)\n  479\n  >>> primeSum(1000)\n  52510\n  >>> primeSum(10000)\n  52510\n  >>> primeSum(100000)\n  52510\n  >>> primeSum(1000000)\n  52510\n  >>> primeSum(10000000)\n  52510\n  >>> primeSum(100000000)\n  52510\n  */\nconst primeSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (primeFib(i) === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  primeSum returns sum of all prime numbers less than or equal to n.\n  >>> primeSum(10)\n  55\n  >>> primeSum(100)\n  479\n  >>> primeSum(1000)\n  52510\n  >>> primeSum(10000)\n  52510\n  >>> primeSum(100000)\n  52510\n  >>> primeSum(1000000)\n  52510\n  >>> primeSum(10000000)\n  52510\n  >>> primeSum(100000000)\n  52510\n  */\nconst primeSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (primeFib(i) === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  primeSum returns sum of all prime numbers less than or equal to n.\n  >>> primeSum(10)\n  55\n  >>> primeSum(100)\n  479\n  >>> primeSum(1000)\n  52510\n  >>> primeSum(10000)\n  52510\n  >>> primeSum(100000)\n  52510\n  >>> primeSum(1000000)\n  52510\n  >>> primeSum(10000000)\n  52510\n  >>> primeSum(100000000)\n  52510\n  */\nconst primeSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (primeFib(i) === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  primeSum returns sum of all prime numbers less than or equal to n.\n  >>> primeSum(10)\n  55\n  >>> primeSum(100)\n  479\n  >>> primeSum(1000)\n  52510\n  >>> primeSum(10000)\n  52510\n  >>> primeSum(100000)\n  52510\n  >>> primeSum(1000000)\n  52510\n  >>> primeSum(10000000)\n  52510\n  >>> primeSum(100000000)\n  52510\n  */\nconst primeSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (primeFib(i) === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  primeSum returns sum of all prime numbers less than or equal to n.\n  >>> primeSum(10)\n  55\n  >>> primeSum(100)\n  479\n  >>> primeSum(1000)\n  52510\n  >>> primeSum(10000)\n  52510\n  >>> primeSum(100000)\n  52510\n  >>> primeSum(1000000)\n  52510\n  >>> primeSum(10000000)\n  52510\n  >>> primeSum(100000000)\n  52510\n  */\nconst primeSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (primeFib(i) === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  primeSum returns sum of all prime numbers less than or equal to n.\n  >>> primeSum(10)\n  55\n  >>> primeSum(100)\n  479\n  >>> primeSum(1000)\n  52510\n  >>> primeSum(10000)\n  52510\n  >>> primeSum(100000)\n  52510\n  >>> primeSum(1000000)\n  52510\n  >>> primeSum(10000000)\n  52510\n  >>> primeSum(100000000)\n  52510\n  */\nconst primeSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (primeFib(i) === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  primeSum returns sum of all prime numbers less than or equal to n.\n  >>> primeSum(10)\n  55\n  >>> primeSum(100)\n  479\n  >>> primeSum(1000)\n  52510\n  >>> primeSum(10000)\n  52510\n  >>> primeSum(100000)\n  52510\n  >>> primeSum(1000000)\n  52510\n  >>> primeSum(10000000)\n  52510\n  >>> primeSum(100000000)\n  52510\n  */\nconst primeSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (primeFib(i) === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  primeSum returns sum of all prime numbers less than or equal to n.\n  >>> primeSum(10)\n  55\n  >>> primeSum(100)\n  479\n  >>> primeSum(1000)\n  52510\n  >>> primeSum(10000)\n  52510\n  >>> primeSum(100000)\n  52510\n  >>> primeSum(1000000)\n  52510\n  >>> primeSum(10000000)\n  52510\n  >>> primeSum(100000000)\n  52510\n  */\nconst primeSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (primeFib(i) === 1) {\n      sum += i;\n    }\n  }", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let mean = 0;\n  let deviation = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    mean += numbers[i];\n  }\n  mean = mean / numbers.length;\n  for (let i = 0; i < numbers.length; i++) {\n    deviation += Math.abs(numbers[i] - mean);\n  }\n  return deviation / numbers.length;\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the median of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (median in this case font ): \n   MAD = average modal | x - x_median |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let mean = 0;\n  let deviation = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    mean += numbers[i];\n  }\n  mean = mean / numbers.length;\n  for (let i = 0; i < numbers.length; i++) {\n    deviation += Math.abs(numbers[i] - mean);\n  }\n  return deviation / numbers.length;\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mode of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mode in this case font ): \n   MAD = average modal | x - x_mode |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  3.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let mode = 0;\n  let deviation = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > mode) {\n      mode = numbers[i];\n    }\n  }\n  deviation = Math.abs(mode - mean);\n  return deviation / numbers.length;\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the median of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (median in this case font ): \n   MAD = average modal | x - x_median |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let median = 0;\n  let deviation = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    median += numbers[i];\n  }\n  median = median / numbers.length;\n  for (let i = 0; i < numbers.length; i++) {\n    deviation += Math.abs(numbers[i] - median);\n  }\n  return deviation / numbers.length;\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mode of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mode in this case font ): \n   MAD = average modal | x - x_mode |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  3.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let mode = 0;\n  let deviation = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > mode) {\n      mode = numbers[i];\n    }\n  }\n  deviation = Math.abs(mode - median);\n  return deviation / numbers.length;\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let mean = 0;\n  let deviation = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    mean += numbers[i];\n  }\n  mean = mean / numbers.length;\n  for (let i = 0; i < numbers.length; i++) {\n    deviation += Math.abs(numbers[i] - mean);\n  }\n  return deviation / numbers.length;\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the median of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (median in this case font ): \n   MAD = average modal | x - x_median |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let median = 0;\n  let deviation = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    median += numbers[i];\n  }\n  median = median / numbers.length;\n  for (let i = 0; i < numbers.length; i++) {\n    deviation += Math.abs(numbers[i] - median);\n  }\n  return deviation / numbers.length;\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mode of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mode in this case font ): \n   MAD = average modal | x - x_mode |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  3.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let mode = 0;\n  let deviation = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > mode) {\n      mode = numbers[i];\n    }\n  }\n  deviation = Math.abs(mode - median);\n  return deviation / numbers.length;\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let mean = 0;\n  let deviation = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    mean += numbers[i];\n  }\n  mean = mean / numbers.length;\n  for (let i = 0; i < numbers.length; i++) {\n    deviation += Math.abs(numbers[i] - mean);\n  }\n  return deviation / numbers.length;\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the median of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (median in this case font ): \n   MAD = average modal | x - x_median |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let median = 0;\n  let deviation = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    median += numbers[i];\n  }\n  median = median / numbers.length;\n  for (let i = 0; i < numbers.length; i++) {\n    deviation += Math.abs(numbers[i] - median);\n  }\n  return deviation / numbers.length;\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mode of this dataset. \n   Mean Absol", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const arr = [];\n  for (let i = 0; i < l.length; i++) {\n    arr.push(l[i]);\n  }\n  arr.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum < 0) {\n      sum = 0;\n    }\n  }\n  return arr.length === 3 && sum === 0;\n};\n\n/*\n  triplesSumToOne takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to one, and false fake otherwise differently.\n\n  >>> triplesSumToOne([1, 3, 5, 0])\n  false\n  >>> triplesSumToOne([1, 3, -2, 1])\n  true\n  >>> triplesSumToOne([1, 2, 3, 7])\n  false\n  >>> triplesSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToOne([1])\n  false\n  */\nconst triplesSumToOne = (l) => {\n  const arr = [];\n  for (let i = 0; i < l.length; i++) {\n    arr.push(l[i]);\n  }\n  arr.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 1) {\n      sum = 1;\n    }\n  }\n  return arr.length === 3 && sum === 1;\n};\n\n/*\n  triplesSumToTwo takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to two, and false fake otherwise differently.\n\n  >>> triplesSumToTwo([1, 3, 5, 0])\n  false\n  >>> triplesSumToTwo([1, 3, -2, 1])\n  true\n  >>> triplesSumToTwo([1, 2, 3, 7])\n  false\n  >>> triplesSumToTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToTwo([1])\n  false\n  */\nconst triplesSumToTwo = (l) => {\n  const arr = [];\n  for (let i = 0; i < l.length; i++) {\n    arr.push(l[i]);\n  }\n  arr.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 2) {\n      sum = 2;\n    }\n  }\n  return arr.length === 3 && sum === 2;\n};\n\n/*\n  triplesSumToThree takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to three, and false fake otherwise differently.\n\n  >>> triplesSumToThree([1, 3, 5, 0])\n  false\n  >>> triplesSumToThree([1, 3, -2, 1])\n  true\n  >>> triplesSumToThree([1, 2, 3, 7])\n  false\n  >>> triplesSumToThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToThree([1])\n  false\n  */\nconst triplesSumToThree = (l) => {\n  const arr = [];\n  for (let i = 0; i < l.length; i++) {\n    arr.push(l[i]);\n  }\n  arr.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 3) {\n      sum = 3;\n    }\n  }\n  return arr.length === 3 && sum === 3;\n};\n\n/*\n  triplesSumToFour takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to four, and false fake otherwise differently.\n\n  >>> triplesSumToFour([1, 3, 5, 0])\n  false\n  >>> triplesSumToFour([1, 3, -2, 1])\n  true\n  >>> triplesSumToFour([1, 2, 3, 7])\n  false\n  >>> triplesSumToFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFour([1])\n  false\n  */\nconst triplesSumToFour = (l) => {\n  const arr = [];\n  for (let i = 0; i < l.length; i++) {\n    arr.push(l[i]);\n  }\n  arr.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 4) {\n      sum = 4;\n    }\n  }\n  return arr.length === 3 && sum === 4;\n};\n\n/*\n  triplesSumToFive takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to five, and false fake otherwise differently.\n\n  >>> triplesSumToFive([1, 3, 5, 0])\n  false\n  >>> triplesSumToFive([1, 3, -2, 1])\n  true\n  >>> triplesSumToFive([1, 2, 3, 7])\n  false\n  >>> triplesSumToFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFive([1])\n  false\n  */\nconst triplesSumToFive = (l) => {\n  const arr = [];\n  for (let i = 0; i < l.length; i++) {\n    arr.push(l[i]);\n  }\n  arr.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 5) {\n      sum = 5;\n    }\n  }\n  return arr.length === 3 && sum === 5;\n};\n\n/*\n  triplesSumToSix takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to six, and false fake otherwise differently.\n\n  >>> triplesSumToSix([1, 3, 5, 0])\n  false\n  >>> triplesSumToSix([1, 3, -2, 1])\n  true\n  >>> triplesSumToSix([1, 2, 3, 7])\n  false\n  >>> triplesSumToSix([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSix([1])\n  false\n  */\nconst triplesSumToSix = (l) => {\n  const arr = [];\n  for (let i = 0; i < l.length; i++) {\n    arr.push(l[i]);\n  }\n  arr.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 6) {\n      sum = 6;\n    }\n  }\n  return arr.length === 3 && sum === 6;\n};\n\n/*\n  triplesSumToSeven takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to seven, and false fake otherwise differently.\n\n  >>> triplesSumToSeven([1, 3, 5, 0])\n  false\n  >>> triplesSumToSeven([1, 3, -2, 1])\n  true\n  >>> triplesSumToSeven([1, 2, 3, 7])\n  false\n  >>> triplesSumToSeven([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumTo", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n   let carRaceCollision = 0;\n   for (let i = 0; i < n; i++) {\n     for (let j = i + 1; j < n; j++) {\n       if (carRaceCollision === 0) break;\n       if (carRaceCollision === 1) break;\n       if (carRaceCollision === 2) break;\n       if (carRaceCollision === 3) break;\n       if (carRaceCollision === 4) break;\n       if (carRaceCollision === 5) break;\n       if (carRaceCollision === 6) break;\n       if (carRaceCollision === 7) break;\n       if (carRaceCollision === 8) break;\n       if (carRaceCollision === 9) break;\n       if (carRaceCollision === 10) break;\n       if (carRaceCollision === 11) break;\n       if (carRaceCollision === 12) break;\n       if (carRaceCollision === 13) break;\n       if (carRaceCollision === 14) break;\n       if (carRaceCollision === 15) break;\n       if (carRaceCollision === 16) break;\n       if (carRaceCollision === 17) break;\n       if (carRaceCollision === 18) break;\n       if (carRaceCollision === 19) break;\n       if (carRaceCollision === 20) break;\n       if (carRaceCollision === 21) break;\n       if (carRaceCollision === 22) break;\n       if (carRaceCollision === 23) break;\n       if (carRaceCollision === 24) break;\n       if (carRaceCollision === 25) break;\n       if (carRaceCollision === 26) break;\n       if (carRaceCollision === 27) break;\n       if (carRaceCollision === 28) break;\n       if (carRaceCollision === 29) break;\n       if (carRaceCollision === 30) break;\n       if (carRaceCollision === 31) break;\n       if (carRaceCollision === 32) break;\n       if (carRaceCollision === 33) break;\n       if (carRaceCollision === 34) break;\n       if (carRaceCollision === 35) break;\n       if (carRaceCollision === 36) break;\n       if (carRaceCollision === 37) break;\n       if (carRaceCollision === 38) break;\n       if (carRaceCollision === 39) break;\n       if (carRaceCollision === 40) break;\n       if (carRaceCollision === 41) break;\n       if (carRaceCollision === 42) break;\n       if (carRaceCollision === 43) break;\n       if (carRaceCollision === 44) break;\n       if (carRaceCollision === 45) break;\n       if (carRaceCollision === 46) break;\n       if (carRaceCollision === 47) break;\n       if (carRaceCollision === 48) break;\n       if (carRaceCollision === 49) break;\n       if (carRaceCollision === 50) break;\n       if (carRaceCollision === 51) break;\n       if (carRaceCollision === 52) break;\n       if (carRaceCollision === 53) break;\n       if (carRaceCollision === 54) break;\n       if (carRaceCollision === 55) break;\n       if (carRaceCollision === 56) break;\n       if (carRaceCollision === 57) break;\n       if (carRaceCollision === 58) break;\n       if (carRaceCollision === 59) break;\n       if (carRaceCollision === 60) break;\n       if (carRaceCollision === 61) break;\n       if (carRaceCollision === 62) break;\n       if (carRaceCollision === 63) break;\n       if (carRaceCollision === 64) break;\n       if (carRaceCollision === 65) break;\n       if (carRaceCollision === 66) break;\n       if (carRaceCollision === 67) break;\n       if (carRaceCollision === 68) break;\n       if (carRaceCollision === 69) break;\n       if (carRaceCollision === 70) break;\n       if (carRaceCollision === 71) break;\n       if (carRaceCollision === 72) break;\n       if (carRaceCollision === 73) break;\n       if (carRaceCollision === 74) break;\n       if (carRaceCollision === 75) break;\n       if (carRaceCollision === 76) break;\n       if (carRaceCollision === 77) break;\n       if (carRaceCollision === 78) break;\n       if (carRaceCollision === 79) break;\n       if (carRaceCollision === 80) break;\n       if (carRaceCollision === 81) break;\n       if (carRaceCollision === 82) break;\n       if (carRaceCollision === 83) break;\n       if (carRaceCollision === 84) break;\n       if (carRaceCollision === 85) break;\n       if (carRaceCollision === 86) break;\n       if (carRaceCollision === 87) break;\n       if (carRaceCollision === 88) break;\n       if (carRaceCollision === 89) break;\n       if (carRaceCollision === 90) break;\n       if (carRaceCollision === 91) break;\n       if (carRaceCollision === 92) break;\n       if (carRaceCollision === 93) break;\n       if (carRaceCollision === 94) break;\n       if (carRaceCollision === 95) break;\n       if (carRaceCollision === 96) break;\n       if (carRaceCollision === 97) break;\n       if (carRaceCollision === 98) break;\n       if (carRaceCollision === 99) break;\n       if (carRaceCollision === 100) break;\n       if (carRaceCollision === 101) break;\n       if (carRaceCollision === 102) break;\n       if (carRaceCollision === 103) break;\n       if (carRaceCollision === 104) break;\n       if (carRaceCollision === 105) break;\n       if (carRaceCollision === 106) break;\n       if (carRaceCollision === 107) break;\n       if (carRaceCollision === 108) break;\n       if (carRaceCollision === 109) break;\n       if (carRaceCollision === 110) break;\n       if (carRaceCollision === 111) break;\n       if (carRaceCollision === 112) break;\n       if (carRaceCollision === 113) break;\n       if (carRaceCollision === 114) break;\n       if (carRaceCollision === 115) break;\n       if (carRaceCollision === 116) break;\n       if (carRaceCollision === 117) break;\n       if (carRaceCollision === 118) break;\n       if (carRaceCollision === 119) break;\n       if (carRaceCollision === 120) break;\n       if (carRaceCollision === 121) break;\n       if (carRaceCollision === 122) break;\n       if (carRaceCollision === 123) break;\n       if (carRaceCollision === 124) break;\n       if (carRaceCollision === 125) break;\n       if (carRaceCollision === 126) break;\n       if (carRaceCollision === 127) break;\n       if (carRaceCollision === 128) break;\n       if (carRaceCollision === 129) break;\n       if (carRaceCollision === 130) break;\n       if (carRaceCollision === 131) break;\n       if (carRaceCollision === ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n++;\n    l[i] = l[i] + 1;\n  }\n  return l;\n};\n\n/*Return list with elements element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 4, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n--;\n    l[i] = l[i] - 1;\n  }\n  return l;\n};\n\n/*Return list with elements element multiplied by 2.\n  >>> multList([1, 2, 3])\n  [2, 4, 6]\n  >>> multList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55]\n  */\nconst multList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n *= 2;\n    l[i] = l[i] * 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, 5, 55]\n  */\nconst divList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n /= 2;\n    l[i] = l[i] / 2;\n  }\n  return l;\n};\n\n/*Return list with elements element divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 2]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 10, 5, 20, 5, 30, 5, 40, 5, 50, ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === sum) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === sum) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === sum) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === sum) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === sum) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === sum) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === sum) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === sum) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical numeral base of input stimulation number act x to base.\n   return string representation after the conversion. \n   base numbers phone number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Change numerical numeral base of input stimulation number act x to base.\n   return string representation after the conversion. \n   base numbers phone number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase2 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase2(8, 3)\n  '22'\n  >>> changeBase2(8, 2)\n  '1000'\n  >>> changeBase2(7, 2)\n  '111'\n  */\nconst changeBase3 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase3(8, 3)\n  '22'\n  >>> changeBase3(8, 2)\n  '1000'\n  >>> changeBase3(7, 2)\n  '111'\n  */\nconst changeBase4 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase4(8, 3)\n  '22'\n  >>> changeBase4(8, 2)\n  '1000'\n  >>> changeBase4(7, 2)\n  '111'\n  */\nconst changeBase5 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase5(8, 3)\n  '22'\n  >>> changeBase5(8, 2)\n  '1000'\n  >>> changeBase5(7, 2)\n  '111'\n  */\nconst changeBase6 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase6(8, 3)\n  '22'\n  >>> changeBase6(8, 2)\n  '1000'\n  >>> changeBase6(7, 2)\n  '111'\n  */\nconst changeBase7 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase7(8, 3)\n  '22'\n  >>> changeBase7(8, 2)\n  '1000'\n  >>> changeBase7(7, 2)\n  '111'\n  */\nconst changeBase8 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase8(8, 3)\n  '22'\n  >>> changeBase8(8, 2)\n  '1000'\n  >>> changeBase8(7, 2)\n  '111'\n  */\nconst changeBase9 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase9(8, 3)\n  '22'\n  >>> changeBase9(8, 2)\n  '1000'\n  >>> changeBase9(7, 2)\n  '111'\n  */\nconst changeBase10 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase10(8, 3)\n  '22'\n  >>> changeBase10(8, 2)\n  '1000'\n  >>> changeBase10(7, 2)\n  '111'\n  */\nconst changeBase11 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase11(8, 3)\n  '22'\n  >>> changeBase11(8, 2)\n  '1000'\n  >>> changeBase11(7, 2)\n  '111'\n  */\nconst changeBase12 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase12(8, 3)\n  '22'\n  >>> changeBase12(8, 2)\n  '1000'\n  >>> changeBase12(7, 2)\n  '111'\n  */\nconst changeBase13 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase13(8, 3)\n  '22'\n  >>> changeBase13(8, 2)\n  '1000'\n  >>> changeBase13(7, 2)\n  '111'\n  */\nconst changeBase14 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase14(8, 3)\n  '22'\n  >>> changeBase14(8, 2)\n  '1000'\n  >>> changeBase14(7, 2)\n  '111'\n  */\nconst changeBase15 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase15(8, 3)\n  '22'\n  >>> changeBase15(8, 2)\n  '1000'\n  >>> changeBase15(7, 2)\n  '111'\n  */\nconst changeBase16 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = '';\n  while (n >= 0) {\n    res += (str.charAt(n) + base);\n    n--;\n  }\n  return res;\n};\n\n/*\n  >>> changeBase16(8, 3)\n  '22'\n  >>> changeBase16(8, 2)\n  '1000'\n  >>> changeBase16(7, 2)\n  '111'\n  */\nconst changeBase17 = (x, base) => {\n  const str = x.toString();\n  const n = str.length - 1;\n  const res = ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * a + h * h);\n};\n\n/*Given length duration of a side english and high return area sphere for a circle.\n  >>> circleArea(5, 3)\n  7.5\n  */\nconst circleArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a sphere.\n  >>> sphereArea(5, 3)\n  7.5\n  */\nconst sphereArea = (a, h) => {\n  return Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a cylinder.\n  >>> cylinderArea(5, 3)\n  7.5\n  */\nconst cylinderArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a cone.\n  >>> coneArea(5, 3)\n  7.5\n  */\nconst coneArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a pyramid.\n  >>> pyramidArea(5, 3)\n  7.5\n  */\nconst pyramidArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a spiral.\n  >>> spiralArea(5, 3)\n  7.5\n  */\nconst spiralArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a torus.\n  >>> torusArea(5, 3)\n  7.5\n  */\nconst torusArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron.\n  >>> tetrahedronArea(5, 3)\n  7.5\n  */\nconst tetrahedronArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a prism\n  >>> prismArea(5, 3)\n  7.5\n  */\nconst prismArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a hexagon.\n  >>> hexagonArea(5, 3)\n  7.5\n  */\nconst hexagonArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a octahedron.\n  >>> octahedronArea(5, 3)\n  7.5\n  */\nconst octahedronArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a dodecahedron.\n  >>> dodecahedronArea(5, 3)\n  7.5\n  */\nconst dodecahedronArea = (a, h) => {\n  return Math.PI * Math.pow(a, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 4 sides.\n  >>> tetrahedronArea(4, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 6 sides.\n  >>> tetrahedronArea(6, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 8 sides.\n  >>> tetrahedronArea(8, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 10 sides.\n  >>> tetrahedronArea(10, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 12 sides.\n  >>> tetrahedronArea(12, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 14 sides.\n  >>> tetrahedronArea(14, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 16 sides.\n  >>> tetrahedronArea(16, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 18 sides.\n  >>> tetrahedronArea(18, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 20 sides.\n  >>> tetrahedronArea(20, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 22 sides.\n  >>> tetrahedronArea(22, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 24 sides.\n  >>> tetrahedronArea(24, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahedron with 26 sides.\n  >>> tetrahedronArea(26, 3)\n  7.5\n  */\nconst tetrahedronArea = (s, h) => {\n  return Math.PI * Math.pow(s, 2) * h;\n};\n\n/*Given length duration of a side english and high return area sphere for a tetrahe", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fib4 number sequence.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*The Fib4 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fib4 number sequence.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n === 3) {\n    return 1;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fib5 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib5(0) - > 0 \n   fib5(1) - > 0 \n   fib5(2) - > 1 \n   fib5(3) - > 0 \n   fib5(4) - > 0 \n   fib5(5) - > 1 \n   fib5(6) - > 0 \n   fib5(7) - > 1 \n   fib5(8) - > 2 \n   fib5(9) - > 0 \n   fib5(n) - > fib5(n-1) + fib5(n-2) + fib5(n-3) + fib5(n-4) + fib5(n-5) + fib5(n-6) + fib5(n-7) + fib5(n-8) + fib5(n-9).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fib5 number sequence.   Do not use recursion.\n  >>> fib5(5)\n  5\n  >>> fib5(6)\n  10\n  >>> fib5(7)\n  15\n  */\nconst fib5 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  if (n === 3) {\n    return 1;\n  }\n  if (n === 4) {\n    return 1;\n  }\n  if (n === 5) {\n    return 2;\n  }\n  if (n === 6) {\n    return 1;\n  }\n  if (n === 7) {\n    return 1;\n  }\n  if (n === 8) {\n    return 2;\n  }\n  if (n === 9) {\n    return 1;\n  }\n  return fib5(n - 1) + fib5(n - 2) + fib5(n - 3) + fib5(n - 4) + fib5(n - 5) + fib5(n - 6) + fib5(n - 7) + fib5(n - 8) + fib5(n - 9);\n};\n\n/*The Fib6 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib6(0) - > 0 \n   fib6(1) - > 0 \n   fib6(2) - > 1 \n   fib6(3) - > 0 \n   fib6(4) - > 0 \n   fib6(5) - > 1 \n   fib6(6) - > 0 \n   fib6(7) - > 1 \n   fib6(8) - > 2 \n   fib6(9) - > 0 \n   fib6(10) - > 0 \n   fib6(11) - > 1 \n   fib6(12) - > 0 \n   fib6(13) - > 1 \n   fib6(14) - > 2 \n   fib6(15) - > 0 \n   fib6(n) - > fib6(n-1) + fib6(n-2) + fib6(n-3) + fib6(n-4) + fib6(n-5) + fib6(n-6) + fib6(n-7) + fib6(n-8) + fib6(n-9) + fib6(n-10) + fib6(n-11) + fib6(n-12) + fib6(n-13) + fib6(n-14) + fib6(n-15).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fib6 number sequence.   Do not use recursion.\n  >>> fib6(6)\n  6\n  >>> fib6(7)\n  12\n  >>> fib6(8)\n  18\n  >>> fib6(9)\n  24\n  */\nconst fib6 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  if (n === 3) {\n    return 1;\n  }\n  if (n === 4) {\n    return 1;\n  }\n  if (n === 5) {\n    return 2;\n  }\n  if (n === 6) {\n    return 1;\n  }\n  if (n === 7) {\n    return 1;\n  }\n  if (n === 8) {\n    return 2;\n  }\n  if (n === 9) {\n    return 1;\n  }\n  if (n === 10) {\n    return 1;\n  }\n  if (n === 11) {\n    return 2;\n  }\n  if (n === 12) {\n    return 1;\n  }\n  if (n === 13) {\n    return 1;\n  }\n  if (n === 14) {\n    return 2;\n  }\n  if (n === 15) {\n    return 1;\n  }\n  return fib6(n - 1) + fib6(n - 2) + fib6(n - 3) + fib6(n - 4) + fib6(n - 5) + fib6(n - 6) + fib6(n - 7) + fib6(n - 8) + fib6(n - 9) + fib6(n - 10) + fib6(n - 11) + fib6(n - 12) + fib6(n - 13) + fib6(n - 14) + fib6(n - 15);\n};\n\n/*The Fib7 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib7(0) - > 0 \n   fib7(1) - > 0 \n   fib7(2) - > 1 \n   fib7(3) - > 0 \n   fib7(4) - > 0 \n   fib7(5) - > 1 \n   fib7(6) - > 0 \n   fib7(7) - > 1 \n   fib7(8) - > 2 \n   fib7(9) - > 0 \n   fib7(10) - > 0 \n   fib7(11) - > 1 \n   fib7(12) - > 0 \n   fib7(13) - > 1 \n   fib7(14) - > 2 \n   fib7(15) - > 0 \n   fib7(16) - > 0 \n   fib7(17) - > 1 \n   fib7(18) - > 0 \n   fib7(19) - > 1 \n   fib7(20) - > 2 \n   fib7(21) - > 0 \n   fib7(22) - > 0 \n   fib7(23) - > 1 \n   fib7(24) - > 0 \n   fib7(25) - > 1 \n   fib7(26) - > 2 \n   fib7(27) - > 0 \n   fib7(28) - > 0 \n   fib7(29) - > 1 \n   fib7(30) - > 2 \n   fib7(31) - > 0 \n   fib7(32) - > 0 \n   fib7(33) - > 1 \n   fib7(34) - > 2 \n   fib7(35) - > 0 \n   fib7(36) - > 0 \n   fib7(37) - > 1 \n   fib7(38) - > 2 ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  const mid = Math.floor(l.length / 2);\n  return (l[mid] + l[mid-1]) / 2;\n};\n\n/*Return median of elements ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArr = text.split('');\n  const reversedArr = textArr.reverse();\n  return textArr.join('') === reversedArr.join('');\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 0)\n    throw new Error(\"modp() arguments must be non-negative\");\n  if (p === 0)\n    return 1;\n  if (n === 0)\n    return 0;\n  if (n === p)\n    return 1;\n  if (n < p)\n    return modp(n - p, p);\n  else\n    return modp((n - p) / 2, p) + 1;\n};\n\n/*\n  >>> modpow(3, 5, 5)\n  25\n  >>> modpow(3, 5, 7)\n  12\n  >>> modpow(3, 5, 9)\n  4\n  >>> modpow(3, 5, 11)\n  2\n  >>> modpow(3, 5, 15)\n  8\n  >>> modpow(3, 5, 17)\n  2\n  >>> modpow(3, 5, 19)\n  4\n  >>> modpow(3, 5, 21)\n  2\n  >>> modpow(3, 5, 23)\n  8\n  >>> modpow(3, 5, 25)\n  2\n  >>> modpow(3, 5, 27)\n  8\n  >>> modpow(3, 5, 29)\n  2\n  >>> modpow(3, 5, 31)\n  8\n  >>> modpow(3, 5, 33)\n  2\n  >>> modpow(3, 5, 35)\n  8\n  >>> modpow(3, 5, 37)\n  2\n  >>> modpow(3, 5, 39)\n  8\n  >>> modpow(3, 5, 41)\n  2\n  >>> modpow(3, 5, 43)\n  8\n  >>> modpow(3, 5, 45)\n  2\n  >>> modpow(3, 5, 47)\n  8\n  >>> modpow(3, 5, 49)\n  2\n  >>> modpow(3, 5, 51)\n  8\n  >>> modpow(3, 5, 53)\n  2\n  >>> modpow(3, 5, 55)\n  8\n  >>> modpow(3, 5, 57)\n  2\n  >>> modpow(3, 5, 59)\n  8\n  >>> modpow(3, 5, 61)\n  2\n  >>> modpow(3, 5, 63)\n  8\n  >>> modpow(3, 5, 65)\n  2\n  >>> modpow(3, 5, 67)\n  8\n  >>> modpow(3, 5, 69)\n  2\n  >>> modpow(3, 5, 71)\n  8\n  >>> modpow(3, 5, 73)\n  2\n  >>> modpow(3, 5, 75)\n  8\n  >>> modpow(3, 5, 77)\n  2\n  >>> modpow(3, 5, 79)\n  8\n  >>> modpow(3, 5, 81)\n  2\n  >>> modpow(3, 5, 83)\n  8\n  >>> modpow(3, 5, 85)\n  2\n  >>> modpow(3, 5, 87)\n  8\n  >>> modpow(3, 5, 89)\n  2\n  >>> modpow(3, 5, 91)\n  8\n  >>> modpow(3, 5, 93)\n  2\n  >>> modpow(3, 5, 95)\n  8\n  >>> modpow(3, 5, 97)\n  2\n  >>> modpow(3, 5, 99)\n  8\n  >>> modpow(3, 5, 101)\n  2\n  >>> modpow(3, 5, 103)\n  8\n  >>> modpow(3, 5, 105)\n  2\n  >>> modpow(3, 5, 107)\n  8\n  >>> modpow(3, 5, 109)\n  2\n  >>> modpow(3, 5, 111)\n  8\n  >>> modpow(3, 5, 113)\n  2\n  >>> modpow(3, 5, 115)\n  8\n  >>> modpow(3, 5, 117)\n  2\n  >>> modpow(3, 5, 119)\n  8\n  >>> modpow(3, 5, 121)\n  2\n  >>> modpow(3, 5, 123)\n  8\n  >>> modpow(3, 5, 125)\n  2\n  >>> modpow(3, 5, 127)\n  8\n  >>> modpow(3, 5, 129)\n  2\n  >>> modpow(3, 5, 131)\n  8\n  >>> modpow(3, 5, 133)\n  2\n  >>> modpow(3, 5, 135)\n  8\n  >>> modpow(3, 5, 137)\n  2\n  >>> modpow(3, 5, 139)\n  8\n  >>> modpow(3, 5, 141)\n  2\n  >>> modpow(3, 5, 143)\n  8\n  >>> modpow(3, 5, 145)\n  2\n  >>> modpow(3, 5, 147)\n  8\n  >>> modpow(3, 5, 149)\n  2\n  >>> modpow(3, 5, 151)\n  8\n  >>> modpow(3, 5, 153)\n  2\n  >>> modpow(3, 5, 155)\n  8\n  >>> modpow(3, 5, 157)\n  2\n  >>> modpow(3, 5, 159)\n  8\n  >>> modpow(3, 5, 161)\n  2\n  >>> modpow(3, 5, 163)\n  8\n  >>> modpow(3, 5, 165)\n  2\n  >>> modpow(3, 5, 167)\n  8\n  >>> modpow(3, 5, 169)\n  2\n  >>> modpow(3, 5, 171)\n  8\n  >>> modpow(3, 5, 173)\n  2\n  >>> modpow(3, 5, 175)\n  8\n  >>> modpow(3, 5, 177)\n  2\n  >>> modpow(3, 5, 179)\n  8\n  >>> modpow(3, 5, 181)\n  2\n  >>> modpow(3, 5, 183)\n  8\n  >>> modpow(3, 5, 185)\n  2\n  >>> modpow(3, 5, 187)\n  8\n  >>> modpow(3, 5, 189)\n  2\n  >>> modpow(3, 5, 191)\n  8\n  >>> modpow(3, 5, 193)\n  2\n  >>> modpow(3, 5, 195)\n  8\n  >>> modpow(3, 5, 197)\n  2\n  >>> modpow(3, 5, 199)\n  8\n  >>> modpow(3, 5, 201)\n  2\n  >>> modpow(3, 5, 203)\n  8\n  >>> modpow(3, 5, 205)\n  2\n  >>> modpow(3, 5, 207)\n  8\n  >>> modpow(3, 5, 209)\n  2\n  >>> modpow(3, 5, 211)\n  8\n  >>> modpow(3, 5, 213)\n  2\n  >>> modpow(3, 5, 215)\n  8\n  >>> modpow(3, 5, 217)\n  2\n  >>> modpow(3, 5, 219)\n  8\n  >>> modpow(3, 5, 221)\n  2\n  >>> modpow(3, 5, 223)\n  8\n  >>> modpow(3, 5, 225)\n  2\n  >>> modpow(3, 5, 227)\n  8\n  >>> modpow(3, 5, 229)\n  2\n  >>> modpow(3, 5, 231)\n  8\n  >>> modpow(3, 5, 233)\n  2\n  >>> modpow(3, 5, 235)\n  8\n  >>> modpow(3, 5, 237)\n  2\n  >>> modpow", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number numeral 'delimeter' between every two consecutive back-to-back elements of input remark list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Insert a number numeral 'delimeter' between every two consecutive back-to-back elements of input remark list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  if (numbers.length === 0) {\n    return [];\n  }\n\n  const result = [];\n  let lastNumber = numbers[0];\n  for (let i = 1; i < numbers.length; i += 1) {\n    if (numbers[i] === lastNumber) {\n      result.push(numbers[i]);\n    } else {\n      result.push(lastNumber);\n      result.push(delimeter);\n      result.push(numbers[i]);\n    }\n    lastNumber = numbers[i];\n  }\n  return result;\n};\n\n/* Remove all occurrences of 'delimeter' from input remark list `numbers'\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  [1, 2]\n  >>> removeAll('1, 2, 3, 4','')\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 + 26) % 26) + \" a\".charCodeAt(0) \n   ) ).join (\"\"); \n } \n \n / * \n   returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 + 26) % 26) + \" a\".charCodeAt(0) \n   ) ).join (\"\"); \n } \n \n / * \n   returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 + 26) % 26) + \" a\".charCodeAt(0) \n   ) ).join (\"\"); \n } \n \n / * \n   returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 + 26) % 26) + \" a\".charCodeAt(0) \n   ) ).join (\"\"); \n } \n \n / * \n   returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 + 26) % 26) + \" a\".charCodeAt(0) \n   ) ).join (\"\"); \n } \n \n / * \n   returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 + 26) % 26) + \" a\".charCodeAt(0) \n   ) ).join (\"\"); \n } \n \n / * \n   returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 + 26) % 26) + \" a\".charCodeAt(0) \n   ) ).join (\"\"); \n } \n \n / * \n   returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 + 26) % 26) + \" a\".charCodeAt(0) \n   ) ).join (\"\"); \n } \n \n / * \n   returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 + 26) % 26) + \" a\".charCodeAt(0) \n   ) ).join (\"\"); \n } \n \n / * \n   returns tax return encoded encode string by shifting ca", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  return text.replace(/[aeiou]/g, '');\n};\n\n/*\n  removeStopWords is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without stop words stop word.\n  >>> removeStopWords('')\n  ''\n  >>> removeStopWords(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeStopWords('abcdef')\n  'bcdf'\n  >>> removeStopWords('aaaaa')\n  ''\n  >>> removeStopWords('aaBAA')\n  'B'\n  >>> removeStopWords('zbcd')\n  'zbcd'\n  */\nconst removeStopWords = (text) => {\n  return text.replace(/\\b(\\w+)\\b/g, '');\n};\n\n/*\n  removeNumbers is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without numbers number.\n  >>> removeNumbers('')\n  ''\n  >>> removeNumbers(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeNumbers('abcdef')\n  'bcdf'\n  >>> removeNumbers('aaaaa')\n  ''\n  >>> removeNumbers('aaBAA')\n  'B'\n  >>> removeNumbers('zbcd')\n  'zbcd'\n  */\nconst removeNumbers = (text) => {\n  return text.replace(/\\b\\d+\\b/g, '');\n};\n\n/*\n  removePunctuations is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without punctuations punctuation.\n  >>> removePunctuations('')\n  ''\n  >>> removePunctuations(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removePunctuations('abcdef')\n  'bcdf'\n  >>> removePunctuations('aaaaa')\n  ''\n  >>> removePunctuations('aaBAA')\n  'B'\n  >>> removePunctuations('zbcd')\n  'zbcd'\n  */\nconst removePunctuations = (text) => {\n  return text.replace(/[!,.:;?]/g, '');\n};\n\n/*\n  removeWhiteSpaces is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without white spaces white space.\n  >>> removeWhiteSpaces('')\n  ''\n  >>> removeWhiteSpaces(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeWhiteSpaces('abcdef')\n  'bcdf'\n  >>> removeWhiteSpaces('aaaaa')\n  ''\n  >>> removeWhiteSpaces('aaBAA')\n  'B'\n  >>> removeWhiteSpaces('zbcd')\n  'zbcd'\n  */\nconst removeWhiteSpaces = (text) => {\n  return text.replace(/\\s/g, '');\n};\n\n/*\n  removeWhiteSpacesAndPunctuations is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without white spaces white space and punctuations punctuation.\n  >>> removeWhiteSpacesAndPunctuations('')\n  ''\n  >>> removeWhiteSpacesAndPunctuations(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeWhiteSpacesAndPunctuations('abcdef')\n  'bcdf'\n  >>> removeWhiteSpacesAndPunctuations('aaaaa')\n  ''\n  >>> removeWhiteSpacesAndPunctuations('aaBAA')\n  'B'\n  >>> removeWhiteSpacesAndPunctuations('zbcd')\n  'zbcd'\n  */\nconst removeWhiteSpacesAndPunctuations = (text) => {\n  return text.replace(/[!,.:;?]/g, '').replace(/\\s+/g, '');\n};\n\n/*\n  removeWhiteSpacesAndNumbers is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without white spaces white space and numbers number.\n  >>> removeWhiteSpacesAndNumbers('')\n  ''\n  >>> removeWhiteSpacesAndNumbers(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeWhiteSpacesAndNumbers('abcdef')\n  'bcdf'\n  >>> removeWhiteSpacesAndNumbers('aaaaa')\n  ''\n  >>> removeWhiteSpacesAndNumbers('aaBAA')\n  'B'\n  >>> removeWhiteSpacesAndNumbers('zbcd')\n  'zbcd'\n  */\nconst removeWhiteSpacesAndNumbers = (text) => {\n  return text.replace(/[!,.:;?]/g, '').replace(/\\s+/g, '').replace(/\\d+/g, '');\n};\n\n/*\n  removeWhiteSpacesAndVowels is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without white spaces white space and vowels vowel.\n  >>> removeWhiteSpacesAndVowels('')\n  ''\n  >>> removeWhiteSpacesAndVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeWhiteSpacesAndVowels('abcdef')\n  'bcdf'\n  >>> removeWhiteSpacesAndVowels('aaaaa')\n  ''\n  >>> removeWhiteSpacesAndVowels('aaBAA')\n  'B'\n  >>> removeWhiteSpacesAndVowels('zbcd')\n  'zbcd'\n  */\nconst removeWhiteSpacesAndVowels = (text) => {\n  return text.replace(/[!,.:;?]/g, '').replace(/\\s+/g, '').replace(/[aeiou]/g, '');\n};\n\n/*\n  removeWhiteSpacesAndStopWords is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without white spaces white space and stop words stop word.\n  >>> removeWhiteSpacesAndStopWords('')\n  ''\n  >>> removeWhiteSpacesAndStopWords(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeWhiteSpacesAndStopWords('abcdef')\n  'bcdf'\n  >>> removeWhiteSpacesAndStopWords('aaaaa')\n  ''\n  >>> removeWhiteSpacesAndStopWords('aaBAA')\n  'B'\n  >>> removeWhiteSpacesAndStopWords('zbcd')\n  'zbcd'\n  */\nconst removeWhiteSpacesAndStopWords = (text) => {\n  return text.replace(/[!,.:;?]/g, '').replace(/\\s+/g, '').replace(/\\b(\\w+)\\b/g, '');\n};\n\n/*\n  removeWhiteSpacesAndNumbers is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without white spaces white space and numbers number.\n  >>> removeWhite", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true genuine if all numbers phone number in the list l are below threshold brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return true genuine if all numbers phone number in the list l are below threshold brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are above threshold brink t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold2 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold3 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold4 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold5 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold6 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold7 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold8 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold9 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold10 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold11 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold12 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold13 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold14 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true genuine if all numbers phone number in the list l are between threshold and brink t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold15 = (l, t) => {", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*Subtract two numbers phone number x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  3\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*Multiply two numbers phone number x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  42\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*Divide two numbers phone number x and y\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  3\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*Get the modulus of a number phone number x and y\n  >>> modulus(2, 3)\n  1\n  >>> modulus(5, 7)\n  2\n  */\nconst modulus = (x, y) => {\n  return x % y;\n};\n\n/*Get the remainder of a number phone number x and y\n  >>> remainder(2, 3)\n  1\n  >>> remainder(5, 7)\n  2\n  */\nconst remainder = (x, y) => {\n  return x % y;\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the absolute value of a number phone number x\n  >>> abs(-5)\n  5\n  >>> abs(5)\n  5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s0.length, s1.length);\n  for (let i = 0; i < len; i++) {\n    if (s0.charAt(i)!== s1.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s0.length, s1.length);\n  for (let i = 0; i < len; i++) {\n    if (s0.charAt(i)!== s1.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s0.length, s1.length);\n  for (let i = 0; i < len; i++) {\n    if (s0.charAt(i)!== s1.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s0.length, s1.length);\n  for (let i = 0; i < len; i++) {\n    if (s0.charAt(i)!== s1.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s0.length, s1.length);\n  for (let i = 0; i < len; i++) {\n    if (s0.charAt(i)!== s1.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s0.length, s1.length);\n  for (let i = 0; i < len; i++) {\n    if (s0.charAt(i)!== s1.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s0.length, s1.length);\n  for (let i = 0; i < len; i++) {\n    if (s0.charAt(i)!== s1.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s0.length, s1.length);\n  for (let i = 0; i < len; i++) {\n    if (s0.charAt(i)!== s1.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s0.length, s1.length);\n  for (let i = 0; i < len; i++) {\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/\\<+/g);\n  const closingBrackets = brackets.match(/\\>+/g);\n  const openingBracketsCount = openingBrackets? openingBrackets.length : 0;\n  const closingBracketsCount = closingBrackets? closingBrackets.length : 0;\n  const openingBracketsCountIncorrect = openingBracketsCount!== openingBracketsCount;\n  const closingBracketsCountIncorrect = closingBracketsCount!== closingBracketsCount;\n  return openingBracketsCountIncorrect && closingBracketsCountIncorrect;\n};\n\n/* \n   Given an instrument string, return true if it contains only \n   one opening bracket and no closing bracket.\n\n  >>> correctBracketing(\"<\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<<><>>\")\n  true\n  >>> correctBracketing(\"><<>\")\n  true\n  */\nconst correctBracketingForOne = (instrument) => {\n  const openingBrackets = instrument.match(/\\<+/g);\n  const closingBrackets = instrument.match(/\\>+/g);\n  const openingBracketsCount = openingBrackets? openingBrackets.length : 0;\n  const closingBracketsCount = closingBrackets? closingBrackets.length : 0;\n  const openingBracketsCountIncorrect = openingBracketsCount!== openingBracketsCount;\n  const closingBracketsCountIncorrect = closingBracketsCount!== closingBracketsCount;\n  return openingBracketsCountIncorrect && closingBracketsCountIncorrect;\n};\n\n/* \n   Given an instrument string, return true if it contains only \n   one opening bracket and no closing bracket.\n\n  >>> correctBracketingForOne(\"<\")\n  true\n  >>> correctBracketingForOne(\"<>\")\n  true\n  >>> correctBracketingForOne(\"<<><>>\")\n  true\n  >>> correctBracketingForOne(\"><<>\")\n  true\n  */\nconst correctBracketingForOne = (instrument) => {\n  const openingBrackets = instrument.match(/\\<+/g);\n  const closingBrackets = instrument.match(/\\>+/g);\n  const openingBracketsCount = openingBrackets? openingBrackets.length : 0;\n  const closingBracketsCount = closingBrackets? closingBrackets.length : 0;\n  const openingBracketsCountIncorrect = openingBracketsCount!== openingBracketsCount;\n  const closingBracketsCountIncorrect = closingBracketsCount!== closingBracketsCount;\n  return openingBracketsCountIncorrect && closingBracketsCountIncorrect;\n};\n\n/* \n   Given an instrument string, return true if it contains only \n   one opening bracket and no closing bracket.\n\n  >>> correctBracketingForOne(\"<\")\n  true\n  >>> correctBracketingForOne(\"<>\")\n  true\n  >>> correctBracketingForOne(\"<<><>>\")\n  true\n  >>> correctBracketingForOne(\"><<>\")\n  true\n  */\nconst correctBracketingForOne = (instrument) => {\n  const openingBrackets = instrument.match(/\\<+/g);\n  const closingBrackets = instrument.match(/\\>+/g);\n  const openingBracketsCount = openingBrackets? openingBrackets.length : 0;\n  const closingBracketsCount = closingBrackets? closingBrackets.length : 0;\n  const openingBracketsCountIncorrect = openingBracketsCount!== openingBracketsCount;\n  const closingBracketsCountIncorrect = closingBracketsCount!== closingBracketsCount;\n  return openingBracketsCountIncorrect && closingBracketsCountIncorrect;\n};\n\n/* \n   Given an instrument string, return true if it contains only \n   one opening bracket and no closing bracket.\n\n  >>> correctBracketingForOne(\"<\")\n  true\n  >>> correctBracketingForOne(\"<>\")\n  true\n  >>> correctBracketingForOne(\"<<><>>\")\n  true\n  >>> correctBracketingForOne(\"><<>\")\n  true\n  */\nconst correctBracketingForOne = (instrument) => {\n  const openingBrackets = instrument.match(/\\<+/g);\n  const closingBrackets = instrument.match(/\\>+/g);\n  const openingBracketsCount = openingBrackets? openingBrackets.length : 0;\n  const closingBracketsCount = closingBrackets? closingBrackets.length : 0;\n  const openingBracketsCountIncorrect = openingBracketsCount!== openingBracketsCount;\n  const closingBracketsCountIncorrect = closingBracketsCount!== closingBracketsCount;\n  return openingBracketsCountIncorrect && closingBracketsCountIncorrect;\n};\n\n/* \n   Given an instrument string, return true if it contains only \n   one opening bracket and no closing bracket.\n\n  >>> correctBracketingForOne(\"<\")\n  true\n  >>> correctBracketingForOne(\"<>\")\n  true\n  >>> correctBracketingForOne(\"<<><>>\")\n  true\n  >>> correctBracketingForOne(\"><<>\")\n  true\n  */\nconst correctBracketingForOne = (instrument) => {\n  const openingBrackets = instrument.match(/\\<+/g);\n  const closingBrackets = instrument.match(/\\>+/g);\n  const openingBracketsCount = openingBrackets? openingBrackets.length : 0;\n  const closingBracketsCount = closingBrackets? closingBrackets.length : 0;\n  const openingBracketsCountIncorrect = openingBracketsCount!== openingBracketsCount;\n  const closingBracketsCountIncorrect = closingBracketsCount!== closingBracketsCount;\n  return openingBracketsCountIncorrect && closingBracketsCountIncorrect;\n};\n\n/* \n   Given an instrument string, return true if it contains only \n   one opening bracket and no closing bracket.\n\n  >>> correctBracketingForOne(\"<\")\n  true\n  >>> correctBracketingForOne(\"<>\")\n  true\n  >>> correctBracketingForOne(\"<<><>>\")\n  true\n  >>> correctBracketingForOne(\"><<>\")\n  true\n  */\nconst correctBracketingForOne = (instrument) => {\n  const openingBrackets = instrument.match(/\\<+/g);\n  const closingBrackets = instrument.match(/\\>+/g);\n  const openingBracketsCount = openingBrackets? openingBrackets.length : 0;\n  const closingBra", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  for (let i = 0; i < set1.size; i++) {\n    if (set2.has(set1.get(i))) {\n      common.push(set1.get(i));\n    }\n  }\n  return common;\n};\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime choice factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return the largest prime choice factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Return the smallest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Return the number of prime factors of n. Assume n > 1 and is not a prime.\n  >>> primeFactors(13195)\n  3\n  >>> primeFactors(2048)\n  2\n  */\nconst primeFactors = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of prime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  3\n  >>> primeFactorsLessThan(2048)\n  2\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factor", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  const max_level = Math.max(...paren_groups.map(g => g.length));\n  const max_level_groups = paren_groups.filter(g => g.length === max_level);\n  return max_level_groups.map(g => g.length);\n}\n\n/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens2 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  const max_level = Math.max(...paren_groups.map(g => g.length));\n  const max_level_groups = paren_groups.filter(g => g.length === max_level);\n  return max_level_groups;\n}\n\n/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens3 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  const max_level = Math.max(...paren_groups.map(g => g.length));\n  const max_level_groups = paren_groups.filter(g => g.length === max_level);\n  return max_level_groups;\n}\n\n/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens4 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  const max_level = Math.max(...paren_groups.map(g => g.length));\n  const max_level_groups = paren_groups.filter(g => g.length === max_level);\n  return max_level_groups;\n}\n\n/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens5 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  const max_level = Math.max(...paren_groups.map(g => g.length));\n  const max_level_groups = paren_groups.filter(g => g.length === max_level);\n  return max_level_groups;\n}\n\n/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens6 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  const max_level = Math.max(...paren_groups.map(g => g.length));\n  const max_level_groups = paren_groups.filter(g => g.length === max_level);\n  return max_level_groups;\n}\n\n/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens7 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  const max_level = Math.max(...paren_groups.map(g => g.length));\n  const max_level_groups = paren_groups.filter(g => g.length === max_level);\n  return max_level_groups;\n}\n\n/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens8 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  const max_level = Math.max(...paren_groups.map(g => g.length));\n  const max_level_groups = paren_groups.filter(g => g.length === max_level);\n  return max_level_groups;\n}\n\n/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens9 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*|\\([^()]*\\))*\\)/g);\n  const max_level = Math.max(...paren_groups.map(", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  \n  if (openingBrackets && closingBrackets) {\n    const openingBracketsCount = openingBrackets.length;\n    const closingBracketsCount = closingBrackets.length;\n    \n    if (openingBracketsCount === closingBracketsCount) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n/* \n  Given a string, return true if every character in the string is a digit.\n  \n  >>> isDigit(\"1\")\n  true\n  >>> isDigit(\"12\")\n  true\n  >>> isDigit(\"123\")\n  true\n  >>> isDigit(\"1234\")\n  true\n  >>> isDigit(\"12345\")\n  false\n  >>> isDigit(\"123456\")\n  false\n  */\nconst isDigit = (string) => {\n  return string.match(/\\d/g);\n}\n\n/* \n  Given a string, return true if every character in the string is a letter.\n  \n  >>> isLetter(\"a\")\n  true\n  >>> isLetter(\"b\")\n  true\n  >>> isLetter(\"c\")\n  true\n  >>> isLetter(\"d\")\n  true\n  >>> isLetter(\"e\")\n  true\n  >>> isLetter(\"f\")\n  true\n  >>> isLetter(\"g\")\n  true\n  >>> isLetter(\"h\")\n  true\n  >>> isLetter(\"i\")\n  true\n  >>> isLetter(\"j\")\n  true\n  >>> isLetter(\"k\")\n  true\n  >>> isLetter(\"l\")\n  true\n  >>> isLetter(\"m\")\n  true\n  >>> isLetter(\"n\")\n  true\n  >>> isLetter(\"o\")\n  true\n  >>> isLetter(\"p\")\n  true\n  >>> isLetter(\"q\")\n  true\n  >>> isLetter(\"r\")\n  true\n  >>> isLetter(\"s\")\n  true\n  >>> isLetter(\"t\")\n  true\n  >>> isLetter(\"u\")\n  true\n  >>> isLetter(\"v\")\n  true\n  >>> isLetter(\"w\")\n  true\n  >>> isLetter(\"x\")\n  true\n  >>> isLetter(\"y\")\n  true\n  >>> isLetter(\"z\")\n  true\n  >>> isLetter(\"A\")\n  true\n  >>> isLetter(\"B\")\n  true\n  >>> isLetter(\"C\")\n  true\n  >>> isLetter(\"D\")\n  true\n  >>> isLetter(\"E\")\n  true\n  >>> isLetter(\"F\")\n  true\n  >>> isLetter(\"G\")\n  true\n  >>> isLetter(\"H\")\n  true\n  >>> isLetter(\"I\")\n  true\n  >>> isLetter(\"J\")\n  true\n  >>> isLetter(\"K\")\n  true\n  >>> isLetter(\"L\")\n  true\n  >>> isLetter(\"M\")\n  true\n  >>> isLetter(\"N\")\n  true\n  >>> isLetter(\"O\")\n  true\n  >>> isLetter(\"P\")\n  true\n  >>> isLetter(\"Q\")\n  true\n  >>> isLetter(\"R\")\n  true\n  >>> isLetter(\"S\")\n  true\n  >>> isLetter(\"T\")\n  true\n  >>> isLetter(\"U\")\n  true\n  >>> isLetter(\"V\")\n  true\n  >>> isLetter(\"W\")\n  true\n  >>> isLetter(\"X\")\n  true\n  >>> isLetter(\"Y\")\n  true\n  >>> isLetter(\"Z\")\n  true\n  >>> isLetter(\"a\")\n  true\n  >>> isLetter(\"b\")\n  true\n  >>> isLetter(\"c\")\n  true\n  >>> isLetter(\"d\")\n  true\n  >>> isLetter(\"e\")\n  true\n  >>> isLetter(\"f\")\n  true\n  >>> isLetter(\"g\")\n  true\n  >>> isLetter(\"h\")\n  true\n  >>> isLetter(\"i\")\n  true\n  >>> isLetter(\"j\")\n  true\n  >>> isLetter(\"k\")\n  true\n  >>> isLetter(\"l\")\n  true\n  >>> isLetter(\"m\")\n  true\n  >>> isLetter(\"n\")\n  true\n  >>> isLetter(\"o\")\n  true\n  >>> isLetter(\"p\")\n  true\n  >>> isLetter(\"q\")\n  true\n  >>> isLetter(\"r\")\n  true\n  >>> isLetter(\"s\")\n  true\n  >>> isLetter(\"t\")\n  true\n  >>> isLetter(\"u\")\n  true\n  >>> isLetter(\"v\")\n  true\n  >>> isLetter(\"w\")\n  true\n  >>> isLetter(\"x\")\n  true\n  >>> isLetter(\"y\")\n  true\n  >>> isLetter(\"z\")\n  true\n  >>> isLetter(\"A\")\n  true\n  >>> isLetter(\"B\")\n  true\n  >>> isLetter(\"C\")\n  true\n  >>> isLetter(\"D\")\n  true\n  >>> isLetter(\"E\")\n  true\n  >>> isLetter(\"F\")\n  true\n  >>> isLetter(\"G\")\n  true\n  >>> isLetter(\"H\")\n  true\n  >>> isLetter(\"I\")\n  true\n  >>> isLetter(\"J\")\n  true\n  >>> isLetter(\"K\")\n  true\n  >>> isLetter(\"L\")\n  true\n  >>> isLetter(\"M\")\n  true\n  >>> isLetter(\"N\")\n  true\n  >>> isLetter(\"O\")\n  true\n  >>> isLetter(\"P\")\n  true\n  >>> isLetter(\"Q\")\n  true\n  >>> isLetter(\"R\")\n  true\n  >>> isLetter(\"S\")\n  true\n  >>> isLetter(\"T\")\n  true\n  >>> isLetter(\"U\")\n  true\n  >>> isLetter(\"V\")\n  true\n  >>> isLetter(\"W\")\n  true\n  >>> isLetter(\"X\")\n  true\n  >>> isLetter(\"Y\")\n  true\n  >>> isLetter(\"Z\")\n  true\n  */\nconst isLetter = (string) => {\n  return string.match(/[a-z]/g);\n}\n\n/* \n  Given a string, return true if every character in the string is a punctuation character.\n  \n  >>> isPunctuation(\"!\")\n  true\n  >>> isPunctuation(\"?\")\n  true\n  >>> isPunctuation(\".\")\n  true\n  >>> isPunctuation(\",\")\n  true\n  >>> isPunctuation(\":\")\n  true\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 1)\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3], 1)\n  [2, 6]\n  */\nconst derivativeOrder = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 2)\n  [1, 4, 9, 16]\n  >>> derivative([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOrder2 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 3)\n  [1, 4, 9, 16, 25]\n  >>> derivative([1, 2, 3], 3)\n  [2, 6]\n  */\nconst derivativeOrder3 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 4)\n  [1, 4, 9, 16, 25, 36]\n  >>> derivative([1, 2, 3], 4)\n  [2, 6]\n  */\nconst derivativeOrder4 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 5)\n  [1, 4, 9, 16, 25, 36, 49]\n  >>> derivative([1, 2, 3], 5)\n  [2, 6]\n  */\nconst derivativeOrder5 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 6)\n  [1, 4, 9, 16, 25, 36, 49, 64]\n  >>> derivative([1, 2, 3], 6)\n  [2, 6]\n  */\nconst derivativeOrder6 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 7)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81]\n  >>> derivative([1, 2, 3], 7)\n  [2, 6]\n  */\nconst derivativeOrder7 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 8)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n  >>> derivative([1, 2, 3], 8)\n  [2, 6]\n  */\nconst derivativeOrder8 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 9)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]\n  >>> derivative([1, 2, 3], 9)\n  [2, 6]\n  */\nconst derivativeOrder9 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 10)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144]\n  >>> derivative([1, 2, 3], 10)\n  [2, 6]\n  */\nconst derivativeOrder10 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 11)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169]\n  >>> derivative([1, 2, 3], 11)\n  [2, 6]\n  */\nconst derivativeOrder11 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 12)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 192]\n  >>> derivative([1, 2, 3], 12)\n  [2, 6]\n  */\nconst derivativeOrder12 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 13)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 192, 225]\n  >>> derivative([1, 2, 3], 13)\n  [2, 6]\n  */\nconst derivativeOrder13 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 14)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 192, 225, 256]\n  >>> derivative([1, 2, 3], 14)\n  [2, 6]\n  */\nconst derivativeOrder14 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 15)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 192, 225, 256, 289]\n  >>> derivative([1, 2, 3], 15)\n  [2, 6]\n  */\nconst derivativeOrder15 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 16)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 192, 225, 256, 289, 324]\n  >>> derivative([1, 2, 3], 16)\n  [2, 6]\n  */\nconst derivativeOrder16 = (xs, order) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i]) * xs[i]);\n  }\n  return derivatives;\n};\n\n/* \n  Return derivative of this polynomial with given order.\n  >>> derivative([3, 1, 2, 4, 5], 17)\n  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 192, 225, 256, 289, 324, 361]", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*The FibFib number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  let fibfibArray = [];\n  for (let i = 0; i <= n; i++) {\n    fibfibArray.push(i);\n  }\n  return fibfibArray[n];\n};\n\n/*The Fibonacci number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fibonacci(0) = = 0 \n   fibonacci(1) = = 1 \n   fibonacci(2) = = 1 \n   fibonacci(n) = = fibonacci(n-1) + fibonacci(n-2).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  let fibonacciArray = [];\n  for (let i = 0; i <= n; i++) {\n    fibonacciArray.push(i);\n  }\n  return fibonacciArray[n];\n};\n\n/*The FizzBuzz number numeral sequence succession is a sequence similar exchangeable to the FizzBuzz sequnece that's defined as follows play along: \n   fizzbuzz(0) = = 0 \n   fizzbuzz(1) = = 1 \n   fizzbuzz(2) = = 1 \n   fizzbuzz(3) = = 2 \n   fizzbuzz(4) = = 2 \n   fizzbuzz(5) = = 3 \n   fizzbuzz(6) = = 3 \n   fizzbuzz(7) = = 4 \n   fizzbuzz(8) = = 4 \n   fizzbuzz(9) = = 5 \n   fizzbuzz(10) = = 5 \n   fizzbuzz(11) = = 6 \n   fizzbuzz(12) = = 6 \n   fizzbuzz(13) = = 7 \n   fizzbuzz(14) = = 7 \n   fizzbuzz(15) = = 8 \n   fizzbuzz(16) = = 8 \n   fizzbuzz(17) = = 9 \n   fizzbuzz(18) = = 9 \n   fizzbuzz(19) = = 10 \n   fizzbuzz(20) = = 10 \n   fizzbuzz(21) = = 11 \n   fizzbuzz(22) = = 11 \n   fizzbuzz(23) = = 12 \n   fizzbuzz(24) = = 12 \n   fizzbuzz(25) = = 13 \n   fizzbuzz(26) = = 13 \n   fizzbuzz(27) = = 14 \n   fizzbuzz(28) = = 14 \n   fizzbuzz(29) = = 15 \n   fizzbuzz(30) = = 15 \n   fizzbuzz(31) = = 16 \n   fizzbuzz(32) = = 16 \n   fizzbuzz(33) = = 17 \n   fizzbuzz(34) = = 17 \n   fizzbuzz(35) = = 18 \n   fizzbuzz(36) = = 18 \n   fizzbuzz(37) = = 19 \n   fizzbuzz(38) = = 19 \n   fizzbuzz(39) = = 20 \n   fizzbuzz(40) = = 20 \n   fizzbuzz(41) = = 21 \n   fizzbuzz(42) = = 21 \n   fizzbuzz(43) = = 22 \n   fizzbuzz(44) = = 22 \n   fizzbuzz(45) = = 23 \n   fizzbuzz(46) = = 23 \n   fizzbuzz(47) = = 24 \n   fizzbuzz(48) = = 24 \n   fizzbuzz(49) = = 25 \n   fizzbuzz(50) = = 25 \n   fizzbuzz(51) = = 26 \n   fizzbuzz(52) = = 26 \n   fizzbuzz(53) = = 27 \n   fizzbuzz(54) = = 27 \n   fizzbuzz(55) = = 28 \n   fizzbuzz(56) = = 28 \n   fizzbuzz(57) = = 29 \n   fizzbuzz(58) = = 29 \n   fizzbuzz(59) = = 30 \n   fizzbuzz(60) = = 30 \n   fizzbuzz(61) = = 31 \n   fizzbuzz(62) = = 31 \n   fizzbuzz(63) = = 32 \n   fizzbuzz(64) = = 32 \n   fizzbuzz(65) = = 33 \n   fizzbuzz(66) = = 33 \n   fizzbuzz(67) = = 34 \n   fizzbuzz(68) = = 34 \n   fizzbuzz(69) = = 35 \n   fizzbuzz(70) = = 35 \n   fizzbuzz(71) = = 36 \n   fizzbuzz(72) = = 36 \n   fizzbuzz(73) = = 37 \n   fizzbuzz(74) = = 37 \n   fizzbuzz(75) = = 38 \n   fizzbuzz(76) = = 38 \n   fizzbuzz(77) = = 39 \n   fizzbuzz(78) = = 39 \n   fizzbuzz(79) = = 40 \n   fizzbuzz(80) = = 40 \n   fizzbuzz(81) = = 41 \n   fizzbuzz(82) = = 41 \n   fizzbuzz(83) = = 42 \n   fizzbuzz(84) = = 42 \n   fizzbuzz(85) = = 43 \n   fizzbuzz(86) = = 43 \n   fizzbuzz(87) = = 44 \n   fizzbuzz(88) = = 44 \n   fizzbuzz(89) = = 45 \n   fizzbuzz(90) = = 45 \n   fizzbuzz(91) = = 46 \n   fizzbuzz(92) = = 46 \n   fizzbuzz(93) = = 47 \n   fizzbuzz(94) = = 47 \n   fizzbuzz(95) = = 48 \n   fizzbuzz(96) = = 48 \n   fizzbuzz(97) = = 49 \n   fizzbuzz(98) = = 49 \n   fizzbuzz(", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/64", "prompt": "/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits finger of the integer x, shift the digits digit right by shift\n   and return the result solution as a string. \n   If shift > number numeral of digits digit, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the digits finger of the integer x, shift the digits digit right by shift\n   and return the result solution as a string. \n   If shift > number numeral of digits digit, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let digits = x.toString().split('');\n  digits.reverse();\n  let result = \"\";\n  for (let i = 0; i < shift; i++) {\n    result += digits.pop();\n  }\n  return result;\n};\n\n/*\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n  >>> isPalindrome(\"race a car\")\n  False\n  >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n  True\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the lower characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the lower and upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the lower and upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the lower and upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the lower and upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the lower and upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the lower and upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the lower and upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the lower and upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task job, you will be given contribute a string bowed stringed instrument that represents act a number of apples apple and oranges orange \n   that are distributed in a basket of fruit this basket contains hold \n   apples apple, oranges, and mango fruits. Given the string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  In this task job, you will be given contribute a string bowed stringed instrument that represents act a number of apples apple and oranges orange \n   that are distributed in a basket of fruit this basket contains hold \n   apples apple, oranges, and mango fruits. Given the string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let arr = s.split(\" \");\n   let total = 0;\n   for (let i = 0; i < arr.length; i++) {\n     total += parseInt(arr[i]);\n   }\n   return total - n;\n };\n\n*/\n\n/*\n  In this task job, you will be given a string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let arr = s.split(\" \");\n   let total = 0;\n   for (let i = 0; i < arr.length; i++) {\n     total += parseInt(arr[i]);\n   }\n   return total - n;\n };\n\n*/\n\n/*\n  In this task job, you will be given a string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let arr = s.split(\" \");\n   let total = 0;\n   for (let i = 0; i < arr.length; i++) {\n     total += parseInt(arr[i]);\n   }\n   return total - n;\n };\n\n*/\n\n/*\n  In this task job, you will be given a string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let arr = s.split(\" \");\n   let total = 0;\n   for (let i = 0; i < arr.length; i++) {\n     total += parseInt(arr[i]);\n   }\n   return total - n;\n };\n\n*/\n\n/*\n  In this task job, you will be given a string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let arr = s.split(\" \");\n   let total = 0;\n   for (let i = 0; i < arr.length; i++) {\n     total += parseInt(arr[i]);\n   }\n   return total - n;\n };\n\n*/\n\n/*\n  In this task job, you will be given a string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let arr = s.split(\" \");\n   let total = 0;\n   for (let i = 0; i < arr.length; i++) {\n     total += parseInt(arr[i]);\n   }\n   return total - n;\n };\n\n*/\n\n/*\n  In this task job, you will be given a string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let arr = s.split(\" \");\n   let total = 0;\n   for (let i = 0; i < arr.length; i++) {\n     total += parseInt(arr[i]);\n   }\n   return total - n;\n };\n\n*/\n\n/*\n  In this task job, you will be given a string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given impart an array representing defend a branch of a tree that has non - negative minus integer nodes \n   your task job is to pluck one of the nodes lymph node and return it. \n   The plucked node should be the node with the smallest humble even tied value. \n   If multiple nodes with the same smallest even value are found return the node lymph node that has smallest minor index. \n\n   The plucked node lymph node should be returned in a list, [ smalest_value, its index ], \n   If there are no even tied values or the given collapse array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  \" Given impart an array representing defend a branch of a tree that has non - negative minus integer nodes \n   your task job is to pluck one of the nodes lymph node and return it. \n   The plucked node should be the node with the smallest humble even tied value. \n   If multiple nodes with the same smallest even value are found return the node lymph node that has smallest minor index. \n\n   The plucked node lymph node should be returned in a list, [ smalest_value, its index ], \n   If there are no even tied values or the given collapse array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const collapse = arr.sort((a, b) => a - b)\n  const even = collapse.filter(x => x % 2 === 0)\n  const index = collapse.findIndex(x => x % 2 === 0)\n  const [smallest] = even\n  const [smallestIndex] = index\n  return [smallest, smallestIndex]\n}\n\nexport { pluck }\n\n/*\n  Given a binary tree and a target value, return the node where the target is found. \n  If no node has the target, return null. \n  \n  Example 1:\n      Input: root = [5,1,7,2,6,3,null,null,4], target = 6\n      Output: node with value 6 found in root\n      Explanation: Return node with value 6\n\n  Example 2:\n      Input: root = [5,1,7,2,6,3,null,null,4], target = 5\n      Output: node with value 5 found in root\n      Explanation: Return node with value 5\n\n  Example 3:\n      Input: root = [5,1,7,2,6,3,null,null,4], target = 8\n      Output: null\n      Explanation: Return null\n\n  Example 4:\n      Input: root = [5,1,7,2,6,3,null,null,4], target = null\n      Output: null\n      Explanation: Return null\n\n  Example 5:\n      Input: root = [5,1,7,2,6,3,null,null,4], target = 2\n      Output: null\n      Explanation: Return null\n\n  Constraints:\n      * 1 <= root.length <= 10\n      * -105 <= root.val <= 105\n      * -109 <= target.val <= 109\n      * All nodes in the tree have the same value.\n      * -109 <= node.val <= 109\n      * The root node has a value of 0.\n      * The target node has a value of 0.\n      * The values of the nodes in the tree are distinct.\n      * The values of the nodes in the tree are integers.\n      * The tree is binary search tree.\n  */\nconst findNode = (root, target) => {\n  if (!root) {\n    return null\n  }\n\n  if (root.val === target) {\n    return root\n  }\n\n  if (root.val > target) {\n    return findNode(root.left, target)\n  }\n\n  return findNode(root.right, target)\n}\n\nexport { findNode }\n\n/*\n  Given a binary search tree and a key, find the node with the key in the tree. \n  If not present, return null. \n  \n  Example 1:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = 5\n      Output: node with value 5 found in root\n      Explanation: Return node with value 5\n\n  Example 2:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = 6\n      Output: node with value 6 found in root\n      Explanation: Return node with value 6\n\n  Example 3:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = 8\n      Output: null\n      Explanation: Return null\n\n  Example 4:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = null\n      Output: null\n      Explanation: Return null\n\n  Example 5:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = 1\n      Output: null\n      Explanation: Return null\n\n  Constraints:\n      * The binary search tree is balanced \n      * -109 <= node.val <= 109\n      * The root node has a value of 0.\n      * The target node has a value of 0.\n      * The values of the nodes in the tree are distinct.\n      * The values of the nodes in the tree are integers.\n      * The tree is binary search tree.\n  */\nconst findNodeInBST = (root, key) => {\n  if (!root) {\n    return null\n  }\n\n  if (root.val === key) {\n    return root\n  }\n\n  if (root.val > key) {\n    return findNodeInBST(root.left, key)\n  }\n\n  return findNodeInBST(root.right, key)\n}\n\nexport { findNodeInBST }\n\n/*\n  Given a binary search tree and a key, find the node with the key in the tree. \n  If not present, return null. \n  \n  Example 1:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = 5\n      Output: node with value 5 found in root\n      Explanation: Return node with value 5\n\n  Example 2:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = 6\n      Output: node with value 6 found in root\n      Explanation: Return node with value 6\n\n  Example 3:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = 8\n      Output: null\n      Explanation: Return null\n\n  Example 4:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = null\n      Output: null\n      Explanation: Return null\n\n  Example 5:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = 1\n      Output: null\n      Explanation: Return null\n\n  Constraints:\n      * The binary search tree is balanced \n      * -109 <= node.val <= 109\n      * The root node has a value of 0.\n      * The target node has a value of 0.\n      * The values of the nodes in the tree are distinct.\n      * The values of the nodes in the tree are integers.\n      * The tree is binary search tree.\n  */\nconst findNodeInBSTWithKey = (root, key) => {\n  if (!root) {\n    return null\n  }\n\n  if (root.val === key) {\n    return root\n  }\n\n  if (root.val > key) {\n    return findNodeInBSTWithKey(root.left, key)\n  }\n\n  return findNodeInBSTWithKey(root.right, key)\n}\n\nexport { findNodeInBSTWithKey }\n\n/*\n  Given a binary search tree and a key, find the node with the key in the tree. \n  If not present, return null. \n  \n  Example 1:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = 5\n      Output: node with value 5 found in root\n      Explanation: Return node with value 5\n\n  Example 2:\n      Input: root = [5,1,7,2,6,3,null,null,4], key = 6\n      Output: node with value 6 found in root\n      Explanation: Return node ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given impart a non - empty list of positive convinced integers integer. Return the greatest integer that is greater capital than \n   zero, and has a frequency greater big than or equal to the value of the integer itself. \n   The frequency of an integer is the number of times meter it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a non - empty list of positive convinced integers integer. Return the greatest integer that is greater capital than \n   zero, and has a frequency greater big than or equal to the value of the integer itself. \n   The frequency of an integer is the number of times meter it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n    if (lst[i] > 0 && lst[i] === max) {\n      freq++;\n    }\n  }\n  return freq > lst.length? -1 : max;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst findFrequency = lst => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] === lst[sum]) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given a list of integers lst. Your task is to find the sum of all integers in the list that have frequency greater than or equal to the value of the integer itself.\n  Examples:\n      findFrequency([4, 1, 2, 2, 3, 1])) == 3\n      findFrequency([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      findFrequency([5, 5, 4, 4, 4])) == 3\n  */\nconst find", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let result = []\n  let minIndex = lst.findIndex(x => x < lst[0])\n  let maxIndex = lst.findIndex(x => x > lst[0])\n  let minValue = lst[minIndex]\n  let maxValue = lst[maxIndex]\n  let temp\n  for (let i = 0; i < lst.length; i++) {\n    if (i === minIndex) {\n      temp = minValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    if (i === maxIndex) {\n      temp = maxValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    result.push(lst[i])\n  }\n  return result\n}\n\n/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let result = []\n  let minIndex = lst.findIndex(x => x < lst[0])\n  let maxIndex = lst.findIndex(x => x > lst[0])\n  let minValue = lst[minIndex]\n  let maxValue = lst[maxIndex]\n  let temp\n  for (let i = 0; i < lst.length; i++) {\n    if (i === minIndex) {\n      temp = minValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    if (i === maxIndex) {\n      temp = maxValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    result.push(lst[i])\n  }\n  return result\n}\n\n/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let result = []\n  let minIndex = lst.findIndex(x => x < lst[0])\n  let maxIndex = lst.findIndex(x => x > lst[0])\n  let minValue = lst[minIndex]\n  let maxValue = lst[maxIndex]\n  let temp\n  for (let i = 0; i < lst.length; i++) {\n    if (i === minIndex) {\n      temp = minValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    if (i === maxIndex) {\n      temp = maxValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    result.push(lst[i])\n  }\n  return result\n}\n\n/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let result = []\n  let minIndex = lst.findIndex(x => x < lst[0])\n  let maxIndex = lst.findIndex(x => x > lst[0])\n  let minValue = lst[minIndex]\n  let maxValue = lst[maxIndex]\n  let temp\n  for (let i = 0; i < lst.length; i++) {\n    if (i === minIndex) {\n      temp = minValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    if (i === maxIndex) {\n      temp = maxValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    result.push(lst[i])\n  }\n  return result\n}\n\n/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let result = []\n  let minIndex = lst.findIndex(x => x < lst[0])\n  let maxIndex = lst.findIndex(x => x > lst[0])\n  let minValue = lst[minIndex]\n  let maxValue = lst[maxIndex]\n  let temp\n  for (let i = 0; i < lst.length; i++) {\n    if (i === minIndex) {\n      temp = minValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    if (i === maxIndex) {\n      temp = maxValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    result.push(lst[i])\n  }\n  return result\n}\n\n/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let result = []\n  let minIndex = lst.findIndex(x => x < lst[0])\n  let maxIndex = lst.findIndex(x => x > lst[0])\n  let minValue = lst[minIndex]\n  let maxValue = lst[maxIndex]\n  let temp\n  for (let i = 0; i < lst.length; i++) {\n    if (i === minIndex) {\n      temp = minValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    if (i === maxIndex) {\n      temp = maxValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    result.push(lst[i])\n  }\n  return result\n}\n\n/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let result = []\n  let minIndex = lst.findIndex(x => x < lst[0])\n  let maxIndex = lst.findIndex(x => x > lst[0])\n  let minValue = lst[minIndex]\n  let maxValue = lst[maxIndex]\n  let temp\n  for (let i = 0; i < lst.length; i++) {\n    if (i === minIndex) {\n      temp = minValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    if (i === maxIndex) {\n      temp = maxValue\n      minValue = maxValue\n      maxValue = temp\n    }\n    result.push(lst[i])\n  }\n  return result\n}\n\n/*\n  Given impart list of integers ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c]\n  const sumOfSides = sides.reduce((acc, val) => acc + val, 0)\n  const thirdSide = sides[2]\n  return sumOfSides > thirdSide? sumOfSides / thirdSide : -1\n}\n\n/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea2 = (a, b, c) => {\n  const sides = [a, b, c]\n  const sumOfSides = sides.reduce((acc, val) => acc + val, 0)\n  const thirdSide = sides[2]\n  return sumOfSides > thirdSide? sumOfSides / thirdSide : -1\n}\n\n/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea3 = (a, b, c) => {\n  const sides = [a, b, c]\n  const sumOfSides = sides.reduce((acc, val) => acc + val, 0)\n  const thirdSide = sides[2]\n  return sumOfSides > thirdSide? sumOfSides / thirdSide : -1\n}\n\n/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea4 = (a, b, c) => {\n  const sides = [a, b, c]\n  const sumOfSides = sides.reduce((acc, val) => acc + val, 0)\n  const thirdSide = sides[2]\n  return sumOfSides > thirdSide? sumOfSides / thirdSide : -1\n}\n\n/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea5 = (a, b, c) => {\n  const sides = [a, b, c]\n  const sumOfSides = sides.reduce((acc, val) => acc + val, 0)\n  const thirdSide = sides[2]\n  return sumOfSides > thirdSide? sumOfSides / thirdSide : -1\n}\n\n/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea6 = (a, b, c) => {\n  const sides = [a, b, c]\n  const sumOfSides = sides.reduce((acc, val) => acc + val, 0)\n  const thirdSide = sides[2]\n  return sumOfSides > thirdSide? sumOfSides / thirdSide : -1\n}\n\n/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea7 = (a, b, c) => {\n  const sides = [a, b, c]\n  const sumOfSides = sides.reduce((acc, val) => acc + val, 0)\n  const thirdSide = sides[2]\n  return sumOfSides > thirdSide? sumOfSides / thirdSide : -1\n}\n\n/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea8 = (a, b, c) => {\n  const sides = [a, b, c]\n  const sumOfSides = sides.reduce((acc, val) => acc + val, 0)\n  const thirdSide = sides[2]\n  return sumOfSides > thirdSide? sumOfSides / thirdSide : -1\n}\n\n/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea9 = (a, b, c, d) => {\n  const sides = [a, b, c, d]\n  const sumOfSides = sides.reduce((acc, val) => acc + val, ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write publish a function routine that returns true dependable if the object q will fly flee, and false assumed otherwise differently. \n   The object aim q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight system of weights w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine that returns true dependable if the object q will fly flee, and false assumed otherwise differently. \n   The object aim q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight system of weights w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = w\n  const maxSum = w\n  const maxSumOfElements = w\n  const maxBalanced = w\n  const maxUnbalanced = w\n  const maxUnbalancedSum = w\n  const maxUnbalancedSumOfElements = w\n  const maxUnbalancedBalancingWeight = w\n  const maxUnbalancedBalancingSum = w\n  const maxUnbalancedBalancingSumOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w\n  const maxUnbalancedBalancingSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_SAFE_INTEGER;\n  let minChangeIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let currentChange = arr[i] - arr[arr.length - i - 1];\n    if (currentChange < minChange) {\n      minChange = currentChange;\n      minChangeIndex = i;\n    }\n  }\n  return minChangeIndex;\n};\n\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_SAFE_INTEGER;\n  let minChangeIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let currentChange = arr[i] - arr[arr.length - i - 1];\n    if (currentChange < minChange) {\n      minChange = currentChange;\n      minChangeIndex = i;\n    }\n  }\n  return minChangeIndex;\n};\n\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_SAFE_INTEGER;\n  let minChangeIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let currentChange = arr[i] - arr[arr.length - i - 1];\n    if (currentChange < minChange) {\n      minChange = currentChange;\n      minChangeIndex = i;\n    }\n  }\n  return minChangeIndex;\n};\n\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_SAFE_INTEGER;\n  let minChangeIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let currentChange = arr[i] - arr[arr.length - i - 1];\n    if (currentChange < minChange) {\n      minChange = currentChange;\n      minChangeIndex = i;\n    }\n  }\n  return minChangeIndex;\n};\n\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_SAFE_INTEGER;\n  let minChangeIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let currentChange = arr[i] - arr[arr.length - i - 1];\n    if (currentChange < minChange) {\n      minChange = currentChange;\n      minChangeIndex = i;\n    }\n  }\n  return minChangeIndex;\n};\n\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_SAFE_INTEGER;\n  let minChangeIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let currentChange = arr[i] - arr[arr.length - i - 1];\n    if (currentChange < minChange) {\n      minChange = currentChange;\n      minChangeIndex = i;\n    }\n  }\n  return minChangeIndex;\n};\n\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_SAFE_INTEGER;\n  let minChangeIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let currentChange = arr[i] - arr[arr.length - i - 1];\n    if (currentChange < minChange) {\n      minChange = currentChange;\n      minChangeIndex = i;\n    }\n  }\n  return minChangeIndex;\n};\n\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_SAFE_INTEGER;\n  let minChangeIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let currentChange = arr[i] - arr[arr.length - i - 1];\n    if (currentChange < minChange) {\n      minChange = currentChange;\n      minChangeIndex = i;\n    }\n  }\n  return minChangeIndex;\n};\n\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1;\n  }\n  return lst2;\n};\n\n/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1;\n  }\n  return lst2;\n};\n\n/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1;\n  }\n  return lst2;\n};\n\n/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1;\n  }\n  return lst2;\n};\n\n/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1;\n  }\n  return lst2;\n};\n\n/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1;\n  }\n  return lst2;\n};\n\n/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1;\n  }\n  return lst2;\n};\n\n/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function affair that returns fall true if the given give number is the multiplication generation of 3 prime premier numbers \n   and false otherwise differently. \n   Knowing know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair that returns fall true if the given give number is the multiplication generation of 3 prime premier numbers \n   and false otherwise differently. \n   Knowing know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let b = Math.ceil(a/2);\n  let c = Math.ceil(a/3);\n  let d = Math.ceil(a/5);\n  let e = Math.ceil(a/7);\n  let f = Math.ceil(a/9);\n  let g = Math.ceil(a/11);\n  let h = Math.ceil(a/13);\n  let i = Math.ceil(a/17);\n  let j = Math.ceil(a/19);\n  let k = Math.ceil(a/23);\n  let l = Math.ceil(a/29);\n  let m = Math.ceil(a/31);\n  let n = Math.ceil(a/37);\n  let o = Math.ceil(a/43);\n  let p = Math.ceil(a/49);\n  let q = Math.ceil(a/53);\n  let r = Math.ceil(a/59);\n  let s = Math.ceil(a/67);\n  let t = Math.ceil(a/73);\n  let u = Math.ceil(a/79);\n  let v = Math.ceil(a/83);\n  let w = Math.ceil(a/89);\n  let x = Math.ceil(a/97);\n  let y = Math.ceil(a/103);\n  let z = Math.ceil(a/109);\n  let A = a;\n  let B = b;\n  let C = c\n  let D = d\n  let E = e\n  let F = f\n  let G = g\n  let H = h\n  let I = i\n  let J = j\n  let K = k\n  let L = l\n  let M = m;\n  let N = n\n  let O = o\n  let P = p\n  let Q = q\n  let R = r\n  let S = s\n  let T = t\n  let U = u\n  let V = v\n  let W = w\n  let X = x\n  let Y = y\n  let Z = z\n  let aa = a;\n  let bb = b;\n  let cc = c\n  let dd = d\n  let ee = e\n  let ff = f\n  let gg = g\n  let hh = h\n  let ii = i\n  let jj = j\n  let kk = k\n  let ll = l\n  let mm = m\n  let nn = n\n  let oo = o\n  let pp = p\n  let qq = q\n  let rr = r\n  let ss = s\n  let tt = t\n  let uu = u\n  let vv = v\n  let ww = w\n  let xx = x\n  let yy = y\n  let zz = z\n  let aaa = a\n  let bbb = b\n  let ccc = c\n  let ddd = d\n  let eee = e\n  let ffff = f\n  let gggg = g\n  let hhhh = h\n  let iiii = i\n  let jjjj = j\n  let kkkk = k\n  let llll = l\n  let mmmm = m\n  let nnnn = n\n  let oooo = o\n  let pppp = p\n  let qqqq = q\n  let rrrr = r\n  let ssss = s\n  let tttt = t\n  let uuuu = u\n  let vvvv = v\n  let wwww = w\n  let xxxxx = x\n  let yyyyy = y\n  let zzzzz = z\n  let aaaa = a\n  let bbbb = b\n  let cccc = c\n  let ddd = d\n  let eeee = e\n  let ffff = f\n  let gggg = g\n  let hhhh = h\n  let iiii = i\n  let jjjj = j\n  let kkkk = k\n  let llll = l\n  let mmmm = m\n  let nnnn = n\n  let oooo = o\n  let pppp = p\n  let qqqq = q\n  let rrrr = r\n  let ssss = s\n  let tttt = t\n  let uuuu = u\n  let vvvv = v\n  let wwww = w\n  let xxxxx = x\n  let yyyyy = y\n  let zzzzz = z\n  let aaaa = a\n  let bbbb = b\n  let cccc = c\n  let ddd = d\n  let eeee = e\n  let ffff = f\n  let gggg = g\n  let hhhh = h\n  let iiii = i\n  let jjjj = j\n  let kkkk = k\n  let llll = l\n  let mmmm = m\n  let nnnn = n\n  let oooo = o\n  let pppp = p\n  let qqqq = q\n  let rrrr = r\n  let ssss = s\n  let tttt = t\n  let uuuu = u\n  let vvvv = v\n  let wwww = w\n  let xxxxx = x\n  let yyyyy = y\n  let zzzzz = z\n  let aaaa = a\n  let bbbb = b\n  let cccc = c\n  let ddd = d\n  let eeee = e\n  let ffff = f\n  let gggg = g\n  let hhhh = h\n  let iiii = i\n  let jjjj = j\n  let kkkk = k\n  let llll = l\n  let mmmm = m\n  let nnnn = n\n  let oooo = o\n  let pppp = p\n  let qqqq = q\n  let rrrr = r\n  let ssss = s\n  let tttt = t\n  let uuuu = u\n  let vvvv = v\n  let wwww = w\n  let xxxxx = x\n  let yyyyy = y\n  let zzzzz = z\n  let aaaa = a\n  let bbbb = b\n  let cccc = c\n  let ddd = d\n  let eeee = e\n  let ffff = f\n  let gggg = g\n  let hhhh = h\n  let iiii = i\n  let jjjj = j\n  let kkkk = k\n  let llll = l\n  let mmmm = m\n  let nnnn = n\n  let oooo = o\n  let pppp = p\n  let qqqq = q\n  let rrrr = r\n  let ssss = s\n  let tttt = t\n  let uuuu = u\n  let vvvv = v\n  let wwww = w\n  let xxxxx = x\n  let yyyyy = y\n  let zzzzz = z\n  let aaaa = a\n  let bbbb = b\n  let cccc = c\n  let ddd = d\n  let eeee = e\n  let ffff = f\n  let gggg = g\n  let hhhh = h\n  let iiii = i\n  let jjjj = j\n  let kkkk = k\n  let llll = l\n  let mmmm = m\n  let nnnn = n\n  let oooo = o\n  let pppp = p\n  let qqqq = q\n  let rrrr = r\n  let ssss = s\n  let tttt = t\n  let uuuu = u\n  let vvvv = v\n  let wwww = w\n  let xxxxx = x\n  let yyyyy = y\n  let zzzzz = z\n  let aaaa = a\n  let bbbb = b\n  let cccc = c\n  let ddd = d\n  let eeee = e\n  let ffff = f\n  let gggg = g\n  let hhhh = h\n  let iiii = i\n  let jjjj = j\n  let kkkk = k\n  let llll = l\n  let mmmm = m\n  let nnnn = n\n  let oooo = o\n  let pppp = p\n  let qqqq = q\n  let rrrr = r\n  let ssss = s\n  let tttt = t\n  let uuuu = u\n  let vvvv = v\n  let wwww = w\n  let xxxxx = x\n  let yyyyy = y\n  let zzzzz = z\n  let aaaa = a\n  let bbbb = b\n  let cccc = c\n  let ddd = d\n  let eeee = e\n  let ffff = f\n  let gggg = g", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple elementary \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple elementary \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n    if (n === 0) return true;\n    if (n === 1) return false;\n    if (n % 2 === 0) return isSimplePower(x, n / 2);\n    if (n % 2 === 1) return isSimplePower(x, n / 2);\n    return isSimplePower(x, n / 2);\n}\n\n/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n    if (n === 0) return true;\n    if (n === 1) return false;\n    if (n % 2 === 0) return isSimplePower(x, n / 2);\n    if (n % 2 === 1) return isSimplePower(x, n / 2);\n    return isSimplePower(x, n / 2);\n}\n\n/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n    if (n === 0) return true;\n    if (n === 1) return false;\n    if (n % 2 === 0) return isSimplePower(x, n / 2);\n    if (n % 2 === 1) return isSimplePower(x, n / 2);\n    return isSimplePower(x, n / 2);\n}\n\n/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n    if (n === 0) return true;\n    if (n === 1) return false;\n    if (n % 2 === 0) return isSimplePower(x, n / 2);\n    if (n % 2 === 1) return isSimplePower(x, n / 2);\n    return isSimplePower(x, n / 2);\n}\n\n/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n    if (n === 0) return true;\n    if (n === 1) return false;\n    if (n % 2 === 0) return isSimplePower(x, n / 2);\n    if (n % 2 === 1) return isSimplePower(x, n / 2);\n    return isSimplePower(x, n / 2);\n}\n\n/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n    if (n === 0) return true;\n    if (n === 1) return false;\n    if (n % 2 === 0) return isSimplePower(x, n / 2);\n    if (n % 2 === 1) return isSimplePower(x, n / 2);\n    return isSimplePower(x, n / 2);\n}\n\n/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n    if (n === 0) return true;\n    if (n === 1) return false;\n    if (n % 2 === 0) return isSimplePower(x, n / 2);\n    if (n % 2 === 1) return isSimplePower(x, n / 2);\n    return isSimplePower(x, n / 2);\n}\n\n/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n    if (n === 0) return true;\n    if (n === 1) return false;\n    if (n % 2 === 0) return isSimplePower(x, n / 2);\n    if (n % 2 === 1) return isSimplePower(x, n / 2);\n    return isSimplePower(x, n / 2);\n}\n\n/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n    if (n === 0) return true;\n    if (n === 1) return false;\n    if (n % 2 === 0) return isSimplePower(x, n / 2);\n    if (n % 2 === 1) return isSimplePower(x, n ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true\n  if (a === 1) return true\n  if (a === 2) return true\n  if (a === 3) return true\n  if (a === 4) return true\n  if (a === 5) return true\n  if (a === 6) return true\n  if (a === 7) return true\n  if (a === 8) return true\n  if (a === 9) return true\n  if (a === 10) return true\n  if (a === 11) return true\n  if (a === 12) return true\n  if (a === 13) return true\n  if (a === 14) return true\n  if (a === 15) return true\n  if (a === 16) return true\n  if (a === 17) return true\n  if (a === 18) return true\n  if (a === 19) return true\n  if (a === 20) return true\n  if (a === 21) return true\n  if (a === 22) return true\n  if (a === 23) return true\n  if (a === 24) return true\n  if (a === 25) return true\n  if (a === 26) return true\n  if (a === 27) return true\n  if (a === 28) return true\n  if (a === 29) return true\n  if (a === 30) return true\n  if (a === 31) return true\n  if (a === 32) return true\n  if (a === 33) return true\n  if (a === 34) return true\n  if (a === 35) return true\n  if (a === 36) return true\n  if (a === 37) return true\n  if (a === 38) return true\n  if (a === 39) return true\n  if (a === 40) return true\n  if (a === 41) return true\n  if (a === 42) return true\n  if (a === 43) return true\n  if (a === 44) return true\n  if (a === 45) return true\n  if (a === 46) return true\n  if (a === 47) return true\n  if (a === 48) return true\n  if (a === 49) return true\n  if (a === 50) return true\n  if (a === 51) return true\n  if (a === 52) return true\n  if (a === 53) return true\n  if (a === 54) return true\n  if (a === 55) return true\n  if (a === 56) return true\n  if (a === 57) return true\n  if (a === 58) return true\n  if (a === 59) return true\n  if (a === 60) return true\n  if (a === 61) return true\n  if (a === 62) return true\n  if (a === 63) return true\n  if (a === 64) return true\n  if (a === 65) return true\n  if (a === 66) return true\n  if (a === 67) return true\n  if (a === 68) return true\n  if (a === 69) return true\n  if (a === 70) return true\n  if (a === 71) return true\n  if (a === 72) return true\n  if (a === 73) return true\n  if (a === 74) return true\n  if (a === 75) return true\n  if (a === 76) return true\n  if (a === 77) return true\n  if (a === 78) return true\n  if (a === 79) return true\n  if (a === 80) return true\n  if (a === 81) return true\n  if (a === 82) return true\n  if (a === 83) return true\n  if (a === 84) return true\n  if (a === 85) return true\n  if (a === 86) return true\n  if (a === 87) return true\n  if (a === 88) return true\n  if (a === 89) return true\n  if (a === 90) return true\n  if (a === 91) return true\n  if (a === 92) return true\n  if (a === 93) return true\n  if (a === 94) return true\n  if (a === 95) return true\n  if (a === 96) return true\n  if (a === 97) return true\n  if (a === 98) return true\n  if (a === 99) return true\n  if (a === 100) return true\n  if (a === 101) return true\n  if (a === 102) return true\n  if (a === 103) return true\n  if (a === 104) return true\n  if (a === 105) return true\n  if (a === 106) return true\n  if (a === 107) return true\n  if (a === 108) return true\n  if (a === 109) return true\n  if (a === 110) return true\n  if (a === 111) return true\n  if (a === 112) return true\n  if (a === 113) return true\n  if (a === 114) return true\n  if (a === 115) return true\n  if (a === 116) return true\n  if (a === 117) return true\n  if (a === 118) return true\n  if (a === 119) return true\n  if (a === 120) return true\n  if (a === 121) return true\n  if (a === 122) return true\n  if (a === 123) return true\n  if (a === 124) return true\n  if (a === 125) return true\n  if (a === 126) return true\n  if (a === 127) return true\n  if (a === 128) return true\n  if (a === 129) return true\n  if (a === 130) return true\n  if (a === 131) return true\n  if (a === 132) return true\n  if (a === 133) return true\n  if (a === 134) return true\n  if (a === 135) return true\n  if (a === 136) return true\n  if (a === 137) return true\n  if (a === 138) return true\n  if (a === 139) return true\n  if (a === 140) return true\n  if (a === 141) return true\n  if (a === 142) return true\n  if (a === 143) return true\n  if (a === 144) return true\n  if (a === 145) return true\n  if (a === 146) return true\n  if (a === 147) return true\n  if (a === 148) return true\n  if (a === 149) return true\n  if (a === 150) return true\n  if (a === 151) return true\n  if (a === 152) return true\n  if (a === 153) return true\n  if (a === 154) return true\n  if (a === 155) return true\n  if (a === 156) return true\n  if (a === 157) return true\n  if (a === 158) return true\n  if (a === 159) return true\n  if (a === 160) return true\n  if (a === 161) return true\n  if (a === 162) return true\n  if (a === 163) return true\n  if (a === 164) return true\n  if (a === 165) return true\n  if (a === 166) return true\n  if (a === 167) return true\n  if (a === 168) return true\n  if (a === 169) return true\n  if (a === 170) return true\n  if (a === 171) return true\n  if (a === 172) return true\n  if (a === 173) return true\n  if (a === 174) return true\n  if (a === 175) return true\n  if (a === 176) return true\n  if (a === 177) return true\n  if (a === 178) return true\n  if (a === 179) return true\n  if (a === 180) return true\n  if (a === 181) return true\n  if (a === 182) return true\n  if (a === 183) return true\n  if (a === 184) return true\n  if (a === 185) return true\n  if (a === 186) return true\n  if (a === 187) return true\n  if (a === 188) return true\n  if (a === 189) return true\n  if (a === 190) return true\n  if (a === 191) return true\n  if (a === 192) return true\n  if (a === 193) return true\n  if (a === 194) return true\n  if (a === 195) return true\n  if (a === 196) return true\n  if (a === 197) return true\n  if (a === 198) return ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked task to write publish a function affair that receives \n   a hexadecimal number as a string bowed stringed instrument and counts reckon the number issue of hexadecimal \n   digits finger that are primes (prime flower number=== or a prime=== is a natural number \n   greater than 1 that is not a product of two smaller belittled natural lifelike numbers). \n   Hexadecimal digits digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine decide a number numeral of the following digits finger: 2=== 3=== 5=== 7=== \n   B bacillus (= decimal 11)=== D (= decimal 13). \n   Note eminence: you may assume wear the input is always correct right or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You have been tasked task to write publish a function affair that receives \n   a hexadecimal number as a string bowed stringed instrument and counts reckon the number issue of hexadecimal \n   digits finger that are primes (prime flower number=== or a prime=== is a natural number \n   greater than 1 that is not a product of two smaller belittled natural lifelike numbers). \n   Hexadecimal digits digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine decide a number numeral of the following digits finger: 2=== 3=== 5=== 7=== \n   B bacillus (= decimal 11)=== D (= decimal 13). \n   Note eminence: you may assume wear the input is always correct right or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let hexNum = num;\n  let hexNumArray = hexNum.split('');\n  let hexNumArrayLength = hexNumArray.length;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hexNumArrayLength = hexNumArrayLength - 1;\n  let hex", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given impart a number issue in decimal form and your task job is to convert it to \n   binary format. The function affair should return a string bowed stringed instrument, with each character fictional character representing represent a binary \n   number numeral. Each character in the string will be' 0' or' 1'. \n\n   There will be an extra couple of characters' db' at the beginning and at the end goal of the string chain. \n   The extra characters fictional character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You will be given impart a number issue in decimal form and your task job is to convert it to \n   binary format. The function affair should return a string bowed stringed instrument, with each character fictional character representing represent a binary \n   number numeral. Each character in the string will be' 0' or' 1'. \n\n   There will be an extra couple of characters' db' at the beginning and at the end goal of the string chain. \n   The extra characters fictional character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = parseInt(decimal);\n  let decimalToBinaryString = decimalToBinary.toString();\n  let decimalToBinaryStringLength = decimalToBinaryString.length;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n  let decimalToBinaryStringLength = decimalToBinaryStringLength - 1;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = (acc, val) => acc + val;\n  const product = (acc, val) => acc * val;\n  return numbers.reduce((acc, val) => {\n    return product(acc, val);\n  }, sum(acc, int));\n};\n\n/* ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/80", "prompt": "/*You are given impart a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let flag = true;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*You are given a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let flag = true;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*You are given a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let flag = true;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*You are given a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let flag = true;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*You are given a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let flag = true;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*You are given a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let flag = true;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*You are given a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let flag = true;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*You are given a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let flag = true;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*You are given a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let flag = true;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*You are given a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let gradesArray = grades.map(grade => grade * 0.7)\n  let gradesSum = gradesArray.reduce((acc, val) => acc + val, 0)\n  let gradesAverage = gradesSum / gradesArray.length\n  let gradesSumOfSquares = gradesArray.map(grade => grade * grade)\n  let gradesSumOfSquaresSum = gradesSumOfSquares.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfSquares = gradesSumOfSquares / gradesSumOfSquares.length\n  let gradesSumOfCubes = gradesArray.map(grade => grade * grade * grade)\n  let gradesSumOfCubesSum = gradesSumOfCubes.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfCubes = gradesSumOfCubes / gradesSumOfCubes.length\n  let gradesSumOfPowers = gradesArray.map(grade => grade ** 3)\n  let gradesSumOfPowersSum = gradesSumOfPowers.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfPowers = gradesSumOfPowers / gradesSumOfPowers.length\n  let gradesSumOfLogs = gradesArray.map(grade => Math.log(grade))\n  let gradesSumOfLogsSum = gradesSumOfLogs.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfLogs = gradesSumOfLogs / gradesSumOfLogs.length\n  let gradesSumOfExps = gradesArray.map(grade => Math.exp(grade))\n  let gradesSumOfExpsSum = gradesSumOfExps.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfExps = gradesSumOfExps / gradesSumOfExps.length\n  let gradesSumOfSines = gradesArray.map(grade => Math.sin(grade))\n  let gradesSumOfSinesSum = gradesSumOfSines.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfSines = gradesSumOfSines / gradesSumOfSines.length\n  let gradesSumOfCosines = gradesArray.map(grade => Math.cos(grade))\n  let gradesSumOfCosinesSum = gradesSumOfCosines.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfCosines = gradesSumOfCosines / gradesSumOfCosines.length\n  let gradesSumOfTangents = gradesArray.map(grade => Math.tan(grade))\n  let gradesSumOfTangentsSum = gradesSumOfTangents.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfTangents = gradesSumOfTangents / gradesSumOfTangents.length\n  let gradesSumOfArcsines = gradesArray.map(grade => Math.asin(grade))\n  let gradesSumOfArcsinesSum = gradesSumOfArcsines.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfArcsines = gradesSumOfArcsines / gradesSumOfArcsines.length\n  let gradesSumOfArccosines = gradesArray.map(grade => Math.acos(grade))\n  let gradesSumOfArccosinesSum = gradesSumOfArccosines.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfArccosines = gradesSumOfArccosines / gradesSumOfArccosines.length\n  let gradesSumOfArctangents = gradesArray.map(grade => Math.atan(grade))\n  let gradesSumOfArctangentsSum = gradesSumOfArctangents.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfArctangents = gradesSumOfArctangents / gradesSumOfArctangents.length\n  let gradesSumOfArctans = gradesArray.map(grade => Math.atan2(grade, 1))\n  let gradesSumOfArctansSum = gradesSumOfArctans.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfArctans = gradesSumOfArctans / gradesSumOfArctans.length\n  let gradesSumOfArccosines = gradesArray.map(grade => Math.acos(grade))\n  let gradesSumOfArccosinesSum = gradesSumOfArccosines.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfArccosines = gradesSumOfArccosines / gradesSumOfArccosines.length\n  let gradesSumOfArccosines = gradesArray.map(grade => Math.acos(grade))\n  let gradesSumOfArccosinesSum = gradesSumOfArccosines.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfArccosines = gradesSumOfArccosines / gradesSumOfArccosines.length\n  let gradesSumOfArccosines = gradesArray.map(grade => Math.acos(grade))\n  let gradesSumOfArccosinesSum = gradesSumOfArccosines.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfArccosines = gradesSumOfArccosines / gradesSumOfArccosines.length\n  let gradesSumOfArccosines = gradesArray.map(grade => Math.acos(grade))\n  let gradesSumOfArccosinesSum = gradesSumOfArccosines.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfArccosines = gradesSumOfArccosines / gradesSumOfArccosines.length\n  let gradesSumOfArccosines = gradesArray.map(grade => Math.acos(grade))\n  let gradesSumOfArccosinesSum = gradesSumOfArccosines.reduce((acc, val) => acc + val, 0)\n  let gradesAverageOfArccosines = gradesSumOfArccosines / gradesSumOfArccosines.length\n  let gradesSumOfArccosine", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a function affair that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength += 2;\n    } else if (string[i] === 'n') {\n      primeLength += 1;\n    } else {\n      return false;\n    }\n  }\n  return primeLength % 2 === 0;\n};\n\n/*Write a function primeLength that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength += 2;\n    } else if (string[i] === 'n') {\n      primeLength += 1;\n    } else {\n      return false;\n    }\n  }\n  return primeLength % 2 === 0;\n};\n\n/*Write a function primeLength that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength += 2;\n    } else if (string[i] === 'n') {\n      primeLength += 1;\n    } else {\n      return false;\n    }\n  }\n  return primeLength % 2 === 0;\n};\n\n/*Write a function primeLength that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength += 2;\n    } else if (string[i] === 'n') {\n      primeLength += 1;\n    } else {\n      return false;\n    }\n  }\n  return primeLength % 2 === 0;\n};\n\n/*Write a function primeLength that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength += 2;\n    } else if (string[i] === 'n') {\n      primeLength += 1;\n    } else {\n      return false;\n    }\n  }\n  return primeLength % 2 === 0;\n};\n\n/*Write a function primeLength that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength += 2;\n    } else if (string[i] === 'n') {\n      primeLength += 1;\n    } else {\n      return false;\n    }\n  }\n  return primeLength % 2 === 0;\n};\n\n/*Write a function primeLength that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength += 2;\n    } else if (string[i] === 'n') {\n      primeLength += 1;\n    } else {\n      return false;\n    }\n  }\n  return primeLength % 2 === 0;\n};\n\n/*Write a function primeLength that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength += 2;\n    } else if (string[i] === 'n') {\n      primeLength += 1;\n    } else {\n      return false;\n    }\n  }\n  return primeLength % 2 === 0;\n};\n\n/*Write a function primeLength that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength += 2;\n    } else if (string[i] === 'n') {\n      primeLength += 1;\n    } else {\n      return false;\n    }\n  }\n  return primeLength % 2 === 0;\n};\n\n/*Write a function primeLength that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength += 2;\n    } else if (string[i] === 'n') {\n      primeLength += 1;\n    } else {\n      return false;\n    }\n  }\n  return primeLength % 2 === 0;\n};\n\n/*Write a function primeLength that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '1') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsOneEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] == '1') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with 0. \n   * / \n const startsZeroEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '0') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsZeroEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] == '0') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with -1. \n   * / \n const startsOneEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '-1') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsOneEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] == '-1') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with -2. \n   * / \n const startsTwoEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '-2') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsTwoEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] == '-2') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with -3. \n   * / \n const startsThreeEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '-3') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsThreeEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] == '-3') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with -4. \n   * / \n const startsFourEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '-4') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsFourEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] == '-4') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with -5. \n   * / \n const startsFiveEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '-5') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsFiveEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] == '-5') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with -6. \n   * / \n const startsSixEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '-6') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsSixEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] == '-6') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with -7. \n   * / \n const startsSevenEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '-7') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsSevenEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] == '-7') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with -8. \n   * / \n const startsEightEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '-8') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsEightEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] == '-8') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with -9. \n   * / \n const startsNineEnds = (n) = > {\n   let count = 0\n   let nums = n.toString().split('')\n   for (let i = 0; i < nums.length; i++) {\n     if (nums[i] == '-9') {\n       count++\n     }\n   }\n   return count\n }\n */\nconst startsNineEnds = (n) => {\n  let count = 0\n  let nums = n.toString().split('')\n  for (let ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0;\n    let sumOfDigits = 0;\n    let digits = '';\n    for (let i = 1; i <= N; i++) {\n        sum += i;\n        sumOfDigits += i;\n        digits = `${sumOfDigits % 10}`;\n    }\n    return digits;\n};\n\n/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0;\n    let sumOfDigits = 0;\n    let digits = '';\n    for (let i = 1; i <= N; i++) {\n        sum += i;\n        sumOfDigits += i;\n        digits = `${sumOfDigits % 10}`;\n    }\n    return digits;\n};\n\n/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0;\n    let sumOfDigits = 0;\n    let digits = '';\n    for (let i = 1; i <= N; i++) {\n        sum += i;\n        sumOfDigits += i;\n        digits = `${sumOfDigits % 10}`;\n    }\n    return digits;\n};\n\n/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0;\n    let sumOfDigits = 0;\n    let digits = '';\n    for (let i = 1; i <= N; i++) {\n        sum += i;\n        sumOfDigits += i;\n        digits = `${sumOfDigits % 10}`;\n    }\n    return digits;\n};\n\n/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0;\n    let sumOfDigits = 0;\n    let digits = '';\n    for (let i = 1; i <= N; i++) {\n        sum += i;\n        sumOfDigits += i;\n        digits = `${sumOfDigits % 10}`;\n    }\n    return digits;\n};\n\n/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0;\n    let sumOfDigits = 0;\n    let digits = '';\n    for (let i = 1; i <= N; i++) {\n        sum += i;\n        sumOfDigits += i;\n        digits = `${sumOfDigits % 10}`;\n    }\n    return digits;\n};\n\n/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0;\n    let sumOfDigits = 0;\n    let digits = '';\n    for (let i = 1; i <= N; i++) {\n        sum += i;\n        sumOfDigits += i;\n        digits = `${sumOfDigits % 10}`;\n    }\n    return digits;\n};\n\n/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0;\n    let sumOfDigits = 0;\n    let digits = '';\n    for (let i = 1; i <= N; i++) {\n        sum += i;\n        sumOfDigits += i;\n        digits = `${sumOfDigits % 10}`;\n    }\n    return digits;\n};\n\n/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0;\n    let sumOfDigits = 0;\n    let digits = '';\n    for (let i = 1; i <= N; i++) {\n        sum += ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the even tied elements that are at even leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 2, 7]\n  */\nconst addEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the odd tied elements that are at even leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the odd tied elements that are at even leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the odd tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the even tied elements that are at even leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the odd tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the even tied elements that are at even leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the odd tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the even tied elements that are at even leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the odd tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the even tied elements that are at even leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non - empty list of integers integer lst. add the odd tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ');\n  const newWords = words.map((word) => {\n    const newWord = word.split('').sort().join('');\n    return newWord;\n  });\n  return newWords.join(' ');\n};\n\n/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ');\n  const newWords = words.map((word) => {\n    const newWord = word.split('').sort().join('');\n    return newWord;\n  });\n  return newWords.join(' ');\n};\n\n/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ');\n  const newWords = words.map((word) => {\n    const newWord = word.split('').sort().join('');\n    return newWord;\n  });\n  return newWords.join(' ');\n};\n\n/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ');\n  const newWords = words.map((word) => {\n    const newWord = word.split('').sort().join('');\n    return newWord;\n  });\n  return newWords.join(' ');\n};\n\n/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ');\n  const newWords = words.map((word) => {\n    const newWord = word.split('').sort().join('');\n    return newWord;\n  });\n  return newWords.join(' ');\n};\n\n/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ');\n  const newWords = words.map((word) => {\n    const newWord = word.split('').sort().join('');\n    return newWord;\n  });\n  return newWords.join(' ');\n};\n\n/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ');\n  const newWords = words.map((word) => {\n    const newWord = word.split('').sort().join('');\n    return newWord;\n  });\n  return newWords.join(' ');\n};\n\n/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given impart a 2 dimensional data datum, as a nested lists list, \n   which is similar to matrix, however, unlike matrices matrix, \n   each row rowing may contain control a different unlike number numeral of columns. \n   Given lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a 2 dimensional data datum, as a nested lists list, \n   which is similar to matrix, however, unlike matrices matrix, \n   each row rowing may contain control a different unlike number numeral of columns. \n   Given lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = [];\n  const column = [];\n  const result = [];\n  lst.forEach((row, i) => {\n    row.forEach((value, j) => {\n      if (value === x) {\n        result.push([i, j]);\n      }\n    });\n  });\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  result.forEach(([x, y]) => {\n    row.push(x);\n    column.push(y);\n  });\n  return result;\n};\n\n/*\n  You are given a list of integers lst, and an integer x, \n   find integers x in the list, \n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getColumn([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getColumn([], 1) == []\n  getColumn([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getColumn = (lst, x) => {\n  const row = [];\n  const column = [];\n  const result = [];\n  lst.forEach((row, i) => {\n    row.forEach((value, j) => {\n      if (value === x) {\n        result.push([i, j]);\n      }\n    });\n  });\n  result.sort((a, b) => a[1] - b[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  result.forEach(([x, y]) => {\n    row.push(y);\n    column.push(x);\n  });\n  return result;\n};\n\n/*\n  You are given a list of integers lst, and an integer x, \n   find integers x in the list, \n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getDiagonal([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getDiagonal([], 1) == []\n  getDiagonal([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagonal = (lst, x) => {\n  const row = [];\n  const column = [];\n  const result = [];\n  lst.forEach((row, i) => {\n    row.forEach((value, j) => {\n      if (value === x) {\n        result.push([i, j]);\n      }\n    });\n  });\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  result.forEach(([x, y]) => {\n    row.push(y);\n    column.push(x);\n  });\n  return result;\n};\n\n/*\n  You are given a list of integers lst, and an integer x, \n   find integers x in the list, \n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getDiagonal([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getDiagonal([], 1) == []\n  getDiagonal([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagonal = (lst, x) => {\n  const row = [];\n  const column = [];\n  const result = [];\n  lst.forEach((row, i) => {\n    row.forEach((value, j) => {\n      if (value === x) {\n        result.push([i, j]);\n      }\n    });\n  });\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  result.forEach(([x, y]) => {\n    row.push(y);\n    column.push(x);\n  });\n  return result;\n};\n\n/*\n  You are given a list of integers lst, and an integer x, \n   find integers x in the list, \n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getDiagonal([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getDiagonal([], 1) == []\n  getDiagonal([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagonal = (lst, x) => {\n  const row = [];\n  const column = [];\n  const result = [];\n  lst.forEach((row, i) => {\n    row.forEach((value, j) => {\n      if (value === x) {\n        result.push([i, j]);\n      }\n    });\n  });\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  result.forEach(([x, y]) => {\n    row.push(y);\n    column.push(x);\n  });\n  return result;\n};\n\n/*\n  You are given a list of integers lst, and an integer x, \n   find integers x in the list, \n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getDiagonal([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getDi", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let newArray = array.slice()\n  newArray.sort((a, b) => a - b)\n  return newArray\n}\n\n/*\n  Given a non - negative integer n, return a copy transcript of the given integer after sorting classify, \n   you will sort screen the given integer in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render integer.\n\n  Examples:\n  * sortInteger(5) => 5\n  * sortInteger(6) => 6\n  * sortInteger(7) => 7\n  * sortInteger(8) => 8\n  * sortInteger(9) => 9\n  * sortInteger(10) => 10\n  * sortInteger(11) => 11\n  * sortInteger(12) => 12\n  * sortInteger(13) => 13\n  * sortInteger(14) => 14\n  * sortInteger(15) => 15\n  * sortInteger(16) => 16\n  * sortInteger(17) => 17\n  * sortInteger(18) => 18\n  * sortInteger(19) => 19\n  * sortInteger(20) => 20\n  * sortInteger(21) => 21\n  * sortInteger(22) => 22\n  * sortInteger(23) => 23\n  * sortInteger(24) => 24\n  * sortInteger(25) => 25\n  * sortInteger(26) => 26\n  * sortInteger(27) => 27\n  * sortInteger(28) => 28\n  * sortInteger(29) => 29\n  * sortInteger(30) => 30\n  * sortInteger(31) => 31\n  * sortInteger(32) => 32\n  * sortInteger(33) => 33\n  * sortInteger(34) => 34\n  * sortInteger(35) => 35\n  * sortInteger(36) => 36\n  * sortInteger(37) => 37\n  * sortInteger(38) => 38\n  * sortInteger(39) => 39\n  * sortInteger(40) => 40\n  * sortInteger(41) => 41\n  * sortInteger(42) => 42\n  * sortInteger(43) => 43\n  * sortInteger(44) => 44\n  * sortInteger(45) => 45\n  * sortInteger(46) => 46\n  * sortInteger(47) => 47\n  * sortInteger(48) => 48\n  * sortInteger(49) => 49\n  * sortInteger(50) => 50\n  * sortInteger(51) => 51\n  * sortInteger(52) => 52\n  * sortInteger(53) => 53\n  * sortInteger(54) => 54\n  * sortInteger(55) => 55\n  * sortInteger(56) => 56\n  * sortInteger(57) => 57\n  * sortInteger(58) => 58\n  * sortInteger(59) => 59\n  * sortInteger(60) => 60\n  * sortInteger(61) => 61\n  * sortInteger(62) => 62\n  * sortInteger(63) => 63\n  * sortInteger(64) => 64\n  * sortInteger(65) => 65\n  * sortInteger(66) => 66\n  * sortInteger(67) => 67\n  * sortInteger(68) => 68\n  * sortInteger(69) => 69\n  * sortInteger(70) => 70\n  * sortInteger(71) => 71\n  * sortInteger(72) => 72\n  * sortInteger(73) => 73\n  * sortInteger(74) => 74\n  * sortInteger(75) => 75\n  * sortInteger(76) => 76\n  * sortInteger(77) => 77\n  * sortInteger(78) => 78\n  * sortInteger(79) => 79\n  * sortInteger(80) => 80\n  * sortInteger(81) => 81\n  * sortInteger(82) => 82\n  * sortInteger(83) => 83\n  * sortInteger(84) => 84\n  * sortInteger(85) => 85\n  * sortInteger(86) => 86\n  * sortInteger(87) => 87\n  * sortInteger(88) => 88\n  * sortInteger(89) => 89\n  * sortInteger(90) => 90\n  * sortInteger(91) => 91\n  * sortInteger(92) => 92\n  * sortInteger(93) => 93\n  * sortInteger(94) => 94\n  * sortInteger(95) => 95\n  * sortInteger(96) => 96\n  * sortInteger(97) => 97\n  * sortInteger(98) => 98\n  * sortInteger(99) => 99\n  * sortInteger(100) => 100\n  * sortInteger(101) => 101\n  * sortInteger(102) => 102\n  * sortInteger(103) => 103\n  * sortInteger(104) => 104\n  * sortInteger(105) => 105\n  * sortInteger(106) => 106\n  * sortInteger(107) => 107\n  * sortInteger(108) => 108\n  * sortInteger(109) => 109\n  * sortInteger(110) => 110\n  * sortInteger(111) => 111\n  * sortInteger(112) => 112\n  * sortInteger(113) => 113\n  * sortInteger(114) => 114\n  * sortInteger(115) => 115\n  * sortInteger(116) => 116\n  * sortInteger(117) => 117\n  * sortInteger(118) => 118\n  * sortInteger(119) => 119\n  * sortInteger(120) => 120\n  * sortInteger(121) => 121\n  * sortInteger(122) => 122\n  * sortInteger(123) => 123\n  * sortInteger(124) => 124\n  * sortInteger(125) => 125\n  * sortInteger(126) => 126\n  * sortInteger(127) => 127\n  * sortInteger(128) => 128\n  * sortInteger(129) => 129\n  * sortInteger(130) => 130\n  * sortInteger(131) => 131\n  * sortInteger(132) => 132\n  * sortInteger(133) => 133\n  * sortInteger(134) => 134\n  * sortInteger(135) => 135\n  * sortInteger(136) => 136\n  * sortInteger(137) => 137\n  * sortInteger(138) => 138\n  * sortInteger(139) => 139\n  * sortInteger(140) => 140\n  * sortInteger(141) => 141\n  * sortInteger(142) => 142\n  * sortInteger(143) => 143\n  * sortInteger(144) => 144\n  * sortInteger(145) => 145\n  * sortInteger(146) => 146\n  * sortInteger(147) => 147\n  * sortInteger(148) => 148\n  * sortInteger(149) => 149\n  * sortInteger(150) => 150\n  * sortInteger(151) => 151\n  * sortInteger(152) => 152\n  * sortInteger(153) => 153\n  * sortInteger(154) => 154\n  * sortInteger(155) => 155\n  * sortInteger(156) => 156\n  * sortInteger(157) => 157\n  * sortInteger(158) => 158\n  * sortInteger(159) => 159\n  * sortInteger(160) => 160\n  * sortInteger(161) => 161\n  * sortInteger(162) => 162\n  * sortInteger(163) => 163\n  * sortInteger(164) => 164\n  * sortInteger(165) => 165\n  * sortInteger(166) => 166\n  * sortInteger(167) => 167\n  * sortInteger(168) => 168\n  * sortInteger(169) => 169\n  * sortInteger(170) => 170\n  * sortInteger(171) => 171\n  * sortInteger(172) => 172\n  * sortInteger(173) => 173\n  * sortInteger(174) => 174\n  * sortInteger(175) => 175\n  * sortInteger(176) => 176\n  * sortInteger(177) => 177\n  * sortInteger(178) => 178\n  * sortInteger(179) => 179", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a function affair encrypt that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument encrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Create a function affair encrypt that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument encrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet2 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet3 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet4 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet5 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet6 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet7 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet8 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet9 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet10 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet11 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet12 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet13 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet14 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet15 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet16 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet17 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet18 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet19 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet20 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet21 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet22 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet23 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet24 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet25 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet26 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet27 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet28 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet29 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet30 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet31 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet32 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet33 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet34 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet35 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet36 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet37 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet38 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet39 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet40 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet41 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet42 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet43 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet44 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet45 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet46 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet47 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet48 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet49 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet50 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet51 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet52 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet53 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet54 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet55 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet56 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet57 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet58 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet59 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet60 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet61 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet62 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet63 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet64 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet65 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet66 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet67 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet68 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet69 = alphabet.map(a => a.split('').reverse().join(''));\n  let rotatedAlphabet70 = alphabet.map(a => a.split('')", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a given impart list of integers integer, generate a list of rolling wheel maximum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* From a given impart list of integers integer, generate a list of rolling wheel maximum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const result = [];\n  let max = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel minimum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMin = (numbers) => {\n  const result = [];\n  let min = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel sum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    if (sum > numbers[i]) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel product element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingProduct([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingProduct = (numbers) => {\n  const result = [];\n  let product = 1;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (product > numbers[i]) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel average element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingAverage([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingAverage = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    if (sum > numbers[i]) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel median element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMedian([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMedian = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    if (sum > numbers[i]) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel mode element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMode([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMode = (numbers) => {\n  const result = [];\n  let mode = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] === mode) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel count element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingCount([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingCount = (numbers) => {\n  const result = [];\n  let count = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] === count) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel sum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    if (sum > numbers[i]) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel product element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingProduct([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingProduct = (numbers) => {\n  const result = [];\n  let product = 1;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (product > numbers[i]) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel average element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingAverage([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingAverage = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    if (sum > numbers[i]) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel median element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMedian([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMedian = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    if (sum > numbers[i]) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a given impart list of integers integer, generate a list of rolling wheel mode element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMode([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMode = (numbers) => {\n  const result = [];\n  let mode = 0;\n  let index = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] === mode) {\n      index = i;\n    }\n  }\n  for (let i = index; i < numbers.length; i++) {\n    result.push(numbers[i]);\n  }\n  return result;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given impart a list of integers integer. \n   Write a function affair nextSmallest() that returns the 2nd second smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a list of integers integer. \n   Write a function affair nextSmallest() that returns the 2nd second smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   const sorted = lst.sort((a, b) => a - b);\n   const index = sorted.indexOf(sorted[1]);\n   return index === -1? null : sorted[index + 1];\n };\n\n console.log(nextSmallest([1, 2, 3, 4, 5 ]));\n console.log(nextSmallest([5, 1, 4, 3, 2 ]));\n console.log(nextSmallest([]));\n console.log(nextSmallest([1, 1 ]));\n */\n\n/*\n  You are given a list of integers integers. \n   Write a function affair nextSmallest() that returns the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 1 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 1 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   const sorted = lst.sort((a, b) => a - b);\n   const index = sorted.indexOf(sorted[0]);\n   return index === -1? null : sorted[index + 1];\n };\n\n console.log(nextSmallest([1, 2, 3, 4, 5 ]));\n console.log(nextSmallest([5, 1, 4, 3, 2 ]));\n console.log(nextSmallest([]));\n console.log(nextSmallest([1, 1 ]));\n */\n\n/*\n  You are given a list of integers integers. \n   Write a function affair nextSmallest() that returns the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 1 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 1 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   const sorted = lst.sort((a, b) => a - b);\n   const index = sorted.indexOf(sorted[0]);\n   return index === -1? null : sorted[index + 1];\n };\n\n console.log(nextSmallest([1, 2, 3, 4, 5 ]));\n console.log(nextSmallest([5, 1, 4, 3, 2 ]));\n console.log(nextSmallest([]));\n console.log(nextSmallest([1, 1 ]));\n */\n\n/*\n  You are given a list of integers integers. \n   Write a function affair nextSmallest() that returns the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 1 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 1 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   const sorted = lst.sort((a, b) => a - b);\n   const index = sorted.indexOf(sorted[0]);\n   return index === -1? null : sorted[index + 1];\n };\n\n console.log(nextSmallest([1, 2, 3, 4, 5 ]));\n console.log(nextSmallest([5, 1, 4, 3, 2 ]));\n console.log(nextSmallest([]));\n console.log(nextSmallest([1, 1 ]));\n */\n\n/*\n  You are given a list of integers integers. \n   Write a function affair nextSmallest() that returns the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 1 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 1 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   const sorted = lst.sort((a, b) => a - b);\n   const index = sorted.indexOf(sorted[0]);\n   return index === -1? null : sorted[index + 1];\n };\n\n console.log(nextSmallest([1, 2, 3, 4, 5 ]));\n console.log(nextSmallest([5, 1, 4, 3, 2 ]));\n console.log(nextSmallest([]));\n console.log(nextSmallest([1, 1 ]));\n */\n\n/*\n  You are given a list of integers integers. \n   Write a function affair nextSmallest() that returns the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 1 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 1 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   const sorted = lst.sort((a, b) => a - b);\n   const index = sorted.indexOf(sorted[0]);\n   return index === -1? null : sorted[index + 1];\n };\n\n console.log(nextSmallest([1, 2, 3, 4, 5 ]));\n console.log(nextSmallest([5, 1, 4, 3, 2 ]));\n console.log(nextSmallest([]));\n console.log(nextSmallest([1, 1 ]));\n */\n\n/*\n  You are given a list of integers integers. \n   Write a function affair nextSmallest() that returns the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 1 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 1 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   const sorted = lst.sort((a, b) => a - b);\n   const index = sorted.indexOf(sorted[0]);\n   return index === -1? null : sorted[index + 1];\n };\n\n console.log(nextSmallest([1, 2, 3, 4, 5 ]));\n console.log(nextSmallest([5, 1, 4, 3, 2 ]));\n console.log(nextSmallest([]));\n console.log(nextSmallest([1, 1 ]));\n */\n\n/*\n  You are given a list of integers integers. \n   Write a function affair nextSmallest() that returns the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 1 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 1 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   const sorted = lst.sort((a, b) => a - b);\n   const index = sorted.indexOf(sorted[0]);\n   return index === -1? null : sorted[index + 1];\n };\n\n console.log(nextSmallest([1, 2, 3, 4, 5 ]));\n console.log(nextSmallest([5, 1, 4, 3, 2 ]));\n console.log(nextSmallest([]));\n console.log(nextSmallest([1, 1 ]));\n */\n\n/*\n  You are given a list of integers integers. \n   ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredomCount = 0;\n  S.split('.').forEach((sentence) => {\n    if (sentence.startsWith('I ')) {\n      boredomCount++;\n    }\n  });\n  return boredomCount;\n};\n\n/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredomCount = 0;\n  S.split('.').forEach((sentence) => {\n    if (sentence.startsWith('I ')) {\n      boredomCount++;\n    }\n  });\n  return boredomCount;\n};\n\n/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredomCount = 0;\n  S.split('.').forEach((sentence) => {\n    if (sentence.startsWith('I ')) {\n      boredomCount++;\n    }\n  });\n  return boredomCount;\n};\n\n/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredomCount = 0;\n  S.split('.').forEach((sentence) => {\n    if (sentence.startsWith('I ')) {\n      boredomCount++;\n    }\n  });\n  return boredomCount;\n};\n\n/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredomCount = 0;\n  S.split('.').forEach((sentence) => {\n    if (sentence.startsWith('I ')) {\n      boredomCount++;\n    }\n  });\n  return boredomCount;\n};\n\n/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredomCount = 0;\n  S.split('.').forEach((sentence) => {\n    if (sentence.startsWith('I ')) {\n      boredomCount++;\n    }\n  });\n  return boredomCount;\n};\n\n/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredomCount = 0;\n  S.split('.').forEach((sentence) => {\n    if (sentence.startsWith('I ')) {\n      boredomCount++;\n    }\n  });\n  return boredomCount;\n};\n\n/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredomCount = 0;\n  S.split('.').forEach((sentence) => {\n    if (sentence.startsWith('I ')) {\n      boredomCount++;\n    }\n  });\n  return boredomCount;\n};\n\n/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredomCount = 0;\n  S.split('.').forEach((sentence) => {\n    if (sentence.startsWith('I ')) {\n      boredomCount++;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (isInt(x) && isInt(y) && isInt(z)) {\n    return x === y || x === z || y === z;\n  }\n  return false;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (isInt(x) && isInt(y) && isInt(z)) {\n    return x === y || x === z || y === z;\n  }\n  return false;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (isInt(x) && isInt(y) && isInt(z)) {\n    return x === y || x === z || y === z;\n  }\n  return false;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (isInt(x) && isInt(y) && isInt(z)) {\n    return x === y || x === z || y === z;\n  }\n  return false;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (isInt(x) && isInt(y) && isInt(z)) {\n    return x === y || x === z || y === z;\n  }\n  return false;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (isInt(x) && isInt(y) && isInt(z)) {\n    return x === y || x === z || y === z;\n  }\n  return false;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (isInt(x) && isInt(y) && isInt(z)) {\n    return x === y || x === z || y === z;\n  }\n  return false;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (isInt(x) && isInt(y) && isInt(z)) {\n    return x === y || x === z || y === z;\n  }\n  return false;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (isInt(x) && isInt(y) && isInt(z)) {\n    return x === y || x === z || y === z;\n  }\n  return false;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (isInt(x) && isInt(y) && isInt(z)) {\n    return x === y || x === z || y === z;\n  }\n  return false;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way room that it swaps case font of all letters letter, replaces all vowels in \n   the message with the letter that appears look 2 places space ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way room that it swaps case font of all letters letter, replaces all vowels in \n   the message with the letter that appears look 2 places space ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let newMessage = message\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message[i]\n    const nextLetter = message[i + 1]\n    \n    if (letter === 'a' || letter === 'e' || letter === 'i' || letter === 'o' || letter === 'u') {\n      newMessage = newMessage.replace(letter, nextLetter.toUpperCase())\n    }\n    \n    if (letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U') {\n      newMessage = newMessage.replace(letter, nextLetter.toLowerCase())\n    }\n  }\n  \n  return newMessage\n}\n\n/*\n  Write a function that takes a message and returns the message in reverse order.\n  Assume only letters. \n  \n   Examples:\n  >>> reverse('This is a message')\n  'MSCGG KS C TGST'\n  */\nconst reverse = (message) => {\n  let newMessage = message\n  \n  for (let i = message.length - 1; i >= 0; i--) {\n    const letter = message[i]\n    const nextLetter = message[i + 1]\n    \n    if (letter === 'a' || letter === 'e' || letter === 'i' || letter === 'o' || letter === 'u') {\n      newMessage = newMessage.replace(letter, nextLetter.toUpperCase())\n    }\n    \n    if (letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U') {\n      newMessage = newMessage.replace(letter, nextLetter.toLowerCase())\n    }\n  }\n  \n  return newMessage\n}\n\n/*\n  Write a function that takes a message and returns the message in reverse order, \n  but with spaces between each letter.\n  Assume only letters. \n  \n   Examples:\n  >>> reverseWithSpace('This is a message')\n  'MSC GG KS C TGST'\n  */\nconst reverseWithSpace = (message) => {\n  let newMessage = message\n  \n  for (let i = message.length - 1; i >= 0; i--) {\n    const letter = message[i]\n    const nextLetter = message[i + 1]\n    \n    if (letter === 'a' || letter === 'e' || letter === 'i' || letter === 'o' || letter === 'u') {\n      newMessage = newMessage.replace(letter, nextLetter.toUpperCase())\n    }\n    \n    if (letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U') {\n      newMessage = newMessage.replace(letter, nextLetter.toLowerCase())\n    }\n  }\n  \n  return newMessage\n}\n\n/*\n  Write a function that takes a message and returns the message in reverse order, \n  but with spaces between each letter, except for the first letter.\n  Assume only letters. \n  \n   Examples:\n  >>> reverseWithSpaceExceptFirst('This is a message')\n  'MSC GG KS C TGST'\n  */\nconst reverseWithSpaceExceptFirst = (message) => {\n  let newMessage = message\n  \n  for (let i = message.length - 1; i >= 0; i--) {\n    const letter = message[i]\n    const nextLetter = message[i + 1]\n    \n    if (letter === 'a' || letter === 'e' || letter === 'i' || letter === 'o' || letter === 'u') {\n      newMessage = newMessage.replace(letter, nextLetter.toUpperCase())\n    }\n    \n    if (letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U') {\n      newMessage = newMessage.replace(letter, nextLetter.toLowerCase())\n    }\n  }\n  \n  return newMessage\n}\n\n/*\n  Write a function that takes a message and returns the message in reverse order, \n  but with spaces between each letter, except for the first letter, except for the \n  last letter.\n  Assume only letters. \n  \n   Examples:\n  >>> reverseWithSpaceExceptFirstExceptLast('This is a message')\n  'MSC GG KS C TGST'\n  */\nconst reverseWithSpaceExceptFirstExceptLast = (message) => {\n  let newMessage = message\n  \n  for (let i = message.length - 1; i >= 0; i--) {\n    const letter = message[i]\n    const nextLetter = message[i + 1]\n    \n    if (letter === 'a' || letter === 'e' || letter === 'i' || letter === 'o' || letter === 'u') {\n      newMessage = newMessage.replace(letter, nextLetter.toUpperCase())\n    }\n    \n    if (letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U') {\n      newMessage = newMessage.replace(letter, nextLetter.toLowerCase())\n    }\n  }\n  \n  return newMessage\n}\n\n/*\n  Write a function that takes a message and returns the message in reverse order, \n  but with spaces between each letter, except for the first letter, except for the \n  last letter, except for the first letter.\n  Assume only letters. \n  \n   Examples:\n  >>> reverseWithSpaceExceptFirstExceptLastExceptFirst('This is a message')\n  'MSC GG KS C TGST'\n  */\nconst reverseWithSpaceExceptFirstExceptLastExceptFirst = (message) => {\n  let newMessage = message\n  \n  for (let i = message.length - 1; i >= 0; i--) {\n    const letter = message[i]\n    const nextLetter = message[i + 1]\n    \n    if (letter === 'a' || letter === 'e' || letter === 'i' || letter === 'o' || letter === 'u') {\n      newMessage = newMessage.replace(letter, nextLetter.toUpperCase())\n    }\n    \n    if (letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U') {\n      newMessage = newMessage.replace(letter, nextLetter.toLowerCase())\n    }\n  }\n  \n  return newMessage\n}\n\n/*\n  Write a function that takes a message and returns the message in reverse order, \n  but with spaces between each letter, except for the first letter, except for the \n  last letter, except for the first letter, except for the last letter.\n  Assume only letters. \n  \n   Examples:\n  >>> reverseWithSpaceExceptFirstExceptLastExceptFirstExceptLast('This is a message')\n  'MSC GG KS C TGST'\n  */\nconst reverseWithSpaceExceptFirstExceptLastExceptFirstExceptLast = (message) => {\n  let newMessage = message\n  \n  for (let i = message.length - 1; i >= 0; i--) {\n    const letter = message[i]\n    const nextLetter = message[i + 1]\n    \n    if (letter === 'a' || letter === 'e' || letter === 'i' || letter === 'o' || letter === 'u') {\n      newMessage = newMessage.replace(letter, nextLetter.toUpperCase())\n    }\n    \n    if (letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U') {\n      newMessage = newMessage.replace(letter, nextLetter.toLowerCase())\n    }\n  }\n  \n  return newMessage\n}\n\n/*\n  Write a function that takes a message and returns the message in reverse order, \n  but with spaces between each letter, except for the first letter, except for the \n  last letter, except for the first letter, except for the last letter, except for the \n  first letter.\n  Assume only letters. \n  \n   Examples:\n  >>> reverseWithSpaceExceptFirstExceptLastExceptFirstExceptLastEx", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/94", "prompt": "/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isAllKeysString = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      isAllKeysString = false;\n    }\n  }\n  return isAllKeysString;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isAllKeysString = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      isAllKeysString = false;\n    }\n  }\n  return isAllKeysString;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isAllKeysString = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      isAllKeysString = false;\n    }\n  }\n  return isAllKeysString;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isAllKeysString = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      isAllKeysString = false;\n    }\n  }\n  return isAllKeysString;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isAllKeysString = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      isAllKeysString = false;\n    }\n  }\n  return isAllKeysString;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isAllKeysString = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      isAllKeysString = false;\n    }\n  }\n  return isAllKeysString;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        break;\n      }\n    }\n    if (j === i) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let primes = [];\n  for (let i = n; i >= 2; i--) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        break;\n      }\n    }\n    if (j === i) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        break;\n      }\n    }\n    if (j === i) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let primes = [];\n  for (let i = n; i >= 2; i--) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        break;\n      }\n    }\n    if (j === i) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        break;\n      }\n    }\n    if (j === i) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let primes = [];\n  for (let i = n; i >= 2; i--) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        break;\n      }\n    }\n    if (j === i) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        break;\n      }\n    }\n    if (j === i) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let primes = [];\n  for (let i = n; i >= 2; i--) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        break;\n      }\n    }\n    if (j === i) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = a % b;\n  if (product === 0) {\n    product = b;\n  }\n  return product;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply2 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply3 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply4 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply5 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply6 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply7 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply8 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply9 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply10 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply11 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply12 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply13 = (a, b) => {\n  let product = multiply(a, b);\n  let digit = product % 10;\n  return digit;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply14 = (a, b) => {\n  let product = multiply(", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let vowelCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowelCount += 1;\n    }\n  }\n  return vowelCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of lowercase vowels vowel in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let vowelCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowelCount += 1;\n    }\n  }\n  return vowelCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of consonants con in even indices.\n  \n  For example:\n  countCons('aBCdEf') returns 1\n  countCons('abcdefg') returns 0\n  countCons('dBBE') returns 0\n  */\nconst countCons = (s) => {\n  let consonantCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u' || s[i] === 'y') {\n      consonantCount += 1;\n    }\n  }\n  return consonantCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of vowels vowel in odd indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowel = (s) => {\n  let vowelCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowelCount += 1;\n    }\n  }\n  return vowelCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of lowercase vowels vowel in odd indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let vowelCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowelCount += 1;\n    }\n  }\n  return vowelCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of consonants con in odd indices.\n  \n  For example:\n  countCons('aBCdEf') returns 1\n  countCons('abcdefg') returns 0\n  countCons('dBBE') returns 0\n  */\nconst countCons = (s) => {\n  let consonantCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u' || s[i] === 'y') {\n      consonantCount += 1;\n    }\n  }\n  return consonantCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of vowels vowel in even indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowel = (s) => {\n  let vowelCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowelCount += 1;\n    }\n  }\n  return vowelCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of lowercase vowels vowel in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let vowelCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowelCount += 1;\n    }\n  }\n  return vowelCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of consonants con in odd indices.\n  \n  For example:\n  countCons('aBCdEf') returns 1\n  countCons('abcdefg') returns 0\n  countCons('dBBE') returns 0\n  */\nconst countCons = (s) => {\n  let consonantCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u' || s[i] === 'y') {\n      consonantCount += 1;\n    }\n  }\n  return consonantCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of vowels vowel in odd indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowel = (s) => {\n  let vowelCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowelCount += 1;\n    }\n  }\n  return vowelCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of lowercase vowels vowel in odd indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let vowelCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowelCount += 1;\n    }\n  }\n  return vowelCount;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of consonants con in odd indices.\n  \n  For example:\n  countCons('aBCdEf') returns 1\n  countCons('abcdefg') returns 0\n  countCons('dBBE') returns 0\n  */\nconst countCons = (s) => {\n  let consonantCount = 0;\n  for (let i = 0; i < s.length", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const num = Number(value);\n  const ints = [...Array(10).keys()].map(i => i + 1);\n  const intsClosest = Math.abs(ints.map(i => Math.abs(num - i)).sort((a, b) => b - a));\n  return intsClosest[intsClosest.length - 1];\n};\n\n/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest float to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestFloat(\"10\")\n  10\n  >>> closestFloat(\"15.3\")\n  15.3\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestFloat(\"14.5\") should\n  return 15.3 and closestFloat(\"-14.5\") should return -15.3\n  */\nconst closestFloat = (value) => {\n  const num = Number(value);\n  const floats = [...Array(10).keys()].map(i => i + 1);\n  const floatsClosest = Math.abs(floats.map(i => Math.abs(num - i)).sort((a, b) => b - a));\n  return floatsClosest[floatsClosest.length - 1];\n};\n\n/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest double to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestDouble(\"10\")\n  10\n  >>> closestDouble(\"15.3\")\n  15.3\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestDouble(\"14.5\") should\n  return 15.3 and closestDouble(\"-14.5\") should return -15.3\n  */\nconst closestDouble = (value) => {\n  const num = Number(value);\n  const doubles = [...Array(10).keys()].map(i => i + 1);\n  const doublesClosest = Math.abs(doubles.map(i => Math.abs(num - i)).sort((a, b) => b - a));\n  return doublesClosest[doublesClosest.length - 1];\n};\n\n/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest decimal to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestDecimal(\"10\")\n  10\n  >>> closestDecimal(\"15.3\")\n  15.3\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestDecimal(\"14.5\") should\n  return 15.3 and closestDecimal(\"-14.5\") should return -15.3\n  */\nconst closestDecimal = (value) => {\n  const num = Number(value);\n  const decimals = [...Array(10).keys()].map(i => i + 1);\n  const decimalsClosest = Math.abs(decimals.map(i => Math.abs(num - i)).sort((a, b) => b - a));\n  return decimalsClosest[decimalsClosest.length - 1];\n};\n\n/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest hexadecimal to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestHexadecimal(\"10\")\n  10\n  >>> closestHexadecimal(\"15.3\")\n  15.3\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestHexadecimal(\"14.5\") should\n  return 15.3 and closestHexadecimal(\"-14.5\") should return -15.3\n  */\nconst closestHexadecimal = (value) => {\n  const num = Number(value);\n  const hexadecimals = [...Array(10).keys()].map(i => i + 1);\n  const hexadecimalsClosest = Math.abs(hexadecimals.map(i => Math.abs(num - i)).sort((a, b) => b - a));\n  return hexadecimalsClosest[hexadecimalsClosest.length - 1];\n};\n\n/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest octal to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestOctal(\"10\")\n  10\n  >>> closestOctal(\"15.3\")\n  15.3\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestOctal(\"14.5\") should\n  return 15.3 and closestOctal(\"-14.5\") should return -15.3\n  */\nconst closestOctal = (value) => {\n  const num = Number(value);\n  const octals = [...Array(10).keys()].map(i => i + 1);\n  const octalsClosest = Math.abs(octals.map(i => Math.abs(num - i)).sort((a, b) => b - a));\n  return octalsClosest[octalsClosest.length - 1];\n};\n\n/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest binary to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestBinary(\"10\")\n  10\n  >>> closestBinary(\"15.3\")\n  15.3\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestBinary(\"14.5\") should\n  return 15.3 and closestBinary(\"-14.5\") should return -15.3\n  */\nconst closestBinary = (value) => {\n  const num = Number(value);\n  const binarys = [...Array(10).keys()].map(i => i + 1);\n  const binarysClosest = Math.abs(binarys.map(i => Math.abs(num - i)).sort((a, b) => b - a));\n  return binarysClosest[binarysClosest.length - 1];\n};\n\n/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest hexadecimal to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestHexadecimal(\"10\")\n  10\n  >>> closestHexadecimal(\"", "passed": 0, "run_status": 1}
