{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers close to each other than \n   give threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 3, "perturbed": true, "gc": "/* Check if in given list of numbers, are any two numbers close to each other than \n   give threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements2 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements3 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements4 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements5 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements6 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements7 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements8 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a bowed stringed instrument containing multiple group of nest parenthesis. Your finish is to \n   freestanding those group into freestanding strings and return the list of those. \n   disjoined groups are balanced (each open pair is by rights shut) and not nested within each other \n   dismiss any spaces in the input chain.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 3, "perturbed": true, "gc": "/* Input to this function is a bowed stringed instrument containing multiple group of nest parenthesis. Your finish is to \n   freestanding those group into freestanding strings and return the list of those. \n   disjoined groups are balanced (each open pair is by rights shut) and not nested within each other \n   dismiss any spaces in the input chain.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.split('');\n  const paren_groups_length = paren_groups.length;\n  const paren_groups_length_minus_one = paren_groups_length - 1;\n  const paren_groups_length_minus_two = paren_groups_length - 2;\n  const paren_groups_length_minus_three = paren_groups_length - 3;\n  const paren_groups_length_minus_four = paren_groups_length - 4;\n  const paren_groups_length_minus_five = paren_groups_length - 5;\n  const paren_groups_length_minus_six = paren_groups_length - 6;\n  const paren_groups_length_minus_seven = paren_groups_length - 7;\n  const paren_groups_length_minus_eight = paren_groups_length - 8;\n  const paren_groups_length_minus_nine = paren_groups_length - 9;\n  const paren_groups_length_minus_ten = paren_groups_length - 10;\n  const paren_groups_length_minus_eleven = paren_groups_length - 11;\n  const paren_groups_length_minus_twelve = paren_groups_length - 12;\n  const paren_groups_length_minus_thirteen = paren_groups_length - 13;\n  const paren_groups_length_minus_fourteen = paren_groups_length - 14;\n  const paren_groups_length_minus_fifteen = paren_groups_length - 15;\n  const paren_groups_length_minus_sixteen = paren_groups_length - 16;\n  const paren_groups_length_minus_seventeen = paren_groups_length - 17;\n  const paren_groups_length_minus_eighteen = paren_groups_length - 18;\n  const paren_groups_length_minus_nineteen = paren_groups_length - 19;\n  const paren_groups_length_minus_twenty = paren_groups_length - 20;\n  const paren_groups_length_minus_twenty_one = paren_groups_length - 21;\n  const paren_groups_length_minus_twenty_two = paren_groups_length - 22;\n  const paren_groups_length_minus_twenty_three = paren_groups_length - 23;\n  const paren_groups_length_minus_twenty_four = paren_groups_length - 24;\n  const paren_groups_length_minus_twenty_five = paren_groups_length - 25;\n  const paren_groups_length_minus_twenty_six = paren_groups_length - 26;\n  const paren_groups_length_minus_twenty_seven = paren_groups_length - 27;\n  const paren_groups_length_minus_twenty_eight = paren_groups_length - 28;\n  const paren_groups_length_minus_twenty_nine = paren_groups_length - 29;\n  const paren_groups_length_minus_thirty = paren_groups_length - 30;\n  const paren_groups_length_minus_thirty_one = paren_groups_length - 31;\n  const paren_groups_length_minus_thirty_two = paren_groups_length - 32;\n  const paren_groups_length_minus_thirty_three = paren_groups_length - 33;\n  const paren_groups_length_minus_thirty_four = paren_groups_length - 34;\n  const paren_groups_length_minus_thirty_five = paren_groups_length - 35;\n  const paren_groups_length_minus_thirty_six = paren_groups_length - 36;\n  const paren_groups_length_minus_thirty_seven = paren_groups_length - 37;\n  const paren_groups_length_minus_thirty_eight = paren_groups_length - 38;\n  const paren_groups_length_minus_thirty_nine = paren_groups_length - 39;\n  const paren_groups_length_minus_thirty_ten = paren_groups_length - 40;\n  const paren_groups_length_minus_thirty_eleven = paren_groups_length - 41;\n  const paren_groups_length_minus_thirty_twelve = paren_groups_length - 42;\n  const paren_groups_length_minus_thirty_thirteen = paren_groups_length - 43;\n  const paren_groups_length_minus_thirty_fourteen = paren_groups_length - 44;\n  const paren_groups_length_minus_thirty_fifteen = paren_groups_length - 45;\n  const paren_groups_length_minus_thirty_sixteen = paren_groups_length - 46;\n  const paren_groups_length_minus_thirty_seventeen = paren_groups_length - 47;\n  const paren_groups_length_minus_thirty_eighteen = paren_groups_length - 48;\n  const paren_groups_length_minus_thirty_nineteen = paren_groups_length - 49;\n  const paren_groups_length_minus_thirty_twenty = paren_groups_length - 50;\n  const paren_groups_length_minus_thirty_twenty_one = paren_groups_length - 51;\n  const paren_groups_length_minus_thirty_twenty_two = paren_groups_length - 52;\n  const paren_groups_length_minus_thirty_twenty_three = paren_groups_length - 53;\n  const paren_groups_length_minus_thirty_twenty_four = paren_groups_length - 54", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* discover the short palindrome that begin with a provide string.\n   Algorithm idea is simple: \n   - line up the longest suffix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that derive before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "/* Test if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* discover the short palindrome that begin with a provide string.\n   Algorithm idea is simple: \n   - line up the longest suffix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that derive before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* Test if a string is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* discover the shortest palindrome that begin with a provide string.\n   Algorithm idea is simple: \n   - line up the longest suffix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that derive before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* discover the longest palindrome that begin with a provide string.\n   Algorithm idea is simple: \n   - line up the longest suffix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that derive before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* discover the longest palindrome that begin with a provide string.\n   Algorithm idea is simple: \n   - line up the longest suffix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that derive before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* discover the longest palindrome that begin with a provide string.\n   Algorithm idea is simple: \n   - line up the longest suffix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that derive before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* discover the longest palindrome that begin with a provide string.\n   Algorithm idea is simple: \n   - line up the longest suffix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that derive before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* discover the longest palindrome that begin with a provide string.\n   Algorithm idea is simple: \n   - line up the longest suffix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that derive before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* discover the longest palindrome that begin with a provide string.\n   Algorithm idea is simple: \n   - line up the longest suffix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that derive before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* discover the longest palindrome that begin with a provide string.\n   Algorithm idea is simple: \n   - line up the longest suffix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that derive before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n degree of stone. \n   The inaugural degree experience n stones. \n   The issue of stones in the adjacent degree is: \n       - the next leftover number if n is odd. \n       - the future even number if n is even. \n   Return the act of stones in each level in a list, where component at index \n   i typify the issue of stone in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive integer n, you have to make a pile of n degree of stone. \n   The inaugural degree experience n stones. \n   The issue of stones in the adjacent degree is: \n       - the next leftover number if n is odd. \n       - the future even number if n is even. \n   Return the act of stones in each level in a list, where component at index \n   i typify the issue of stone in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\n/*\n  Given a positive integer n, you have to make a pile of n degree of stone. \n   The issue of stones in the adjacent degree is: \n       - the next leftover number if n is odd. \n       - the future even number if n is even. \n   Return the act of stones in each level in a list, where component at index \n   i typify the issue of stone in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile2 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile3 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile4 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile5 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile6 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile7 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile8 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile9 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile10 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile11 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile12 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile13 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile14 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile15 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile16 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile17 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile18 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile19 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile20 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile21 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile22 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile23 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile24 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile25 = (n)", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of lyric separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 3, "perturbed": true, "gc": "/*\n  You will be given a string of lyric separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]\\s*/);\n  return words;\n};\n\n/*\n  You will be given a string of lyrics separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]\\s*/);\n  return words;\n};\n\n/*\n  You will be given a string of lyrics separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]\\s*/);\n  return words;\n};\n\n/*\n  You will be given a string of lyrics separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]\\s*/);\n  return words;\n};\n\n/*\n  You will be given a string of lyrics separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]\\s*/);\n  return words;\n};\n\n/*\n  You will be given a string of lyrics separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]\\s*/);\n  return words;\n};\n\n/*\n  You will be given a string of lyrics separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]\\s*/);\n  return words;\n};\n\n/*\n  You will be given a string of lyrics separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]\\s*/);\n  return words;\n};\n\n/*\n  You will be given a string of lyrics separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]\\s*/);\n  return words;\n};\n\n/*\n  You will be given a string of lyrics separated by comma or distance. Your undertaking is \n   to split the chain into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]\\s*/);\n  return words;\n};\n\n/*\n  You will be given a string of lyrics separated by comma or distance", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two convinced numbers x and y and reelect the \n   big even integer number that embody in the compass [x, y] inclusive. If \n   there's no such issue, then the routine should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 3, "perturbed": true, "gc": "/*This function takes two convinced numbers x and y and reelect the \n   big even integer number that embody in the compass [x, y] inclusive. If \n   there's no such issue, then the routine should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum2 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum2(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum2(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum3 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum3(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum3(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum4 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum4(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum4(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum5 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum5(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum5(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum6 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum6(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum6(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum7 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum7(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum7(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum8 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum8(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum8(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum9 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum9(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum9(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum10 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum10(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum10(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum11 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum11(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum11(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum12 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0) {\n    return chooseNum12(y, x - y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum12(x, y - x);\n  }\n  return -1;\n};\n\nconst chooseNum13 = (x, y) => {\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integer n and m, and your task is to compute the \n   average of the integer from n through m (include n and m). \n   Round the answer to the near integer and change that to binary. \n   If n is bang-up than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 3, "perturbed": true, "gc": "/*You are given two positive integer n and m, and your task is to compute the \n   average of the integer from n through m (include n and m). \n   Round the answer to the near integer and change that to binary. \n   If n is bang-up than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const n_m = n + m;\n  const n_m_1 = n_m - 1;\n  const n_m_2 = n_m - 2;\n  const n_m_3 = n_m - 3;\n  const n_m_4 = n_m - 4;\n  const n_m_5 = n_m - 5;\n  const n_m_6 = n_m - 6;\n  const n_m_7 = n_m - 7;\n  const n_m_8 = n_m - 8;\n  const n_m_9 = n_m - 9;\n  const n_m_10 = n_m - 10;\n  const n_m_11 = n_m - 11;\n  const n_m_12 = n_m - 12;\n  const n_m_13 = n_m - 13;\n  const n_m_14 = n_m - 14;\n  const n_m_15 = n_m - 15;\n  const n_m_16 = n_m - 16;\n  const n_m_17 = n_m - 17;\n  const n_m_18 = n_m - 18;\n  const n_m_19 = n_m - 19;\n  const n_m_20 = n_m - 20;\n  const n_m_21 = n_m - 21;\n  const n_m_22 = n_m - 22;\n  const n_m_23 = n_m - 23;\n  const n_m_24 = n_m - 24;\n  const n_m_25 = n_m - 25;\n  const n_m_26 = n_m - 26;\n  const n_m_27 = n_m - 27;\n  const n_m_28 = n_m - 28;\n  const n_m_29 = n_m - 29;\n  const n_m_30 = n_m - 30;\n  const n_m_31 = n_m - 31;\n  const n_m_32 = n_m - 32;\n  const n_m_33 = n_m - 33;\n  const n_m_34 = n_m - 34;\n  const n_m_35 = n_m - 35;\n  const n_m_36 = n_m - 36;\n  const n_m_37 = n_m - 37;\n  const n_m_38 = n_m - 38;\n  const n_m_39 = n_m - 39;\n  const n_m_40 = n_m - 40;\n  const n_m_41 = n_m - 41;\n  const n_m_42 = n_m - 42;\n  const n_m_43 = n_m - 43;\n  const n_m_44 = n_m - 44;\n  const n_m_45 = n_m - 45;\n  const n_m_46 = n_m - 46;\n  const n_m_47 = n_m - 47;\n  const n_m_48 = n_m - 48;\n  const n_m_49 = n_m - 49;\n  const n_m_50 = n_m - 50;\n  const n_m_51 = n_m - 51;\n  const n_m_52 = n_m - 52;\n  const n_m_53 = n_m - 53;\n  const n_m_54 = n_m - 54;\n  const n_m_55 = n_m - 55;\n  const n_m_56 = n_m - 56;\n  const n_m_57 = n_m - 57;\n  const n_m_58 = n_m - 58;\n  const n_m_59 = n_m - 59;\n  const n_m_60 = n_m - 60;\n  const n_m_61 = n_m - 61;\n  const n_m_62 = n_m - 62;\n  const n_m_63 = n_m - 63;\n  const n_m_64 = n_m - 64;\n  const n_m_65 = n_m - 65;\n  const n_m_66 = n_m - 66;\n  const n_m_67 = n_m - 67;\n  const n_m_68 = n_m - 68;\n  const n_m_69 = n_m - 69;\n  const n_m_70 = n_m - 70;\n  const n_m_71 = n_m - 71;\n  const n_m_72 = n_m - 72;\n  const n_m_73 = n_m - 73;\n  const n_m_74 = n_m - 74;\n  const n_m_75 = n_m - 75;\n  const n_m_76 = n_m - 76;\n  const n_m_77 = n_m - 77;\n  const n_m_78 = n_m - 78;\n  const n_m_79 = n_m - 79;\n  const n_m_80 = n_m - 80;\n  const n_m_81 = n_m - 81;\n  const n_m_82 = n_m - 82;\n  const n_m_83 = n_m - 83;\n  const n_m_84 = n_m - 84;\n  const n_m_85 = n_m - 85;\n  const n_m_86 = n_m - 86;\n  const n_m_87 = n_m - 87;\n  const n_m_88 = n_m - 88;\n  const n_m_89 = n_m - 89;\n  const n_m_90 = n_m - 90;\n  const n_m_91 = n_m - 91;\n  const n_m_92 = n_m - 92;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integer x. return a sorted list of all \n   elements that hasn't any tied finger. \n\n   Note: Returned list should be screen in increasing ordering. \n  \n   For case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 3, "perturbed": true, "gc": "/*Given a list of positive integer x. return a sorted list of all \n   elements that hasn't any tied finger. \n\n   Note: Returned list should be screen in increasing ordering. \n  \n   For case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const sorted = x.sort();\n  const unique = [];\n  let i = 0;\n  let j = 0;\n  while (i < sorted.length) {\n    if (sorted[i]!== sorted[j]) {\n      unique.push(sorted[i]);\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return unique;\n};\n\nconsole.log(uniqueDigits([15, 33, 1422, 1]));\nconsole.log(uniqueDigits([152, 323, 1422, 10]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integer, sort the integers that are between 1 and 9 inclusive, \n   change by reversal the resulting array, and then supplant each digit by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array of integer, sort the integers that are between 1 and 9 inclusive, \n   change by reversal the resulting array, and then supplant each digit by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  let sorted = arr.sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let result = []\n  for (let i = 0; i < reversed.length; i++) {\n    result.push(reversed[i] + \" \" + names[reversed[i]])\n  }\n  return result\n}\n\nconst names = {\n  1: \"One\",\n  2: \"Two\",\n  3: \"Three\",\n  4: \"Four\",\n  5: \"Five\",\n  6: \"Six\",\n  7: \"Seven\",\n  8: \"Eight\",\n  9: \"Nine\"\n}\n\nconsole.log(byLength([2, 1, 1, 4, 5, 8, 2, 3]))\nconsole.log(byLength([1, -1, 55]))\nconsole.log(byLength([1, -1, 55, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that take n as a parameter, \n   and reelect a list of size n, such that the value of the component at exponent i be the factorial of i if i is even \n   or the sum of act from 1 to i otherwise. \n   i begin from 1. \n   the factorial of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 3, "perturbed": true, "gc": "/* Implement the function f that take n as a parameter, \n   and reelect a list of size n, such that the value of the component at exponent i be the factorial of i if i is even \n   or the sum of act from 1 to i otherwise. \n   i begin from 1. \n   the factorial of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 2 === 0) {\n      result.push(factorial(i));\n    } else {\n      result.push(sum(i));\n    }\n  }\n  return result;\n};\n\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\nconst factorial = (n) => {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n};\n\nconst test = () => {\n  let result = f(5);\n  console.log(result);\n};\n\ntest();\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and curious \n   integer palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive integer n, return a tuple that has the number of even and curious \n   integer palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which take an array of integer and return \n   the issue of element which hold a kernel of digit > 0. \n   If a issue exist negative, then its first sign finger will equal negative: \n   e.g. -123 has sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function countNums which take an array of integer and return \n   the issue of element which hold a kernel of digit > 0. \n   If a issue exist negative, then its first sign finger will equal negative: \n   e.g. -123 has sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    if (num > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integer arr[1], arr[2],... , arr[N].The\n   numbers in the array will be randomly order. Your undertaking is to determine if \n   it is potential to catch an array classify in non - decreasing decree by performing \n   the trace operation on the given array: \n       You are allow to perform correct shift operation any act of time. \n  \n   One right switch mathematical process mean shifting all component of the array by one \n   position in the right guidance. The concluding chemical element of the array will be affect to \n   the starting position in the array i.e. 0th index. \n\n   If it embody possible to obtain the grouped array by performing the above process \n   then return true else return false. \n   If the give array is empty then return true. \n\n   Note: The given list is guarantee to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 3, "perturbed": true, "gc": "/*We have an array 'arr' of N integer arr[1], arr[2],..., arr[N].The\n   numbers in the array will be randomly order. Your undertaking is to determine if \n   it is potential to catch an array classify in non - decreasing decree by performing \n   the trace operation on the given array: \n       You are allow to perform correct shift operation any act of time. \n  \n   One right switch mathematical process mean shifting all component of the array by one \n   position in the right guidance. The concluding chemical element of the array will be affect to \n   the starting position in the array i.e. 0th index. \n\n   If it embody possible to obtain the grouped array by performing the above process \n   then return true else return false. \n   If the give array is empty then return true. \n\n   Note: The given list is guarantee to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall2 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall3 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall4 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall5 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall6 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall7 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall8 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall9 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall10 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b dwell only of 1s and zero. \n   do binary XOR on these stimulation and return consequence besides as a chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 3, "perturbed": true, "gc": "/* Input are two strings a and b dwell only of 1s and zero. \n   do binary XOR on these stimulation and return consequence besides as a chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor2 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor3 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor4 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor5 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor6 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor7 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor8 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor9 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor10 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor11 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor12 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor13 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor14 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor15 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor16 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a affair that takes two tilt of number, \n   and settle whether it is potential to do an exchange of component \n   between them to produce lst1 a list of only even numbers. \n   There is no terminus ad quem on the phone number of exchange component between lst1 and lst2.\n   If it be possible to exchange element between the lst1 and lst2 to make \n   all the elements of lst1 to exist even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 3, "perturbed": true, "gc": "/*In this problem, you will implement a affair that takes two tilt of number, \n   and settle whether it is potential to do an exchange of component \n   between them to produce lst1 a list of only even numbers. \n   There is no terminus ad quem on the phone number of exchange component between lst1 and lst2.\n   If it be possible to exchange element between the lst1 and lst2 to make \n   all the elements of lst1 to exist even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let lst1_even = lst1.filter(x => x % 2 === 0);\n  let lst2_even = lst2.filter(x => x % 2 === 0);\n  if (lst1_even.length === 0 || lst2_even.length === 0) {\n    return \"NO\";\n  }\n  let lst1_odd = lst1.filter(x => x % 2!== 0);\n  let lst2_odd = lst2.filter(x => x % 2!== 0);\n  if (lst1_odd.length === 0 || lst2_odd.length === 0) {\n    return \"NO\";\n  }\n  let lst1_even_odd = lst1_even.concat(lst1_odd);\n  let lst2_even_odd = lst2_even.concat(lst2_odd);\n  return lst1_even_odd.every(x => lst2_even_odd.includes(x))? \"YES\" : \"NO\";\n};\n\nconst test = [\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 5, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a outer space separated small letter letter, return a dictionary \n   of the letter with the most repeat and incorporate the correspond count. \n   If several letter have the like occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 3, "perturbed": true, "gc": "/*Given a string representing a outer space separated small letter letter, return a dictionary \n   of the letter with the most repeat and incorporate the correspond count. \n   If several letter have the like occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split('');\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1;\n    } else {\n      histogram[letters[i]]++;\n    }\n  }\n  return histogram;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const histogram = histogram(test);\n  const max = Object.keys(histogram).reduce((max, key) => {\n    if (histogram[key] > max) {\n      return histogram[key];\n    }\n  }, 0);\n  return max;\n};\n\nconst letterCount = (test) => {\n  const", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/112", "prompt": "/*Task \n   We are given two string section s and c, you have to erase all the character in s that be equal to any fictional character in c\n   then match if the result chain be palindrome. \n   A string is call palindrome if it reads the same backward as forward. \n   You should return a tuple containing the resultant role drawstring and true / delusive for the bridle.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 3, "perturbed": true, "gc": "/*Task \n   We are given two string section s and c, you have to erase all the character in s that be equal to any fictional character in c\n   then match if the result chain be palindrome. \n   A string is call palindrome if it reads the same backward as forward. \n   You should return a tuple containing the resultant role drawstring and true / delusive for the bridle.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  const cLen = c.length\n  const sLen = s.length\n  const result = []\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i] === c[j]) {\n      i++\n      j--\n    } else {\n      result.push(s[i])\n      i++\n    }\n  }\n  return (result.reverse(), j === -1)\n}\n\nconst reverse = (s) => {\n  const result = []\n  for (let i = s.length - 1; i >= 0; i--) {\n    result.push(s[i])\n  }\n  return result.reverse()\n}\n\nconst isPalindrome = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome2 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome3 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome4 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome5 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome6 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome7 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome8 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome9 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome10 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome11 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome12 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst isPalindrome13 = (s) => {\n  const sLen = s.length\n  let i = 0\n  let j = sLen - 1\n  while (i < sLen && j >= 0) {\n    if (s[i]!== s[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digit, return a list.\n   Each chemical element i of the end product should exist \" the numeral of odd elements in the \n   chain i of the stimulation. \" where all the i's should be substitute by the act \n   of leftover digits in the i'th chain of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 3, "perturbed": true, "gc": "/*Given a list of strings, where each string consists of only digit, return a list.\n   Each chemical element i of the end product should exist \" the numeral of odd elements in the \n   chain i of the stimulation. \" where all the i's should be substitute by the act \n   of leftover digits in the i'th chain of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const count = [];\n  for (let i = 0; i < lst.length; i++) {\n    const chain = lst[i];\n    const chainLength = chain.length;\n    const oddCount = chain.reduce((acc, digit, index) => {\n      if (index % 2 === 1) {\n        acc.push(digit);\n      }\n      return acc;\n    }, []);\n    count.push(`the number of odd elements ${oddCount.length} of the ${chainLength} chain of the ${i}th input.`);\n  }\n  return count;\n};\n\nmodule.exports = oddCount;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integer nums, find the minimum sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array of integer nums, find the minimum sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = Infinity;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\nconsole.log(minSubArraySum([2, 3, 4, 1, 2, 4]));\nconsole.log(minSubArraySum([-1, -2, -3]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of well. Each row represent a individual well, \n   and each 1 in a quarrel defend a individual unit of measurement of body of water. \n   Each well has a comparable bucket that can be use to educe body of water from it, \n   and all bucket have the same capacity.\n   Your job is to use the buckets to empty the well. \n   output signal the number of time you want to turn down the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of well. Each row represent a individual well, \n   and each 1 in a quarrel defend a individual unit of measurement of body of water. \n   Each well has a comparable bucket that can be use to educe body of water from it, \n   and all bucket have the same capacity.\n   Your job is to use the buckets to empty the well. \n   output signal the number of time you want to turn down the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const rows = grid.length\n  const cols = grid[0].length\n  const max = rows * cols\n  const buckets = new Array(max)\n  const fill = 0\n  const count = 0\n  const result = []\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        fill += 1\n        buckets[fill] = i * cols + j\n        count += 1\n      }\n    }\n  }\n\n  while (count > 0) {\n    let index = 0\n    let count = 0\n    let i = 0\n    let j = 0\n\n    while (count < capacity) {\n      if (buckets[index]!== 0) {\n        i = buckets[index] / cols\n        j = buckets[index] % cols\n        count += 1\n        fill -= 1\n        buckets[fill] = i * cols + j\n      } else {\n        index++\n      }\n    }\n\n    if (count === capacity) {\n      result.push(fill)\n    }\n  }\n\n  return result\n}\n\nconst grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\nconst capacity = 1\nconst result = fill(grid, capacity)\n\nconsole.log(result)\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non - negative integer accord to \n   act of one in their binary theatrical performance in ascend order. \n   For exchangeable numeral of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort an array of non - negative integer accord to \n   act of one in their binary theatrical performance in ascend order. \n   For exchangeable numeral of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sorted = arr.slice(0);\n  sorted.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return sorted;\n};\n\nexport default sortArray;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a lifelike number n, you have been tasked to implement \n   a affair that return a list of all bible from chain s that contain precisely \n   n consonant, in order these quarrel look in the string s.\n   If the bowed stringed instrument s is empty then the function should return an empty list.\n   Note: you may assume the stimulation drawstring contains merely letter and distance.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 3, "perturbed": true, "gc": "/*Given a string s and a lifelike number n, you have been tasked to implement \n   a affair that return a list of all bible from chain s that contain precisely \n   n consonant, in order these quarrel look in the string s.\n   If the bowed stringed instrument s is empty then the function should return an empty list.\n   Note: you may assume the stimulation drawstring contains merely letter and distance.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords2 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords3 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords4 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords5 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords6 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords7 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords8 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords9 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords10 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords11 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords12 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords13 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\nconst selectWords14 = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to detect the closest vowel that stand between \n   two consonant from the good english of the word (subject sensible). \n  \n   Vowels in the beginning and conclusion doesn't consider. Return empty string if you didn't \n   determine any vowel met the above condition. \n\n   You may assume that the give string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 3, "perturbed": true, "gc": "/*You are given a word. Your task is to detect the closest vowel that stand between \n   two consonant from the good english of the word (subject sensible). \n  \n   Vowels in the beginning and conclusion doesn't consider. Return empty string if you didn't \n   determine any vowel met the above condition. \n\n   You may assume that the give string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const consonants = ['a', 'e', 'i', 'o', 'u', 'y', 'w', 'x', 'z'];\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'y', 'w', 'x', 'z'];\n  const consonantIndex = consonants.indexOf(word[0]);\n  const vowelIndex = vowels.indexOf(word[word.length - 1]);\n  const consonantLength = consonantIndex + 1;\n  const vowelLength = vowelIndex + 1;\n  const min = Math.min(consonantLength, vowelLength);\n  const max = Math.max(consonantLength, vowelLength);\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  while (i < min) {\n    if (consonants[i] === word[j]) {\n      k = i;\n      break;\n    }\n    i++;\n  }\n  while (j < word.length - 1) {\n    if (vowels[j] === word[j + 1]) {\n      l = j;\n      break;\n    }\n    j++;\n  }\n  while (k < consonantLength) {\n    if (consonants[k] === word[j]) {\n      m = k;\n      break;\n    }\n    k++;\n  }\n  while (l < word.length - 1) {\n    if (vowels[l] === word[j + 1]) {\n      n = l;\n      break;\n    }\n    l++;\n  }\n  while (m < consonantLength) {\n    if (consonants[m] === word[j]) {\n      o = m;\n      break;\n    }\n    m++;\n  }\n  while (n < word.length - 1) {\n    if (vowels[n] === word[j + 1]) {\n      p = n;\n      break;\n    }\n    n++;\n  }\n  while (o < consonantLength) {\n    if (consonants[o] === word[j]) {\n      q = o;\n      break;\n    }\n    o++;\n  }\n  while (p < word.length - 1) {\n    if (vowels[p] === word[j + 1]) {\n      r = p;\n      break;\n    }\n    p++;\n  }\n  while (q < consonantLength) {\n    if (consonants[q] === word[j]) {\n      s = q;\n      break;\n    }\n    q++;\n  }\n  while (r < word.length - 1) {\n    if (vowels[r] === word[j + 1]) {\n      t = r;\n      break;\n    }\n    r++;\n  }\n  while (s < consonantLength) {\n    if (consonants[s] === word[j]) {\n      u = s;\n      break;\n    }\n    s++;\n  }\n  while (t < word.length - 1) {\n    if (vowels[t] === word[j + 1]) {\n      v = t;\n      break;\n    }\n    t++;\n  }\n  while (u < consonantLength) {\n    if (consonants[u] === word[j]) {\n      w = u;\n      break;\n    }\n    u++;\n  }\n  while (v < word.length - 1) {\n    if (vowels[v] === word[j + 1]) {\n      x = v;\n      break;\n    }\n    v++;\n  }\n  while (w < consonantLength) {\n    if (consonants[w] === word[j]) {\n      y = w;\n      break;\n    }\n    w++;\n  }\n  while (x < word.length - 1) {\n    if (vowels[x] === word[j + 1]) {\n      z = x;\n      break;\n    }\n    x++;\n  }\n  return word.slice(y, z + 1);\n};\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both string section consist of receptive \n   parenthesis' (' or cheeseparing parenthesis')' merely. \n   Your job is to match if it is potential to concatenate the two string in\n   some ordering, that the resulting drawstring will be good. \n   A drawstring S is consider to be good if and only if all parentheses in S \n   embody balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 3, "perturbed": true, "gc": "/* You are given a list of two strings, both string section consist of receptive \n   parenthesis' (' or cheeseparing parenthesis')' merely. \n   Your job is to match if it is potential to concatenate the two string in\n   some ordering, that the resulting drawstring will be good. \n   A drawstring S is consider to be good if and only if all parentheses in S \n   embody balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\n/*\n  Given a string S, return the longest string that is a concatenation of\n  parentheses.\n  Examples:\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()'\n  longestConcatenation('(())') == '()()", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in case of multiple \n   strings of the same duration. Return nothing in font the stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 3, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return the first one in case of multiple \n   strings of the same duration. Return nothing in font the stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return ''\n  }\n  let longest = strings[0]\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i]\n    }\n  }\n  return longest\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e'])\n  'e'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f'])\n  'e'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g'])\n  'g'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])\n  'g'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  'i'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n  'j'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'])\n  'k'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'])\n  'l'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m'])\n  'l'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n'])\n  'n'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o'])\n  'o'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p'])\n  'p'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q'])\n  'q'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r'])\n  'r'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s'])\n 's'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't'])\n 's'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u'])\n  't'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v'])\n  'v'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w'])\n  'w'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x'])\n  'x'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y'])\n  'y'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'])\n  'z'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g',", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integer and a positive integer k, return a sorted list \n   of duration k with the maximum k issue in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array arr of integer and a positive integer k, return a sorted list \n   of duration k with the maximum k issue in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const arrLength = arr.length\n  const max = arr[0]\n  const maxIndex = 0\n  const maxDuration = 0\n\n  for (let i = 0; i < arrLength; i++) {\n    if (arr[i] > max) {\n      max = arr[i]\n      maxIndex = i\n      maxDuration = i\n    }\n  }\n\n  const result = []\n  for (let i = 0; i < k; i++) {\n    result.push(arr[maxIndex - i])\n  }\n\n  return result\n}\n\nexport default maximum\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integers, return the sum of all of the curious element that cost in even situation.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 3, "perturbed": true, "gc": "/*Given a non - empty list of integers, return the sum of all of the curious element that cost in even situation.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non - empty array of integers arr and an integer k, return\n   the union of the element with at most two digit from the inaugural k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 3, "perturbed": true, "gc": "/*\n  Given a non - empty array of integers arr and an integer k, return\n   the union of the element with at most two digit from the inaugural k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements2 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements3 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements4 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements5 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements6 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements7 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements8 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements9 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements10 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements11 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements12 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements13 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements14 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements15 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements16 = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n};\n\nconst addElements17 = (arr, k) => {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd number in collatz succession. \n\n   The Collatz conjecture is a speculation in mathematics that refer a succession defined \n   as follows: start with any plus integer n. Then each condition is obtain from the \n   former terminus as follows: if the former condition is even, the following terminus is one half of \n   the former terminus. If the previous term is leftover, the next term is 3 clock time the former \n   condition plus 1. The guess is that no matter what value of n, the succession will always strive 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list screen in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive integer n, return a sorted list that has the odd number in collatz succession. \n\n   The Collatz conjecture is a speculation in mathematics that refer a succession defined \n   as follows: start with any plus integer n. Then each condition is obtain from the \n   former terminus as follows: if the former condition is even, the following terminus is one half of \n   the former terminus. If the previous term is leftover, the next term is 3 clock time the former \n   condition plus 1. The guess is that no matter what value of n, the succession will always strive 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list screen in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  const oddCollatz = [];\n  for (let i = 1; i < n; i++) {\n    const odd = collatz(i);\n    oddCollatz.push(odd);\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz2 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  const oddCollatz = [];\n  for (let i = 1; i < n; i++) {\n    const odd = collatz(i);\n    oddCollatz.push(odd);\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz3 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  const oddCollatz = [];\n  for (let i = 1; i < n; i++) {\n    const odd = collatz(i);\n    oddCollatz.push(odd);\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz4 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  const oddCollatz = [];\n  for (let i = 1; i < n; i++) {\n    const odd = collatz(i);\n    oddCollatz.push(odd);\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz5 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  const oddCollatz = [];\n  for (let i = 1; i < n; i++) {\n    const odd = collatz(i);\n    oddCollatz.push(odd);\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz6 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  const oddCollatz = [];\n  for (let i = 1; i < n; i++) {\n    const odd = collatz(i);\n    oddCollatz.push(odd);\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz7 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  const oddCollatz = [];\n  for (let i = 1; i < n; i++) {\n    const odd = collatz(i);\n    oddCollatz.push(odd);\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz8 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  const oddCollatz = [];\n  for (let i = 1; i < n; i++) {\n    const odd = collatz(i);\n    oddCollatz.push(odd);\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz9 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  const oddCollatz = [];\n  for (let i = 1; i < n; i++) {\n    const odd = collatz(i);\n    oddCollatz.push(odd);\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz10 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a affair which validates a give date chain and \n   recurrence truthful if the date embody valid differently delusive. \n   The date is valid if all of the following convention embody satisfied: \n   1. The date drawstring is not empty. \n   2. The number of day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or gamey than 30 days for month 4,6,9,11. And, the issue of day is not less than 1 or high than 29 for the month 2. \n   3. The months should not be less than 1 or high than 12. \n   4. The date should equal in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 3, "perturbed": true, "gc": "/*You have to write a affair which validates a give date chain and \n   recurrence truthful if the date embody valid differently delusive. \n   The date is valid if all of the following convention embody satisfied: \n   1. The date drawstring is not empty. \n   2. The number of day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or gamey than 30 days for month 4,6,9,11. And, the issue of day is not less than 1 or high than 29 for the month 2. \n   3. The months should not be less than 1 or high than 12. \n   4. The date should equal in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateArray = date.split('-');\n  const dateLength = dateArray.length;\n  const dateLengthMin = 1;\n  const dateLengthMax = 31;\n  const dateLengthDay = dateLengthMin;\n  const dateLengthMonth = 1;\n  const dateLengthYear = 2000;\n  const dateLengthMinMonth = 1;\n  const dateLengthMaxMonth = 12;\n  const dateLengthMinDay = 1;\n  const dateLengthMaxDay = 30;\n  const dateLengthMinYear = 2000;\n  const dateLengthMaxYear = 2020;\n  const dateLengthDayMin = 1;\n  const dateLengthDayMax = 29;\n  const dateLengthMonthMin = 1;\n  const dateLengthMonthMax = 12;\n  const dateLengthYearMin = 2000;\n  const dateLengthYearMax = 2020;\n  const dateLengthDayMinMonth = 1;\n  const dateLengthDayMaxMonth = 29;\n  const dateLengthYearMinMonth = 2000;\n  const dateLengthYearMaxMonth = 2020;\n  const dateLengthDayMinYear = 1;\n  const dateLengthDayMaxYear = 29;\n  const dateLengthMonthMin = 1;\n  const dateLengthMonthMax = 12;\n  const dateLengthYearMin = 2000;\n  const dateLengthYearMax = 2020;\n  const dateLengthDayMinMonthYear = 1;\n  const dateLengthDayMaxMonthYear = 29;\n  const dateLengthMonthMinYear = 2000;\n  const dateLengthMonthMaxYear = 2020;\n  const dateLengthDayMinMonthYearMin = 1;\n  const dateLengthDayMaxMonthYearMin = 29;\n  const dateLengthMonthMinYearMin = 2000;\n  const dateLengthMonthMaxYearMin = 2020;\n  const dateLengthDayMinMonthYearMax = 29;\n  const dateLengthDayMaxMonthYearMax = 29;\n  const dateLengthMonthMinYearMax = 2020;\n  const dateLengthMonthMaxYearMax = 2020;\n  const dateLengthDayMinMonthYearMaxMin = 1;\n  const dateLengthDayMaxMonthYearMaxMin = 29;\n  const dateLengthMonthMinYearMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMax = 29;\n  const dateLengthDayMaxMonthYearMaxMax = 29;\n  const dateLengthMonthMinYearMaxMax = 2020;\n  const dateLengthMonthMaxYearMaxMax = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMin = 1;\n  const dateLengthDayMaxMonthYearMaxMaxMin = 29;\n  const dateLengthMonthMinYearMaxMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMax = 29;\n  const dateLengthDayMaxMonthYearMaxMaxMax = 29;\n  const dateLengthMonthMinYearMaxMaxMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMaxMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMaxMax = 29;\n  const dateLengthDayMaxMonthYearMaxMaxMaxMax = 29;\n  const dateLengthMonthMinYearMaxMaxMaxMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMaxMaxMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMaxMax = 29;\n  const dateLengthDayMaxMonthYearMaxMaxMaxMax = 29;\n  const dateLengthMonthMinYearMaxMaxMaxMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMaxMaxMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMaxMaxMax = 29;\n  const dateLengthDayMaxMonthYearMaxMaxMaxMaxMax = 29;\n  const dateLengthMonthMinYearMaxMaxMaxMaxMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMaxMaxMaxMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMaxMaxMax = 29;\n  const dateLengthDayMaxMonthYearMaxMaxMaxMaxMax = 29;\n  const dateLengthMonthMinYearMaxMaxMaxMaxMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMaxMaxMaxMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMaxMaxMaxMax = 29;\n  const dateLengthDayMaxMonthYearMaxMaxMaxMaxMaxMax = 29;\n  const dateLengthMonthMinYearMaxMaxMaxMaxMaxMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMaxMaxMaxMaxMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMaxMaxMaxMaxMax = 29;\n  const dateLengthDayMaxMonthYearMaxMaxMaxMaxMaxMaxMax = 29;\n  const dateLengthMonthMinYearMaxMaxMaxMaxMaxMaxMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMaxMaxMaxMaxMaxMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMaxMaxMaxMaxMaxMax = 29;\n  const dateLengthDayMaxMonthYearMaxMaxMaxMaxMaxMaxMaxMax = 29;\n  const dateLengthMonthMinYearMaxMaxMaxMaxMaxMaxMaxMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMaxMaxMaxMaxMaxMaxMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMaxMaxMaxMaxMaxMaxMax = 29;\n  const dateLengthDayMaxMonthYearMaxMaxMaxMaxMaxMaxMaxMaxMax = 29;\n  const dateLengthMonthMinYearMaxMaxMaxMaxMaxMaxMaxMaxMaxMin = 2000;\n  const dateLengthMonthMaxYearMaxMaxMaxMaxMaxMaxMaxMaxMaxMin = 2020;\n  const dateLengthDayMinMonthYearMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 29;\n  const dateLengthDayMax", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of lyric, return a list of words separate on whitespace, if no whitespaces exist in the text you \n   should divide on comma',' if no commas exists you should return the issue of lower - lawsuit letter with odd club in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 3, "perturbed": true, "gc": "/* Given a string of lyric, return a list of words separate on whitespace, if no whitespaces exist in the text you \n   should divide on comma',' if no commas exists you should return the issue of lower - lawsuit letter with odd club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/*\n  Given a string of lyric, return a list of words separated on whitespace, if no whitespaces exist in the text you \n  should divide on comma',' if no commas exists you should return the issue of lower - lawsuit letter with odd club in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/*\n  Given a string of lyric, return a list of words separated on whitespace, if no whitespaces exist in the text you \n  should divide on comma',' if no commas exists you should return the issue of lower - lawsuit letter with odd club in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/*\n  Given a string of lyric, return a list of words separated on whitespace, if no whitespaces exist in the text you \n  should divide on comma',' if no commas exists you should return the issue of lower - lawsuit letter with odd club in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/*\n  Given a string of lyric, return a list of words separated on whitespace, if no whitespaces exist in the text you \n  should divide on comma',' if no commas exists you should return the issue of lower - lawsuit letter with odd club in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/*\n  Given a string of lyric, return a list of words separated on whitespace, if no whitespaces exist in the text you \n  should divide on comma',' if no commas exists you should return the issue of lower - lawsuit letter with odd club in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/*\n  Given a string of lyric, return a list of words separated on whitespace, if no whitespaces exist in the text you \n  should divide on comma',' if no commas exists you should return the issue of lower - lawsuit letter with odd club in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/*\n  Given a string of lyric, return a list of words separated on whitespace, if no whitespaces exist in the text you \n  should divide on comma',' if no commas exists you should return the issue of lower - lawsuit letter with odd club in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/*\n  Given a string of lyric, return a list of words separated on whitespace, if no whitespaces exist in the text you \n  should divide on comma',' if no commas exists you should return the issue of lower - lawsuit letter with odd club in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = t", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are screen \n   in ascending club. If list have more than 1 extra of the same \n   numeral, return false. wear no minus act and only integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 3, "perturbed": true, "gc": "/* Given a list of numbers, return whether or not they are screen \n   in ascending club. If list have more than 1 extra of the same \n   numeral, return false. wear no minus act and only integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\n/*\n  Given a list of numbers, return whether or not they are screen \n  in ascending club. If list have more than 1 extra of the same \n  numeral, return false. wear no minus act and only integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted2 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted3 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted4 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted5 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted6 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted7 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted8 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted9 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted10 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted11 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted12 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted13 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted14 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted15 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted16 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const hasDuplicates = sorted.length > 1 && sorted[0] === sorted[1];\n  return!hasDuplicates;\n};\n\nconst isSorted17 = (lst) => {\n  const sorted = lst.sort", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals, \n   where each interval is a pair of integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 3, "perturbed": true, "gc": "/*You are given two intervals, \n   where each interval is a pair of integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1[0] > interval2[1]) {\n    return \"NO\";\n  }\n  if (interval1[1] < interval2[0]) {\n    return \"NO\";\n  }\n  if (interval1[0] === interval2[0]) {\n    return \"YES\";\n  }\n  if (interval1[1] === interval2[1]) {\n    return \"YES\";\n  }\n  return \"NO\";\n};\n\nconsole.log(intersection((-3, -1), (-5, 5)));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integer and you need to return\n   sum of magnitudes of integer reproduce by merchandise of all augury \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   case:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 3, "perturbed": true, "gc": "/*\n  You are given an array arr of integer and you need to return\n   sum of magnitudes of integer reproduce by merchandise of all augury \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   case:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num\n  }\n  const sum = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num * sign(num)\n  }\n  const prod = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num * sign(num) * sum(num)\n  }\n  return arr.reduce((acc, num) => {\n    return acc + prod(num)\n  }, 0)\n}\n\n/*\n  You are given an array arr of integer and you need to return\n   sum of magnitudes of integer reproduce by merchandise of all augury \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   case:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns2 = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num\n  }\n  const sum = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num * sign(num)\n  }\n  const prod = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num * sign(num) * sum(num)\n  }\n  return arr.reduce((acc, num) => {\n    return acc + prod(num)\n  }, 0)\n}\n\n/*\n  You are given an array arr of integer and you need to return\n   sum of magnitudes of integer reproduce by merchandise of all augury \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   case:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns3 = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num\n  }\n  const sum = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num * sign(num)\n  }\n  const prod = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num * sign(num) * sum(num)\n  }\n  return arr.reduce((acc, num) => {\n    return acc + prod(num)\n  }, 0)\n}\n\n/*\n  You are given an array arr of integer and you need to return\n   sum of magnitudes of integer reproduce by merchandise of all augury \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   case:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns4 = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num\n  }\n  const sum = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num * sign(num)\n  }\n  const prod = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num * sign(num) * sum(num)\n  }\n  return arr.reduce((acc, num) => {\n    return acc + prod(num)\n  }, 0)\n}\n\n/*\n  You are given an array arr of integer and you need to return\n   sum of magnitudes of integer reproduce by merchandise of all augury \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   case:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns5 = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num\n  }\n  const sum = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n    return num * sign(num)\n  }\n  const prod = (num) => {\n    if (num === 0) return 0\n    if (num === 1) return 1\n    if (num === -1) return -1\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N column (N > = 2) and a positive integer k, \n   each cellular telephone of the grid check a value. Every integer in the stove [ 1, N * N ] \n   inclusive appear exactly once on the cell of the grid.\n\n   You have to determine the minimal path of duration k in the grid. You can begin \n   from any cell, and in each dance step you can move to any of the neighbor cell, \n   in early words, you can sound to cell which share an boundary with you current \n   cellular telephone. \n   Please notice that a way of duration k means visiting exactly k cells (not \n   inevitably discrete). \n   You CANNOT become off the grid.\n   A path A (of length k) is consider less than a path B (of length k) if \n   after reach the rate lists of the values on the cellular telephone that A and boron start \n   through (let's address them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in early words, there exist an integer exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guarantee that the answer is alone. \n   Return an ordered list of the values on the cells that the minimum way go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 3, "perturbed": true, "gc": "/*\n  Given a grid with N rows and N column (N > = 2) and a positive integer k, \n   each cellular telephone of the grid check a value. Every integer in the stove [ 1, N * N ] \n   inclusive appear exactly once on the cell of the grid.\n\n   You have to determine the minimal path of duration k in the grid. You can begin \n   from any cell, and in each dance step you can move to any of the neighbor cell, \n   in early words, you can sound to cell which share an boundary with you current \n   cellular telephone. \n   Please notice that a way of duration k means visiting exactly k cells (not \n   inevitably discrete). \n   You CANNOT become off the grid.\n   A path A (of length k) is consider less than a path B (of length k) if \n   after reach the rate lists of the values on the cellular telephone that A and boron start \n   through (let's address them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in early words, there exist an integer exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guarantee that the answer is alone. \n   Return an ordered list of the values on the cells that the minimum way go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [N, N] = grid.length;\n  const [lst_A, lst_B] = [new Array(N), new Array(N)];\n  for (let i = 0; i < N; i++) {\n    lst_A[i] = grid[i];\n    lst_B[i] = grid[i];\n  }\n  let min = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < N; i++) {\n    for (let j = i + 1; j < N; j++) {\n      const [a, b] = [lst_A[i], lst_A[j]];\n      const [c, d] = [lst_B[i], lst_B[j]];\n      const [e, f] = [a, b];\n      const [g, h] = [c, d];\n      const [i, j] = [e, f];\n      const [k, l] = [g, h];\n      const [m, n] = [i, j];\n      const [o, p] = [k, l];\n      const [q, r] = [m, n];\n      const [s, t] = [o, p];\n      const [u, v] = [q, r];\n      const [w, x] = [s, t];\n      const [y, z] = [u, v];\n      const [aa, bb] = [w, x];\n      const [cc, dd] = [y, z];\n      const [ee, ff] = [aa, bb];\n      const [gg, hh] = [cc, dd];\n      const [ii, jj] = [ee, ff];\n      const [kk, ll] = [gg, hh];\n      const [mm, nn] = [ii, jj];\n      const [oo, pp] = [kk, ll];\n      const [qq, rr] = [mm, nn];\n      const [ss, tt] = [oo, pp];\n      const [uu, vv] = [qq, rr];\n      const [ww, xx] = [ss, tt];\n      const [yy, zz] = [uu, vv];\n      const [aaa, bbb] = [ww, xx];\n      const [ccc, ddd] = [yy, zz];\n      const [eee, fff] = [aaa, bbb];\n      const [ggg, hhh] = [ccc, ddd];\n      const [iii, jjj] = [eee, fff];\n      const [kkk, lll] = [ggg, hhh];\n      const [mmm, nnn] = [iii, jjj];\n      const [oooo, ppp] = [kkk, lll];\n      const [qqq, rrr] = [mmm, nnn];\n      const [sss, ttt] = [oooo, ppp];\n      const [uuu, vvv] = [qqq, rrr];\n      const [www, xxx] = [sss, ttt];\n      const [yyy, zzz] = [uuu, vvv];\n      const [aaa, bbb] = [www, xxx];\n      const [ccc, ddd] = [yyy, zzz];\n      const [eee, fff] = [aaa, bbb];\n      const [ggg, hhh] = [ccc, ddd];\n      const [iii, jjj] = [eee, fff];\n      const [kkk, lll] = [ggg, hhh];\n      const [mmm, nnn] = [iii, jjj];\n      const [oooo, ppp] = [kkk, lll];\n      const [qqq, rrr] = [mmm, nnn];\n      const [sss, ttt] = [oooo, ppp];\n      const [uuu, vvv] = [qqq, rrr];\n      const [www, xxx] = [sss, ttt];\n      const [yyy, zzz] = [uuu, vvv];\n      const [aaa, bbb] = [www, xxx];\n      const [ccc, ddd] = [yyy, zzz];\n      const [eee, fff] = [aaa, bbb];\n      const [ggg, hhh] = [ccc, ddd];\n      const [iii, jjj] = [eee, fff];\n      const [kkk, lll] = [gg", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest coarse divisor of two integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 3, "perturbed": true, "gc": "/* Return a greatest coarse divisor of two integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor(b, a);\n  }\n  if (a > b) {\n    return greatestCommonDivisor(a, b);\n  }\n  return a;\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple2 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple3 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple4 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple5 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple6 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple7 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple8 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple9 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple10 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple11 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple12 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple13 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple14 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple15 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple16 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple17 = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/* Return a least common multiple of two integer a and b\n  >>> leastCommonMultiple(3, 5)\n  15\n  >>> leastCommonMultiple(25, 15)\n  25\n  */\nconst leastCommonMultiple18 = (a, b", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci succession, it was studied deeply by mathematicians in \n   the final couple century. However, what citizenry don't acknowledge is Tribonacci sequence. \n   Tribonacci sequence is define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 3, "perturbed": true, "gc": "/*Everyone knows Fibonacci succession, it was studied deeply by mathematicians in \n   the final couple century. However, what citizenry don't acknowledge is Tribonacci sequence. \n   Tribonacci sequence is define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let result = []\n  let i = 1\n  let j = 1\n  while (i <= n) {\n    result.push(j)\n    j = i + j\n    i = i + (i / 2)\n  }\n  return result\n}\n\nconsole.log(tri(3))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 3, "perturbed": true, "gc": "/*Given a positive integer n, return the product of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\nconsole.log(digits(1));\nconsole.log(digits(4));\nconsole.log(digits(235));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that take a string as input which contain merely straight bracket. \n   The affair should return true if and merely if there cost a valid subsequence of bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]')  dependable \n   isNested('[]]]]]]][[[[[]')  assumed \n   isNested('[][]')  false \n   isNested('[]')  delusive \n   isNested('[[][]]')  true \n   isNested('[[]][[')  dependable \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 3, "perturbed": true, "gc": "/*\n  Create a function that take a string as input which contain merely straight bracket. \n   The affair should return true if and merely if there cost a valid subsequence of bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]')  dependable \n   isNested('[]]]]]]][[[[[]')  assumed \n   isNested('[][]')  false \n   isNested('[]')  delusive \n   isNested('[[][]]')  true \n   isNested('[[]][[')  dependable \n   * / \n const isNested = (string) = > {\n  const isNested = (string) = > {\n    const isNested = (string) = > {\n      const isNested = (string) = > {\n        const isNested = (string) = > {\n          const isNested = (string) = > {\n            const isNested = (string) = > {\n              const isNested = (string) = > {\n                const isNested = (string) = > {\n                  const isNested = (string) = > {\n                    const isNested = (string) = > {\n                      const isNested = (string) = > {\n                        const isNested = (string) = > {\n                          const isNested = (string) = > {\n                            const isNested = (string) = > {\n                              const isNested = (string) = > {\n                                const isNested = (string) = > {\n                                  const isNested = (string) = > {\n                                    const isNested = (string) = > {\n                                      const isNested = (string) = > {\n                                        const isNested = (string) = > {\n                                          const isNested = (string) = > {\n                                            const isNested = (string) = > {\n                                              const isNested = (string) = > {\n                                                const isNested = (string) = > {\n                                                  const isNested = (string) = > {\n                                                    const isNested = (string) = > {\n                                                      const isNested = (string) = > {\n                                                        const isNested = (string) = > {\n                                                          const isNested = (string) = > {\n                                                           const isNested = (string) = > {\n                                                            const isNested = (string) = > {\n                                                            const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                             const isNested = (string) = > {\n                                                          ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers. \n   You necessitate to return the sum of squared number in the give list,\n   round each chemical element in the list to the upper int(Ceiling) foremost.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "/*You are given a list of numbers. \n   You necessitate to return the sum of squared number in the give list,\n   round each chemical element in the list to the upper int(Ceiling) foremost.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem * elem, 0);\n  return sum;\n};\n\nconst sumSquares2 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + Math.pow(elem, 2), 0);\n  return sum;\n};\n\nconst sumSquares3 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares4 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares5 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares6 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares7 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares8 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares9 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares10 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares11 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares12 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares13 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares14 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares15 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares16 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares17 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares18 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares19 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares20 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares21 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares22 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares23 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares24 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares25 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares26 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares27 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares28 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares29 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares30 = (lst) => {\n  const sum = lst.reduce((acc, elem) => acc + elem, 0);\n  return sum;\n};\n\nconst sumSquares31 = (lst) => {\n  const sum = lst.reduce((acc", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that return true if the final quality \n   of a give string embody an alphabetic character and is not \n   a share of a word, and fake differently. \n   Note: \" news \" is a group of characters separated by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 3, "perturbed": true, "gc": "/* Create a function that return true if the final quality \n   of a give string embody an alphabetic character and is not \n   a share of a word, and fake differently. \n   Note: \" news \" is a group of characters separated by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (isAlphabet(lastChar)) {\n    return true;\n  }\n  const lastCharIsNotALetter = txt.slice(-2) === \" \";\n  return!lastCharIsNotALetter;\n};\n\n/*\n  Create a function that return true if the final quality \n  of a give string embody an alphabetic character and is not \n  a share of a word, and fake differently. \n  Note: \" news \" is a group of characters separated by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (isAlphabet(lastChar)) {\n    return true;\n  }\n  const lastCharIsNotALetter = txt.slice(-2) === \" \";\n  return!lastCharIsNotALetter;\n};\n\n/*\n  Create a function that return true if the final quality \n  of a give string embody an alphabetic character and is not \n  a share of a word, and fake differently. \n  Note: \" news \" is a group of characters separated by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (isAlphabet(lastChar)) {\n    return true;\n  }\n  const lastCharIsNotALetter = txt.slice(-2) === \" \";\n  return!lastCharIsNotALetter;\n};\n\n/*\n  Create a function that return true if the final quality \n  of a give string embody an alphabetic character and is not \n  a share of a word, and fake differently. \n  Note: \" news \" is a group of characters separated by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (isAlphabet(lastChar)) {\n    return true;\n  }\n  const lastCharIsNotALetter = txt.slice(-2) === \" \";\n  return!lastCharIsNotALetter;\n};\n\n/*\n  Create a function that return true if the final quality \n  of a give string embody an alphabetic character and is not \n  a share of a word, and fake differently. \n  Note: \" news \" is a group of characters separated by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (isAlphabet(lastChar)) {\n    return true;\n  }\n  const lastCharIsNotALetter = txt.slice(-2) === \" \";\n  return!lastCharIsNotALetter;\n};\n\n/*\n  Create a function that return true if the final quality \n  of a give string embody an alphabetic character and is not \n  a share of a word, and fake differently. \n  Note: \" news \" is a group of characters separated by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (isAlphabet(lastChar)) {\n    return true;\n  }\n  const lastCharIsNotALetter = txt.slice(-2) === \" \";\n  return!lastCharIsNotALetter;\n};\n\n/*\n  Create a function that return true if the final quality \n  of a give string embody an alphabetic character and is not \n  a share of a word, and fake differently. \n  Note: \" news \" is a group of characters separated by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  if (isAlphabet(lastChar)) {\n    return true;\n  }\n  const lastCharIsNotALetter = txt.slice(-2) === \" \";\n  return!lastCharIsNotALetter;\n};\n\n/*\n  Create a", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which return the largest exponent of an component which \n   be not capital than or adequate to the component immediately precede it. If \n   no such chemical element exist then return -1. The given array will not check \n   duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 3, "perturbed": true, "gc": "/*Create a function which return the largest exponent of an component which \n   be not capital than or adequate to the component immediately precede it. If \n   no such chemical element exist then return -1. The given array will not check \n   duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  const arrLen = arr.length\n  if (arrLen === 0) return -1\n  const max = arr[0]\n  let maxExp = 0\n  for (let i = 1; i < arrLen; i++) {\n    const exp = arr[i]\n    if (exp > maxExp) {\n      maxExp = exp\n      max = arr[i]\n    }\n  }\n  return maxExp\n}\n\n/*\n  Given a string, return the number of occurrences of a given character.\n\n  Examples:\n  countChar('abc', 'a') = 3\n  countChar('abc', 'b') = 2\n  countChar('abc', 'c') = 1\n  countChar('abc', 'd') = 0\n  */\nconst countChar = (str, char) => {\n  const arr = str.split('')\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === char) count++\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of occurrences of a given substring.\n\n  Examples:\n  countSubstr('abc', 'ab') = 2\n  countSubstr('abc', 'bc') = 1\n  countSubstr('abc', 'ac') = 0\n  */\nconst countSubstr = (str, substr) => {\n  const arr = str.split('')\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === substr) count++\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of occurrences of a given substring.\n\n  Examples:\n  countSubstr('abc', 'ab') = 2\n  countSubstr('abc', 'bc') = 1\n  countSubstr('abc', 'ac') = 0\n  */\nconst countSubstr2 = (str, substr) => {\n  const arr = str.split('')\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === substr) count++\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of occurrences of a given substring.\n\n  Examples:\n  countSubstr('abc', 'ab') = 2\n  countSubstr('abc', 'bc') = 1\n  countSubstr('abc', 'ac') = 0\n  */\nconst countSubstr3 = (str, substr) => {\n  const arr = str.split('')\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === substr) count++\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of occurrences of a given substring.\n\n  Examples:\n  countSubstr('abc', 'ab') = 2\n  countSubstr('abc', 'bc') = 1\n  countSubstr('abc', 'ac') = 0\n  */\nconst countSubstr4 = (str, substr) => {\n  const arr = str.split('')\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === substr) count++\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of occurrences of a given substring.\n\n  Examples:\n  countSubstr('abc', 'ab') = 2\n  countSubstr('abc', 'bc') = 1\n  countSubstr('abc', 'ac') = 0\n  */\nconst countSubstr5 = (str, substr) => {\n  const arr = str.split('')\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === substr) count++\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of occurrences of a given substring.\n\n  Examples:\n  countSubstr('abc', 'ab') = 2\n  countSubstr('abc', 'bc') = 1\n  countSubstr('abc', 'ac') = 0\n  */\nconst countSubstr6 = (str, substr) => {\n  const arr = str.split('')\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === substr) count++\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of occurrences of a given substring.\n\n  Examples:\n  countSubstr('abc', 'ab') = 2\n  countSubstr('abc', 'bc') = 1\n  countSubstr('abc', 'ac') = 0\n  */\nconst countSubstr7 = (str, substr) => {\n  const arr = str.split('')\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === substr) count++\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of occurrences of a given substring.\n\n  Examples:\n  countSubstr('abc', 'ab') = 2\n  countSubstr('abc', 'bc') = 1\n  countSubstr('abc', 'ac') = 0\n  */\nconst countSubstr8 = (str, substr) => {\n  const arr = str.split('')\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === substr) count++\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of occurrences of a given substring.\n\n  Examples:\n  countSubstr('abc', 'ab') = 2\n  countSubstr('abc', 'bc') = 1\n  countSubstr('abc', 'ac') = 0\n  */\nconst countSubstr9 = (str, substr) => {\n  const arr = str.split(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that return a tuple (a, b), where 'a' be \n   the bombastic of damaging integer, and 'b' is the small \n   of incontrovertible integer in a list.\n   If there is no negative or positive integer, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 3, "perturbed": true, "gc": "/* Create a function that return a tuple (a, b), where 'a' be \n   the bombastic of damaging integer, and 'b' is the small \n   of incontrovertible integer in a list.\n   If there is no negative or positive integer, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  }\n  if (b === null) {\n    return [a, lst[0]];\n  }\n  return [a, b];", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that take integers, float, or chain constitute \n   actual number, and render the larger variable in its give varying character. \n   Return nothing if the values embody adequate. \n   Note: If a real phone number is map as a chain, the float decimal point might equal. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  null \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 3, "perturbed": true, "gc": "/*\n  Create a function that take integers, float, or chain constitute \n   actual number, and render the larger variable in its give varying character. \n   Return nothing if the values embody adequate. \n   Note: If a real phone number is map as a chain, the float decimal point might equal. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  null \n   * / \n const compareOne = (a, b) = > {\n   if (a > b) {\n     return a\n   } else if (a < b) {\n     return b\n   } else {\n     return null\n   }\n }\n\n/*\n  Create a function that take integers, float, or chain constitute \n   actual number, and render the larger variable in its give varying character. \n   Return nothing if the values embody adequate. \n   Note: If a real phone number is map as a chain, the float decimal point might equal. or, \n\n   compareTwo(1, 2.5)  2.5 \n   compareTwo(1, \" 2,3 \")  \" 2,3 \" \n   compareTwo(\"5,1\", \" 6 \")  \" 6 \" \n   compareTwo(\"1\", 1)  null \n   * / \n const compareTwo = (a, b) = > {\n   if (a > b) {\n     return b\n   } else if (a < b) {\n     return a\n   } else {\n     return null\n   }\n }\n\n/*\n  Create a function that take integers, float, or chain constitute \n   actual number, and render the larger variable in its give varying character. \n   Return nothing if the values embody adequate. \n   Note: If a real phone number is map as a chain, the float decimal point might equal. or, \n\n   compareThree(1, 2.5)  2.5 \n   compareThree(1, \" 2,3 \")  \" 2,3 \" \n   compareThree(\"5,1\", \" 6 \")  \" 6 \" \n   compareThree(\"1\", 1)  null \n   * / \n const compareThree = (a, b) = > {\n   if (a > b) {\n     return a\n   } else if (a < b) {\n     return b\n   } else {\n     return a\n   }\n }\n\n/*\n  Create a function that take integers, float, or chain constitute \n   actual number, and render the larger variable in its give varying character. \n   Return nothing if the values embody adequate. \n   Note: If a real phone number is map as a chain, the float decimal point might equal. or, \n\n   compareFour(1, 2.5)  2.5 \n   compareFour(1, \" 2,3 \")  \" 2,3 \" \n   compareFour(\"5,1\", \" 6 \")  \" 6 \" \n   compareFour(\"1\", 1)  null \n   * / \n const compareFour = (a, b) = > {\n   if (a > b) {\n     return b\n   } else if (a < b) {\n     return a\n   } else {\n     return a\n   }\n }\n\n/*\n  Create a function that take integers, float, or chain constitute \n   actual number, and render the larger variable in its give varying character. \n   Return nothing if the values embody adequate. \n   Note: If a real phone number is map as a chain, the float decimal point might equal. or, \n\n   compareFive(1, 2.5)  2.5 \n   compareFive(1, \" 2,3 \")  \" 2,3 \" \n   compareFive(\"5,1\", \" 6 \")  \" 6 \" \n   compareFive(\"1\", 1)  null \n   * / \n const compareFive = (a, b) = > {\n   if (a > b) {\n     return a\n   } else if (a < b) {\n     return b\n   } else {\n     return a\n   }\n }\n\n/*\n  Create a function that take integers, float, or chain constitute \n   actual number, and render the larger variable in its give varying character. \n   Return nothing if the values embody adequate. \n   Note: If a real phone number is map as a chain, the float decimal point might equal. or, \n\n   compareSix(1, 2.5)  2.5 \n   compareSix(1, \" 2,3 \")  \" 2,3 \" \n   compareSix(\"5,1\", \" 6 \")  \" 6 \" \n   compareSix(\"1\", 1)  null \n   * / \n const compareSix = (a, b) = > {\n   if (a > b) {\n     return b\n   } else if (a < b) {\n     return a\n   } else {\n     return a\n   }\n }\n\n/*\n  Create a function that take integers, float, or chain constitute \n   actual number, and render the larger variable in its give varying character. \n   Return nothing if the values embody adequate. \n   Note: If a real phone number is map as a chain, the float decimal point might equal. or, \n\n   compareSeven(1, 2.5)  2.5 \n   compareSeven(1, \" 2,3 \")  \" 2,3 \" \n   compareSeven(\"5,1\", \" 6 \")  \" 6 \" \n   compareSeven(\"1\", 1)  null \n   * / \n const compareSeven = (a, b) = > {\n   if (a > b) {\n     return a\n   } else if (a < b) {\n     return b\n   } else {\n     return a\n   }\n }\n\n/*\n  Create a function that take integers, float, or chain constitute \n   actual number, and render the larger variable in its give varying character. \n   Return nothing if the values embody adequate. \n   Note: If a real phone number is map as a chain, the float decimal point might equal. or, \n\n   compare", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given act n can be written as the union of precisely 4 convinced even number\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 3, "perturbed": true, "gc": "/*Evaluate whether the given act n can be written as the union of precisely 4 convinced even number\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 0;\n};\n\nexport default isEqualToSumEven;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For exemplar:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 3, "perturbed": true, "gc": "/*The Brazilian factorial is specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For exemplar:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3);\n};\n\n/*\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number of the fibonacci sequence.\n  */\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number of the fibonacci sequence.\n  */\nconst fibonacciRecursive = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number of the fibonacci sequence.\n  */\nconst fibonacciIterative = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  while (n > 2) {\n    c = a + b;\n    a = b;\n    b = c;\n    n -= 1;\n  }\n  return c;\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number of the fibonacci sequence.\n  */\nconst fibonacciRecursiveIterative = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  while (n > 2) {\n    c = a + b;\n    a = b;\n    b = c;\n    n -= 1;\n  }\n  return c;\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number of the fibonacci sequence.\n  */\nconst fibonacciIterativeRecursive = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  while (n > 2) {\n    c = a + b;\n    a = b;\n    b = c;\n    n -= 1;\n  }\n  return c;\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number of the fibonacci sequence.\n  */\nconst fibonacciIterativeRecursive2 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  while (n > 2) {\n    c = a + b;\n    a = b;\n    b = c;\n    n -= 1;\n  }\n  return c;\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number of the fibonacci sequence.\n  */\nconst fibonacciIterativeRecursive3 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  while (n > 2) {\n    c = a + b;\n    a = b;\n    b = c;\n    n -= 1;\n  }\n  return c;\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number of the fibonacci sequence.\n  */\nconst fibonacciIterativeRecursive4 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  while (n > 2) {\n    c = a + b;\n    a = b;\n    b = c;\n    n -= 1;\n  }\n  return c;\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number of the fibonacci sequence.\n  */\nconst fibonacciIterativeRecursive5 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  while (n > 2) {\n    c = a + b;\n    a = b;\n    b = c;\n    n -= 1;\n  }\n  return c;\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number of the fibonacci sequence.\n  */\nconst fibonacciIterativeRecursive6 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 3, "perturbed": false, "gc": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = []\n  const prefix = string.split('')\n  for (let i = 0; i < prefix.length; i++) {\n    const prefixString = prefix.slice(0, i + 1)\n    const prefixesString = prefixString.join('')\n    prefixes.push(prefixesString)\n  }\n  return prefixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixString = suffix.slice(i, string.length)\n    const suffixesString = suffixString.join('')\n    suffixes.push(suffixesString)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixString = suffix.slice(i, string.length)\n    const suffixesString = suffixString.join('')\n    suffixes.push(suffixesString)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixString = suffix.slice(i, string.length)\n    const suffixesString = suffixString.join('')\n    suffixes.push(suffixesString)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixString = suffix.slice(i, string.length)\n    const suffixesString = suffixString.join('')\n    suffixes.push(suffixesString)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixString = suffix.slice(i, string.length)\n    const suffixesString = suffixString.join('')\n    suffixes.push(suffixesString)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixString = suffix.slice(i, string.length)\n    const suffixesString = suffixString.join('')\n    suffixes.push(suffixesString)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixString = suffix.slice(i, string.length)\n    const suffixesString = suffixString.join('')\n    suffixes.push(suffixesString)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixString = suffix.slice(i, string.length)\n    const suffixesString = suffixString.join('')\n    suffixes.push(suffixesString)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixString = suffix.slice(i, string.length)\n    const suffixesString = suffixString.join('')\n    suffixes.push(suffixesString)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixString = suffix.slice(i", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 3, "perturbed": true, "gc": "/*\n  Given a string text, replace all spaces in it with underscores, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string text, replace all underscores with spaces, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example 1\"\n  fixSpaces(\" Example 2\") == \"Example 2\"\n  fixSpaces(\" Example   3\") == \"Example 3\"\n  */\nconst fixUnderscores = (text) => {\n  return text.replace(/_+/g,'')\n}\n\n/*\n  Given a string text, replace all underscores with spaces, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example 1\"\n  fixSpaces(\" Example 2\") == \"Example 2\"\n  fixSpaces(\" Example   3\") == \"Example 3\"\n  */\nconst fixUnderscoresAndSpaces = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\n/*\n  Given a string text, replace all underscores with spaces, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example 1\"\n  fixSpaces(\" Example 2\") == \"Example 2\"\n  fixSpaces(\" Example   3\") == \"Example 3\"\n  */\nconst fixUnderscoresAndSpacesAndHyphens = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all underscores with spaces, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example 1\"\n  fixSpaces(\" Example 2\") == \"Example 2\"\n  fixSpaces(\" Example   3\") == \"Example 3\"\n  */\nconst fixUnderscoresAndSpacesAndHyphensAndDashes = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all underscores with spaces, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example 1\"\n  fixSpaces(\" Example 2\") == \"Example 2\"\n  fixSpaces(\" Example   3\") == \"Example 3\"\n  */\nconst fixUnderscoresAndSpacesAndHyphensAndDashesAndQuotes = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all underscores with spaces, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example 1\"\n  fixSpaces(\" Example 2\") == \"Example 2\"\n  fixSpaces(\" Example   3\") == \"Example 3\"\n  */\nconst fixUnderscoresAndSpacesAndHyphensAndDashesAndQuotesAndQuotes = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all underscores with spaces, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example 1\"\n  fixSpaces(\" Example 2\") == \"Example 2\"\n  fixSpaces(\" Example   3\") == \"Example 3\"\n  */\nconst fixUnderscoresAndSpacesAndHyphensAndDashesAndQuotesAndQuotes = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all underscores with spaces, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example 1\"\n  fixSpaces(\" Example 2\") == \"Example 2\"\n  fixSpaces(\" Example   3\") == \"Example 3\"\n  */\nconst fixUnderscoresAndSpacesAndHyphensAndDashesAndQuotesAndQuotes = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all underscores with spaces, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example 1\"\n  fixSpaces(\" Example 2\") == \"Example 2\"\n  fixSpaces(\" Example   3\") == \"Example 3\"\n  */\nconst fixUnderscoresAndSpacesAndHyphensAndDashesAndQuotesAndQuotes = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all underscores with spaces, \n   and if a chain have more than 2 straight space, \n   then substitute all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example 1\"\n  fixSpaces(\" Example 2\") == \"Example 2\"\n  fixSpaces(\" Example   3\") == \"Example 3\"\n  */\nconst fixUnderscoresAndSpacesAndHyphensAndDashesAndQuotesAndQuotes = (text) =>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which take a string represent a file's name, and return \n  ' Yes' if the the file's name be valid, and returns' No' otherwise. \n   A file's name is study to exist valid if and entirely if all the following conditions \n   are meet: \n   - There should not cost more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one department of transportation'.' \n   - The substring before the dot should not be empty, and it get down with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the point should constitute one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 3, "perturbed": true, "gc": "/*Create a function which take a string represent a file's name, and return \n 'Yes' if the the file's name be valid, and returns' No' otherwise. \n   A file's name is study to exist valid if and entirely if all the following conditions \n   are meet: \n   - There should not cost more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one department of transportation'.' \n   - The substring before the dot should not be empty, and it get down with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the point should constitute one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regex = /^[a-zA-Z]{1}[a-zA-Z0-9]{1,3}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1,3}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-9]{1}[a-zA-Z]{1}[a-zA-Z0-9]{1}[0-", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integer. For all entries in the list, the function shall square the integer entrance if its exponent is a \n   multiple of 3 and will cube the integer entrance if its index exist a multiple of 4 and not a multiple of 3. The function will not \n   deepen the entry in the list whose index are not a multiple of 3 or 4. The routine shall then return the union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "/*\"\n  This function will take a list of integer. For all entries in the list, the function shall square the integer entrance if its exponent is a \n   multiple of 3 and will cube the integer entrance if its index exist a multiple of 4 and not a multiple of 3. The function will not \n   deepen the entry in the list whose index are not a multiple of 3 or 4. The routine shall then return the union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string represent a sentence,\n   the sentence contains some password discriminate by a quad, \n   and you receive to return a chain that control the words from the original sentence,\n   whose lengths be premier numbers, \n   the club of the words in the new chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a string represent a sentence,\n   the sentence contains some password discriminate by a quad, \n   and you receive to return a chain that control the words from the original sentence,\n   whose lengths be premier numbers, \n   the club of the words in the new chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(' ')\n  let newWords = []\n  let newWordsLength = 0\n  let newWordsIndex = 0\n  let word = ''\n  let wordLength = 0\n  let wordIndex = 0\n  let wordIndexLength = 0\n  let wordIndexLengthLength = 0\n  let wordIndexLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength length of the string\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthlength\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength length of the string\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthlength\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength length of the string\n  let wordIndexLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a affair that will simplify the expression \n   x * n. The routine render genuine if x * n measure to a solid number and assumed \n   differently. Both x and n, are string representation of a fraction, and own the follow format, \n   < numerator>/<denominator > where both numerator and denominator are cocksure whole numbers. \n\n   You can assume that x, and n are valid fraction, and do not induce zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = dependable \n   simplify(\"1/6\", \" 2/1 \") = assumed \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 3, "perturbed": true, "gc": "/*Your task is to implement a affair that will simplify the expression \n   x * n. The routine render genuine if x * n measure to a solid number and assumed \n   differently. Both x and n, are string representation of a fraction, and own the follow format, \n   < numerator>/<denominator > where both numerator and denominator are cocksure whole numbers. \n\n   You can assume that x, and n are valid fraction, and do not induce zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = dependable \n   simplify(\"1/6\", \" 2/1 \") = assumed \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n   let x = x.split(\"/\")\n   let n = n.split(\"/\")\n   if (x[0] == n[0]) {\n     return true\n   } else {\n     let x = parseInt(x[0])\n     let n = parseInt(n[0])\n     if (x % n == 0) {\n       return true\n     } else {\n       return false\n     }\n   }\n }\n */\n\nfunction simplify(x, n) {\n  let x = x.split(\"/\")\n  let n = n.split(\"/\")\n  if (x[0] == n[0]) {\n    return true\n  } else {\n    let x = parseInt(x[0])\n    let n = parseInt(n[0])\n    if (x % n == 0) {\n      return true\n    } else {\n      return false\n    }\n  }\n}\n\nconsole.log(simplify(\"1/5\", \" 5/1 \"))\nconsole.log(simplify(\"1/6\", \" 2/1 \"))\nconsole.log(simplify(\"7/10\", \" 10/2 \"))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which screen the given list of integer \n   in ascend ordering according to the kernel of their digits. \n   bill: if there cost several items with like kernel of their digits, \n   club them based on their index in master list.\n\n   For exemplar:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function which screen the given list of integer \n   in ascend ordering according to the kernel of their digits. \n   bill: if there cost several items with like kernel of their digits, \n   club them based on their index in master list.\n\n   For exemplar:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints2 = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints3 = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints4 = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints5 = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints6 = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints7 = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints8 = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints9 = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints10 = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints11 = (nums) => {\n  const master = []\n  for (let i = 0; i < nums.length; i++) {\n    master.push(nums[i])\n  }\n  const sorted = master.sort((a, b) => {\n    const aNum = a.toString().split('').reverse().join('')\n    const bNum = b.toString().split('').reverse().join('')\n    return aNum > bNum\n  })\n  return sorted\n}\n\nconst orderByPoints12 = (nums) => {\n  const master = []\n  for (let i = 0; i <", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that take an array of number as stimulation and recurrence \n   the act of element in the array that constitute capital than 10 and both \n   first and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 3, "perturbed": true, "gc": "/*Write a function that take an array of number as stimulation and recurrence \n   the act of element in the array that constitute capital than 10 and both \n   first and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const arr = nums.filter(n => n % 10 === 1 && n % 11 === 3 && n % 13 === 5 && n % 17 === 7 && n % 19 === 9)\n  return arr.length\n}\n\nconsole.log(specialFilter([15, -73, 14, -15]))\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of distance n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the numeral of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to create an integer array a of distance n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the numeral of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = new Array(n);\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1;\n  }\n  let max = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k]);\n        }\n      }\n    }\n  }\n  return max;\n};\n\nconsole.log(getMaxTriples(5));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar arrangement: the closerst to the Sun \n   be Mercury, the future one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write a affair that takes two satellite names as strings planet1 and planet2.\n   The routine should return a tuple containing all satellite whose orbit are \n   located between the scope of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function should return an empty tuple if planet1 or planet2\n   are not right satellite names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 3, "perturbed": true, "gc": "/* There are eight planets in our solar arrangement: the closerst to the Sun \n   be Mercury, the future one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write a affair that takes two satellite names as strings planet1 and planet2.\n   The routine should return a tuple containing all satellite whose orbit are \n   located between the scope of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function should return an empty tuple if planet1 or planet2\n   are not right satellite names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"];\n  const planet1Index = planets.indexOf(planet1);\n  const planet2Index = planets.indexOf(planet2);\n  const planet1Orbit = planet1Index + 1;\n  const planet2Orbit = planet2Index + 1;\n  const planet1OrbitLength = planet1Orbit - 1;\n  const planet2OrbitLength = planet2Orbit - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  const planet1OrbitLength = planet1OrbitLength - 1;\n  const planet2OrbitLength = planet2OrbitLength - 1;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accept a list of strings as a argument, \n   erase the string that hold leftover length from it, \n   and return the result list with a sorted order, \n   The list is constantly a list of string and never an array of number, \n   and it may contain extra. \n   The order of the list should be ascending by distance of each word, and you \n   should return the list sorted by that rule. \n   If two parole induce the same distance, sort the list alphabetically. \n   The function should return a list of strings in classify order. \n   You may assume that all discussion will induce the same duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 3, "perturbed": true, "gc": "/*Write a function that accept a list of strings as a argument, \n   erase the string that hold leftover length from it, \n   and return the result list with a sorted order, \n   The list is constantly a list of string and never an array of number, \n   and it may contain extra. \n   The order of the list should be ascending by distance of each word, and you \n   should return the list sorted by that rule. \n   If two parole induce the same distance, sort the list alphabetically. \n   The function should return a list of strings in classify order. \n   You may assume that all discussion will induce the same duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let result = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  for (let i = 0; i < lst.length; i++) {\n    result.push(lst[i]);\n    if (sum > lst[i].length) {\n      result.splice(i, 1);\n      sum -= lst[i].length;\n    }\n  }\n  return result;\n};\n\nconst list_sort = (lst) => {\n  let result = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  for (let i = 0; i < lst.length; i++) {\n    result.push(lst[i]);\n    if (sum > lst[i].length) {\n      result.splice(i, 1);\n      sum -= lst[i].length;\n    }\n  }\n  return result;\n};\n\nconst list_sort_by_distance = (lst) => {\n  let result = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  for (let i = 0; i < lst.length; i++) {\n    result.push(lst[i]);\n    if (sum > lst[i].length) {\n      result.splice(i, 1);\n      sum -= lst[i].length;\n    }\n  }\n  return result;\n};\n\nconst list_sort_by_alphabet = (lst) => {\n  let result = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  for (let i = 0; i < lst.length; i++) {\n    result.push(lst[i]);\n    if (sum > lst[i].length) {\n      result.splice(i, 1);\n      sum -= lst[i].length;\n    }\n  }\n  return result;\n};\n\nconst list_sort_by_distance_and_alphabet = (lst) => {\n  let result = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  for (let i = 0; i < lst.length; i++) {\n    result.push(lst[i]);\n    if (sum > lst[i].length) {\n      result.splice(i, 1);\n      sum -= lst[i].length;\n    }\n  }\n  return result;\n};\n\nconst list_sort_by_distance_and_alphabet_with_extra = (lst) => {\n  let result = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  for (let i = 0; i < lst.length; i++) {\n    result.push(lst[i]);\n    if (sum > lst[i].length) {\n      result.splice(i, 1);\n      sum -= lst[i].length;\n    }\n  }\n  return result;\n};\n\nconst list_sort_by_distance_and_alphabet_with_extra_with_extra = (lst) => {\n  let result = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  for (let i = 0; i < lst.length; i++) {\n    result.push(lst[i]);\n    if (sum > lst[i].length) {\n      result.splice(i, 1);\n      sum -= lst[i].length;\n    }\n  }\n  return result;\n};\n\nconst list_sort_by_distance_and_alphabet_with_extra_with_extra_with_extra = (lst) => {\n  let result = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  for (let i = 0; i < lst.length; i++) {\n    result.push(lst[i]);\n    if (sum > lst[i].length) {\n      result.splice(i, 1);\n      sum -= lst[i].length;\n    }\n  }\n  return result;\n};\n\nconst list_sort_by_distance_and_alphabet_with_extra_with_extra_with_extra_with_extra = (lst) => {\n  let result = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  for (let i = 0; i < lst.length; i++) {\n    result.push(lst[i]);\n    if (sum > lst[i].length) {\n      result.splice(i, 1);\n      sum -= lst[i].length;\n    }\n  }\n  return result;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 3, "perturbed": true, "gc": "/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence2 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence3 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence4 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence5 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence6 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence7 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence8 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence9 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence10 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence11 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence12 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence13 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/* Return a string incorporate space - subtend numeral get down from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence14 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n   a prime numeral and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 3, "perturbed": true, "gc": "/*A simple program which should return the value of x if n is \n   a prime numeral and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n === 3) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  let i = 5;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 6;\n  }\n  return true;\n};\n\nconst xOrYPrime = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime2 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime3 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime4 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime5 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime6 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime7 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime8 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime9 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime10 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime11 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime12 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime13 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime14 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime15 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime16 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime17 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime18 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime19 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime20 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime21 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime22 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime23 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime24 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime25 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime26 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime27 = (n, x, y) => {\n  if (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the kernel of squares of the number \n   in the list that be curious. Ignore number that be damaging or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 3, "perturbed": true, "gc": "/* Given a list of numbers, return the kernel of squares of the number \n   in the list that be curious. Ignore number that be damaging or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let {length} = lst\n   if {length} = 0 {\n     return 0\n   }\n   let {sum} = {\n     let {difference} = {\n       let {i} = 0\n       while {i} < {length} {\n         let {n} = {\n           let {n1} = {\n             let {n2} = {\n               let {n3} = {\n                 let {n4} = {\n                   let {n5} = {\n                     let {n6} = {\n                       let {n7} = {\n                         let {n8} = {\n                           let {n9} = {\n                             let {n10} = {\n                               let {n11} = {\n                                 let {n12} = {\n                                    let {n13} = {\n                                       let {n14} = {\n                                          let {n15} = {\n                                            let {n16} = {\n                                              let {n17} = {\n                                                let {n18} = {\n                                                  let {n19} = {\n                                                    let {n20} = {\n                                                      let {n21} = {\n                                                        let {n22} = {\n                                                          let {n23} = {\n                                                            let {n24} = {\n                                                              let {n25} = {\n                                                                let {n26} = {\n                                                                  let {n27} = {\n                                                                     let {n28} = {\n                                                                      let {n29} = {\n                                                                        let {n30} = {\n                                                                          let {n31} = {\n                                                                            let {n32} = {\n                                                                               let {n33} = {\n                                                                              let {n34} = {\n                                                                                let {n35} = {\n                                                                                  let {n36} = {\n                                                                                    let {n37} = {\n                                                                                       let {n38} = {\n                                                                                          let {n39} = {\n                                                                                            let {n40} = {\n                                                                                             let {n41} = {\n                                                                                               let {n42} = {\n                                                                                                let {n43} = {\n                                                                                                   let {n44} = {\n                                                                                                    let {n45} = {\n                                                                                                      let {n46} = {\n                                                                                                         let {n47} = {\n                                                                                                           let {n48} = {\n                                                                                                             let {n49} = {\n                                                                                                                let {n50} = {\n                                                                                                                let {n51} = {\n                                                                                                                   let {n52} = {\n                                                                                                                       let {n53} = {\n                                                                                                                          let {n54} = {\n                                                                                                                          let {n55} = {\n                                                                                                                           let {n56} = {\n                                                                                                                              let {n57} = {\n                                                                                                                              let {n58} = {\n                                                                                                                              }\n                                                                                                                            }\n                                                                                                                          }\n                                                                                                                          }\n                                                                                                                          }\n                                                                                                                       }\n                                                                                                                     }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                                                                                                                   }\n                               ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that impression when the solution of some long - expect \n   consequence is finally know. The spirit and thoughts you have at that consequence are \n   definitely deserving noting down and compare. \n   Your undertaking is to specify if a person correctly estimate the resultant role of a number of matches. \n   You are given two array of score and guesses of adequate distance, where each index shows a catch. \n   Return an array of the same length denote how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 3, "perturbed": true, "gc": "/*I think we all remember that impression when the solution of some long - expect \n   consequence is finally know. The spirit and thoughts you have at that consequence are \n   definitely deserving noting down and compare. \n   Your undertaking is to specify if a person correctly estimate the resultant role of a number of matches. \n   You are given two array of score and guesses of adequate distance, where each index shows a catch. \n   Return an array of the same length denote how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let result = []\n  for (let i = 0; i < game.length; i++) {\n    let score = game[i]\n    let guess = guess[i]\n    let diff = Math.abs(score - guess)\n    result.push(diff)\n  }\n  return result\n}\n\n/*\n  Given a number n, return the number of trailing zeros in n.\n  \n  example:\n\n  trailingZeros(5) -> 2\n  trailingZeros(4) -> 0\n  trailingZeros(3) -> 1\n  trailingZeros(2) -> 0\n  trailingZeros(1) -> 0\n  trailingZeros(0) -> 0\n  trailingZeros(-1) -> 1\n  trailingZeros(-2) -> 2\n  trailingZeros(-3) -> 3\n  trailingZeros(-4) -> 4\n  trailingZeros(-5) -> 5\n  trailingZeros(-6) -> 6\n  trailingZeros(-7) -> 7\n  trailingZeros(-8) -> 8\n  trailingZeros(-9) -> 9\n  trailingZeros(-10) -> 10\n  trailingZeros(-11) -> 11\n  trailingZeros(-12) -> 12\n  trailingZeros(-13) -> 13\n  trailingZeros(-14) -> 14\n  trailingZeros(-15) -> 15\n  trailingZeros(-16) -> 16\n  trailingZeros(-17) -> 17\n  trailingZeros(-18) -> 18\n  trailingZeros(-19) -> 19\n  trailingZeros(-20) -> 20\n  trailingZeros(-21) -> 21\n  trailingZeros(-22) -> 22\n  trailingZeros(-23) -> 23\n  trailingZeros(-24) -> 24\n  trailingZeros(-25) -> 25\n  trailingZeros(-26) -> 26\n  trailingZeros(-27) -> 27\n  trailingZeros(-28) -> 28\n  trailingZeros(-29) -> 29\n  trailingZeros(-30) -> 30\n  trailingZeros(-31) -> 31\n  trailingZeros(-32) -> 32\n  trailingZeros(-33) -> 33\n  trailingZeros(-34) -> 34\n  trailingZeros(-35) -> 35\n  trailingZeros(-36) -> 36\n  trailingZeros(-37) -> 37\n  trailingZeros(-38) -> 38\n  trailingZeros(-39) -> 39\n  trailingZeros(-40) -> 40\n  trailingZeros(-41) -> 41\n  trailingZeros(-42) -> 42\n  trailingZeros(-43) -> 43\n  trailingZeros(-44) -> 44\n  trailingZeros(-45) -> 45\n  trailingZeros(-46) -> 46\n  trailingZeros(-47) -> 47\n  trailingZeros(-48) -> 48\n  trailingZeros(-49) -> 49\n  trailingZeros(-50) -> 50\n  trailingZeros(-51) -> 51\n  trailingZeros(-52) -> 52\n  trailingZeros(-53) -> 53\n  trailingZeros(-54) -> 54\n  trailingZeros(-55) -> 55\n  trailingZeros(-56) -> 56\n  trailingZeros(-57) -> 57\n  trailingZeros(-58) -> 58\n  trailingZeros(-59) -> 59\n  trailingZeros(-60) -> 60\n  trailingZeros(-61) -> 61\n  trailingZeros(-62) -> 62\n  trailingZeros(-63) -> 63\n  trailingZeros(-64) -> 64\n  trailingZeros(-65) -> 65\n  trailingZeros(-66) -> 66\n  trailingZeros(-67) -> 67\n  trailingZeros(-68) -> 68\n  trailingZeros(-69) -> 69\n  trailingZeros(-70) -> 70\n  trailingZeros(-71) -> 71\n  trailingZeros(-72) -> 72\n  trailingZeros(-73) -> 73\n  trailingZeros(-74) -> 74\n  trailingZeros(-75) -> 75\n  trailingZeros(-76) -> 76\n  trailingZeros(-77) -> 77\n  trailingZeros(-78) -> 78\n  trailingZeros(-79) -> 79\n  trailingZeros(-80) -> 80\n  trailingZeros(-81) -> 81\n  trailingZeros(-82) -> 82\n  trailingZeros(-83) -> 83\n  trailingZeros(-84) -> 84\n  trailingZeros(-85) -> 85\n  trailingZeros(-86) -> 86\n  trailingZeros(-87) -> 87\n  trailingZeros(-88) -> 88\n  trailingZeros(-89) -> 89\n  trailingZeros(-90) -> 90\n  trailingZeros(-91) -> 91\n  trailingZeros(-92) -> 92\n  trailingZeros(-93) -> 93\n  trailingZeros(-94) -> 94\n  trailingZeros(-95) -> 95\n  trailingZeros(-96) -> 96\n  trailingZeros(-97) -> 97\n  trailingZeros(-98) -> 98\n  trailingZeros(-99) -> 99\n  trailingZeros(-100) -> 100\n  trailingZeros(-101) -> 101\n  trailingZeros(-102) -> 102\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a course (a string) and a list of extensions.\n   The extensions are to be used to load extra class to the course. The \n   strength of the elongation is as follows: lease CAP cost the number of the uppercase \n   letter in the propagation's name, and get SM be the number of small letter letters \n   in the extension's name, the military capability is given by the fraction CAP - SM. \n   You should recover the solid extension and return a drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same military capability, you should \n   choose the one that comes foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 3, "perturbed": true, "gc": "/*You will be given the name of a course (a string) and a list of extensions.\n   The extensions are to be used to load extra class to the course. The \n   strength of the elongation is as follows: lease CAP cost the number of the uppercase \n   letter in the propagation's name, and get SM be the number of small letter letters \n   in the extension's name, the military capability is given by the fraction CAP - SM. \n   You should recover the solid extension and return a drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same military capability, you should \n   choose the one that comes foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  const strongestExtension = {};\n  const strongestExtensionName = '';\n  const strongestExtensionStrength = 0;\n  const strongestExtensionCap = 0;\n  const strongestExtensionSM = 0;\n  const strongestExtensionExtension = '';\n  const strongestExtensionExtensionStrength = 0;\n  const strongestExtensionExtensionCap = 0;\n  const strongestExtensionExtensionSM = 0;\n  extensions.forEach(extension => {\n    strength[extension.toUpperCase()] = strength[extension.toUpperCase()] || 0;\n    strength[extension.toUpperCase()]++;\n    const extensionCap = strength[extension.toUpperCase()] - strength[extension.toUpperCase().toUpperCase()];\n    const extensionSM = strength[extension.toUpperCase()] - strength[extension.toUpperCase().toLowerCase()];\n    if (extensionCap > strongestExtensionCap) {\n      strongestExtensionCap = extensionCap;\n      strongestExtensionName = extension;\n      strongestExtensionStrength = strength[extension.toUpperCase()];\n      strongestExtensionSM = strength[extension.toUpperCase().toLowerCase()];\n    }\n    if (extensionSM > strongestExtensionSM) {\n      strongestExtensionSM = extensionSM;\n      strongestExtensionExtension = extension;\n      strongestExtensionExtensionStrength = strength[extension.toUpperCase()];\n      strongestExtensionExtensionCap = strength[extension.toUpperCase().toUpperCase()];\n    }\n  });\n  return `${class_name}.${strongestExtensionName}`;\n};\n\nmodule.exports = strongestExtension;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You necessitate to return true if the second discussion or any of its rotation be a substring in the inaugural parole \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > assumed \n   cycpatternCheck(\"abab\",\"baa\") = > genuine \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > on-key \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 3, "perturbed": true, "gc": "/*You are given 2 words. You necessitate to return true if the second discussion or any of its rotation be a substring in the inaugural parole \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > assumed \n   cycpatternCheck(\"abab\",\"baa\") = > genuine \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > on-key \n   * / \n const cycpatternCheck = (a, b) = > {\n   let a = a.split(\"\");\n   let b = b.split(\"\");\n   let i = 0;\n   while (i < a.length) {\n     if (a[i] === b[i]) {\n       i++;\n     } else {\n       return false;\n     }\n   }\n   return true;\n }\n */\n\nfunction cycpatternCheck(a, b) {\n    let a = a.split(\"\");\n    let b = b.split(\"\");\n    let i = 0;\n    while (i < a.length) {\n        if (a[i] === b[i]) {\n            i++;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nconsole.log(cycpatternCheck(\"abcd\", \"abd\"));\nconsole.log(cycpatternCheck(\"hello\", \"ell\"));\nconsole.log(cycpatternCheck(\"whassup\", \"psus\"));\nconsole.log(cycpatternCheck(\"abab\", \"baa\"));\nconsole.log(cycpatternCheck(\"efef\", \"eeff\"));\nconsole.log(cycpatternCheck(\"himenss\", \"simen\"));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that have the number of even and leftover digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 3, "perturbed": true, "gc": "/*Given an integer. return a tuple that have the number of even and leftover digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [count, odd];\n};\n\nexport default evenOddCount;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a chain, \n   and return it in small letter. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a chain, \n   and return it in small letter. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let roman = ['M', 'D', 'C', 'L', 'X', 'V', 'I']\n  let result = ''\n  let i = 0\n  while (number > 0) {\n    while (number % 10 == 0) {\n      number = number / 10\n      result = roman[i] + result\n    }\n    number = number % 10\n    i++\n  }\n  return result\n}\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a chain, \n   and return it in small letter. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let roman = ['M', 'D', 'C', 'L', 'X', 'V', 'I']\n  let result = ''\n  let i = 0\n  while (number > 0) {\n    while (number % 1000 == 0) {\n      number = number / 1000\n      result = roman[i] + result\n    }\n    number = number % 1000\n    i++\n  }\n  return result\n}\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a chain, \n   and return it in small letter. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman2 = (number) => {\n  let roman = ['M', 'D', 'C', 'L', 'X', 'V', 'I']\n  let result = ''\n  let i = 0\n  while (number > 0) {\n    while (number % 100 == 0) {\n      number = number / 100\n      result = roman[i] + result\n    }\n    number = number % 100\n    i++\n  }\n  return result\n}\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a chain, \n   and return it in small letter. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman3 = (number) => {\n  let roman = ['M', 'D', 'C', 'L', 'X', 'V', 'I']\n  let result = ''\n  let i = 0\n  while (number > 0) {\n    while (number % 10 == 0) {\n      number = number / 10\n      result = roman[i] + result\n    }\n    number = number % 10\n    i++\n  }\n  return result\n}\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a chain, \n   and return it in small letter. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman4 = (number) => {\n  let roman = ['M', 'D', 'C', 'L', 'X', 'V', 'I']\n  let result = ''\n  let i = 0\n  while (number > 0) {\n    while (number % 100 == 0) {\n      number = number / 100\n      result = roman[i] + result\n    }\n    number = number % 100\n    i++\n  }\n  return result\n}\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a chain, \n   and return it in small letter. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman5 = (number) => {\n  let roman = ['M', 'D', 'C', 'L', 'X', 'V', 'I']\n  let result = ''\n  let i = 0\n  while (number > 0) {\n    while (number % 1000 == 0) {\n      number = number / 1000\n      result = roman[i] + result\n    }\n    number = number % 1000\n    i++\n  }\n  return result\n}\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a chain, \n   and return it in small letter. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman6 = (number) => {\n  let roman = ['M', 'D', 'C', 'L', 'X', 'V', 'I']\n  let result = ''\n  let i = 0\n  while (number > 0) {\n    while (number % 100 == 0) {\n      number = number / 100\n      result = roman[i] + result\n    }\n    number = number % 100\n    i++\n  }\n  return result\n}\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a chain, \n   and return it in small letter. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three side of a triangle. render dependable if the three \n   side form a justly - angled triangulum, false otherwise. \n   A correctly - angled triangulum is a triangle in which one slant is right slant or \n   90 academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 3, "perturbed": true, "gc": "/*\n Given the lengths of the three side of a triangle. render dependable if the three \n   side form a justly - angled triangulum, false otherwise. \n   A correctly - angled triangulum is a triangle in which one slant is right slant or \n   90 academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  if (a === b && b === c) {\n    return true\n  }\n  if (a === b || b === c || a === c) {\n    return false\n  }\n  if (a === c) {\n    return (b > c)\n  }\n  if (b === c) {\n    return (a > c)\n  }\n  if (a === b) {\n    return (b > c)\n  }\n  return (a > b)\n}\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle2 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle3 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle4 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle5 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle6 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle7 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle8 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle9 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle10 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle11 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle12 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle13 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle14 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle15 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle16 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle17 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle18 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle19 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle20 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle21 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle22 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle23 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle24 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle25 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle26 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle27 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle28 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle29 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle30 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle31 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle32 = (a, b, c) => {\n  return!rightAngleTriangle(a, b, c)\n}\n\nconst isNotRightAngleTriangle33 = (a, b,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accept a list of strings. \n   The list contain unlike words. Return the news with maximum numeral \n   of unique character. If multiple strings have maximum phone number of alone \n   characters, return the one which fall first in lexicographical orderliness. \n\n   findMax([\"name\", \" of \", \" chain \" ]) = = = \" chain \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 3, "perturbed": true, "gc": "/*Write a function that accept a list of strings. \n   The list contain unlike words. Return the news with maximum numeral \n   of unique character. If multiple strings have maximum phone number of alone \n   characters, return the one which fall first in lexicographical orderliness. \n\n   findMax([\"name\", \" of \", \" chain \" ]) = = = \" chain \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   const words = words.sort((a, b) => a.length - b.length);\n   const max = words[0];\n   for (let i = 1; i < words.length; i++) {\n     if (words[i].length > max.length) {\n       max = words[i];\n     }\n   }\n   return max;\n }\n*/\n\nconst findMax = (words) => {\n  const words = words.sort((a, b) => a.length - b.length);\n  const max = words[0];\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n    }\n  }\n  return max;\n};\n\nconsole.log(findMax([\"name\", \" of \", \" chain \"]));\nconsole.log(findMax([\"name\", \" enam \", \" game \"]));\nconsole.log(findMax([\"aaaaaaa\", \" bb \", \" milliliter \"]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry lapin, and you already have eaten a certain number of carrot, \n   but nowadays you need to eat more carrot to dispatch the sidereal day's meal. \n   you should return an array of [ total number of eat carrots after your meal, \n                                   the number of carrot left after your meal ] \n   if there are not enough remaining carrot, you will eat all remaining carrot, but will even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 3, "perturbed": true, "gc": "/*\n  You're a hungry lapin, and you already have eaten a certain number of carrot, \n   but nowadays you need to eat more carrot to dispatch the sidereal day's meal. \n   you should return an array of [ total number of eat carrots after your meal, \n                                   the number of carrot left after your meal ] \n   if there are not enough remaining carrot, you will eat all remaining carrot, but will even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining];\n  } else {\n    return [number, remaining - number];\n  }\n}\n\nconst test = (number, need, remaining) => {\n  const [eat, remaining] = eat(number, need, remaining);\n  console.log(`eat ${number} carrots, remaining ${remaining}`);\n}\n\ntest(5, 6, 10);\ntest(4, 8, 9);\ntest(1, 10, 10);\ntest(2, 11, 5);\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of casing) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 3, "perturbed": true, "gc": "/* Given a string, find out how many distinct characters (regardless of casing) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const chars = string.split('')\n  const map = new Map()\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (!map.has(char)) {\n      map.set(char, 1)\n    } else {\n      map.set(char, map.get(char) + 1)\n    }\n  }\n  return map.size\n}\n\n/*\n  Given a string, find out how many distinct characters (regardless of casing) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters2 = (string) => {\n  const chars = string.split('')\n  const map = new Map()\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (!map.has(char)) {\n      map.set(char, 1)\n    } else {\n      map.set(char, map.get(char) + 1)\n    }\n  }\n  return map.size\n}\n\n/*\n  Given a string, find out how many distinct characters (regardless of casing) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters3 = (string) => {\n  const chars = string.split('')\n  const map = new Map()\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (!map.has(char)) {\n      map.set(char, 1)\n    } else {\n      map.set(char, map.get(char) + 1)\n    }\n  }\n  return map.size\n}\n\n/*\n  Given a string, find out how many distinct characters (regardless of casing) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters4 = (string) => {\n  const chars = string.split('')\n  const map = new Map()\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (!map.has(char)) {\n      map.set(char, 1)\n    } else {\n      map.set(char, map.get(char) + 1)\n    }\n  }\n  return map.size\n}\n\n/*\n  Given a string, find out how many distinct characters (regardless of casing) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters5 = (string) => {\n  const chars = string.split('')\n  const map = new Map()\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (!map.has(char)) {\n      map.set(char, 1)\n    } else {\n      map.set(char, map.get(char) + 1)\n    }\n  }\n  return map.size\n}\n\n/*\n  Given a string, find out how many distinct characters (regardless of casing) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters6 = (string) => {\n  const chars = string.split('')\n  const map = new Map()\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (!map.has(char)) {\n      map.set(char, 1)\n    } else {\n      map.set(char, map.get(char) + 1)\n    }\n  }\n  return map.size\n}\n\n/*\n  Given a string, find out how many distinct characters (regardless of casing) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters7 = (string) => {\n  const chars = string.split('')\n  const map = new Map()\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (!map.has(char)) {\n      map.set(char, 1)\n    } else {\n      map.set(char, map.get(char) + 1)\n    }\n  }\n  return map.size\n}\n\n/*\n  Given a string, find out how many distinct characters (regardless of casing) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters8 = (string) => {\n  const chars = string.split('')\n  const map = new Map()\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (!map.has(char)) {\n      map.set(char, 1)\n    } else {\n      map.set(char, map.get(char) + 1)\n    }\n  }\n  return map.size\n}\n\n/*\n  Given a string, find out how many distinct characters (regardless of casing) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters9 = (string) => {\n  const chars = string.split('')\n  const map = new Map()\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (!map.has(char)) {\n      map.set(char, 1)\n    } else {\n      map.set(char, map.get(char) +", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The inaugural list has basic algebra operation, and \n   the second list cost a list of integer. practice the two give lists to build the algebric \n   expression and return the evaluation of this formulation. \n\n   The basic algebra operation: \n   Addition (+) \n   Subtraction (-) \n   generation (*) \n   Floor division (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 3, "perturbed": true, "gc": "/*\n  Given two lists operator, and operand. The inaugural list has basic algebra operation, and \n   the second list cost a list of integer. practice the two give lists to build the algebric \n   expression and return the evaluation of this formulation. \n\n   The basic algebra operation: \n   Addition (+) \n   Subtraction (-) \n   generation (*) \n   Floor division (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const len = operator.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const opLen = operand.length\n    const opIndex = operand.indexOf(op)\n    if (opIndex === -1) {\n      throw new Error(`Operand ${op} not found in operand list`)\n    }\n    const opValue = operand[opIndex]\n    const opLen = operand.length\n    const opIndex = operand.indexOf(op)\n    if (opIndex === -1) {\n      throw new Error(`Operand ${op} not found in operand list`)\n    }\n    const opValue = operand[opIndex]\n    result.push(opValue)\n    operand.splice(opIndex, 1)\n  }\n  return result\n}\n\nconst doAlgebra2 = (operator, operand) => {\n  const len = operator.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const opLen = operand.length\n    const opIndex = operand.indexOf(op)\n    if (opIndex === -1) {\n      throw new Error(`Operand ${op} not found in operand list`)\n    }\n    const opValue = operand[opIndex]\n    result.push(opValue)\n    operand.splice(opIndex, 1)\n  }\n  return result\n}\n\nconst doAlgebra3 = (operator, operand) => {\n  const len = operator.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const opLen = operand.length\n    const opIndex = operand.indexOf(op)\n    if (opIndex === -1) {\n      throw new Error(`Operand ${op} not found in operand list`)\n    }\n    const opValue = operand[opIndex]\n    result.push(opValue)\n    operand.splice(opIndex, 1)\n  }\n  return result\n}\n\nconst doAlgebra4 = (operator, operand) => {\n  const len = operator.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const opLen = operand.length\n    const opIndex = operand.indexOf(op)\n    if (opIndex === -1) {\n      throw new Error(`Operand ${op} not found in operand list`)\n    }\n    const opValue = operand[opIndex]\n    result.push(opValue)\n    operand.splice(opIndex, 1)\n  }\n  return result\n}\n\nconst doAlgebra5 = (operator, operand) => {\n  const len = operator.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const opLen = operand.length\n    const opIndex = operand.indexOf(op)\n    if (opIndex === -1) {\n      throw new Error(`Operand ${op} not found in operand list`)\n    }\n    const opValue = operand[opIndex]\n    result.push(opValue)\n    operand.splice(opIndex, 1)\n  }\n  return result\n}\n\nconst doAlgebra6 = (operator, operand) => {\n  const len = operator.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const opLen = operand.length\n    const opIndex = operand.indexOf(op)\n    if (opIndex === -1) {\n      throw new Error(`Operand ${op} not found in operand list`)\n    }\n    const opValue = operand[opIndex]\n    result.push(opValue)\n    operand.splice(opIndex, 1)\n  }\n  return result\n}\n\nconst doAlgebra7 = (operator, operand) => {\n  const len = operator.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const opLen = operand.length\n    const opIndex = operand.indexOf(op)\n    if (opIndex === -1) {\n      throw new Error(`Operand ${op} not found in operand list`)\n    }\n    const opValue = operand[opIndex]\n    result.push(opValue)\n    operand.splice(opIndex, 1)\n  }\n  return result\n}\n\nconst doAlgebra8 = (operator, operand) => {\n  const len = operator.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const opLen = operand.length\n    const opIndex = operand.indexOf(op)\n    if (opIndex === -1) {\n      throw new Error(`Operand ${op} not found in operand list`)\n    }\n    const opValue = operand[opIndex]\n    result.push(opValue)\n    operand.splice(opIndex, 1)\n  }\n  return result\n}\n\nconst doAlgebra9", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n   if s[i] is a letter, reverse its case from lower to upper or vise versa, \n   differently restrain it as it be. \n   If the chain contain no letters, reverse the drawstring. \n   The affair should return the resulted drawstring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*You are given a string s.\n   if s[i] is a letter, reverse its case from lower to upper or vise versa, \n   differently restrain it as it be. \n   If the chain contain no letters, reverse the drawstring. \n   The affair should return the resulted drawstring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  const len = s.length\n  let i = 0\n  let j = len - 1\n  let result = \"\"\n  while (i < j) {\n    if (s[i] === s[j]) {\n      result += s[i]\n      i++\n      j--\n    } else if (s[i].toLowerCase() === s[j].toUpperCase()) {\n      result += s[i].toUpperCase()\n      i++\n      j--\n    } else if (s[i].toUpperCase() === s[j].toLowerCase()) {\n      result += s[i].toLowerCase()\n      i++\n      j--\n    } else {\n      result += s[i]\n      i++\n      j--\n    }\n  }\n  if (i === j) {\n    result += s[i]\n  }\n  return result\n}\n\nconsole.log(solve(\"1234\"))\nconsole.log(solve(\"ab\"))\nconsole.log(solve(\"#a@C\"))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hashish equivalent string. \n   If 'text' is an empty chain, return nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 3, "perturbed": true, "gc": "/*\n  Given a string 'text', return its md5 hashish equivalent string. \n   If 'text' is an empty chain, return nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return ''\n  }\n  const md5 = crypto.createHash('md5')\n  md5.update(text)\n  return md5.digest('hex')\n}\n\n/*\n  Given a string 'text', return its sha1 hashish equivalent string. \n   If 'text' is an empty chain, return nothing.\n\n  >>> stringToSha1('Hello world') == 'a9d7b5d9e9f7a9f7d7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integer a and b, return the even digits between a\n   and b, in ascending decree.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 3, "perturbed": true, "gc": "/*\n  Given two positive integer a and b, return the even digits between a\n   and b, in ascending decree.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers2 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers3 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers4 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers5 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers6 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers7 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers8 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers9 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers10 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers11 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers12 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers13 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers14 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers15 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers16 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers17 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers18 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers19 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers20 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers21 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers22 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers23 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers24 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers25 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers26 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers27 = (a, b) => {\n  let result", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a bowed stringed instrument representing melodious bill in a particular ASCII format. \n   Your undertaking is to parse this string and return list of integers represent to how many beats does each \n   not final. \n\n   Here is a caption: \n  ' o' - whole eminence, last four meter \n  ' o|' - half note, last two beatnik \n  ' .|' - quater eminence, survive one pulse\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 3, "perturbed": true, "gc": "/* Input to this function is a bowed stringed instrument representing melodious bill in a particular ASCII format. \n   Your undertaking is to parse this string and return list of integers represent to how many beats does each \n   not final. \n\n   Here is a caption: \n 'o' - whole eminence, last four meter \n 'o|' - half note, last two beatnik \n  '.|' - quater eminence, survive one pulse\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split(' ')\n  const beats = []\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(1)\n    } else if (notes[i] === 'o|') {\n      beats.push(2)\n    } else if (notes[i] === '.') {\n      beats.push(4)\n    } else if (notes[i] === '|') {\n      beats.push(8)\n    }\n  }\n  return beats\n}\n\n/*\n  Input to this function is a string representing a melody in a particular ASCII format. \n  Your undertaking is to parse this string and return list of integers represent to how many beats does each \n  not final. \n\n  Here is a caption: \n 'o' - whole eminence, last four meter \n 'o|' - half note, last two beatnik \n  '.|' - quater eminence, survive one pulse\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMelody = (melody_string) => {\n  const notes = melody_string.split(' ')\n  const beats = []\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(1)\n    } else if (notes[i] === 'o|') {\n      beats.push(2)\n    } else if (notes[i] === '.') {\n      beats.push(4)\n    } else if (notes[i] === '|') {\n      beats.push(8)\n    }\n  }\n  return beats\n}\n\n/*\n  Input to this function is a string representing a melody in a particular ASCII format. \n  Your undertaking is to parse this string and return list of integers represent to how many beats does each \n  not final. \n\n  Here is a caption: \n 'o' - whole eminence, last four meter \n 'o|' - half note, last two beatnik \n  '.|' - quater eminence, survive one pulse\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMelody2 = (melody_string) => {\n  const notes = melody_string.split(' ')\n  const beats = []\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(1)\n    } else if (notes[i] === 'o|') {\n      beats.push(2)\n    } else if (notes[i] === '.') {\n      beats.push(4)\n    } else if (notes[i] === '|') {\n      beats.push(8)\n    }\n  }\n  return beats\n}\n\n/*\n  Input to this function is a string representing a melody in a particular ASCII format. \n  Your undertaking is to parse this string and return list of integers represent to how many beats does each \n  not final. \n\n  Here is a caption: \n 'o' - whole eminence, last four meter \n 'o|' - half note, last two beatnik \n  '.|' - quater eminence, survive one pulse\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMelody3 = (melody_string) => {\n  const notes = melody_string.split(' ')\n  const beats = []\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(1)\n    } else if (notes[i] === 'o|') {\n      beats.push(2)\n    } else if (notes[i] === '.') {\n      beats.push(4)\n    } else if (notes[i] === '|') {\n      beats.push(8)\n    }\n  }\n  return beats\n}\n\n/*\n  Input to this function is a string representing a melody in a particular ASCII format. \n  Your undertaking is to parse this string and return list of integers represent to how many beats does each \n  not final. \n\n  Here is a caption: \n 'o' - whole eminence, last four meter \n 'o|' - half note, last two beatnik \n  '.|' - quater eminence, survive one pulse\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMelody4 = (melody_string) => {\n  const notes = melody_string.split(' ')\n  const beats = []\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(1)\n    } else if (notes[i] === 'o|') {\n      beats.push(2)\n    } else if (notes[i] === '.') {\n      beats.push(4)", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlap subject.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 3, "perturbed": true, "gc": "/* Find how many times a given substring can be found in the original string. Count overlap subject.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Find the longest substring in the original string.\n  >>> longestSubstring('abc')\n  'abc'\n  >>> longestSubstring('abcde')\n  'abcde'\n  >>> longestSubstring('abcd')\n  'abcd'\n  >>> longestSubstring('abcde')\n  'abcde'\n  >>> longestSubstring('abcdef')\n  'abcdef'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefgh')\n  'abcdefgh'\n  >>> longestSubstring('abcdefghi')\n  'abcdefghi'\n  >>> longestSubstring('abcdefghij')\n  'abcdefghij'\n  >>> longestSubstring('abcdefghijkl')\n  'abcdefghijkl'\n  >>> longestSubstring('abcdefghijklm')\n  'abcdefghijklm'\n  >>> longestSubstring('abcdefghijklmn')\n  'abcdefghijklmn'\n  >>> longestSubstring('abcdefghijklmnop')\n  'abcdefghijklmnop'\n  >>> longestSubstring('abcdefghijklmnopq')\n  'abcdefghijklmnopq'\n  >>> longestSubstring('abcdefghijklmnopqr')\n  'abcdefghijklmnopqr'\n  >>> longestSubstring('abcdefghijklmnopqrst')\n  'abcdefghijklmnopqrst'\n  >>> longestSubstring('abcdefghijklmnopqrstu')\n  'abcdefghijklmnopqrstu'\n  >>> longestSubstring('abcdefghijklmnopqrstuv')\n  'abcdefghijklmnopqrstuv'\n  >>> longestSubstring('abcdefghijklmnopqrstuvw')\n  'abcdefghijklmnopqrstuvw'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxy')\n  'abcdefghijklmnopqrstuvwxy'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabc')\n  'abcdefghijklmnopqrstuvwxyzabc'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdef')\n  'abcdefghijklmnopqrstuvwxyzabcdef'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefg')\n  'abcdefghijklmnopqrstuvwxyzabcdefg'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefgh')\n  'abcdefghijklmnopqrstuvwxyzabcdefgh'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghi')\n  'abcdefghijklmnopqrstuvwxyzabcdefghi'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghij')\n  'abcdefghijklmnopqrstuvwxyzabcdefghij'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghijk')\n  'abcdefghijklmnopqrstuvwxyzabcdefghijk'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghijkl')\n  'abcdefghijklmnopqrstuvwxyzabcdefghijkl'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghijklm')\n  'abcdefghijklmnopqrstuvwxyzabcdefghijklm'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghijklmn')\n  'abcdefghijklmnopqrstuvwxyzabcdefghijklmn'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghijklmno')\n  'abcdefghijklmnopqrstuvwxyzabcdefghijklmno'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghijklmnop')\n  'abcdefghijklmnopqrstuvwxyzabcdefghijklmnop'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghijklmnopq')\n  'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopq'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqr')\n  'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqr'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrst')\n  'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrst'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu')\n  'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu'\n  >>> longestSubstring('abcdefghijklmnopqrstuv", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space - specify string of numberals from' zero' to' nine'. \n   Valid choice are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   render the string with numbers screen from smallest to big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 3, "perturbed": true, "gc": "/* Input is a space - specify string of numberals from' zero' to' nine'. \n   Valid choice are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   render the string with numbers screen from smallest to big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const numbersArrayLength = numbersArray.length\n  const numbersArrayLengthMinusOne = numbersArrayLength - 1\n  const numbersArrayLengthMinusTwo = numbersArrayLength - 2\n  const numbersArrayLengthMinusThree = numbersArrayLength - 3\n  const numbersArrayLengthMinusFour = numbersArrayLength - 4\n  const numbersArrayLengthMinusFive = numbersArrayLength - 5\n  const numbersArrayLengthMinusSix = numbersArrayLength - 6\n  const numbersArrayLengthMinusSeven = numbersArrayLength - 7\n  const numbersArrayLengthMinusEight = numbersArrayLength - 8\n  const numbersArrayLengthMinusNine = numbersArrayLength - 9\n  const numbersArrayLengthMinusTen = numbersArrayLength - 10\n  const numbersArrayLengthMinusEleven = numbersArrayLength - 11\n  const numbersArrayLengthMinusTwelve = numbersArrayLength - 12\n  const numbersArrayLengthMinusThirteen = numbersArrayLength - 13\n  const numbersArrayLengthMinusFourteen = numbersArrayLength - 14\n  const numbersArrayLengthMinusFifteen = numbersArrayLength - 15\n  const numbersArrayLengthMinusSixteen = numbersArrayLength - 16\n  const numbersArrayLengthMinusSeventeen = numbersArrayLength - 17\n  const numbersArrayLengthMinusEighteen = numbersArrayLength - 18\n  const numbersArrayLengthMinusNineteen = numbersArrayLength - 19\n  const numbersArrayLengthMinusTwenty = numbersArrayLength - 20\n  const numbersArrayLengthMinusTwentyOne = numbersArrayLength - 21\n  const numbersArrayLengthMinusTwentyTwo = numbersArrayLength - 22\n  const numbersArrayLengthMinusTwentyThree = numbersArrayLength - 23\n  const numbersArrayLengthMinusTwentyFour = numbersArrayLength - 24\n  const numbersArrayLengthMinusTwentyFive = numbersArrayLength - 25\n  const numbersArrayLengthMinusTwentySix = numbersArrayLength - 26\n  const numbersArrayLengthMinusTwentySeven = numbersArrayLength - 27\n  const numbersArrayLengthMinusTwentyEight = numbersArrayLength - 28\n  const numbersArrayLengthMinusTwentyNine = numbersArrayLength - 29\n  const numbersArrayLengthMinusThirty = numbersArrayLength - 30\n  const numbersArrayLengthMinusThirtyOne = numbersArrayLength - 31\n  const numbersArrayLengthMinusThirtyTwo = numbersArrayLength - 32\n  const numbersArrayLengthMinusThirtyThree = numbersArrayLength - 33\n  const numbersArrayLengthMinusThirtyFour = numbersArrayLength - 34\n  const numbersArrayLengthMinusThirtyFive = numbersArrayLength - 35\n  const numbersArrayLengthMinusThirtySix = numbersArrayLength - 36\n  const numbersArrayLengthMinusThirtySeven = numbersArrayLength - 37\n  const numbersArrayLengthMinusThirtyEight = numbersArrayLength - 38\n  const numbersArrayLengthMinusThirtyNine = numbersArrayLength - 39\n  const numbersArrayLengthMinusForty = numbersArrayLength - 40\n  const numbersArrayLengthMinusFortyOne = numbersArrayLength - 41\n  const numbersArrayLengthMinusFortyTwo = numbersArrayLength - 42\n  const numbersArrayLengthMinusFortyThree = numbersArrayLength - 43\n  const numbersArrayLengthMinusFortyFour = numbersArrayLength - 44\n  const numbersArrayLengthMinusFortyFive = numbersArrayLength - 45\n  const numbersArrayLengthMinusFortySix = numbersArrayLength - 46\n  const numbersArrayLengthMinusFortySeven = numbersArrayLength - 47\n  const numbersArrayLengthMinusFortyEight = numbersArrayLength - 48\n  const numbersArrayLengthMinusFortyNine = numbersArrayLength - 49\n  const numbersArrayLengthMinusFifty = numbersArrayLength - 50\n  const numbersArrayLengthMinusFiftyOne = numbersArrayLength - 51\n  const numbersArrayLengthMinusFiftyTwo = numbersArrayLength - 52\n  const numbersArrayLengthMinusFiftyThree = numbersArrayLength - 53\n  const numbersArrayLengthMinusFiftyFour = numbersArrayLength - 54\n  const numbersArrayLengthMinusFiftyFive = numbersArrayLength - 55\n  const numbersArrayLengthMinusFiftySix = numbersArrayLength - 56\n  const numbersArrayLengthMinusFiftySeven = numbersArrayLength - 57\n  const numbersArrayLengthMinusFiftyEight = numbersArrayLength - 58\n  const numbersArrayLengthMinusFiftyNine = numbersArrayLength - 59\n  const numbersArrayLengthMinusSixty = numbersArrayLength - 60\n  const numbersArrayLengthMinusSixtyOne = numbersArrayLength - 61\n  const numbersArrayLengthMinusSixtyTwo = numbersArrayLength - 62\n  const numbersArrayLengthMinusSixtyThree = numbersArrayLength - 63\n  const numbersArrayLengthMinusSixtyFour = numbersArrayLength - 64\n  const numbersArrayLengthMinusSixtyFive = numbersArrayLength - 65\n  const numbersArrayLengthMinusSixtySix = numbersArrayLength - 66\n  const numbersArrayLengthMinusSixtySeven = numbersArrayLength - 67\n  const numbersArrayLengthMinusSixtyEight = numbersArrayLength - 68\n  const numbersArrayLengthMinusSixtyNine = numbersArrayLength - 69\n  const numbersArrayLengthMinusSeventy = numbersArrayLength - 70\n  const numbersArrayLengthMinusSeventyOne = numbersArrayLength - 71\n  const numbersArrayLengthMinusSeventyTwo = numbersArrayLength - 72\n  const numbersArrayLengthMinusSeventyThree = numbersArrayLength - 73\n  const numbersArrayLengthMinusSeventyFour = numbersArrayLength - 74\n  const numbersArrayLengthMinusSeventyFive = numbersArrayLength - 75\n  const numbersArrayLengthMinusSeventySix = numbersArrayLength - 76\n  const numbersArrayLengthMinusSeventySeven = numbersArrayLength - 77\n  const numbersArrayLengthMinusSeventyEight = numbersArrayLength - 78\n  const numbersArrayLengthMinusSeventyNine = numbersArrayLength - 79\n  const numbersArrayLengthMinusSeventyTen = numbersArrayLength - 80\n  const numbersArrayLengthMinusSeventyEleven = numbersArrayLength - 81\n  const numbersArrayLengthMinusSeventyTwelve = numbersArrayLength - 82\n  const numbersArrayLengthMinusSeventyThirteen = numbersArrayLength - 83\n  const numbersArrayLengthMinusSeventyFourteen = numbersArrayLength - 84\n  const numbersArrayLengthMinusSeventyFifteen = numbersArrayLength - 85\n  const numbersArrayLengthMinus", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive float point number, it can be disintegrate into \n   and integer region (largest integer minor than give number) and decimals \n   (leftover part constantly smaller than 1). \n\n   reelect the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 3, "perturbed": true, "gc": "/* Given a positive float point number, it can be disintegrate into \n   and integer region (largest integer minor than give number) and decimals \n   (leftover part constantly smaller than 1). \n\n   reelect the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  let result = integerPart;\n  if (decimalPart > 0) {\n    result += 1;\n  }\n  return result;\n};\n\nexport default truncateNumber;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the close to each \n   early and return them in order (modest numeral, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 3, "perturbed": true, "gc": "/* From a supplied list of numbers (of length at least two) select and return two that are the close to each \n   early and return them in order (modest numeral, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const early = sorted[0];\n  const late = sorted[sorted.length - 1];\n  return [early, late];\n};\n\n/*\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements2 = (numbers) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const early = sorted[0];\n  const late = sorted[sorted.length - 1];\n  return [early, late];\n};\n\n/*\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements3 = (numbers) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const early = sorted[0];\n  const late = sorted[sorted.length - 1];\n  return [early, late];\n};\n\n/*\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements4 = (numbers) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const early = sorted[0];\n  const late = sorted[sorted.length - 1];\n  return [early, late];\n};\n\n/*\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements5 = (numbers) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const early = sorted[0];\n  const late = sorted[sorted.length - 1];\n  return [early, late];\n};\n\n/*\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements6 = (numbers) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const early = sorted[0];\n  const late = sorted[sorted.length - 1];\n  return [early, late];\n};\n\n/*\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements7 = (numbers) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const early = sorted[0];\n  const late = sorted[sorted.length - 1];\n  return [early, late];\n};\n\n/*\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements8 = (numbers) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const early = sorted[0];\n  const late = sorted[sorted.length - 1];\n  return [early, late];\n};\n\n/*\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements9 = (numbers) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const early = sorted[0];\n  const late = sorted[sorted.length - 1];\n  return [early, late];\n};\n\n/*\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n   such that the small number will become 0 and the bombastic will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 3, "perturbed": true, "gc": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n   such that the small number will become 0 and the bombastic will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const sum = numbers.reduce((acc, n) => acc + n, 0)\n  const factor = 1 / sum\n  return numbers.map(n => n * factor)\n}\n\n/* Given a list of numbers, return the list of their logarithms.\n  >>> log([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst log = (numbers) => numbers.map(Math.log)\n\n/* Given a list of numbers, return the list of their exponents.\n  >>> exp([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 2.0, 4.0, 6.0, 8.0]\n  */\nconst exp = (numbers) => numbers.map(Math.exp)\n\n/* Given a list of numbers, return the list of their square roots.\n  >>> sqrt([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979]\n  */\nconst sqrt = (numbers) => numbers.map(Math.sqrt)\n\n/* Given a list of numbers, return the list of their square root of their squares.\n  >>> sqrt([1.0, 4.0, 9.0, 16.0, 25.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst sqrtOfSqrt = (numbers) => numbers.map(n => Math.sqrt(n))\n\n/* Given a list of numbers, return the list of their cube roots.\n  >>> cubeRoot([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 1.2599210498948732, 1.5874010519681994, 2.0, 2.4494897427831780, 3.0]\n  */\nconst cubeRoot = (numbers) => numbers.map(Math.cbrt)\n\n/* Given a list of numbers, return the list of their cube root of their cubes.\n  >>> cubeRoot([1.0, 8.0, 27.0, 64.0, 125.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst cubeRootOfCube = (numbers) => numbers.map(n => Math.cbrt(n))\n\n/* Given a list of numbers, return the list of their cube root of their cubes.\n  >>> cubeRoot([1.0, 8.0, 27.0, 64.0, 125.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst cubeRootOfCube = (numbers) => numbers.map(n => Math.cbrt(n))\n\n/* Given a list of numbers, return the list of their cube root of their cubes.\n  >>> cubeRoot([1.0, 8.0, 27.0, 64.0, 125.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst cubeRootOfCube = (numbers) => numbers.map(n => Math.cbrt(n))\n\n/* Given a list of numbers, return the list of their cube root of their cubes.\n  >>> cubeRoot([1.0, 8.0, 27.0, 64.0, 125.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst cubeRootOfCube = (numbers) => numbers.map(n => Math.cbrt(n))\n\n/* Given a list of numbers, return the list of their cube root of their cubes.\n  >>> cubeRoot([1.0, 8.0, 27.0, 64.0, 125.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst cubeRootOfCube = (numbers) => numbers.map(n => Math.cbrt(n))\n\n/* Given a list of numbers, return the list of their cube root of their cubes.\n  >>> cubeRoot([1.0, 8.0, 27.0, 64.0, 125.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst cubeRootOfCube = (numbers) => numbers.map(n => Math.cbrt(n))\n\n/* Given a list of numbers, return the list of their cube root of their cubes.\n  >>> cubeRoot([1.0, 8.0, 27.0, 64.0, 125.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst cubeRootOfCube = (numbers) => numbers.map(n => Math.cbrt(n))\n\n/* Given a list of numbers, return the list of their cube root of their cubes.\n  >>> cubeRoot([1.0, 8.0, 27.0, 64.0, 125.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst cubeRootOfCube = (numbers) => numbers.map(n => Math.cbrt(n))\n\n/* Given a list of numbers, return the list of their cube root of their cubes.\n  >>> cubeRoot([1.0, 8.0, 27.0, 64.0, 125.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst cubeRootOfCube = (numbers) => numbers.map(n => Math.cbrt(", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 3, "perturbed": false, "gc": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number' && isInteger(v));\n};\n\n/**\n  * Filter given list of any python values only for floats\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFloats = (values) => {\n  return values.filter(v => typeof v === 'number' && isFloat(v));\n};\n\n/**\n  * Filter given list of any python values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given list of any python values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given list of any python values only for lists\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterLists = (values) => {\n  return values.filter(v => typeof v === 'object' && v instanceof Array);\n};\n\n/**\n  * Filter given list of any python values only for dictionaries\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(v => typeof v === 'object' &&!(v instanceof Array));\n};\n\n/**\n  * Filter given list of any python values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given list of any python values only for functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter given list of any python values only for numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given list of any python values only for integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number' && isInteger(v));\n};\n\n/**\n  * Filter given list of any python values only for floats\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFloats = (values) => {\n  return values.filter(v => typeof v === 'number' && isFloat(v));\n};\n\n/**\n  * Filter given list of any python values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given list of any python values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given list of any python values only for lists\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterLists = (values) => {\n  return values.filter(v => typeof v === 'object' && v instanceof Array);\n};\n\n/**\n  * Filter given list of any python values only for dictionaries\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(v => typeof v === 'object' &&!(v instanceof Array));\n};\n\n/**\n  * Filter given list of any python values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given list of any python values only for functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter given list of any python values only for numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given list of any python values only for integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number' && isInteger(v));\n};\n\n/**\n  * Filter given list of any python values only for floats\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFloats = (values) => {\n  return values.filter(v => typeof v === 'number' && isFloat(v));\n};\n\n/**\n  * Filter given list of any python values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given list of any python values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/23", "prompt": "/* Return length of give string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 3, "perturbed": true, "gc": "/* Return length of give string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/**\n  * Return the index of the first occurrence of a substring in a string\n  *\n  * @param {string} string\n  * @param {string} substring\n  * @return {number}\n  *\n  * @example\n  * strindex( 'abcdefg', 'c' )\n  * // => 1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc' )\n  * // => 0\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', 2 )\n  * // => 1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -1 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -2 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -3 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -4 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -5 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -6 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -7 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -8 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -9 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -10 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -11 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -12 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -13 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -14 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -15 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -16 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -17 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -18 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -19 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -20 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -21 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -22 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -23 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -24 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -25 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -26 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -27 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -28 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -29 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -30 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -31 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -32 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -33 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -34 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -35 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -36 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -37 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -38 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -39 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -40 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -41 )\n  * // => -1\n  *\n  * @example\n  * strindex( 'abcdefg', 'bc', -42 )\n  * // => -1\n  *\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 3, "perturbed": true, "gc": "/* For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > max) {\n        max = i;\n        count = 1;\n      } else if (i === max) {\n        count++;\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor2 = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > max) {\n        max = i;\n        count = 1;\n      } else if (i === max) {\n        count++;\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor3 = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > max) {\n        max = i;\n        count = 1;\n      } else if (i === max) {\n        count++;\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor4 = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > max) {\n        max = i;\n        count = 1;\n      } else if (i === max) {\n        count++;\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor5 = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > max) {\n        max = i;\n        count = 1;\n      } else if (i === max) {\n        count++;\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor6 = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > max) {\n        max = i;\n        count = 1;\n      } else if (i === max) {\n        count++;\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor7 = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > max) {\n        max = i;\n        count = 1;\n      } else if (i === max) {\n        count++;\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor8 = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > max) {\n        max = i;\n        count = 1;\n      } else if (i === max) {\n        count++;\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor9 = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > max) {\n        max = i;\n        count = 1;\n      } else if (i === max) {\n        count++;\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor10 = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > max) {\n        max = i;\n        count = 1;\n      } else if (i === max) {\n        count++;\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  For a given number n, detect the largest issue that separate n evenly, humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor11 = (n) => {\n  let max = 1;\n  let count = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factor of given integer in the orderliness from small to big. \n   Each of the gene should be listed numeral of time corresponding to how many fourth dimension it appeares in factorization. \n   input signal numeral should be equal to the intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 3, "perturbed": true, "gc": "/* Return list of prime factor of given integer in the orderliness from small to big. \n   Each of the gene should be listed numeral of time corresponding to how many fourth dimension it appeares in factorization. \n   input signal numeral should be equal to the intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = []\n  let num = n\n  while (num > 1) {\n    let factor = num % 4\n    if (factor === 0) {\n      num = num / 4\n    } else {\n      num = num / factor\n      factors.push(factor)\n    }\n  }\n  return factors\n}\n\n/* Return list of prime factor of given integer in the orderliness from small to big. \n   Each of the gene should be listed numeral of time corresponding to how many fifth dimension it appeares in factorization. \n   input signal numeral should be equal to the intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  let factors = []\n  let num = n\n  while (num > 1) {\n    let factor = num % 5\n    if (factor === 0) {\n      num = num / 5\n    } else {\n      num = num / factor\n      factors.push(factor)\n    }\n  }\n  return factors\n}\n\n/* Return list of prime factor of given integer in the orderliness from small to big. \n   Each of the gene should be listed numeral of time corresponding to how many sixth dimension it appeares in factorization. \n   input signal numeral should be equal to the intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  let factors = []\n  let num = n\n  while (num > 1) {\n    let factor = num % 6\n    if (factor === 0) {\n      num = num / 6\n    } else {\n      num = num / factor\n      factors.push(factor)\n    }\n  }\n  return factors\n}\n\n/* Return list of prime factor of given integer in the orderliness from small to big. \n   Each of the gene should be listed numeral of time corresponding to how many seventh dimension it appeares in factorization. \n   input signal numeral should be equal to the intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  let factors = []\n  let num = n\n  while (num > 1) {\n    let factor = num % 7\n    if (factor === 0) {\n      num = num / 7\n    } else {\n      num = num / factor\n      factors.push(factor)\n    }\n  }\n  return factors\n}\n\n/* Return list of prime factor of given integer in the orderliness from small to big. \n   Each of the gene should be listed numeral of time corresponding to how many eighth dimension it appeares in factorization. \n   input signal numeral should be equal to the intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize8 = (n) => {\n  let factors = []\n  let num = n\n  while (num > 1) {\n    let factor = num % 8\n    if (factor === 0) {\n      num = num / 8\n    } else {\n      num = num / factor\n      factors.push(factor)\n    }\n  }\n  return factors\n}\n\n/* Return list of prime factor of given integer in the orderliness from small to big. \n   Each of the gene should be listed numeral of time corresponding to how many ninth dimension it appeares in factorization. \n   input signal numeral should be equal to the intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize9 = (n) => {\n  let factors = []\n  let num = n\n  while (num > 1) {\n    let factor = num % 9\n    if (factor === 0) {\n      num = num / 9\n    } else {\n      num = num / factor\n      factors.push(factor)\n    }\n  }\n  return factors\n}\n\n/* Return list of prime factor of given integer in the orderliness from small to big. \n   Each of the gene should be listed numeral of time corresponding to how many tenth dimension it appeares in factorization. \n   input signal numeral should be equal to the intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize10 = (n) => {\n  let factors = []\n  let num = n\n  while (num > 1) {\n    let factor = num % 10\n    if (factor === 0) {\n      num = num / 10\n    } else {\n      num = num / factor\n      factors.push(factor)\n    }\n  }\n  return factors\n}\n\n/* Return list of prime factor of given integer in the orderliness from small to big. \n   Each of the gene should be listed numeral of time corresponding to how many eleventh dimension it appeares in factorization. \n   input signal numeral should be equal to the intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all component that occur more than once. \n   sustain ordering of elements entrust the like as in the stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 3, "perturbed": true, "gc": "/* From a list of integers, remove all component that occur more than once. \n   sustain ordering of elements entrust the like as in the stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates2 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates3 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates4 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates5 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates6 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates7 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates8 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates9 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates10 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates11 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates12 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates13 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates14 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates15 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates16 = (numbers) => {\n  const sorted = Array.from(numbers).sort();\n  const unique = sorted.filter((element, index) => index === sorted.lastIndexOf(element));\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, throw lowercase character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 3, "perturbed": true, "gc": "/* For a given string, throw lowercase character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().replace(/\\B([a-z])/g, (match, p1) => {\n    return p1.toUpperCase();\n  });\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase.\n  >>> lowerCase('Hello')\n  'hello'\n  */\nconst lowerCase = (string) => {\n  return string.toLowerCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCase = (string) => {\n  return string.toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toLowerCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and lowercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string).", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 3, "perturbed": true, "gc": "/* Concatenate list of strings into a single bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate(['a', 'b', 'c'], 'd')\n  'abcd'\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e')\n  'abcde'\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings,...rest) => {\n  return concatenate(strings) + concatenate(rest);\n};\n\n/*\n  >>> concatenate(['a', 'b', 'c'], 'd', 'e', 'f')\n  'abcdef'\n  */\nconst concatenate = (strings", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for one that start with a give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 3, "perturbed": true, "gc": "/* Filter an input list of strings only for one that start with a give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/* Filter an input list of strings only for one that contains a given string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input list of strings only for one that ends with a given string.\n  >>> filterByEndsWith([], 'a')\n  []\n  >>> filterByEndsWith(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByEndsWith = (strings, endsWith) => {\n  return strings.filter(s => s.endsWith(endsWith));\n};\n\n/* Filter an input list of strings only for one that contains a given string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input list of strings only for one that starts with a given string.\n  >>> filterByStartsWith([], 'a')\n  []\n  >>> filterByStartsWith(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByStartsWith = (strings, startsWith) => {\n  return strings.filter(s => s.startsWith(startsWith));\n};\n\n/* Filter an input list of strings only for one that ends with a given string.\n  >>> filterByEndsWith([], 'a')\n  []\n  >>> filterByEndsWith(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByEndsWith = (strings, endsWith) => {\n  return strings.filter(s => s.endsWith(endsWith));\n};\n\n/* Filter an input list of strings only for one that contains a given string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input list of strings only for one that starts with a given string.\n  >>> filterByStartsWith([], 'a')\n  []\n  >>> filterByStartsWith(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByStartsWith = (strings, startsWith) => {\n  return strings.filter(s => s.startsWith(startsWith));\n};\n\n/* Filter an input list of strings only for one that ends with a given string.\n  >>> filterByEndsWith([], 'a')\n  []\n  >>> filterByEndsWith(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByEndsWith = (strings, endsWith) => {\n  return strings.filter(s => s.endsWith(endsWith));\n};\n\n/* Filter an input list of strings only for one that contains a given string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input list of strings only for one that starts with a given string.\n  >>> filterByStartsWith([], 'a')\n  []\n  >>> filterByStartsWith(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByStartsWith = (strings, startsWith) => {\n  return strings.filter(s => s.startsWith(startsWith));\n};\n\n/* Filter an input list of strings only for one that ends with a given string.\n  >>> filterByEndsWith([], 'a')\n  []\n  >>> filterByEndsWith(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByEndsWith = (strings, endsWith) => {\n  return strings.filter(s => s.endsWith(endsWith));\n};\n\n/* Filter an input list of strings only for one that contains a given string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input list of strings only for one that starts with a given string.\n  >>> filterByStartsWith([], 'a')\n  []\n  >>> filterByStartsWith(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with \n   zero balance. Your undertaking is to detect if at any period the balance of history fallls below zero, and \n   at that item function should return on-key. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 3, "perturbed": true, "gc": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with \n   zero balance. Your undertaking is to detect if at any period the balance of history fallls below zero, and \n   at that item function should return on-key. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  const balance = sum - operations.reduce((acc, curr) => acc - curr, 0)\n  return balance < 0\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  return sum\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance2 = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  return sum\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance3 = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  return sum\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance4 = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  return sum\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance5 = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  return sum\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance6 = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  return sum\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance7 = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  return sum\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance8 = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  return sum\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance9 = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  return sum\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance10 = (operations) => {\n  const operations = operations.slice(0)\n  const sum = operations.reduce((acc, curr) => acc + curr, 0)\n  return sum\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a bank account that starts with \n  zero balance, return the balance of the account at the end of the operations.\n  >>> belowZero([1, 2, 3])\n  6\n  >>> belowZero([1, 2, -4, 5])\n  -5\n  */\nconst balance11 = (operations) => {\n  const", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/30", "prompt": "/*Return only convinced numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 3, "perturbed": true, "gc": "/*Return only convinced numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const positive = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      positive.push(l[i]);\n    }\n  }\n  return positive;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a give number be premier, and assumed differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 3, "perturbed": true, "gc": "/*Return true if a give number be premier, and assumed differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  if (n < 2) return false\n  if (n % 3 === 0) return false\n  if (n < 9) return true\n  if (n % 7 === 0) return false\n  if (n < 99) return true\n  if (n % 11 === 0) return false\n  if (n % 13 === 0) return false\n  if (n % 17 === 0) return false\n  if (n < 999999) return true\n  return false\n}\n\n/*Return the number of divisors of a given number.\n  >>> countDivisors(1)\n  1\n  >>> countDivisors(2)\n  2\n  >>> countDivisors(3)\n  3\n  >>> countDivisors(4)\n  4\n  >>> countDivisors(5)\n  5\n  >>> countDivisors(6)\n  6\n  >>> countDivisors(7)\n  7\n  >>> countDivisors(8)\n  8\n  >>> countDivisors(9)\n  9\n  >>> countDivisors(10)\n  10\n  >>> countDivisors(11)\n  11\n  >>> countDivisors(12)\n  12\n  >>> countDivisors(13)\n  13\n  >>> countDivisors(14)\n  14\n  >>> countDivisors(15)\n  15\n  >>> countDivisors(16)\n  16\n  >>> countDivisors(17)\n  17\n  >>> countDivisors(18)\n  18\n  >>> countDivisors(19)\n  19\n  >>> countDivisors(20)\n  20\n  >>> countDivisors(21)\n  21\n  >>> countDivisors(22)\n  22\n  >>> countDivisors(23)\n  23\n  >>> countDivisors(24)\n  24\n  >>> countDivisors(25)\n  25\n  >>> countDivisors(26)\n  26\n  >>> countDivisors(27)\n  27\n  >>> countDivisors(28)\n  28\n  >>> countDivisors(29)\n  29\n  >>> countDivisors(30)\n  30\n  >>> countDivisors(31)\n  31\n  >>> countDivisors(32)\n  32\n  >>> countDivisors(33)\n  33\n  >>> countDivisors(34)\n  34\n  >>> countDivisors(35)\n  35\n  >>> countDivisors(36)\n  36\n  >>> countDivisors(37)\n  37\n  >>> countDivisors(38)\n  38\n  >>> countDivisors(39)\n  39\n  >>> countDivisors(40)\n  40\n  >>> countDivisors(41)\n  41\n  >>> countDivisors(42)\n  42\n  >>> countDivisors(43)\n  43\n  >>> countDivisors(44)\n  44\n  >>> countDivisors(45)\n  45\n  >>> countDivisors(46)\n  46\n  >>> countDivisors(47)\n  47\n  >>> countDivisors(48)\n  48\n  >>> countDivisors(49)\n  49\n  >>> countDivisors(50)\n  50\n  >>> countDivisors(51)\n  51\n  >>> countDivisors(52)\n  52\n  >>> countDivisors(53)\n  53\n  >>> countDivisors(54)\n  54\n  >>> countDivisors(55)\n  55\n  >>> countDivisors(56)\n  56\n  >>> countDivisors(57)\n  57\n  >>> countDivisors(58)\n  58\n  >>> countDivisors(59)\n  59\n  >>> countDivisors(60)\n  60\n  >>> countDivisors(61)\n  61\n  >>> countDivisors(62)\n  62\n  >>> countDivisors(63)\n  63\n  >>> countDivisors(64)\n  64\n  >>> countDivisors(65)\n  65\n  >>> countDivisors(66)\n  66\n  >>> countDivisors(67)\n  67\n  >>> countDivisors(68)\n  68\n  >>> countDivisors(69)\n  69\n  >>> countDivisors(70)\n  70\n  >>> countDivisors(71)\n  71\n  >>> countDivisors(72)\n  72\n  >>> countDivisors(73)\n  73\n  >>> countDivisors(74)\n  74\n  >>> countDivisors(75)\n  75\n  >>> countDivisors(76)\n  76\n  >>> countDivisors(77)\n  77\n  >>> countDivisors(78)\n  78\n  >>> countDivisors(79)\n  79\n  >>> countDivisors(80)\n  80\n  >>> countDivisors(81)\n  81\n  >>> countDivisors(82)\n  82\n  >>> countDivisors(83)\n  83\n  >>> countDivisors(84)\n  84\n  >>> countDivisors(85)\n  85\n  >>> countDivisors(86)\n  86\n  >>> countDivisors(87)\n  87\n  >>> countDivisors(88)\n  88\n  >>> countDivisors(89)\n  89\n  >>> countDivisors(90)\n  90\n  >>> countDivisors(91)\n  91\n  >>> countDivisors(92)\n  92\n  >>> countDivisors(93)\n  93\n  >>> countDivisors(94)\n  94\n  >>> countDivisors(95)\n  95\n  >>> countDivisors(96)\n  96\n  >>> countDivisors(97)\n  97\n  >>> countDivisors(98)\n  98\n  >>>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficient xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero receive x such that poly(x) = 0. \n   findZero returns merely only zero distributor point, even if there are many. \n   Moreover, findZero only take list xs have even number of coefficient \n   and largest non zero coefficient as it guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 3, "perturbed": true, "gc": "/*\n  Evaluates polynomial with coefficient xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero receive x such that poly(x) = 0. \n   findZero returns merely only zero distributor point, even if there are many. \n   Moreover, findZero only take list xs have even number of coefficient \n   and largest non zero coefficient as it guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length\n  const half = len / 2\n  const x = xs[half]\n  const y = xs[half + 1]\n  const z = xs[half + 2]\n  const n = half + 3\n  const poly = (x, y, z) = > {\n    return x + y * x + z * x * x\n  }\n  const zero = (x) = > {\n    return x - poly(x) / poly(x)\n  }\n  return zero(x)\n}\n\n/*\n  Evaluates polynomial with coefficient xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero receive x such that poly(x) = 0. \n   findZero returns merely only zero distributor point, even if there are many. \n   Moreover, findZero only take list xs have even number of coefficient \n   and largest non zero coefficient as it guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length\n  const half = len / 2\n  const x = xs[half]\n  const y = xs[half + 1]\n  const z = xs[half + 2]\n  const n = half + 3\n  const poly = (x, y, z) = > {\n    return x + y * x + z * x * x\n  }\n  const zero = (x) = > {\n    return x - poly(x) / poly(x)\n  }\n  return zero(x)\n}\n\n/*\n  Evaluates polynomial with coefficient xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero receive x such that poly(x) = 0. \n   findZero returns merely only zero distributor point, even if there are many. \n   Moreover, findZero only take list xs have even number of coefficient \n   and largest non zero coefficient as it guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length\n  const half = len / 2\n  const x = xs[half]\n  const y = xs[half + 1]\n  const z = xs[half + 2]\n  const n = half + 3\n  const poly = (x, y, z) = > {\n    return x + y * x + z * x * x\n  }\n  const zero = (x) = > {\n    return x - poly(x) / poly(x)\n  }\n  return zero(x)\n}\n\n/*\n  Evaluates polynomial with coefficient xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero receive x such that poly(x) = 0. \n   findZero returns merely only zero distributor point, even if there are many. \n   Moreover, findZero only take list xs have even number of coefficient \n   and largest non zero coefficient as it guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and return a list l' such that \n   l' is identical to l in the indicies that equal not divisible by three, while its value at the indicies that be divisible by three are equal \n   to the values of the represent indicies of l, but classify.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 3, "perturbed": true, "gc": "/*This function takes a list l and return a list l' such that \n   l' is identical to l in the indicies that equal not divisible by three, while its value at the indicies that be divisible by three are equal \n   to the values of the represent indicies of l, but classify.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = l.slice();\n  const l3 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l3.push(l[i]);\n    }\n  }\n  l2.splice(l2.indexOf(l3[0]), 1);\n  return l2;\n};\n\n/*This function takes a list l and return a list l' such that \n   l' is identical to l in the indicies that equal not divisible by five, while its value at the indicies that be divisible by five are equal \n   to the values of the represent indicies of l, but classify.\n  >>> sortFifth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFifth = (l) => {\n  const l2 = l.slice();\n  const l5 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 5 === 0) {\n      l5.push(l[i]);\n    }\n  }\n  l2.splice(l2.indexOf(l5[0]), 1);\n  return l2;\n};\n\n/*This function takes a list l and return a list l' such that \n   l' is identical to l in the indicies that equal not divisible by ten, while its value at the indicies that be divisible by ten are equal \n   to the values of the represent indicies of l, but classify.\n  >>> sortTenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortTenth = (l) => {\n  const l2 = l.slice();\n  const l10 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 10 === 0) {\n      l10.push(l[i]);\n    }\n  }\n  l2.splice(l2.indexOf(l10[0]), 1);\n  return l2;\n};\n\n/*This function takes a list l and return a list l' such that \n   l' is identical to l in the indicies that equal not divisible by twenty, while its value at the indicies that be divisible by twenty are equal \n   to the values of the represent indicies of l, but classify.\n  >>> sortTwenty([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwenty([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortTwenty = (l) => {\n  const l2 = l.slice();\n  const l20 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 20 === 0) {\n      l20.push(l[i]);\n    }\n  }\n  l2.splice(l2.indexOf(l20[0]), 1);\n  return l2;\n};\n\n/*This function takes a list l and return a list l' such that \n   l' is identical to l in the indicies that equal not divisible by thirty, while its value at the indicies that be divisible by thirty are equal \n   to the values of the represent indicies of l, but classify.\n  >>> sortThirty([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirty([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirty = (l) => {\n  const l2 = l.slice();\n  const l30 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 30 === 0) {\n      l30.push(l[i]);\n    }\n  }\n  l2.splice(l2.indexOf(l30[0]), 1);\n  return l2;\n};\n\n/*This function takes a list l and return a list l' such that \n   l' is identical to l in the indicies that equal not divisible by forty, while its value at the indicies that be divisible by forty are equal \n   to the values of the represent indicies of l, but classify.\n  >>> sortForty([1, 2, 3])\n  [1, 2, 3]\n  >>> sortForty([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortForty = (l) => {\n  const l2 = l.slice();\n  const l40 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 40 === 0) {\n      l40.push(l[i]);\n    }\n  }\n  l2.splice(l2.indexOf(l40[0]), 1);\n  return l2;\n};\n\n/*This function takes a list l and return a list l' such that \n   l' is identical to l in the indicies that equal not divisible by fifty, while its value at the indicies that be divisible by fifty are equal \n   to the values of the represent indicies of l, but classify.\n  >>> sortFifty([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifty([5, 6, 3, 4, 8, 9, 2])", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique component in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 3, "perturbed": true, "gc": "/*Return sorted unique component in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const uniqueList = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i]);\n    }\n  }\n  return uniqueList;\n};\n\nexport default unique;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 3, "perturbed": true, "gc": "/*Return maximum component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5,", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of multiplication the digit 7 appear in integer less than n which cost divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 3, "perturbed": true, "gc": "/*Return the number of multiplication the digit 7 appear in integer less than n which cost divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  const fizz = (n) => {\n    return n % 5 === 0? 'fizz' : '';\n  };\n  const buzz = (n) => {\n    return n % 3 === 0? 'buzz' : '';\n  };\n  const fizzBuzz = (n) => {\n    return fizz(n) + buzz(n);\n  };\n  return fizzBuzz(n);\n};\n\nmodule.exports = fizzBuzz;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and return a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies embody adequate \n   to the value of the even indicies of l, but classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 3, "perturbed": true, "gc": "/*This function takes a list l and return a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies embody adequate \n   to the value of the even indicies of l, but classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const l2 = l.slice(1);\n  const l3 = l.slice(2);\n  const l4 = l.slice(3);\n  const l5 = l.slice(4);\n  const l6 = l.slice(5);\n  const l7 = l.slice(6);\n  const l8 = l.slice(7);\n  const l9 = l.slice(8);\n  const l10 = l.slice(9);\n  const l11 = l.slice(10);\n  const l12 = l.slice(11);\n  const l13 = l.slice(12);\n  const l14 = l.slice(13);\n  const l15 = l.slice(14);\n  const l16 = l.slice(15);\n  const l17 = l.slice(16);\n  const l18 = l.slice(17);\n  const l19 = l.slice(18);\n  const l20 = l.slice(19);\n  const l21 = l.slice(20);\n  const l22 = l.slice(21);\n  const l23 = l.slice(22);\n  const l24 = l.slice(23);\n  const l25 = l.slice(24);\n  const l26 = l.slice(25);\n  const l27 = l.slice(26);\n  const l28 = l.slice(27);\n  const l29 = l.slice(28);\n  const l30 = l.slice(29);\n  const l31 = l.slice(30);\n  const l32 = l.slice(31);\n  const l33 = l.slice(32);\n  const l34 = l.slice(33);\n  const l35 = l.slice(34);\n  const l36 = l.slice(35);\n  const l37 = l.slice(36);\n  const l38 = l.slice(37);\n  const l39 = l.slice(38);\n  const l40 = l.slice(39);\n  const l41 = l.slice(40);\n  const l42 = l.slice(41);\n  const l43 = l.slice(42);\n  const l44 = l.slice(43);\n  const l45 = l.slice(44);\n  const l46 = l.slice(45);\n  const l47 = l.slice(46);\n  const l48 = l.slice(47);\n  const l49 = l.slice(48);\n  const l50 = l.slice(49);\n  const l51 = l.slice(50);\n  const l52 = l.slice(51);\n  const l53 = l.slice(52);\n  const l54 = l.slice(53);\n  const l55 = l.slice(54);\n  const l56 = l.slice(55);\n  const l57 = l.slice(56);\n  const l58 = l.slice(57);\n  const l59 = l.slice(58);\n  const l60 = l.slice(59);\n  const l61 = l.slice(60);\n  const l62 = l.slice(61);\n  const l63 = l.slice(62);\n  const l64 = l.slice(63);\n  const l65 = l.slice(64);\n  const l66 = l.slice(65);\n  const l67 = l.slice(66);\n  const l68 = l.slice(67);\n  const l69 = l.slice(68);\n  const l70 = l.slice(69);\n  const l71 = l.slice(70);\n  const l72 = l.slice(71);\n  const l73 = l.slice(72);\n  const l74 = l.slice(73);\n  const l75 = l.slice(74);\n  const l76 = l.slice(75);\n  const l77 = l.slice(76);\n  const l78 = l.slice(77);\n  const l79 = l.slice(78);\n  const l80 = l.slice(79);\n  const l81 = l.slice(80);\n  const l82 = l.slice(81);\n  const l83 = l.slice(82);\n  const l84 = l.slice(83);\n  const l85 = l.slice(84);\n  const l86 = l.slice(85);\n  const l87 = l.slice(86);\n  const l88 = l.slice(87);\n  const l89 = l.slice(88);\n  const l90 = l.slice(89);\n  const l91 = l.slice(90);\n  const l92 = l.slice(91);\n  const l93 = l.slice(92);\n  const l94 = l.slice(93);\n  const l95 = l.slice(94);\n  const l96 = l.slice(95);\n  const l97 = l.slice(96);\n  const l98 = l.slice(97);\n  const l99 = l.slice(98);\n  const l100 = l.slice(99);\n  const l101 = l.slice(100);\n  const l102 = l.slice(101);\n  const l103 = l.slice(102);\n  const l104 = l.slice(103);\n  const l105 = l.slice(104);\n  const l106 = l.slice(105);\n  const l107 = l.slice(106);\n  const l108 = l.slice(107);\n  const l109 = l.slice(108);\n  const l110 = l.slice(109);\n  const l111 = l.slice(110);\n  const l112 = l.slice(111);\n  const l113 = l.slice(112);\n  const l114 = l.slice(113);\n  const l115 = l.slice(114);\n  const l116 = l.slice(115);\n  const l117 = l.slice(116);\n  const l118 = l.slice(117);\n  const l119 = l.slice(118);\n  const l", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded bowed stringed instrument by cycling groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input chain encode with encode_cyclic affair. Returns decode bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 3, "perturbed": true, "gc": "/*\n  returns encoded bowed stringed instrument by cycling groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input chain encode with encode_cyclic affair. Returns decode bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n   volt-ampere groups = [ ], groups2 = [ ];\n   for (const group of s.split('')) {\n     if (group.length = = 3) \n       groups.push(group.slice(1) + group[0]);\n     else \n       groups.push(group);\n   }\n   return groups.join('');\n}\n*/\n\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_cyclic(s)\n// encode_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that be a Fibonacci number and it's besides choice.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 3, "perturbed": true, "gc": "/*\n  primeFib returns n-th number that be a Fibonacci number and it's besides choice.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  const fib = [1, 2];\n  const fibPrime = [1, 2];\n  const fibPrimePrime = [1, 2];\n  const fibPrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [1, 2];\n  const fibPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average absolute remainder between each \n   component and a centerpoint (mean in this subject ): \n   MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 3, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average absolute remainder between each \n   component and a centerpoint (mean in this subject ): \n   MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation2 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation3 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation4 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation5 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation6 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation7 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation8 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation9 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation10 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation11 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation12 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation13 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation14 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation15 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation16 = (numbers) => {\n  const mean = mean(numbers)\n  const deviations = numbers.map(number => Math.abs(number - mean))\n  return Math.mean(deviations)\n}\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input signal. \n   it returns on-key if there be three discrete element in the list that \n   kernel to zero, and false differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 3, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list of integers as an input signal. \n   it returns on-key if there be three discrete element in the list that \n   kernel to zero, and false differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  triplesSumToZero returns true if there is a triple in the list that \n   kernel to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  triplesSumToZero returns true if there is a triple in the list that \n   kernel to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  triplesSumToZero returns true if there is a triple in the list that \n   kernel to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  triplesSumToZero returns true if there is a triple in the list that \n   kernel to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  triplesSumToZero returns true if there is a triple in the list that \n   kernel to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  triplesSumToZero returns true if there is a triple in the list that \n   kernel to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  triplesSumToZero returns true if there is a triple in the list that \n   kernel to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length;", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely retentive lineage. \n   n cable car are drive left to justly;   simultaneously, a different set of n cars \n   are drive correct to left.    The two set of cars start out be very far from \n   each other.   All cars move in the same focal ratio.   Two car are pronounce to clash \n   when a cable car that's travel left to right hits a car that's move correct to exit. \n   However, the cable car are boundlessly sturdy and impregnable; as a result, they retain affect \n   in their trajectory as if they did not clash. \n\n   This routine output the number of such collision. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 3, "perturbed": true, "gc": "/*\n  Imagine a road that's a perfectly straight infinitely retentive lineage. \n   n cable car are drive left to justly;   simultaneously, a different set of n cars \n   are drive correct to left.    The two set of cars start out be very far from \n   each other.   All cars move in the same focal ratio.   Two car are pronounce to clash \n   when a cable car that's travel left to right hits a car that's move correct to exit. \n   However, the cable car are boundlessly sturdy and impregnable; as a result, they retain affect \n   in their trajectory as if they did not clash. \n\n   This routine output the number of such collision. \n   * / \n const carRaceCollision = (n) = > {\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /\n   * /", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 3, "perturbed": false, "gc": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [0, 1, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [4, 3, 3, 2, 3, 2, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [0, 1, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [4, 3, 3, 2, 3, 2, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [0, 1, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [4, 3, 3, 2, 3, 2, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [0, 1, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [4, 3, 3, 2, 3, 2, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [0, 1, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [4, 3, 3, 2, 3, 2, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const new", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input signal. \n   it returns on-key if there be two discrete element in the list that \n   kernel to zero, and false differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 3, "perturbed": true, "gc": "/*\n  pairsSumToZero takes a list of integers as an input signal. \n   it returns on-key if there be two discrete element in the list that \n   kernel to zero, and false differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const len = l.length\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += l[i]\n  }\n  return sum === 0\n}\n\n/*\n  pairsSumToZero returns true if the list contains two elements that sum to zero.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const len = l.length\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += l[i]\n  }\n  return sum === 0\n}\n\n/*\n  pairsSumToZero returns true if the list contains two elements that sum to zero.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const len = l.length\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += l[i]\n  }\n  return sum === 0\n}\n\n/*\n  pairsSumToZero returns true if the list contains two elements that sum to zero.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const len = l.length\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += l[i]\n  }\n  return sum === 0\n}\n\n/*\n  pairsSumToZero returns true if the list contains two elements that sum to zero.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const len = l.length\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += l[i]\n  }\n  return sum === 0\n}\n\n/*\n  pairsSumToZero returns true if the list contains two elements that sum to zero.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const len = l.length\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += l[i]\n  }\n  return sum === 0\n}\n\n/*\n  pairsSumToZero returns true if the list contains two elements that sum to zero.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const len = l.length\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += l[i]\n  }\n  return sum === 0\n}\n\n/*\n  pairsSumToZero returns true if the list contains two elements that sum to zero.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const len = l.length\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += l[i]\n  }\n  return sum === 0\n}\n\n/*\n  pairsSumToZero returns true if the list contains two elements that sum to zero.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input signal number x to base.\n   return drawstring theatrical performance after the conversion. \n   base phone number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 3, "perturbed": true, "gc": "/*Change numerical base of input signal number x to base.\n   return drawstring theatrical performance after the conversion. \n   base phone number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase2 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase3 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase4 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase5 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase6 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase7 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase8 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase9 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase10 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase11 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase12 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase13 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase14 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase15 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase16 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase17 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase18 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase19 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return result;\n};\n\nconst changeBase20 = (x, base) => {\n  const number = x.toString(base);\n  const result = number.split('');\n  const length = result.length;\n  const result = result.reverse();\n  const result = result.join('');\n  return", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea2 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea3 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea4 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea5 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea6 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea7 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea8 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea9 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea10 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea11 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea12 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea13 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea14 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea15 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea16 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea17 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea18 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea19 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n};\n\n/*Given length of a slope and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea20 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * a - h)) / 2;\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a succession similar to the Fibbonacci sequnece that's defined as take after: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please spell a affair to efficiently calculate the n-th chemical element of the fib4 number sequence.   Do not practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 3, "perturbed": true, "gc": "/*The Fib4 number sequence is a succession similar to the Fibbonacci sequnece that's defined as take after: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please spell a affair to efficiently calculate the n-th chemical element of the fib4 number sequence.   Do not practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n  if (n === 3) return 1;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\nconsole.log(fib4(5));\nconsole.log(fib4(6));\nconsole.log(fib4(7));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 3, "perturbed": false, "gc": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const middle = sorted[half];\n  if (sorted.length % 2 === 0) {\n    return (middle + sorted[half - 1]) / 2;\n  } else {\n    return middle;\n  }\n};\n\nexport default median;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "/*\n  Checks if given bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (exist aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 3, "perturbed": true, "gc": "/*Return 2^n modulo p (exist aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const a = n % p\n  return (a * (p - 1) + p) % p\n}\n\n/*Return n^2 modulo p (exist aware of numerics).\n  >>> modp2(3, 5)\n  9\n  >>> modp2(1101, 101)\n  2\n  >>> modp2(0, 101)\n  1\n  >>> modp2(3, 11)\n  8\n  >>> modp2(100, 101)\n  1\n  */\nconst modp2 = (n, p) => {\n  const a = n % p\n  return (a * a + p) % p\n}\n\n/*Return n^3 modulo p (exist aware of numerics).\n  >>> modp3(3, 5)\n  9\n  >>> modp3(1101, 101)\n  2\n  >>> modp3(0, 101)\n  1\n  >>> modp3(3, 11)\n  8\n  >>> modp3(100, 101)\n  1\n  */\nconst modp3 = (n, p) => {\n  const a = n % p\n  return (a * a * a + p) % p\n}\n\n/*Return n^4 modulo p (exist aware of numerics).\n  >>> modp4(3, 5)\n  9\n  >>> modp4(1101, 101)\n  2\n  >>> modp4(0, 101)\n  1\n  >>> modp4(3, 11)\n  8\n  >>> modp4(100, 101)\n  1\n  */\nconst modp4 = (n, p) => {\n  const a = n % p\n  return (a * a * a * a + p) % p\n}\n\n/*Return n^5 modulo p (exist aware of numerics).\n  >>> modp5(3, 5)\n  9\n  >>> modp5(1101, 101)\n  2\n  >>> modp5(0, 101)\n  1\n  >>> modp5(3, 11)\n  8\n  >>> modp5(100, 101)\n  1\n  */\nconst modp5 = (n, p) => {\n  const a = n % p\n  return (a * a * a * a * a + p) % p\n}\n\n/*Return n^6 modulo p (exist aware of numerics).\n  >>> modp6(3, 5)\n  9\n  >>> modp6(1101, 101)\n  2\n  >>> modp6(0, 101)\n  1\n  >>> modp6(3, 11)\n  8\n  >>> modp6(100, 101)\n  1\n  */\nconst modp6 = (n, p) => {\n  const a = n % p\n  return (a * a * a * a * a * a + p) % p\n}\n\n/*Return n^7 modulo p (exist aware of numerics).\n  >>> modp7(3, 5)\n  9\n  >>> modp7(1101, 101)\n  2\n  >>> modp7(0, 101)\n  1\n  >>> modp7(3, 11)\n  8\n  >>> modp7(100, 101)\n  1\n  */\nconst modp7 = (n, p) => {\n  const a = n % p\n  return (a * a * a * a * a * a * a + p) % p\n}\n\n/*Return n^8 modulo p (exist aware of numerics).\n  >>> modp8(3, 5)\n  9\n  >>> modp8(1101, 101)\n  2\n  >>> modp8(0, 101)\n  1\n  >>> modp8(3, 11)\n  8\n  >>> modp8(100, 101)\n  1\n  */\nconst modp8 = (n, p) => {\n  const a = n % p\n  return (a * a * a * a * a * a * a * a + p) % p\n}\n\n/*Return n^9 modulo p (exist aware of numerics).\n  >>> modp9(3, 5)\n  9\n  >>> modp9(1101, 101)\n  2\n  >>> modp9(0, 101)\n  1\n  >>> modp9(3, 11)\n  8\n  >>> modp9(100, 101)\n  1\n  */\nconst modp9 = (n, p) => {\n  const a = n % p\n  return (a * a * a * a * a * a * a * a * a + p) % p\n}\n\n/*Return n^10 modulo p (exist aware of numerics).\n  >>> modp10(3, 5)\n  9\n  >>> modp10(1101, 101)\n  2\n  >>> modp10(0, 101)\n  1\n  >>> modp10(3, 11)\n  8\n  >>> modp10(100, 101)\n  1\n  */\nconst modp10 = (n, p) => {\n  const a = n % p\n  return (a * a * a * a * a * a * a * a * a * a + p) % p\n}\n\n/*Return n^11 modulo p (exist aware of numerics).\n  >>> modp11(3, 5)\n  9\n  >>> modp11(1101, 101)\n  2\n  >>> modp11(0, 101)\n  1\n  >>> modp11(3, 11)\n  8\n  >>> modp11(100, 101)\n  1\n  */\nconst modp11 = (n, p) => {\n  const a = n % p\n  return (a * a * a * a * a * a * a * a * a * a * a + p) % p\n}\n\n/*Return n^12 modulo p (exist aware of numerics).\n  >>> modp12(3, 5)\n  9\n  >>> modp12(1101, 101)\n  2\n  >>> modp12(0, 101)\n  1\n  >>> mod", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive component of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 3, "perturbed": true, "gc": "/* Insert a number 'delimeter' between every two consecutive component of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let result = []\n  let i = 0\n  while (i < numbers.length - 1) {\n    result.push(numbers[i])\n    i += 1\n  }\n  result.push(numbers[i])\n  return result\n}\n\n/*\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded bowed stringed instrument by shifting every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   take as stimulation bowed stringed instrument encoded with encode_shift function. return decode string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 3, "perturbed": true, "gc": "/*\n  returns encoded bowed stringed instrument by shifting every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation bowed stringed instrument encoded with encode_shift function. return decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n */\n\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => {\n    return (ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) ) % 26 + \" a\".charCodeAt(0);\n  }).join(\" \");\n};\n\nconst decodeShift = (s) => {\n  return s.split(\" \").map(ch => {\n    return (ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26 + \" a\".charCodeAt(0);\n  }).join(\"\");\n};\n\nconst encode = (s) => {\n  return encodeShift(s);\n};\n\nconst decode = (s) => {\n  return decodeShift(s);\n};\n\nconst encode_shift = (s) => {\n  return encodeShift(s);\n};\n\nconst decode_shift = (s) => {\n  return decodeShift(s);\n};\n\nconst encode_shift_decode = (s) => {\n  return encodeShift(decodeShift(s));\n};\n\nconst encode_shift_decode_shift = (s) => {\n  return encodeShift(decodeShift(decodeShift(s)));\n};\n\nconst encode_shift_decode_shift_decode = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(s))));\n};\n\nconst encode_shift_decode_shift_decode_shift = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(s)))));\n};\n\nconst encode_shift_decode_shift_decode_shift_decode = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(s))))));\n};\n\nconst encode_shift_decode_shift_decode_shift_decode_shift = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(s)))))));\n};\n\nconst encode_shift_decode_shift_decode_shift_decode_shift_decode = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(s))))))));\n};\n\nconst encode_shift_decode_shift_decode_shift_decode_shift_decode_shift = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(s))))))));\n};\n\nconst encode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(s))))))))));\n};\n\nconst encode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(s)))))))))));\n};\n\nconst encode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(s))))))))))));\n};\n\nconst encode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(s))))))))))));\n};\n\nconst encode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(s))))))))))));\n};\n\nconst encode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift_decode_shift = (s) => {\n  return encodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift(decodeShift", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes bowed stringed instrument and returns drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 3, "perturbed": true, "gc": "/*\n  removeVowels is a function that takes bowed stringed instrument and returns drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const vowelsLength = vowels.length\n  const textLength = text.length\n  let i = 0\n  let j = 0\n  let vowel = ''\n  while (i < textLength) {\n    vowel = text[i]\n    if (vowels.indexOf(vowel)!== -1) {\n      text = text.substring(0, i) + text.substring(i + 1)\n      i = i - vowelsLength\n    } else {\n      i++\n    }\n  }\n  return text\n}\n\n/*\n  removeVowels is a function that takes bowed stringed instrument and returns drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  const punctuation = ['!', '?', '.', ',']\n  const textLength = text.length\n  let i = 0\n  let j = 0\n  let punctuationLength = punctuation.length\n  let punctuationIndex = 0\n  while (i < textLength) {\n    if (punctuation.indexOf(text[i])!== -1) {\n      text = text.substring(0, i) + text.substring(i + 1)\n      i = i - punctuationLength\n      punctuationIndex++\n    } else {\n      i++\n    }\n  }\n  return text\n}\n\n/*\n  removePunctuation is a function that takes bowed stringed instrument and returns drawstring without vowel.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuationAndVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const punctuation = ['!', '?', '.', ',']\n  const textLength = text.length\n  let i = 0\n  let j = 0\n  let vowel = ''\n  let punctuationLength = punctuation.length\n  let punctuationIndex = 0\n  while (i < textLength) {\n    vowel = text[i]\n    if (vowels.indexOf(vowel)!== -1) {\n      text = text.substring(0, i) + text.substring(i + 1)\n      i = i - punctuationLength\n      punctuationIndex++\n    } else if (punctuation.indexOf(text[i])!== -1) {\n      text = text.substring(0, i) + text.substring(i + 1)\n      i = i - punctuationLength\n      punctuationIndex++\n    } else {\n      i++\n    }\n  }\n  return text\n}\n\n/*\n  removePunctuation is a function that takes bowed stringed instrument and returns drawstring without vowel.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuationAndVowelsAndPunctuation = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const punctuation = ['!', '?', '.', ',']\n  const textLength = text.length\n  let i = 0\n  let j = 0\n  let vowel = ''\n  let punctuationLength = punctuation.length\n  let punctuationIndex = 0\n  while (i < textLength) {\n    vowel = text[i]\n    if (vowels.indexOf(vowel)!== -1) {\n      text = text.substring(0, i) + text.substring(i + 1)\n      i = i - punctuationLength\n      punctuationIndex++\n    } else if (punctuation.indexOf(text[i])!== -1) {\n      text = text.substring(0, i) + text.substring(i + 1)\n      i = i - punctuationLength\n      punctuationIndex++\n    } else {\n      i++\n    }\n  }\n  return text\n}\n\n/*\n  removePunctuation is a function that takes bowed stringed instrument and returns drawstring without vowel.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers pool in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 3, "perturbed": true, "gc": "/*Return true if all numbers pool in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  const len = l.length\n  for (let i = 0; i < len; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Return true if all numbers pool in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  const len = l.length\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Return true if all numbers pool in the list l are in the range [a, b].\n  >>> inRange([1, 2, 4, 10], [1, 5, 10])\n  true\n  >>> inRange([1, 2, 4, 10], [1, 20, 40])\n  false\n  >>> inRange([1, 2, 4, 10], [1, 20, 40, 100])\n  false\n  >>> inRange([1, 2, 4, 10], [1, 20, 40, 50])\n  true\n  */\nconst inRange = (l, a, b) => {\n  const len = l.length\n  for (let i = 0; i < len; i++) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Return true if all numbers pool in the list l are in the range [a, b]\n  and are not in the list l.\n  >>> notInRange([1, 2, 4, 10], [1, 5, 10])\n  false\n  >>> notInRange([1, 2, 4, 10], [1, 20, 40])\n  true\n  >>> notInRange([1, 2, 4, 10], [1, 20, 40, 100])\n  true\n  >>> notInRange([1, 2, 4, 10], [1, 20, 40, 50])\n  false\n  */\nconst notInRange = (l, a, b) => {\n  const len = l.length\n  for (let i = 0; i < len; i++) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Return true if all numbers pool in the list l are in the range [a, b]\n  and are not in the list l.\n  >>> notInRange([1, 2, 4, 10], [1, 5, 10], [1, 20, 40])\n  true\n  >>> notInRange([1, 2, 4, 10], [1, 20, 40], [1, 20, 40, 100])\n  false\n  >>> notInRange([1, 2, 4, 10], [1, 20, 40, 50], [1, 20, 40, 50])\n  true\n  */\nconst notInRange2 = (l, a, b) => {\n  const len = l.length\n  for (let i = 0; i < len; i++) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Return true if all numbers pool in the list l are in the range [a, b]\n  and are not in the list l.\n  >>> notInRange2([1, 2, 4, 10], [1, 5, 10], [1, 20, 40])\n  true\n  >>> notInRange2([1, 2, 4, 10], [1, 20, 40], [1, 20, 40, 100])\n  false\n  >>> notInRange2([1, 2, 4, 10], [1, 20, 40, 50], [1, 20, 40, 50])\n  true\n  */\nconst notInRange3 = (l, a, b) => {\n  const len = l.length\n  for (let i = 0; i < len; i++) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Return true if all numbers pool in the list l are in the range [a, b]\n  and are not in the list l.\n  >>> notInRange3([1, 2, 4, 10], [1, 5, 10], [1, 20, 40])\n  true\n  >>> notInRange3([1, 2, 4, 10], [1, 20, 40], [1, 20, 40, 100])\n  false\n  >>> notInRange3([1, 2, 4, 10], [1, 20, 40, 50], [1, 20, 40, 50])\n  true\n  */\nconst notInRange4 = (l, a, b) => {\n  const len = l.length\n  for (let i = 0; i < len; i++) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Return true if all numbers pool in the list l are in the range [a, b]\n  and are not in the list l.\n  >>> notInRange4([1, 2, 4, 10], [1, 5, 10], [1, 20, 40])\n  true\n  >>> notInRange4([1, 2, 4, 10], [1, 20, 40], [1, 20, 40, 100])\n  false\n  >>> notInRange4([1, 2, 4, 10], [1, 20, 40, 50], [1, 20, 40, 50])\n  true\n  */\nconst notInRange5 = (l, a, b) => {\n  const len = l.length\n  for (let i = 0; i < len; i++) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": false, "gc": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  35\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> divide(2, 3)\n  0.5\n  >>> divide(5, 7)\n  2.5\n  */\nconst modulo = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> modulo(2, 3)\n  1\n  >>> modulo(5, 7)\n  6\n  */\nconst power = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  8\n  >>> power(5, 7)\n  625\n  */\nconst factorial = (x) => {\n  return x === 1? 1 : x * factorial(x - 1);\n};\n\n/*\n  >>> factorial(5)\n  120\n  */\nconst gcd = (x, y) => {\n  return x === 0? y : gcd(y, x % y);\n};\n\n/*\n  >>> gcd(5, 7)\n  1\n  >>> gcd(2, 3)\n  1\n  >>> gcd(0, 0)\n  0\n  */\nconst lcm = (x, y) => {\n  return x * y / gcd(x, y);\n};\n\n/*\n  >>> lcm(5, 7)\n  7\n  >>> lcm(2, 3)\n  6\n  >>> lcm(0, 0)\n  0\n  */\nconst sum = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> sum(5, 7)\n  12\n  >>> sum(2, 3)\n  6\n  >>> sum(0, 0)\n  0\n  */\nconst difference = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> difference(5, 7)\n  4\n  >>> difference(2, 3)\n  1\n  >>> difference(0, 0)\n  0\n  */\nconst product = (x, y) => {\n  return x * y;\n};\n\n/*\n  >>> product(5, 7)\n  35\n  >>> product(2, 3)\n  6\n  >>> product(0, 0)\n  0\n  */\nconst quotient = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> quotient(5, 7)\n  2\n  >>> quotient(2, 3)\n  1\n  >>> quotient(0, 0)\n  0\n  */\nconst remainder = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> remainder(5, 7)\n  1\n  >>> remainder(2, 3)\n  1\n  >>> remainder(0, 0)\n  0\n  */\nconst abs = (x) => {\n  return x > 0? x : -x;\n};\n\n/*\n  >>> abs(5)\n  5\n  >>> abs(-5)\n  5\n  >>> abs(0)\n  0\n  */\nconst negate = (x) => {\n  return -x;\n};\n\n/*\n  >>> negate(5)\n  -5\n  >>> negate(-5)\n  5\n  >>> negate(0)\n  0\n  */\nconst square = (x) => {\n  return x * x;\n};\n\n/*\n  >>> square(5)\n  25\n  >>> square(-5)\n  25\n  >>> square(0)\n  0\n  */\nconst squareRoot = (x) => {\n  return Math.sqrt(x);\n};\n\n/*\n  >>> squareRoot(25)\n  5\n  >>> squareRoot(5)\n  1.4142135623730951\n  >>> squareRoot(0)\n  0\n  */\nconst cubeRoot = (x) => {\n  return Math.pow(x, 1 / 3);\n};\n\n/*\n  >>> cubeRoot(25)\n  5\n  >>> cubeRoot(5)\n  1.7320508075688772\n  >>> cubeRoot(0)\n  0\n  */\nconst factorial = (x) => {\n  return x === 1? 1 : x * factorial(x - 1);\n};\n\n/*\n  >>> factorial(5)\n  120\n  */\nconst factorial2 = (x) => {\n  return x === 1? 1 : x * factorial2(x - 1);\n};\n\n/*\n  >>> factorial2(5)\n  120\n  */\nconst fibonacci = (x) => {\n  if (x === 0) {\n    return 0;\n  }\n  if (x === 1) {\n    return 1;\n  }\n  return fibonacci(x - 1) + fibonacci(x - 2);\n};\n\n/*\n  >>> fibonacci(5)\n  8\n  >>> fibonacci(4)\n  3\n  >>> fibonacci(3)\n  2\n  >>> fibonacci(2)\n  1\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(0)\n  0\n  >>> fibonacci(-1)\n  1\n  >>> fibonacci(-2)\n  2\n  >>> fibonacci(-3)\n  3\n  >>> fibonacci(-4)\n  8\n  */\nconst fibonacci2 = (x) => {\n  if (x === 0) {\n    return 0;\n  }\n  if (x === 1) {\n    return 1;\n  }\n  return fibonacci2(x - 1) + fibonacci2(x - 2);\n};\n\n/*\n  >>> fibonacci2", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words experience the same character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 3, "perturbed": true, "gc": "/*\n  Check if two words experience the same character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = s0.length;\n  if (len!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = sameChars;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 3, "perturbed": false, "gc": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib2(10)\n  55\n  >>> fib2(1)\n  1\n  >>> fib2(8)\n  21\n  */\nconst fib2 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib2(n - 1) + fib2(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib3(10)\n  55\n  >>> fib3(1)\n  1\n  >>> fib3(8)\n  21\n  */\nconst fib3 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib3(n - 1) + fib3(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib4(10)\n  55\n  >>> fib4(1)\n  1\n  >>> fib4(8)\n  21\n  */\nconst fib4 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib4(n - 1) + fib4(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib5(10)\n  55\n  >>> fib5(1)\n  1\n  >>> fib5(8)\n  21\n  */\nconst fib5 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib5(n - 1) + fib5(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib6(10)\n  55\n  >>> fib6(1)\n  1\n  >>> fib6(8)\n  21\n  */\nconst fib6 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib6(n - 1) + fib6(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib7(10)\n  55\n  >>> fib7(1)\n  1\n  >>> fib7(8)\n  21\n  */\nconst fib7 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib7(n - 1) + fib7(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib8(10)\n  55\n  >>> fib8(1)\n  1\n  >>> fib8(8)\n  21\n  */\nconst fib8 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib8(n - 1) + fib8(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib9(10)\n  55\n  >>> fib9(1)\n  1\n  >>> fib9(8)\n  21\n  */\nconst fib9 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib9(n - 1) + fib9(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib10(10)\n  55\n  >>> fib10(1)\n  1\n  >>> fib10(8)\n  21\n  */\nconst fib10 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib10(n - 1) + fib10(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib11(10)\n  55\n  >>> fib11(1)\n  1\n  >>> fib11(8)\n  21\n  */\nconst fib11 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib11(n - 1) + fib11(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib12(10)\n  55\n  >>> fib12(1)\n  1\n  >>> fib12(8)\n  21\n  */\nconst fib12 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib12(n - 1) + fib12(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib13(10)\n  55\n  >>> fib13(1)\n  1\n  >>> fib13(8)\n  21\n  */\nconst fib13 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib13(n - 1) + fib13(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib14(10)\n  55\n  >>> fib14(1)\n  1\n  >>> fib14(8)\n  21\n  */\nconst fib14 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib14(n - 1) + fib14(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib15(10)\n  55\n  >>> fib15(1)\n  1\n  >>> fib15(8)\n  21\n  */\nconst fib15 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib15(n - 1) + fib15(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib16(10)\n  55\n  >>> fib16(1)\n  1\n  >>> fib16(8)\n  21\n  */\nconst fib16 = (n) => {\n  if (n === 1) return 1\n  if (n ===", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \" < \" and \" > \". \n   return false if every possibility bracket have a comparable completion bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "/* brackets is a string of \" < \" and \" > \". \n   return false if every possibility bracket have a comparable completion bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsLength = brackets.length\n  const bracketsLengthMinusOne = bracketsLength - 1\n  const bracketsLengthMinusTwo = bracketsLength - 2\n  const bracketsLengthMinusThree = bracketsLength - 3\n  const bracketsLengthMinusFour = bracketsLength - 4\n  const bracketsLengthMinusFive = bracketsLength - 5\n  const bracketsLengthMinusSix = bracketsLength - 6\n  const bracketsLengthMinusSeven = bracketsLength - 7\n  const bracketsLengthMinusEight = bracketsLength - 8\n  const bracketsLengthMinusNine = bracketsLength - 9\n  const bracketsLengthMinusTen = bracketsLength - 10\n\n  const brackets = brackets.split(\" \")\n  const bracketsLengthMinusOne = brackets.length - 1\n  const bracketsLengthMinusTwo = brackets.length - 2\n  const bracketsLengthMinusThree = brackets.length - 3\n  const bracketsLengthMinusFour = brackets.length - 4\n  const bracketsLengthMinusFive = brackets.length - 5\n  const bracketsLengthMinusSix = brackets.length - 6\n  const bracketsLengthMinusSeven = brackets.length - 7\n  const bracketsLengthMinusEight = brackets.length - 8\n  const bracketsLengthMinusNine = brackets.length - 9\n  const bracketsLengthMinusTen = brackets.length - 10\n\n  const bracketsLengthMinusOne = brackets.length - 1\n  const bracketsLengthMinusTwo = brackets.length - 2\n  const bracketsLengthMinusThree = brackets.length - 3\n  const bracketsLengthMinusFour = brackets.length - 4\n  const bracketsLengthMinusFive = brackets.length - 5\n  const bracketsLengthMinusSix = brackets.length - 6\n  const bracketsLengthMinusSeven = brackets.length - 7\n  const bracketsLengthMinusEight = brackets.length - 8\n  const bracketsLengthMinusNine = brackets.length - 9\n  const bracketsLengthMinusTen = brackets.length - 10\n\n  const bracketsLengthMinusOne = brackets.length - 1\n  const bracketsLengthMinusTwo = brackets.length - 2\n  const bracketsLengthMinusThree = brackets.length - 3\n  const bracketsLengthMinusFour = brackets.length - 4\n  const bracketsLengthMinusFive = brackets.length - 5\n  const bracketsLengthMinusSix = brackets.length - 6\n  const bracketsLengthMinusSeven = brackets.length - 7\n  const bracketsLengthMinusEight = brackets.length - 8\n  const bracketsLengthMinusNine = brackets.length - 9\n  const bracketsLengthMinusTen = brackets.length - 10\n\n  const bracketsLengthMinusOne = brackets.length - 1\n  const bracketsLengthMinusTwo = brackets.length - 2\n  const bracketsLengthMinusThree = brackets.length - 3\n  const bracketsLengthMinusFour = brackets.length - 4\n  const bracketsLengthMinusFive = brackets.length - 5\n  const bracketsLengthMinusSix = brackets.length - 6\n  const bracketsLengthMinusSeven = brackets.length - 7\n  const bracketsLengthMinusEight = brackets.length - 8\n  const bracketsLengthMinusNine = brackets.length - 9\n  const bracketsLengthMinusTen = brackets.length - 10\n\n  const bracketsLengthMinusOne = brackets.length - 1\n  const bracketsLengthMinusTwo = brackets.length - 2\n  const bracketsLengthMinusThree = brackets.length - 3\n  const bracketsLengthMinusFour = brackets.length - 4\n  const bracketsLengthMinusFive = brackets.length - 5\n  const bracketsLengthMinusSix = brackets.length - 6\n  const bracketsLengthMinusSeven = brackets.length - 7\n  const bracketsLengthMinusEight = brackets.length - 8\n  const bracketsLengthMinusNine = brackets.length - 9\n  const bracketsLengthMinusTen = brackets.length - 10\n\n  const bracketsLengthMinusOne = brackets.length - 1\n  const bracketsLengthMinusTwo = brackets.length - 2\n  const bracketsLengthMinusThree = brackets.length - 3\n  const bracketsLengthMinusFour = brackets.length - 4\n  const bracketsLengthMinusFive = brackets.length - 5\n  const bracketsLengthMinusSix = brackets.length - 6\n  const bracketsLengthMinusSeven = brackets.length - 7\n  const bracketsLengthMinusEight = brackets.length - 8\n  const bracketsLengthMinusNine = brackets.length - 9\n  const bracketsLengthMinusTen = brackets.length - 10\n\n  const bracketsLengthMinusOne = brackets.length - 1\n  const bracketsLengthMinusTwo = brackets.length - 2\n  const bracketsLengthMinusThree = brackets.length - 3\n  const bracketsLengthMinusFour = brackets.length - 4\n  const bracketsLengthMinusFive = brackets.length - 5\n  const bracketsLengthMinusSix = brackets.length - 6\n  const bracketsLengthMinusSeven = brackets.length - 7\n  const bracketsLengthMinusEight = brackets.length - 8\n  const bracketsLengthMinusNine = brackets.length - 9\n  const bracketsLengthMinusTen = brackets.length - 10\n\n  const bracketsLengthMinusOne = brackets.length - 1\n  const bracketsLengthMinusTwo = brackets.length - 2\n  const bracketsLengthMinusThree = brackets.length - 3\n  const bracketsLengthMinusFour = brackets.length - 4\n  const bracketsLengthMinusFive = brackets.length - 5\n  const bracketsLengthMinusSix = brackets.length - 6\n  const bracketsLengthMinusSeven = brackets.length - 7\n  const bracketsLengthMinusEight = brackets.length - 8\n  const bracketsLengthMinusNine = brackets.length - 9\n  const bracketsLengthMinusTen = brackets.length - 10\n\n  const bracketsLengthMinusOne = brackets.length - 1\n  const bracketsLengthMinusTwo = brackets.length - 2\n  const bracketsLengthMinusThree = brackets.length - 3\n  const bracketsLengthMinusFour = brackets.length - 4\n  const bracketsLengthMinusFive = brackets.length - 5\n  const bracketsLengthMinusSix = brackets.length - 6\n  const bracketsLengthMinusSeven = brackets.length - 7\n  const bracketsLengthMinusEight = brackets.length - 8\n  const bracketsLengthMinusNine = brackets.length - 9\n  const bracketsLengthMinusTen = brackets.length - 10\n\n  const bracketsLengthMinusOne = brackets.length - 1\n  const bracketsLengthMinusTwo = brackets.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list component are monotonically increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 3, "perturbed": true, "gc": "/*Return true is list component are monotonically increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nexport default monotonic;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted alone common elements for two tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 3, "perturbed": true, "gc": "/*Return sorted alone common elements for two tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1_len = l1.length;\n  const l2_len = l2.length;\n  const l1_i = 0;\n  const l2_i = 0;\n  const common_list = [];\n  while (l1_i < l1_len && l2_i < l2_len) {\n    if (l1[l1_i] === l2[l2_i]) {\n      common_list.push(l1[l1_i]);\n      l1_i++;\n      l2_i++;\n    } else if (l1[l1_i] < l2[l2_i]) {\n      l1_i++;\n    } else {\n      l2_i++;\n    }\n  }\n  return common_list;\n};\n\n/*\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  []\n  >>> common([5, 3, 2, 8], [3, 2, 5, 7])\n  [2, 3, 5]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2, 5])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2, 5, 7])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2, 5, 7, 1])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2, 5, 7, 1, 4])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2, 5, 7, 1, 4, 3])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2, 5, 7, 1, 4, 3, 2])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2, 5, 7, 1, 4, 3, 2, 5])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2, 5, 7, 1, 4, 3, 2, 5, 7])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2, 5, 7, 1, 4, 3, 2, 5, 7, 1])\n  [1, 5, 653]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 2, 3, 5, 7, 1, 4, 3, 2, 5, 7, 1, 4, 3, 2, 5,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime component of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 3, "perturbed": true, "gc": "/*Return the largest prime component of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime component of n. Assume n > 1 and is not a flower.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor2 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a flower.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor2 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor3 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a flower.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor3 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor4 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a flower.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor4 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor5 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a flower.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor5 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor6 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a flower.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor6 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor7 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a flower.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor7 =", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a bowed stringed instrument represented multiple group for nested parenthesis separated by quad. \n   For each of the group, output the cryptic level of nesting of digression. \n   E.g. (() ()) has maximal two levels of nest while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 3, "perturbed": true, "gc": "/* Input to this function is a bowed stringed instrument represented multiple group for nested parenthesis separated by quad. \n   For each of the group, output the cryptic level of nesting of digression. \n   E.g. (() ()) has maximal two levels of nest while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens2 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens3 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens4 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens5 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens6 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens7 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens8 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens9 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens10 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens11 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens12 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens13 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens14 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.map(p => p.reduce((acc, curr) => acc + curr, 0));\n  return paren_levels;\n};\n\nconst parseNestedParens15 = (paren_string) => {\n  const paren_groups = paren_string.split('').map(p => p.split('').map(p => p.length));\n  const paren_levels = paren_groups.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 3, "perturbed": true, "gc": "/*sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \" (\" and \") \". \n   return true if every possibility bracket have a comparable completion bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "/* brackets is a string of \" (\" and \") \". \n   return true if every possibility bracket have a comparable completion bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let stack = [];\n  for (let i = 0; i < brackets.length; i++) {\n    stack.push(brackets[i]);\n  }\n  let bracket = stack.pop();\n  while (stack.length > 0) {\n    if (bracket === stack.pop()) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a string, return the number of brackets in it.\n  The brackets are \"(\" and \")\".\n\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(\")\n  1\n  >>> countBrackets(\"\")\n  0\n  >>> countBrackets(\"()\")\n  2\n  */\nconst countBrackets = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '(') {\n      count++;\n    }\n    if (str[i] === ')') {\n      count--;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of brackets in it.\n  The brackets are \"{\" and \"}\".\n\n  >>> countBrackets(\"{}\")\n  2\n  >>> countBrackets(\"\")\n  0\n  >>> countBrackets(\"{}\")\n  1\n  >>> countBrackets(\"{}{\")\n  2\n  >>> countBrackets(\"{}{\")\n  1\n  >>> countBrackets(\"{}{\")\n  1\n  */\nconst countBrackets = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '{') {\n      count++;\n    }\n    if (str[i] === '}') {\n      count--;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of brackets in it.\n  The brackets are \"{\" and \"}\".\n\n  >>> countBrackets(\"{}\")\n  2\n  >>> countBrackets(\"\")\n  0\n  >>> countBrackets(\"{}\")\n  1\n  >>> countBrackets(\"{}{\")\n  2\n  >>> countBrackets(\"{}{\")\n  1\n  >>> countBrackets(\"{}{\")\n  1\n  */\nconst countBrackets = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '{') {\n      count++;\n    }\n    if (str[i] === '}') {\n      count--;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of brackets in it.\n  The brackets are \"(\" and \")\".\n\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"\")\n  0\n  >>> countBrackets(\"(()())\")\n  2\n  >>> countBrackets(\"(()())\")\n  2\n  >>> countBrackets(\"(()())\")\n  2\n  */\nconst countBrackets = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '(') {\n      count++;\n    }\n    if (str[i] === ')') {\n      count--;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of brackets in it.\n  The brackets are \"{\" and \"}\".\n\n  >>> countBrackets(\"{}\")\n  2\n  >>> countBrackets(\"\")\n  0\n  >>> countBrackets(\"{}\")\n  1\n  >>> countBrackets(\"{}{\")\n  2\n  >>> countBrackets(\"{}{\")\n  1\n  >>> countBrackets(\"{}{\")\n  1\n  */\nconst countBrackets = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '{') {\n      count++;\n    }\n    if (str[i] === '}') {\n      count--;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of brackets in it.\n  The brackets are \"(\" and \")\".\n\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"\")\n  0\n  >>> countBrackets(\"(()())\")\n  2\n  >>> countBrackets(\"(()())\")\n  2\n  >>> countBrackets(\"(()())\")\n  2\n  */\nconst countBrackets = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '(') {\n      count++;\n    }\n    if (str[i] === ')') {\n      count--;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of brackets in it.\n  The brackets are \"{\" and \"}\".\n\n  >>> countBrackets(\"{}\")\n  2\n  >>> countBrackets(\"\")\n  0\n  >>> countBrackets(\"{}\")\n  1\n  >>> countBrackets(\"{}{\")\n  2\n  >>> countBrackets(\"{}{\")\n  1\n  >>> countBrackets(\"{}{\")\n  1\n  */\nconst countBrackets = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '{') {\n      count++;\n    }\n    if (str[i] === '}') {\n      count--;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of brackets in it.\n  The brackets are \"(\"", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same human body.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 3, "perturbed": true, "gc": "/* xs represent coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same human body.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let d = [1]\n  for (let i = 1; i < xs.length; i++) {\n    d.push(xs[i] * d[i - 1])\n  }\n  return d\n}\n\n/*\n  Given a polynomial, return the value of this polynomial at x.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst evaluate = (xs) => {\n  let d = derivative(xs)\n  let sum = 0\n  for (let i = 0; i < d.length; i++) {\n    sum += d[i]\n  }\n  return sum\n}\n\n/*\n  Given a polynomial, return the value of this polynomial at x.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst evaluate2 = (xs) => {\n  let d = derivative(xs)\n  let sum = 0\n  for (let i = 0; i < d.length; i++) {\n    sum += d[i] * xs[i]\n  }\n  return sum\n}\n\n/*\n  Given a polynomial, return the value of this polynomial at x.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst evaluate3 = (xs) => {\n  let d = derivative(xs)\n  let sum = 0\n  for (let i = 0; i < d.length; i++) {\n    sum += d[i] * xs[i] * xs[i]\n  }\n  return sum\n}\n\n/*\n  Given a polynomial, return the value of this polynomial at x.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst evaluate4 = (xs) => {\n  let d = derivative(xs)\n  let sum = 0\n  for (let i = 0; i < d.length; i++) {\n    sum += d[i] * xs[i] * xs[i] * xs[i]\n  }\n  return sum\n}\n\n/*\n  Given a polynomial, return the value of this polynomial at x.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst evaluate5 = (xs) => {\n  let d = derivative(xs)\n  let sum = 0\n  for (let i = 0; i < d.length; i++) {\n    sum += d[i] * xs[i] * xs[i] * xs[i] * xs[i]\n  }\n  return sum\n}\n\n/*\n  Given a polynomial, return the value of this polynomial at x.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst evaluate6 = (xs) => {\n  let d = derivative(xs)\n  let sum = 0\n  for (let i = 0; i < d.length; i++) {\n    sum += d[i] * xs[i] * xs[i] * xs[i] * xs[i] * xs[i]\n  }\n  return sum\n}\n\n/*\n  Given a polynomial, return the value of this polynomial at x.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst evaluate7 = (xs) => {\n  let d = derivative(xs)\n  let sum = 0\n  for (let i = 0; i < d.length; i++) {\n    sum += d[i] * xs[i] * xs[i] * xs[i] * xs[i] * xs[i] * xs[i]\n  }\n  return sum\n}\n\n/*\n  Given a polynomial, return the value of this polynomial at x.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst evaluate8 = (xs) => {\n  let d = derivative(xs)\n  let sum = 0\n  for (let i = 0; i < d.length; i++) {\n    sum += d[i] * xs[i] * xs[i] * xs[i] * xs[i] * xs[i] * xs[i] * xs[i]\n  }\n  return sum\n}\n\n/*\n  Given a polynomial, return the value of this polynomial at x.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst evaluate9 = (xs) => {\n  let d = derivative(xs)\n  let sum = 0\n  for (let i = 0; i < d.length; i++) {\n    sum += d[i] * xs[i] * xs[i] * xs[i] * xs[i] * xs[i] * xs[i] * xs[i] * xs[i]\n  }\n  return", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a succession similar to the Fibbonacci sequnece that's defined as take after: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please spell a affair to efficiently calculate the n-th chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 3, "perturbed": true, "gc": "/*The FibFib number sequence is a succession similar to the Fibbonacci sequnece that's defined as take after: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please spell a affair to efficiently calculate the n-th chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return 0;\n  } else if (n === 2) {\n    return 1;\n  } else {\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n  }\n};\n\nconsole.log(fibfib(1));\nconsole.log(fibfib(5));\nconsole.log(fibfib(8));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which take a string represent \n   a parole as stimulation and fall the numeral of vowels in the string. \n   vowel in this casing are' a',' east',' i',' oxygen',' uranium'. Here,' y' is besides a \n   vowel, but only when it be at the goal of the give word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 3, "perturbed": true, "gc": "/*Write a function vowelsCount which take a string represent \n   a parole as stimulation and fall the numeral of vowels in the string. \n   vowel in this casing are' a',' east',' i',' oxygen',' uranium'. Here,' y' is besides a \n   vowel, but only when it be at the goal of the give word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  const vowels = ['a','e','i','o','u','y']\n  const count = 0\n  for(let i = 0; i < s.length; i++){\n    if(vowels.indexOf(s[i])!== -1){\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function which take a string as a parameter and return a string \n   which contains the same string but with all the vowels replaced by '*'. \n   Here '*' is a wildcard. \n\n   Example:\n  >>> replaceVowels(\"abcde\")\n  'abcde'\n  >>> replaceVowels(\"ACEDY\")\n  'ACEDY'\n  */\nconst replaceVowels = (s) => {\n  const vowels = ['a','e','i','o','u','y','*']\n  const count = 0\n  for(let i = 0; i < s.length; i++){\n    if(vowels.indexOf(s[i])!== -1){\n      count++\n    }\n  }\n  return s.replace(/[aeiouy]/g, '*')\n}\n\n/*Write a function which take a string as a parameter and return a string \n   which contains the same string but with all the vowels replaced by '*'. \n   Here '*' is a wildcard. \n\n   Example:\n  >>> replaceVowels(\"abcde\")\n  'abcde'\n  >>> replaceVowels(\"ACEDY\")\n  'ACEDY'\n  */\nconst replaceVowels2 = (s) => {\n  const vowels = ['a','e','i','o','u','y','*']\n  const count = 0\n  for(let i = 0; i < s.length; i++){\n    if(vowels.indexOf(s[i])!== -1){\n      count++\n    }\n  }\n  return s.replace(/[aeiouy]/g, '*')\n}\n\n/*Write a function which take a string as a parameter and return a string \n   which contains the same string but with all the vowels replaced by '*'. \n   Here '*' is a wildcard. \n\n   Example:\n  >>> replaceVowels(\"abcde\")\n  'abcde'\n  >>> replaceVowels(\"ACEDY\")\n  'ACEDY'\n  */\nconst replaceVowels3 = (s) => {\n  const vowels = ['a','e','i','o','u','y','*']\n  const count = 0\n  for(let i = 0; i < s.length; i++){\n    if(vowels.indexOf(s[i])!== -1){\n      count++\n    }\n  }\n  return s.replace(/[aeiouy]/g, '*')\n}\n\n/*Write a function which take a string as a parameter and return a string \n   which contains the same string but with all the vowels replaced by '*'. \n   Here '*' is a wildcard. \n\n   Example:\n  >>> replaceVowels(\"abcde\")\n  'abcde'\n  >>> replaceVowels(\"ACEDY\")\n  'ACEDY'\n  */\nconst replaceVowels4 = (s) => {\n  const vowels = ['a','e','i','o','u','y','*']\n  const count = 0\n  for(let i = 0; i < s.length; i++){\n    if(vowels.indexOf(s[i])!== -1){\n      count++\n    }\n  }\n  return s.replace(/[aeiouy]/g, '*')\n}\n\n/*Write a function which take a string as a parameter and return a string \n   which contains the same string but with all the vowels replaced by '*'. \n   Here '*' is a wildcard. \n\n   Example:\n  >>> replaceVowels(\"abcde\")\n  'abcde'\n  >>> replaceVowels(\"ACEDY\")\n  'ACEDY'\n  */\nconst replaceVowels5 = (s) => {\n  const vowels = ['a','e','i','o','u','y','*']\n  const count = 0\n  for(let i = 0; i < s.length; i++){\n    if(vowels.indexOf(s[i])!== -1){\n      count++\n    }\n  }\n  return s.replace(/[aeiouy]/g, '*')\n}\n\n/*Write a function which take a string as a parameter and return a string \n   which contains the same string but with all the vowels replaced by '*'. \n   Here '*' is a wildcard. \n\n   Example:\n  >>> replaceVowels(\"abcde\")\n  'abcde'\n  >>> replaceVowels(\"ACEDY\")\n  'ACEDY'\n  */\nconst replaceVowels6 = (s) => {\n  const vowels = ['a','e','i','o','u','y','*']\n  const count = 0\n  for(let i = 0; i < s.length; i++){\n    if(vowels.indexOf(s[i])!== -1){\n      count++\n    }\n  }\n  return s.replace(/[aeiouy]/g, '*')\n}\n\n/*Write a function which take a string as a parameter and return a string \n   which contains the same string but with all the vowels replaced by '*'. \n   Here '*' is a wildcard. \n\n   Example:\n  >>> replaceVowels(\"abcde\")\n  'abcde'\n  >>> replaceVowels(\"ACEDY\")\n  'ACEDY'\n  */\nconst replaceVowels7 = (s) => {\n  const vowels = ['a','e','i','o','u", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n   and return the result as a chain. \n   If shift > numeral of digit, return digit reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 3, "perturbed": true, "gc": "/*Circular shift the digits of the integer x, shift the digits right by shift\n   and return the result as a chain. \n   If shift > numeral of digit, return digit reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift2 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift3 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift4 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift5 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift6 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift7 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift8 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift9 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift10 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift11 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift12 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift13 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift14 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift15 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift16 = (x, shift) => {\n  const numeral = x.toString();\n  const reversed = numeral.split('').reverse().join('');\n  return reversed.substr(shift);\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift17 = (x, shift) => {\n  const numeral = x.to", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/66", "prompt": "/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 3, "perturbed": true, "gc": "/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task \n   Write a affair that takes a drawstring as remark and return the sum of the upper quality merely' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digit", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a bowed stringed instrument that represents a issue of apple and orange \n   that are distributed in a basket of yield this basket control \n   apples, orange, and mango yield. contribute the string that represent the total number of \n   the orange and apple and an integer that typify the total number of the fruit \n   in the basket return the number of the mango yield in the basket. \n   for examble: \n   fruitDistribution(\"5 apple and 6 orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 3, "perturbed": true, "gc": "/*\n  In this task, you will be given a bowed stringed instrument that represents a issue of apple and orange \n   that are distributed in a basket of yield this basket control \n   apples, orange, and mango yield. contribute the string that represent the total number of \n   the orange and apple and an integer that typify the total number of the fruit \n   in the basket return the number of the mango yield in the basket. \n   for examble: \n   fruitDistribution(\"5 apple and 6 orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let s = s.split(\" \")\n   let n = n.split(\" \")\n   let apple = 0\n   let orange = 0\n   let mango = 0\n   for (let i = 0; i < s.length; i++) {\n     if (s[i] == \"apple\") {\n       apple++\n     } else if (s[i] == \"orange\") {\n       orange++\n     } else if (s[i] == \"mango\") {\n       mango++\n     }\n   }\n   return (apple + orange + mango) - n\n }\n */\n\nfunction fruitDistribution(fruit, basket) {\n  let apple = 0\n  let orange = 0\n  let mango = 0\n  for (let i = 0; i < fruit.length; i++) {\n    if (fruit[i] == \"apple\") {\n      apple++\n    } else if (fruit[i] == \"orange\") {\n      orange++\n    } else if (fruit[i] == \"mango\") {\n      mango++\n    }\n  }\n  return (apple + orange + mango) - basket\n}\n\nconsole.log(fruitDistribution(\"5 apple and 6 orange \", 19))\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3))\nconsole.log(fruitDistribution(\"2 apples and 3 oranges \", 100))\nconsole.log(fruitDistribution(\"100 apple and 1 oranges\", 120))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given an array represent a branch of a tree that have non - damaging integer node \n   your undertaking is to pluck one of the node and return it. \n   The plucked node should equal the lymph node with the smallest tied value. \n   If multiple nodes with the like little even value are establish return the node that has modest exponent. \n\n   The plucked node should be return in a list, [ smalest_value, its exponent ], \n   If there cost no even value or the given array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 3, "perturbed": true, "gc": "/*\n  \" Given an array represent a branch of a tree that have non - damaging integer node \n   your undertaking is to pluck one of the node and return it. \n   The plucked node should equal the lymph node with the smallest tied value. \n   If multiple nodes with the like little even value are establish return the node that has modest exponent. \n\n   The plucked node should be return in a list, [ smalest_value, its exponent ], \n   If there cost no even value or the given array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  let min = arr[0];\n  let min_index = 0;\n  let min_exp = 1;\n  let max_exp = 1;\n  let max_index = 0;\n  let max_value = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      min_index = i;\n      min_exp = 1;\n    } else if (arr[i] === min) {\n      min_exp++;\n    }\n    if (arr[i] > max_value) {\n      max_value = arr[i];\n      max_index = i;\n      max_exp = 1;\n    } else if (arr[i] === max_value) {\n      max_exp++;\n    }\n  }\n  return [min, min_exp, max_index, max_exp];\n};\n\nconsole.log(pluck([4, 2, 3]));\nconsole.log(pluck([1, 2, 3]));\nconsole.log(pluck([]));\nconsole.log(pluck([5, 0, 3, 0, 4, 2]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non - empty list of positive integers. refund the great integer that embody great than \n   zero, and has a frequency bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the issue of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a non - empty list of positive integers. refund the great integer that embody great than \n   zero, and has a frequency bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the issue of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  let maxIndex = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      maxIndex = i\n      break\n    }\n  }\n  if (maxIndex === -1) {\n    return -1\n  }\n  let count = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      count++\n    }\n  }\n  if (count === maxIndex) {\n    return max\n  }\n  return search(lst.slice(0, maxIndex))\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1]))\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]))\nconsole.log(search([5, 5, 4, 4, 4]))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for one that contain give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 3, "perturbed": true, "gc": "/* Filter an input list of strings only for one that contain give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring)!== -1);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilter = (strings, substring, filter) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1));\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter = (strings, substring, filter, filter2) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2 = (strings, substring, filter, filter2) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2AndFilter = (strings, substring, filter, filter2, filter3) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2)\n   .filter(filter3);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2AndFilter2 = (strings, substring, filter, filter2, filter3) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2)\n   .filter(filter3);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2AndFilter2AndFilter = (strings, substring, filter, filter2, filter3, filter4) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2)\n   .filter(filter3)\n   .filter(filter4);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2AndFilter2AndFilter2 = (strings, substring, filter, filter2, filter3, filter4) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2)\n   .filter(filter3)\n   .filter(filter4);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2AndFilter2AndFilter2AndFilter = (strings, substring, filter, filter2, filter3, filter4, filter5) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2)\n   .filter(filter3)\n   .filter(filter4)\n   .filter(filter5);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2AndFilter2AndFilter2AndFilter2 = (strings, substring, filter, filter2, filter3, filter4, filter5) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2)\n   .filter(filter3)\n   .filter(filter4)\n   .filter(filter5);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2AndFilter2AndFilter2AndFilter2AndFilter = (strings, substring, filter, filter2, filter3, filter4, filter5, filter6) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2)\n   .filter(filter3)\n   .filter(filter4)\n   .filter(filter5)\n   .filter(filter6);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2AndFilter2AndFilter2AndFilter2AndFilter2 = (strings, substring, filter, filter2, filter3, filter4, filter5, filter6) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2)\n   .filter(filter3)\n   .filter(filter4)\n   .filter(filter5)\n   .filter(filter6);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2AndFilter2AndFilter2AndFilter2AndFilter2 = (strings, substring, filter, filter2, filter3, filter4, filter5, filter6, filter7) => {\n  return strings.filter(filter(string => string.indexOf(substring)!== -1))\n   .filter(filter2)\n   .filter(filter3)\n   .filter(filter4)\n   .filter(filter5)\n   .filter(filter6)\n   .filter(filter7);\n};\n\n// Filter an input list of strings only for one that contain give substring\n// using a custom filter function\nconst filterBySubstringWithFilterAndFilter2AndFilter2AndFilter2AndFilter2AndFilter2AndFilter2 = (strings, substring, filter, filter2, filter3, filter4, filter5, filter6, filter7, filter8) => {\n  return strings.filter(filter(string => string.indexOf(substring", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in foreign order. \n   Strange sorting, is when you begin with the minimal value, \n   then utmost of the remain integers, then minimum and so along.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 3, "perturbed": true, "gc": "/*\n  Given list of integers, return list in foreign order. \n   Strange sorting, is when you begin with the minimal value, \n   then utmost of the remain integers, then minimum and so along.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let min = lst[0]\n  let max = lst[len - 1]\n  let i = 0\n  let j = len - 1\n  let k = 0\n  while (i < j) {\n    while (i < j && lst[i] < min) {\n      i++\n    }\n    while (i < j && lst[j] > max) {\n      j--\n    }\n    if (i < j) {\n      sorted.push(lst[i])\n      i++\n      j--\n    }\n  }\n  return sorted\n}\n\nmodule.exports = strangeSortList\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three side of a triangle. render the area of \n   the triangulum round to 2 decimal point if the three slope imprint a valid triangle. \n   Otherwise return -1 \n   Three side form a valid triangle when the kernel of any two sides is great \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "/*\n  Given the lengths of the three side of a triangle. render the area of \n   the triangulum round to 2 decimal point if the three slope imprint a valid triangle. \n   Otherwise return -1 \n   Three side form a valid triangle when the kernel of any two sides is great \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  const s1 = (a + b) / 2\n  const s2 = (b + c) / 2\n  const s3 = (c + a) / 2\n  const s4 = (a + c) / 2\n  const s5 = (b + a) / 2\n  const s6 = (c + b) / 2\n  const s7 = (a + b + c) / 3\n  const s8 = (b + c + a) / 3\n  const s9 = (c + a + b) / 3\n  const s10 = (a + b + c + a + b + c) / 6\n  const s11 = (s1 + s2) / 2\n  const s12 = (s2 + s3) / 2\n  const s13 = (s3 + s4) / 2\n  const s14 = (s4 + s5) / 2\n  const s15 = (s5 + s6) / 2\n  const s16 = (s6 + s7) / 2\n  const s17 = (s7 + s8) / 2\n  const s18 = (s8 + s9) / 2\n  const s19 = (s9 + s10) / 2\n  const s20 = (s10 + s11) / 2\n  const s21 = (s11 + s12) / 2\n  const s22 = (s12 + s13) / 2\n  const s23 = (s13 + s14) / 2\n  const s24 = (s14 + s15) / 2\n  const s25 = (s15 + s16) / 2\n  const s26 = (s16 + s17) / 2\n  const s27 = (s17 + s18) / 2\n  const s28 = (s18 + s19) / 2\n  const s29 = (s19 + s20) / 2\n  const s30 = (s20 + s21) / 2\n  const s31 = (s21 + s22) / 2\n  const s32 = (s22 + s23) / 2\n  const s33 = (s23 + s24) / 2\n  const s34 = (s24 + s25) / 2\n  const s35 = (s25 + s26) / 2\n  const s36 = (s26 + s27) / 2\n  const s37 = (s27 + s28) / 2\n  const s38 = (s28 + s29) / 2\n  const s39 = (s29 + s30) / 2\n  const s40 = (s30 + s31) / 2\n  const s41 = (s31 + s32) / 2\n  const s42 = (s32 + s33) / 2\n  const s43 = (s33 + s34) / 2\n  const s44 = (s34 + s35) / 2\n  const s45 = (s35 + s36) / 2\n  const s46 = (s36 + s37) / 2\n  const s47 = (s37 + s38) / 2\n  const s48 = (s38 + s39) / 2\n  const s49 = (s39 + s40) / 2\n  const s50 = (s40 + s41) / 2\n  const s51 = (s41 + s42) / 2\n  const s52 = (s42 + s43) / 2\n  const s53 = (s43 + s44) / 2\n  const s54 = (s44 + s45) / 2\n  const s55 = (s45 + s46) / 2\n  const s56 = (s46 + s47) / 2\n  const s57 = (s47 + s48) / 2\n  const s58 = (s48 + s49) / 2\n  const s59 = (s49 + s50) / 2\n  const s60 = (s50 + s51) / 2\n  const s61 = (s51 + s52) / 2\n  const s62 = (s52 + s53) / 2\n  const s63 = (s53 + s54) / 2\n  const s64 = (s54 + s55) / 2\n  const s65 = (s55 + s56) / 2\n  const s66 = (s56 + s57) / 2\n  const s67 = (s57 + s58) / 2\n  const s68 = (s58 + s59) / 2\n  const s69 = (s59 + s60) / 2\n  const s70 = (s60 + s61) / 2\n  const s71 = (s61 + s62) / 2\n  const s72 = (s62 + s63) / 2\n  const s73 = (s63 + s64) / 2\n  const s74 = (s64 + s65) / 2\n  const s75 = (s65 + s66) / 2\n  const s76 = (s66 + s67) / 2\n  const s77 = (s67 + s68) / 2\n  const s78 = (s68 + s69) / 2\n  const s79 = (s69 + s70) / 2\n  const s80 = (s70 + s71) / 2\n  const s81 = (s71 + s72) / 2\n  const s82 = (s72 + s73) / 2\n  const s83 = (s73 + s74) / 2\n  const s84 = (s74 + s75) / 2\n  const s85 = (s75 + s76) / 2\n  const s86 = (s76 + s77) / 2\n  const s87 = (s77 + s78) / 2\n  const s88 = (s78 + s79) / 2\n  const s89 = (s79 + s80) / 2\n  const s90 = (s80 + s81) / 2\n  const s91 = (s81 + s82) / 2\n  const s92 = (s82 + s83) / 2\n  const s93 = (s83 + s84)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that return true if the aim q will vanish, and assumed differently. \n   The aim q will flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximal possible weight unit w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function that return true if the aim q will vanish, and assumed differently. \n   The aim q will flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximal possible weight unit w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly2 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly3 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly4 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly5 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly6 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly7 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly8 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly9 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly10 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly11 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly12 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly13 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly14 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly15 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly16 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly17 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly18 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly19 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly20 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly21 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly22 = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\nconst willItFly", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integer, find the minimum number of chemical element that \n   necessitate to be transfer to cook the array palindromic. A palindromic array is an array that \n   is learn the like backwards and forward. In one variety, you can change one element to any early element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array arr of integer, find the minimum number of chemical element that \n   necessitate to be transfer to cook the array palindromic. A palindromic array is an array that \n   is learn the like backwards and forward. In one variety, you can change one element to any early element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let count = 0;\n    for (let j = 0; j < arr.length; j++) {\n      if (arr[i] === arr[j]) {\n        count++;\n      }\n    }\n    if (count > result) {\n      result = count;\n    }\n  }\n  return result;\n};\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accept two lists of string and return the list that has \n   entire number of char in the all strings of the list less than the other list.\n\n   if the two lists consume the same phone number of char, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function that accept two lists of string and return the list that has \n   entire number of char in the all strings of the list less than the other list.\n\n   if the two lists consume the same phone number of char, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch2 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch3 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch4 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch5 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch6 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch7 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch8 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch9 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch10 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch11 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\nconst totalMatch12 = (lst1, lst2) => {\n  const len", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/75", "prompt": "/*Write a affair that returns on-key if the render numeral cost the generation of 3 premier issue \n   and delusive otherwise. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 3, "perturbed": true, "gc": "/*Write a affair that returns on-key if the render numeral cost the generation of 3 premier issue \n   and delusive otherwise. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrime = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFast = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeSlow = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFastSlow = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFastSlow2 = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFastSlow3 = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFastSlow4 = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFastSlow5 = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFastSlow6 = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFastSlow7 = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFastSlow8 = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i <= Math.sqrt(a)) {\n    if (a % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFastSlow9 = (a) => {\n  if (a < 2) {\n    return false;\n  }\n  if (a === 2", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a affair that returns on-key if a numeral x constitute a elementary \n   power of n and assumed in other lawsuit. \n   x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 3, "perturbed": true, "gc": "/*Your task is to write a affair that returns on-key if a numeral x constitute a elementary \n   power of n and assumed in other lawsuit. \n   x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower(x / n, n);\n};\n\nconst isSimplePower2 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower2(x / n, n);\n};\n\nconst isSimplePower3 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower3(x / n, n);\n};\n\nconst isSimplePower4 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower4(x / n, n);\n};\n\nconst isSimplePower5 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower5(x / n, n);\n};\n\nconst isSimplePower6 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower6(x / n, n);\n};\n\nconst isSimplePower7 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower7(x / n, n);\n};\n\nconst isSimplePower8 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower8(x / n, n);\n};\n\nconst isSimplePower9 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower9(x / n, n);\n};\n\nconst isSimplePower10 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower10(x / n, n);\n};\n\nconst isSimplePower11 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower11(x / n, n);\n};\n\nconst isSimplePower12 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower12(x / n, n);\n};\n\nconst isSimplePower13 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower13(x / n, n);\n};\n\nconst isSimplePower14 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower14(x / n, n);\n};\n\nconst isSimplePower15 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower15(x / n, n);\n};\n\nconst isSimplePower16 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower16(x / n, n);\n};\n\nconst isSimplePower17 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower17(x / n, n);\n};\n\nconst isSimplePower18 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower18(x / n, n);\n};\n\nconst isSimplePower19 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower19(x / n, n);\n};\n\nconst isSimplePower20 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower20(x / n, n);\n};\n\nconst isSimplePower21 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower21(x / n, n);\n};\n\nconst isSimplePower22 = (x, n) => {\n  if (x === 1) return", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that take an integer a and reelect genuine \n   if this ingeger be a block of some integer number. \n   bill: you may bear the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function that take an integer a and reelect genuine \n   if this ingeger be a block of some integer number. \n   bill: you may bear the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) {\n    return true\n  }\n  if (a % 3 === 0) {\n    return false\n  }\n  return iscube(a / 3)\n}\n\nconsole.log(iscube(1))\nconsole.log(iscube(2))\nconsole.log(iscube(-1))\nconsole.log(iscube(64))\nconsole.log(iscube(180))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a affair that receives \n   a hexadecimal phone number as a chain and count the numeral of hexadecimal \n   digits that are primes (flower number=== or a prime=== is a natural numeral \n   greater than 1 that be not a merchandise of two small lifelike numeral). \n   Hexadecimal digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime number are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to decide a issue of the comply digit: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note: you may bear the stimulation is constantly correct or empty string=== \n   and symbols A===B===C===D===E===F are constantly uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 3, "perturbed": true, "gc": "/*You have been tasked to write a affair that receives \n   a hexadecimal phone number as a chain and count the numeral of hexadecimal \n   digits that are primes (flower number=== or a prime=== is a natural numeral \n   greater than 1 that be not a merchandise of two small lifelike numeral). \n   Hexadecimal digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime number are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to decide a issue of the comply digit: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note: you may bear the stimulation is constantly correct or empty string=== \n   and symbols A===B===C===D===E===F are constantly uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  const hex = num.toString(16);\n  const prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1131, 1133, 1139, 1143, 1151, 1159, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal kind and your task be to change it to \n   binary format. The function should return a chain, with each character constitute a binary \n   number. Each character in the string will equal' 0' or' 1'. \n\n   There will be an excess couple of characters' db' at the beginning and at the goal of the string. \n   The extra character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 3, "perturbed": true, "gc": "/*You will be given a number in decimal kind and your task be to change it to \n   binary format. The function should return a chain, with each character constitute a binary \n   number. Each character in the string will equal' 0' or' 1'. \n\n   There will be an excess couple of characters' db' at the beginning and at the goal of the string. \n   The extra character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder = decimal;\n  while (remainder > 0) {\n    let digit = remainder % 2;\n    remainder = remainder / 2;\n    binary = digit + binary;\n  }\n  return binary;\n};\n\n/*\n  You will be given a number in binary format and your task be to convert it to decimal format. \n  The function should return a chain, with each character constitute a decimal number. \n  Each character in the string will equal' 0' or' 1'. \n\n  There will be an excess couple of characters' db' at the beginning and at the goal of the string. \n  The extra character are there to help with the format.\n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let remainder = binary;\n  while (remainder > 0) {\n    let digit = remainder % 2;\n    remainder = remainder / 2;\n    decimal = decimal + digit * Math.pow(2, remainder);\n  }\n  return decimal;\n};\n\nconst test = (decimal) => {\n  console.log(decimalToBinary(decimal));\n  console.log(binaryToDecimal(decimalToBinary(decimal)));\n};\n\ntest(15);\ntest(32);\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple dwell of a sum and a intersection of all the integer in a list.\n   Empty kernel should be adequate to 0 and empty merchandise should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 3, "perturbed": true, "gc": "/* For a given list of integers, return a tuple dwell of a sum and a intersection of all the integer in a list.\n   Empty kernel should be adequate to 0 and empty merchandise should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const product = 1\n  const sum = 0\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i]\n    sum += product\n  }\n  return (sum, product)\n}\n\nexport default sumProduct\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n   Your undertaking is to check if the drawstring is glad or not. \n   A bowed stringed instrument is happy if its duration is at least 3 and every 3 consecutive letter are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 3, "perturbed": true, "gc": "/*You are given a string s.\n   Your undertaking is to check if the drawstring is glad or not. \n   A bowed stringed instrument is happy if its duration is at least 3 and every 3 consecutive letter are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s1 = 0, s2 = 0, s3 = 0, s4 = 0, s5 = 0, s6 = 0, s7 = 0, s8 = 0, s9 = 0, s10 = 0, s11 = 0, s12 = 0, s13 = 0, s14 = 0, s15 = 0, s16 = 0, s17 = 0, s18 = 0, s19 = 0, s20 = 0, s21 = 0, s22 = 0, s23 = 0, s24 = 0, s25 = 0, s26 = 0, s27 = 0, s28 = 0, s29 = 0, s30 = 0, s31 = 0, s32 = 0, s33 = 0, s34 = 0, s35 = 0, s36 = 0, s37 = 0, s38 = 0, s39 = 0, s40 = 0, s41 = 0, s42 = 0, s43 = 0, s44 = 0, s45 = 0, s46 = 0, s47 = 0, s48 = 0, s49 = 0, s50 = 0, s51 = 0, s52 = 0, s53 = 0, s54 = 0, s55 = 0, s56 = 0, s57 = 0, s58 = 0, s59 = 0, s60 = 0, s61 = 0, s62 = 0, s63 = 0, s64 = 0, s65 = 0, s66 = 0, s67 = 0, s68 = 0, s69 = 0, s70 = 0, s71 = 0, s72 = 0, s73 = 0, s74 = 0, s75 = 0, s76 = 0, s77 = 0, s78 = 0, s79 = 0, s80 = 0, s81 = 0, s82 = 0, s83 = 0, s84 = 0, s85 = 0, s86 = 0, s87 = 0, s88 = 0, s89 = 0, s90 = 0, s91 = 0, s92 = 0, s93 = 0, s94 = 0, s95 = 0, s96 = 0, s97 = 0, s98 = 0, s99 = 0, s100 = 0, s101 = 0, s102 = 0, s103 = 0, s104 = 0, s105 = 0, s106 = 0, s107 = 0, s108 = 0, s109 = 0, s110 = 0, s111 = 0, s112 = 0, s113 = 0, s114 = 0, s115 = 0, s116 = 0, s117 = 0, s118 = 0, s119 = 0, s120 = 0, s121 = 0, s122 = 0, s123 = 0, s124 = 0, s125 = 0, s126 = 0, s127 = 0, s128 = 0, s129 = 0, s130 = 0, s131 = 0, s132 = 0, s133 = 0, s134 = 0, s135 = 0, s136 = 0, s137 = 0, s138 = 0, s139 = 0, s140 = 0, s141 = 0, s142 = 0, s143 = 0, s144 = 0, s145 = 0, s146 = 0, s147 = 0, s148 = 0, s149 = 0, s150 = 0, s151 = 0, s152 = 0, s153 = 0, s154 = 0, s155 = 0, s156 = 0, s157 = 0, s158 = 0, s159 = 0, s160 = 0, s161 = 0, s162 = 0, s163 = 0, s164 = 0, s165 = 0, s166 = 0, s167 = 0, s168 = 0, s169 = 0, s170 = 0, s171 = 0, s172 = 0, s173 = 0, s174 = 0, s175 = 0, s176 = 0, s177 = 0, s178 = 0, s179 = 0, s180 = 0, s181 = 0, s182 = 0, s183 = 0, s184 = 0, s185 = 0, s186 = 0, s187 = 0, s188 = 0, s189 = 0, s190 = 0, s191 = 0, s192 = 0, s193 = 0, s194 = 0, s195 = 0, s196 = 0, s197 = 0, s198 = 0, s199 = 0, s200 = 0, s201 = 0, s202 = 0, s203 = 0, s204 = 0, s205 = 0, s206 = 0, s207 = 0, s208 = 0, s209 = 0, s210 = 0, s211 = 0, s212 = 0, s213 = 0, s214 = 0, s215 = 0, s216 = 0, s217 = 0, s218 = 0, s219 = 0, s220 = 0, s221 = 0, s222 = 0, s223 = 0, s224 = 0, s225 = 0, s226 = 0, s227 = 0, s228 = 0, s229 = 0, s230 = 0, s231 = 0, s232 = 0, s233 = 0, s234 = 0, s235 = 0, s236 = 0, s237 = 0, s238 = 0, s239 = 0, s240 = 0, s241 = 0, s242 = 0, s243 = 0, s244 = 0, s245 = 0, s246 = 0, s247 = 0, s248 = 0, s249 = 0, s250 = 0, s251 = 0, s252 = 0, s253 = 0, s254 = 0, s255 = 0, s256 = 0, s257 = 0, s258 = 0, s259 = 0, s260 = 0, s261 = 0, s262 = 0, s263 = 0, s264 = 0, s265 = 0, s266 = 0, s267 = 0, s268 = 0, s269 = 0, s270 = 0, s271 = 0, s272 = 0, s273 = 0, s274 = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last workweek of the semester and the teacher has to contribute the grades\n   to student. The teacher has been seduce her own algorithm for grade. \n   The only trouble is, she has lost the code she use for grade. \n   She has give you a list of GPAs for some students and you own to spell \n   a routine that can output a list of letter grades using the follow table: \n            GPA        |     Letter degree \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 five hundred \n           > 0.0                 D- \n             0.0                 east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 3, "perturbed": true, "gc": "/*It is the last workweek of the semester and the teacher has to contribute the grades\n   to student. The teacher has been seduce her own algorithm for grade. \n   The only trouble is, she has lost the code she use for grade. \n   She has give you a list of GPAs for some students and you own to spell \n   a routine that can output a list of letter grades using the follow table: \n            GPA        |     Letter degree \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 five hundred \n           > 0.0                 D- \n             0.0                 east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrade;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    const letterGrade = grade.toFixed(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that take a string and returns on-key if the string\n   duration constitute a premier numeral or false differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 3, "perturbed": true, "gc": "/*Write a function that take a string and returns on-key if the string\n   duration constitute a premier numeral or false differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const prime = /^\\d+$/;\n  const length = string.length;\n  let i = 0;\n  while (i < length) {\n    if (prime.test(string.charAt(i)) === false) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst prime = primeLength('Hello');\nconsole.log(prime);\n\nconst prime2 = primeLength('abcdcba');\nconsole.log(prime2);\n\nconst prime3 = primeLength('kittens');\nconsole.log(prime3);\n\nconst prime4 = primeLength('orange');\nconsole.log(prime4);\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n   positive integer that begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n   positive integer that begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*Given a positive integer N, return the total sum of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += N % 2;\n    N = N / 2;\n  }\n  return sum;\n};\n\nconsole.log(solve(1000));\nconsole.log(solve(150));\nconsole.log(solve(147));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integers lst. add the even chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "/*Given a non - empty list of integers lst. add the even chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given a non - empty list of integers lst. add the odd chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 6\n  */\nconst addOdd = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given a non - empty list of integers lst. add the even and odd chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 8\n  */\nconst addEvenOdd = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    } else {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given a non - empty list of integers lst. add the odd and even chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 10\n  */\nconst addOddEven = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    } else {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given a non - empty list of integers lst. add the odd and even chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 12\n  */\nconst addOddEven2 = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    } else {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given a non - empty list of integers lst. add the odd and even chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 14\n  */\nconst addOddEven3 = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    } else {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given a non - empty list of integers lst. add the odd and even chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 16\n  */\nconst addOddEven4 = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    } else {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given a non - empty list of integers lst. add the odd and even chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 18\n  */\nconst addOddEven5 = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    } else {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given a non - empty list of integers lst. add the odd and even chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 20\n  */\nconst addOddEven6 = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    } else {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given a non - empty list of integers lst. add the odd and even chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 22\n  */\nconst addOddEven7 = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    } else {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given a non - empty list of integers lst. add the odd and even chemical element that constitute at curious index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 24\n  */\nconst addOddEven8 = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    } else {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\n/*\n  Given", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that take a string and reelect an arranged interpretation of it. \n   arrange interpretation of chain, is a bowed stringed instrument where all words (separate by outer space) \n   are replaced by a modern word where all the quality arrange in\n   ascend order based on ascii value. \n   eminence: You should keep the order of news and blank space in the conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function that take a string and reelect an arranged interpretation of it. \n   arrange interpretation of chain, is a bowed stringed instrument where all words (separate by outer space) \n   are replaced by a modern word where all the quality arrange in\n   ascend order based on ascii value. \n   eminence: You should keep the order of news and blank space in the conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let result = '';\n  let index = 0;\n  let length = s.length;\n  let last = 0;\n  let lastChar = 0;\n  let lastCharAscii = 0;\n  let lastCharAsciiValue = 0;\n  let lastCharAsciiValueValue = 0;\n  let lastCharAsciiValueValueValue = 0;\n  let lastCharAsciiValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValueValueValueValueValueValue = 0;\n  let lastCharAsciiValueValueValueValueValue", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional datum, as a nested lists, \n   which is exchangeable to matrix, however, unlike matrices, \n   each rowing may contain a unlike number of columns. \n   give lst, and integer x, recover integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row, column), originate with 0. \n   Sort coordinates initially by rows in ascend orderliness. \n   besides, kind coordinates of the row by columns in fall order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional datum, as a nested lists, \n   which is exchangeable to matrix, however, unlike matrices, \n   each rowing may contain a unlike number of columns. \n   give lst, and integer x, recover integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row, column), originate with 0. \n   Sort coordinates initially by rows in ascend orderliness. \n   besides, kind coordinates of the row by columns in fall order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const [row, col] = lst.sort((a, b) => a[0] - b[0])\n  const [row1, col1] = lst.sort((a, b) => a[1] - b[1])\n  const [row2, col2] = lst.sort((a, b) => a[1] - b[1])\n  const [row3, col3] = lst.sort((a, b) => a[1] - b[1])\n  const [row4, col4] = lst.sort((a, b) => a[1] - b[1])\n  const [row5, col5] = lst.sort((a, b) => a[1] - b[1])\n  const [row6, col6] = lst.sort((a, b) => a[1] - b[1])\n  const [row7, col7] = lst.sort((a, b) => a[1] - b[1])\n  const [row8, col8] = lst.sort((a, b) => a[1] - b[1])\n  const [row9, col9] = lst.sort((a, b) => a[1] - b[1])\n  const [row10, col10] = lst.sort((a, b) => a[1] - b[1])\n  const [row11, col11] = lst.sort((a, b) => a[1] - b[1])\n  const [row12, col12] = lst.sort((a, b) => a[1] - b[1])\n  const [row13, col13] = lst.sort((a, b) => a[1] - b[1])\n  const [row14, col14] = lst.sort((a, b) => a[1] - b[1])\n  const [row15, col15] = lst.sort((a, b) => a[1] - b[1])\n  const [row16, col16] = lst.sort((a, b) => a[1] - b[1])\n  const [row17, col17] = lst.sort((a, b) => a[1] - b[1])\n  const [row18, col18] = lst.sort((a, b) => a[1] - b[1])\n  const [row19, col19] = lst.sort((a, b) => a[1] - b[1])\n  const [row20, col20] = lst.sort((a, b) => a[1] - b[1])\n  const [row21, col21] = lst.sort((a, b) => a[1] - b[1])\n  const [row22, col22] = lst.sort((a, b) => a[1] - b[1])\n  const [row23, col23] = lst.sort((a, b) => a[1] - b[1])\n  const [row24, col24] = lst.sort((a, b) => a[1] - b[1])\n  const [row25, col25] = lst.sort((a, b) => a[1] - b[1])\n  const [row26, col26] = lst.sort((a, b) => a[1] - b[1])\n  const [row27, col27] = lst.sort((a, b) => a[1] - b[1])\n  const [row28, col28] = lst.sort((a, b) => a[1] - b[1])\n  const [row29, col29] = lst.sort((a, b) => a[1] - b[1])\n  const [row30, col30] = lst.sort((a, b) => a[1] - b[1])\n  const [row31, col31] = lst.sort((a, b) => a[1] - b[1])\n  const [row32, col32] = lst.sort((a, b) => a[1] - b[1])\n  const [row33, col33] = lst.sort((a, b) => a[1] - b[1])\n  const [row34, col34] = lst.sort((a, b) => a[1] - b[1])\n  const [row35, col35] = lst.sort((a, b) => a[1] - b[1])\n  const [row36, col36] = lst.sort((a, b) => a[1] - b[1])\n  const [row37, col37] = lst.sort((a, b) => a[1] - b[1])\n  const [row38, col38] = lst.sort((a, b) => a[1] - b[1])\n  const [row39, col39] = lst.sort((a, b) => a[1] - b[1])\n  const [row40, col40] = lst.sort((a, b) => a[1] - b[1])\n  const [row41, col41] = lst.sort((a, b) => a[1] - b[1", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non - negative integers, return a copy of the render array after screen, \n   you will screen the give array in ascending decree if the sum (beginning index value, last exponent value) be odd, \n   or sort it in condescend order if the sum (beginning index value, last exponent value) is even. \n\n   eminence: \n   * don't deepen the give array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array of non - negative integers, return a copy of the render array after screen, \n   you will screen the give array in ascending decree if the sum (beginning index value, last exponent value) be odd, \n   or sort it in condescend order if the sum (beginning index value, last exponent value) is even. \n\n   eminence: \n   * don't deepen the give array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const len = array.length;\n  const render = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n  let temp4 = 0;\n  let temp5 = 0;\n  let temp6 = 0;\n  let temp7 = 0;\n  let temp8 = 0;\n  let temp9 = 0;\n  let temp10 = 0;\n  let temp11 = 0;\n  let temp12 = 0;\n  let temp13 = 0;\n  let temp14 = 0;\n  let temp15 = 0;\n  let temp16 = 0;\n  let temp17 = 0;\n  let temp18 = 0;\n  let temp19 = 0;\n  let temp20 = 0;\n  let temp21 = 0;\n  let temp22 = 0;\n  let temp23 = 0;\n  let temp24 = 0;\n  let temp25 = 0;\n  let temp26 = 0;\n  let temp27 = 0;\n  let temp28 = 0;\n  let temp29 = 0;\n  let temp30 = 0;\n  let temp31 = 0;\n  let temp32 = 0;\n  let temp33 = 0;\n  let temp34 = 0;\n  let temp35 = 0;\n  let temp36 = 0;\n  let temp37 = 0;\n  let temp38 = 0;\n  let temp39 = 0;\n  let temp40 = 0;\n  let temp41 = 0;\n  let temp42 = 0;\n  let temp43 = 0;\n  let temp44 = 0;\n  let temp45 = 0;\n  let temp46 = 0;\n  let temp47 = 0;\n  let temp48 = 0;\n  let temp49 = 0;\n  let temp50 = 0;\n  let temp51 = 0;\n  let temp52 = 0;\n  let temp53 = 0;\n  let temp54 = 0;\n  let temp55 = 0;\n  let temp56 = 0;\n  let temp57 = 0;\n  let temp58 = 0;\n  let temp59 = 0;\n  let temp60 = 0;\n  let temp61 = 0;\n  let temp62 = 0;\n  let temp63 = 0;\n  let temp64 = 0;\n  let temp65 = 0;\n  let temp66 = 0;\n  let temp67 = 0;\n  let temp68 = 0;\n  let temp69 = 0;\n  let temp70 = 0;\n  let temp71 = 0;\n  let temp72 = 0;\n  let temp73 = 0;\n  let temp74 = 0;\n  let temp75 = 0;\n  let temp76 = 0;\n  let temp77 = 0;\n  let temp78 = 0;\n  let temp79 = 0;\n  let temp80 = 0;\n  let temp81 = 0;\n  let temp82 = 0;\n  let temp83 = 0;\n  let temp84 = 0;\n  let temp85 = 0;\n  let temp86 = 0;\n  let temp87 = 0;\n  let temp88 = 0;\n  let temp89 = 0;\n  let temp90 = 0;\n  let temp91 = 0;\n  let temp92 = 0;\n  let temp93 = 0;\n  let temp94 = 0;\n  let temp95 = 0;\n  let temp96 = 0;\n  let temp97 = 0;\n  let temp98 = 0;\n  let temp99 = 0;\n  let temp100 = 0;\n  let temp101 = 0;\n  let temp102 = 0;\n  let temp103 = 0;\n  let temp104 = 0;\n  let temp105 = 0;\n  let temp106 = 0;\n  let temp107 = 0;\n  let temp108 = 0;\n  let temp109 = 0;\n  let temp110 = 0;\n  let temp111 = 0;\n  let temp112 = 0;\n  let temp113 = 0;\n  let temp114 = 0;\n  let temp115 = 0;\n  let temp116 = 0;\n  let temp117 = 0;\n  let temp118 = 0;\n  let temp119 = 0;\n  let temp120 = 0;\n  let temp121 = 0;\n  let temp122 = 0;\n  let temp123 = 0;\n  let temp124 = 0;\n  let temp125 = 0;\n  let temp126 = 0;\n  let temp127 = 0;\n  let temp128 = 0;\n  let temp129 = 0;\n  let temp130 = 0;\n  let temp131 = 0;\n  let temp132 = 0;\n  let temp133 = 0;\n  let temp134 = 0;\n  let temp135 = 0;\n  let temp136 = 0;\n  let temp137 = 0;\n  let temp138 = 0;\n  let temp139 = 0;\n  let temp140 = 0;\n  let temp141 = 0;\n  let temp142 = 0;\n  let temp143 = 0;\n  let temp144 = 0;\n  let temp145 = 0;\n  let temp146 = 0;\n  let temp147 = 0;\n  let temp148 = 0;\n  let temp149 = 0;\n  let temp150 = 0;\n  let temp151 = 0;\n  let temp152 = 0;\n  let temp153 = 0;\n  let temp154 = 0;\n  let temp155 = 0;\n  let temp156 = 0;\n  let temp157 = 0;\n  let temp158 = 0;\n  let temp159 = 0;\n  let temp160 = 0;\n  let temp161 = 0;\n  let temp162 = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that take a string as an argumentation and \n   render a chain code with the rudiment being revolve. \n   The rudiment should be rotate in a manner such that the letters \n   transfer down by two multiply to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 3, "perturbed": true, "gc": "/*Create a function encrypt that take a string as an argumentation and \n   render a chain code with the rudiment being revolve. \n   The rudiment should be rotate in a manner such that the letters \n   transfer down by two multiply to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  const len = s.length\n  let i = 0\n  let j = len - 1\n  let chain = ''\n  while (i < j) {\n    const temp = s[i]\n    s[i] = s[j]\n    s[j] = temp\n    i++\n    j--\n  }\n  while (i < len) {\n    chain += s[i]\n    i++\n  }\n  return chain\n}\n\n/*\n  Create a function decrypt that take a chain code as an argumentation and \n   render a string with the rudiment being revolve. \n   The rudiment should be rotate in a manner such that the letters \n   transfer up by two multiply to two places.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  const len = s.length\n  let i = 0\n  let j = len - 1\n  let chain = ''\n  while (i < j) {\n    const temp = s[i]\n    s[i] = s[j]\n    s[j] = temp\n    i++\n    j--\n  }\n  while (i < len) {\n    chain += s[i]\n    i++\n  }\n  return chain\n}\n\n/*\n  Create a function encrypt that take a string as an argumentation and \n   render a chain code with the rudiment being revolve. \n   The rudiment should be rotate in a manner such that the letters \n   transfer down by two multiply to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst decrypt = (s) => {\n  const len = s.length\n  let i = 0\n  let j = len - 1\n  let chain = ''\n  while (i < j) {\n    const temp = s[i]\n    s[i] = s[j]\n    s[j] = temp\n    i++\n    j--\n  }\n  while (i < len) {\n    chain += s[i]\n    i++\n  }\n  return chain\n}\n\n/*\n  Create a function encrypt that take a string as an argumentation and \n   render a chain code with the rudiment being revolve. \n   The rudiment should be rotate in a manner such that the letters \n   transfer down by two multiply to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst decrypt = (s) => {\n  const len = s.length\n  let i = 0\n  let j = len - 1\n  let chain = ''\n  while (i < j) {\n    const temp = s[i]\n    s[i] = s[j]\n    s[j] = temp\n    i++\n    j--\n  }\n  while (i < len) {\n    chain += s[i]\n    i++\n  }\n  return chain\n}\n\n/*\n  Create a function encrypt that take a string as an argumentation and \n   render a chain code with the rudiment being revolve. \n   The rudiment should be rotate in a manner such that the letters \n   transfer down by two multiply to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst decrypt = (s) => {\n  const len = s.length\n  let i = 0\n  let j = len - 1\n  let chain = ''\n  while (i < j) {\n    const temp = s[i]\n    s[i] = s[j]\n    s[j] = temp\n    i++\n    j--\n  }\n  while (i < len) {\n    chain += s[i]\n    i++\n  }\n  return chain\n}\n\n/*\n  Create a function encrypt that take a string as an argumentation and \n   render a chain code with the rudiment being revolve. \n   The rudiment should be rotate in a manner such that the letters \n   transfer down by two multiply to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst decrypt = (s) => {\n  const len = s.length\n  let i = 0\n  let j = len - 1\n  let chain = ''\n  while (i < j) {\n    const temp = s[i]\n    s[i] = s[j]\n    s[j] = temp\n    i++\n    j--\n  }\n  while (i < len) {\n    chain += s[i]\n    i++\n  }\n  return chain\n}\n\n/*\n  Create a function encrypt that take a string as an argumentation and \n   render a chain code with the rudiment being revolve. \n   The rudiment should be rotate in a manner such that the letters \n   transfer down by two multiply to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf')", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, render a list of rolling maximal component determine until afford here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 3, "perturbed": true, "gc": "/* From a given list of integers, render a list of rolling maximal component determine until afford here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const maxIndex = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let maxLength = 0;\n  let maxLengthIndex = 0;\n  let maxLengthLength = 0;\n  while (i < numbers.length) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      maxIndex = i;\n      maxLength = 1;\n      maxLengthIndex = i;\n      maxLengthLength = 1;\n    } else if (numbers[i] === max) {\n      maxLength++;\n      maxLengthIndex = i;\n      maxLengthLength++;\n    }\n    i++;\n  }\n  const result = [];\n  let currentMax = max;\n  let currentMaxIndex = maxIndex;\n  let currentMaxLength = maxLength;\n  let currentMaxLengthIndex = maxLengthIndex;\n  let currentMaxLengthLength = maxLengthLength;\n  while (j < maxLength) {\n    result.push(currentMax);\n    currentMax = numbers[currentMaxIndex];\n    currentMaxIndex = maxIndex;\n    currentMaxLength = maxLength;\n    currentMaxLengthIndex = maxLengthIndex;\n    currentMaxLengthLength = maxLengthLength;\n    j++;\n  }\n  return result;\n};\n\nmodule.exports = rollingMax;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers. \n   publish a function nextSmallest() that reelect the second smallest chemical element of the list.\n   Return null if there cost no such chemical element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a list of integers. \n   publish a function nextSmallest() that reelect the second smallest chemical element of the list.\n   Return null if there cost no such chemical element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n    let smallest = lst[0];\n    let smallestIndex = 0;\n    for (let i = 1; i < lst.length; i++) {\n        if (lst[i] < smallest) {\n            smallest = lst[i];\n            smallestIndex = i;\n        }\n    }\n    return lst[smallestIndex + 1];\n}\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//             smallestIndex = i;\n//         }\n//     }\n//     return lst[smallestIndex + 1];\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     let smallestIndex = 0;\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             small", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of lyric, and your task be to consider the numeral \n   of boredom. A boredom is a conviction that start with the word \" I \". \n   Sentences are demarcate by'.','?' or'!'. \n \n   For case:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 3, "perturbed": true, "gc": "/*\n  You'll be given a string of lyric, and your task be to consider the numeral \n   of boredom. A boredom is a conviction that start with the word \" I \". \n   Sentences are demarcate by'.','?' or'!'. \n \n   For case:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const isBored = (S) => {\n    const isBored = (S) => {\n      const isBored = (S) => {\n        const isBored = (S) => {\n          const isBored = (S) => {\n            const isBored = (S) => {\n              const isBored = (S) => {\n                const isBored = (S) => {\n                  const isBored = (S) => {\n                    const isBored = (S) => {\n                      const isBored = (S) => {\n                        const isBored = (S) => {\n                          const isBored = (S) => {\n                            const isBored = (S) => {\n                              const isBored = (S) => {\n                                const isBored = (S) => {\n                                  const isBored = (S) => {\n                                    const isBored = (S) => {\n                                      const isBored = (S) => {\n                                        const isBored = (S) => {\n                                          const isBored = (S) => {\n                                            const isBored = (S) => {\n                                              const isBored = (S) => {\n                                                const isBored = (S) => {\n                                                  const isBored = (S) => {\n                                                    const isBored = (S) => {\n                                                      const isBored = (S) => {\n                                                        const isBored = (S) => {\n                                                          const isBored = (S) => {\n                                                           const isBored = (S) => {\n                                                            const isBored = (S) => {\n                                                              const isBored = (S) => {\n                                                              }\n                                                            }\n                                                           }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nconsole.log(isBored(\"Hello world\"))\nconsole.log(isBored(\"The sky is blue. The sun is shining. I love this weather\"))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that take 3 numbers. \n   return genuine if one of the issue cost adequate to the kernel of the early two, and all numbers are integer. \n   Returns assumed in any other case.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 3, "perturbed": true, "gc": "/* Create a function that take 3 numbers. \n   return genuine if one of the issue cost adequate to the kernel of the early two, and all numbers are integer. \n   Returns assumed in any other case.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt2 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt3 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt4 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt5 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt6 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt7 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt8 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt9 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt10 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt11 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt12 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt13 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt14 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt15 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt16 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt17 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt18 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt19 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt20 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt21 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt22 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt23 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt24 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt25 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt26 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt27 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt28 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt29 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt30 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n  return false\n}\n\nconst anyInt31 = (x, y, z) => {\n  if (x % y === 0 && x % z === 0) {\n    return true\n  }\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that take a message, and encodes in such a \n   room that it trade shell of all letter, replace all vowels in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english rudiment. \n   Assume merely letters. \n  \n   example:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function that take a message, and encodes in such a \n   room that it trade shell of all letter, replace all vowels in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english rudiment. \n   Assume merely letters. \n  \n   example:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const messageLength = message.length\n  const encodedMessage = []\n  let currentLetter = ''\n  for (let i = 0; i < messageLength; i++) {\n    if (vowels.indexOf(message[i])!== -1) {\n      currentLetter = consonants[vowels.indexOf(message[i]) + 2]\n    } else {\n      currentLetter = message[i]\n    }\n    encodedMessage.push(currentLetter)\n  }\n  return encodedMessage.join('')\n}\n\nconsole.log(encode('This is a message'))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers. \n   You necessitate to find the big premier value and return the kernel of its digit.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 3, "perturbed": true, "gc": "/*You are given a list of integers. \n   You necessitate to find the big premier value and return the kernel of its digit.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    result = result * 10 + lst[i];\n  }\n  let prime = 1;\n  let prime_counter = 0;\n  while (prime <= result) {\n    if (result % prime === 0) {\n      prime_counter++;\n    }\n    prime++;\n  }\n  return prime_counter;\n};\n\nconsole.log(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]));\nconsole.log(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]));\nconsole.log(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]));\nconsole.log(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]));\nconsole.log(skjkasdkd([0,81,12,3,1,21]));\nconsole.log(skjkasdkd([0,8,1,2,1,7]));\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return truthful if all keys be chain in humble \n   font or all key are strings in upper case, else return false. \n   The function should return false is the afford dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 3, "perturbed": true, "gc": "/*\n  Given a dictionary, return truthful if all keys be chain in humble \n   font or all key are strings in upper case, else return false. \n   The function should return false is the afford dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    if (typeof dict[key] === \"string\") {\n      return dict[key].toUpperCase() === dict[key];\n    }\n    return dict[key] === dict[key.toUpperCase()];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key] === dict[key.toUpperCase()];\n  });\n};\n\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    return dict[key].toUpperCase() === dict[key];\n  });\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  if (keys.length === 0) {\n    return false;\n  }\n  return keys.every(key => {\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that take an non - minus integer and return an array of the inaugural n\n   integers that constitute choice act and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 3, "perturbed": true, "gc": "/*Implement a function that take an non - minus integer and return an array of the inaugural n\n   integers that constitute choice act and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\n\nconsole.log(countUpTo(5));\nconsole.log(countUpTo(11));\nconsole.log(countUpTo(0));\nconsole.log(countUpTo(20));\nconsole.log(countUpTo(1));\nconsole.log(countUpTo(18));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that take two integers and return \n   the merchandise of their unit of measurement digit. \n   wear the input is constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 3, "perturbed": true, "gc": "/*Complete the function that take two integers and return \n   the merchandise of their unit of measurement digit. \n   wear the input is constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let result = 0;\n  while (b > 0) {\n    result += a;\n    a = a % 10;\n    b = b % 10;\n  }\n  return result;\n};\n\n/*\n  Complete the function that takes two strings and returns their \n  product.\n  \n  Examples:\n  multiply(\"a\", \"b\") should return \"ab\".\n  multiply(\"a\", \"c\") should return \"ac\".\n  multiply(\"a\", \"aa\") should return \"aaa\".\n  multiply(\"aa\", \"aaa\") should return \"aaaa\".\n  multiply(\"a\", \"b\") should return \"ab\".\n  multiply(\"aa\", \"bb\") should return \"aabb\".\n  multiply(\"aaa\", \"bbb\") should return \"aaaaaabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  multiply(\"aaa\", \"bbb\") should return \"aabbb\".\n  mult", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, consider the number of capital vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 3, "perturbed": true, "gc": "/*\n  Given a string s, consider the number of capital vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i]) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countUpper('aBCdEf'));\nconsole.log(countUpper('abcdefg'));\nconsole.log(countUpper('dBBE'));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that take a value (string) represent a numeral \n   and return the close integer to it. If the numeral constitute equidistant \n   from two integers, round it away from zero. \n   model\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 3, "perturbed": true, "gc": "/* Create a function that take a value (string) represent a numeral \n   and return the close integer to it. If the numeral constitute equidistant \n   from two integers, round it away from zero. \n   model\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let numeral = parseInt(value, 10);\n  let closest = Math.abs(numeral);\n  let closestIndex = 0;\n  let closestDiff = Math.abs(closest - numeral);\n  let diffs = [];\n  for (let i = 1; i < 10; i++) {\n    diffs.push(Math.abs(numeral - closest + i));\n  }\n  diffs.sort((a, b) => a - b);\n  for (let i = 0; i < diffs.length; i++) {\n    if (diffs[i] < closestDiff) {\n      closest = numeral + i;\n      closestIndex = i;\n      closestDiff = diffs[i];\n    }\n  }\n  return closest;\n};\n\n/*\n  Given a string, return the closest integer to it.\n  model\n  >>> closestInteger(\"10.3\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n  >>> closestInteger(\"-14.5\")\n  -15\n", "passed": 1, "run_status": 0}
