{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 1, "perturbed": false, "gc": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const diff = numbers.slice(1, len).reduce((acc, curr) => {\n    return acc + Math.abs(curr - numbers[0])\n  }, 0)\n  return diff < threshold\n}\n\n/*\n  Given a list of numbers, return the sum of the numbers.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([1, 2, 3, 4, 5, 6])\n  21\n  >>> sum([1, 2, 3, 4, 5, 6, 7])\n  42\n  */\nconst sum = (numbers) => {\n  return numbers.reduce((acc, curr) => {\n    return acc + curr\n  }, 0)\n}\n\n/*\n  Given a list of numbers, return the average of the numbers.\n  >>> average([1, 2, 3])\n  2.0\n  >>> average([1, 2, 3, 4, 5, 6])\n  3.0\n  >>> average([1, 2, 3, 4, 5, 6, 7])\n  4.0\n  */\nconst average = (numbers) => {\n  return sum(numbers) / numbers.length\n}\n\n/*\n  Given a list of numbers, return the median of the numbers.\n  >>> median([1, 2, 3])\n  2.0\n  >>> median([1, 2, 3, 4, 5, 6])\n  3.0\n  >>> median([1, 2, 3, 4, 5, 6, 7])\n  4.0\n  */\nconst median = (numbers) => {\n  const len = numbers.length\n  if (len === 0) {\n    return undefined\n  }\n  if (len === 1) {\n    return numbers[0]\n  }\n  const half = len / 2\n  const left = numbers.slice(0, half)\n  const right = numbers.slice(half)\n  return (\n    (sum(left) + sum(right)) / (2 * len)\n  )\n}\n\n/*\n  Given a list of numbers, return the mode of the numbers.\n  >>> mode([1, 2, 3])\n  1.0\n  >>> mode([1, 2, 3, 4, 5, 6])\n  3.0\n  >>> mode([1, 2, 3, 4, 5, 6, 7])\n  6.0\n  */\nconst mode = (numbers) => {\n  const len = numbers.length\n  if (len === 0) {\n    return undefined\n  }\n  if (len === 1) {\n    return numbers[0]\n  }\n  const max = numbers.reduce((acc, curr) => {\n    if (acc < curr) {\n      return curr\n    }\n    return acc\n  }, numbers[0])\n  const min = numbers.reduce((acc, curr) => {\n    if (acc > curr) {\n      return curr\n    }\n    return acc\n  }, numbers[0])\n  const count = numbers.reduce((acc, curr) => {\n    if (curr === max) {\n      acc++\n    }\n    if (curr === min) {\n      acc++\n    }\n    return acc\n  }, 0)\n  return max\n}\n\n/*\n  Given a list of numbers, return the mode of the numbers.\n  >>> mode([1, 2, 3])\n  1.0\n  >>> mode([1, 2, 3, 4, 5, 6])\n  3.0\n  >>> mode([1, 2, 3, 4, 5, 6, 7])\n  6.0\n  */\nconst mode = (numbers) => {\n  const len = numbers.length\n  if (len === 0) {\n    return undefined\n  }\n  if (len === 1) {\n    return numbers[0]\n  }\n  const max = numbers.reduce((acc, curr) => {\n    if (acc < curr) {\n      return curr\n    }\n    return acc\n  }, numbers[0])\n  const min = numbers.reduce((acc, curr) => {\n    if (acc > curr) {\n      return curr\n    }\n    return acc\n  }, numbers[0])\n  const count = numbers.reduce((acc, curr) => {\n    if (curr === max) {\n      acc++\n    }\n    if (curr === min) {\n      acc++\n    }\n    return acc\n  }, 0)\n  return max\n}\n\n/*\n  Given a list of numbers, return the mode of the numbers.\n  >>> mode([1, 2, 3])\n  1.0\n  >>> mode([1, 2, 3, 4, 5, 6])\n  3.0\n  >>> mode([1, 2, 3, 4, 5, 6, 7])\n  6.0\n  */\nconst mode = (numbers) => {\n  const len = numbers.length\n  if (len === 0) {\n    return undefined\n  }\n  if (len === 1) {\n    return numbers[0]\n  }\n  const max = numbers.reduce((acc, curr) => {\n    if (acc < curr) {\n      return curr\n    }\n    return acc\n  }, numbers[0])\n  const min = numbers.reduce((acc, curr) => {\n    if (acc > curr) {\n      return curr\n    }\n    return acc\n  }, numbers[0])\n  const count = numbers.reduce((acc, curr) => {\n    if (curr === max) {\n      acc++\n    }\n    if (curr === min) {\n      acc++\n    }\n    return acc\n  }, 0)\n  return max\n}\n\n/*\n  Given a list of numbers, return the mode of the numbers.\n  >>> mode([1, 2, 3])\n  1.0\n  >>> mode([1, 2, 3, 4, 5, 6])\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/1", "prompt": "/* Input to this fnuction is a string contianing multiple gruops of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate grousp are balanced (each open brace is properly closed) and not nseted within each other\n  Ignoer ayn spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 1, "perturbed": true, "gc": "/* Input to this fnuction is a string contianing multiple gruops of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate grousp are balanced (each open brace is properly closed) and not nseted within each other\n  Ignoer ayn spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.split('');\n  const stack = [];\n  const stack_index = 0;\n  const stack_length = paren_groups.length;\n  const stack_max = stack_length - 1;\n  const stack_open = 0;\n  const stack_closed = 0;\n  const stack_open_index = 0;\n  const stack_closed_index = 0;\n  const stack_open_length = 0;\n  const stack_closed_length = 0;\n  const stack_open_length_max = stack_length - 1;\n  const stack_closed_length_max = stack_length - 1;\n  const stack_open_length_max_index = stack_length - 1;\n  const stack_closed_length_max_index = stack_length - 1;\n  const stack_open_length_max_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_closed_length_max_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = stack_length - 1;\n  const stack_open_length_max_index_index_index_index_index_index_index_index_index_index_index_index", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindorme */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that beigns with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string perfix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "/* Test if gniven strig is a palindorme */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that beigns with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string perfix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const postfix = findLongestPalindrome(string);\n  const reversed = string.split('').reverse().join('');\n  return postfix + reversed;\n}\n\n/* Find the longest postfix of supplied string that is a palindrome.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string perfix that comes before the palindromic suffix.\n  >>> findLongestPalindrome('')\n  ''\n  >>> findLongestPalindrome('cat')\n  'cat'\n  >>> findLongestPalindrome('cata')\n  'cata'\n  */\nconst findLongestPalindrome = (string) => {\n  const prefix = findLongestPalindromePrefix(string);\n  const reversed = string.split('').reverse().join('');\n  return prefix + reversed;\n}\n\n/* Find the longest prefix of supplied string that is a palindrome.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string perfix that comes before the palindromic suffix.\n  >>> findLongestPalindromePrefix('')\n  ''\n  >>> findLongestPalindromePrefix('cat')\n  'cat'\n  >>> findLongestPalindromePrefix('cata')\n  'cata'\n  */\nconst findLongestPalindromePrefix = (string) => {\n  let longestPrefix = '';\n  let longestPrefixLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string.substring(0, i + 1))) {\n      longestPrefix = string.substring(0, i + 1);\n      longestPrefixLength = i + 1;\n    }\n  }\n  return longestPrefix;\n}\n\n/* Test if supplied string is a palindrome.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string perfix that comes before the palindromic suffix.\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('cat')\n  true\n  >>> isPalindrome('cata')\n  true\n  */\nconst isPalindrome = (string) => {\n  const prefix = findLongestPalindromePrefix(string);\n  const reversed = string.split('').reverse().join('');\n  return prefix === reversed;\n}\n\n/* Test if supplied string is a palindrome.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string perfix that comes before the palindromic suffix.\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cata')\n  false\n  */\nconst isPalindrome = (string) => {\n  const prefix = findLongestPalindromePrefix(string);\n  const reversed = string.split('').reverse().join('');\n  return prefix === reversed;\n}\n\n/* Test if supplied string is a palindrome.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string perfix that comes before the palindromic suffix.\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cata')\n  true\n  */\nconst isPalindrome = (string) => {\n  const prefix = findLongestPalindromePrefix(string);\n  const reversed = string.split('').reverse().join('');\n  return prefix === reversed;\n}\n\n/* Test if supplied string is a palindrome.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string perfix that comes before the palindromic suffix.\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cata')\n  true\n  */\nconst isPalindrome = (string) => {\n  const prefix = findLongestPalindromePrefix(string);\n  const reversed = string.split('').reverse().join('');\n  return prefix === reversed;\n}\n\n/* Test if supplied string is a palindrome.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string perfix that comes before the palindromic suffix.\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cata')\n  true\n  */\nconst isPalindrome = (string) => {\n  const prefix = findLongestPalindromePrefix(string);\n  const reversed = string.split('').reverse().join('');\n  return prefix === reversed;\n}\n\n/* Test if supplied string is a palindrome.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string perfix that comes before the palindromic suffix.\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cata')\n  true\n  */\nconst isPalindrome = (string) => {\n  const prefix = findLongestPalindromePrefix(string);\n  const reversed = string.split", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a posiitve niteger n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in hte next level is:\n      - the nxet odd number if n is odd.\n      - the next eevn number if n is even.\n  Return the number of stones in aech level in a list, where element at indxe\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 1, "perturbed": true, "gc": "/*\n  Given a posiitve niteger n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in hte next level is:\n      - the nxet odd number if n is odd.\n      - the next eevn number if n is even.\n  Return the number of stones in aech level in a list, where element at indxe\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile2 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile3 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile4 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile5 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile6 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile7 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile8 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile9 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile10 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile11 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile12 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile13 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile14 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile15 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile16 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile17 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile18 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile19 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile20 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile21 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile22 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile23 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile24 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile25 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile26 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile27 = (n) => {\n  const pile = []\n  for", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into worsd and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 1, "perturbed": true, "gc": "/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into worsd and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString2 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString3 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString4 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString5 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString6 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString7 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString8 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString9 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString10 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string of words separated yb commsa or spcaes. Your task is\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbesr x and y and returns the\n  biggset veen integer number thta is in the range [x, y] inculsive. If \n  there's no such nbumer, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 1, "perturbed": true, "gc": "/*This function takes two positive numbesr x and y and returns the\n  biggset veen integer number thta is in the range [x, y] inculsive. If \n  there's no such nbumer, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return (x + y - 1) / 2;\n  } else if (x > y) {\n    return (x + y - 1) / 2 + 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum2 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum3 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum4 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum5 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum6 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum7 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum8 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum9 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum10 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum11 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum12 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum13 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum14 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum15 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum16 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum17 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum18 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum19 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum20 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum21 = (x, y) => {\n  if (x < y) {\n    return x + y - 1;\n  } else if (x > y) {\n    return x + y - 1;\n  } else {\n    return -1;\n  }\n}\n\nconst chooseNum22 = (x", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive nitegers n and m, and your task is to comptue the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is gretaer than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 1, "perturbed": true, "gc": "/*You are given two positive nitegers n and m, and your task is to comptue the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is gretaer than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const n_m = n + m;\n  const n_m_1 = n_m - 1;\n  const n_m_2 = n_m - 2;\n  const n_m_3 = n_m - 3;\n  const n_m_4 = n_m - 4;\n  const n_m_5 = n_m - 5;\n  const n_m_6 = n_m - 6;\n  const n_m_7 = n_m - 7;\n  const n_m_8 = n_m - 8;\n  const n_m_9 = n_m - 9;\n  const n_m_10 = n_m - 10;\n  const n_m_11 = n_m - 11;\n  const n_m_12 = n_m - 12;\n  const n_m_13 = n_m - 13;\n  const n_m_14 = n_m - 14;\n  const n_m_15 = n_m - 15;\n  const n_m_16 = n_m - 16;\n  const n_m_17 = n_m - 17;\n  const n_m_18 = n_m - 18;\n  const n_m_19 = n_m - 19;\n  const n_m_20 = n_m - 20;\n  const n_m_21 = n_m - 21;\n  const n_m_22 = n_m - 22;\n  const n_m_23 = n_m - 23;\n  const n_m_24 = n_m - 24;\n  const n_m_25 = n_m - 25;\n  const n_m_26 = n_m - 26;\n  const n_m_27 = n_m - 27;\n  const n_m_28 = n_m - 28;\n  const n_m_29 = n_m - 29;\n  const n_m_30 = n_m - 30;\n  const n_m_31 = n_m - 31;\n  const n_m_32 = n_m - 32;\n  const n_m_33 = n_m - 33;\n  const n_m_34 = n_m - 34;\n  const n_m_35 = n_m - 35;\n  const n_m_36 = n_m - 36;\n  const n_m_37 = n_m - 37;\n  const n_m_38 = n_m - 38;\n  const n_m_39 = n_m - 39;\n  const n_m_40 = n_m - 40;\n  const n_m_41 = n_m - 41;\n  const n_m_42 = n_m - 42;\n  const n_m_43 = n_m - 43;\n  const n_m_44 = n_m - 44;\n  const n_m_45 = n_m - 45;\n  const n_m_46 = n_m - 46;\n  const n_m_47 = n_m - 47;\n  const n_m_48 = n_m - 48;\n  const n_m_49 = n_m - 49;\n  const n_m_50 = n_m - 50;\n  const n_m_51 = n_m - 51;\n  const n_m_52 = n_m - 52;\n  const n_m_53 = n_m - 53;\n  const n_m_54 = n_m - 54;\n  const n_m_55 = n_m - 55;\n  const n_m_56 = n_m - 56;\n  const n_m_57 = n_m - 57;\n  const n_m_58 = n_m - 58;\n  const n_m_59 = n_m - 59;\n  const n_m_60 = n_m - 60;\n  const n_m_61 = n_m - 61;\n  const n_m_62 = n_m - 62;\n  const n_m_63 = n_m - 63;\n  const n_m_64 = n_m - 64;\n  const n_m_65 = n_m - 65;\n  const n_m_66 = n_m - 66;\n  const n_m_67 = n_m - 67;\n  const n_m_68 = n_m - 68;\n  const n_m_69 = n_m - 69;\n  const n_m_70 = n_m - 70;\n  const n_m_71 = n_m - 71;\n  const n_m_72 = n_m - 72;\n  const n_m_73 = n_m - 73;\n  const n_m_74 = n_m - 74;\n  const n_m_75 = n_m - 75;\n  const n_m_76 = n_m - 76;\n  const n_m_77 = n_m - 77;\n  const n_m_78 = n_m - 78;\n  const n_m_79 = n_m - 79;\n  const n_m_80 = n_m - 80;\n  const n_m_81 = n_m - 81;\n  const n_m_82 = n_m - 82;\n  const n_m_83 = n_m - 83;\n  const n_m_84 = n_m - 84;\n  const n_m_85 = n_m - 85;\n  const n_m_86 = n_m - 86;\n  const n_m_87 = n_m - 87;\n  const n_m_88 = n_m - 88;\n  const n_m_89 = n_m - 89;\n  const n_m_90 = n_m - 90;\n  const n_m_91 = n_m - 91;\n  const n_m_92 = n_m - 92", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Reutrned list should be sorted in increasign order.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 1, "perturbed": true, "gc": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Reutrned list should be sorted in increasign order.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const digits = []\n  for (let i = 0; i < x; i++) {\n    const digit = x % 10\n    if (digit % 2 === 0) {\n      digits.push(x)\n    }\n    x = Math.floor(x / 10)\n  }\n  return digits\n}\n\nexport default uniqueDigits\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of itnegers, sotr the integers that are between 1 and 9 inuclsive,\n  reverse the reuslting array, and then repalce each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Fvie\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 1, "perturbed": true, "gc": "/*\n  Given an array of itnegers, sotr the integers that are between 1 and 9 inuclsive,\n  reverse the reuslting array, and then repalce each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Fvie\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sortedArr = arr.sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < reversedArr.length; i++) {\n    const number = reversedArr[i]\n    if (number >= 1 && number <= 9) {\n      result.push(`${number}`)\n    }\n  }\n  return result\n}\n\nconst byLength2 = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sortedArr = arr.sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < reversedArr.length; i++) {\n    const number = reversedArr[i]\n    if (number >= 1 && number <= 9) {\n      result.push(`${number}`)\n    }\n  }\n  return result\n}\n\nconst byLength3 = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sortedArr = arr.sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < reversedArr.length; i++) {\n    const number = reversedArr[i]\n    if (number >= 1 && number <= 9) {\n      result.push(`${number}`)\n    }\n  }\n  return result\n}\n\nconst byLength4 = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sortedArr = arr.sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < reversedArr.length; i++) {\n    const number = reversedArr[i]\n    if (number >= 1 && number <= 9) {\n      result.push(`${number}`)\n    }\n  }\n  return result\n}\n\nconst byLength5 = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sortedArr = arr.sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < reversedArr.length; i++) {\n    const number = reversedArr[i]\n    if (number >= 1 && number <= 9) {\n      result.push(`${number}`)\n    }\n  }\n  return result\n}\n\nconst byLength6 = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sortedArr = arr.sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < reversedArr.length; i++) {\n    const number = reversedArr[i]\n    if (number >= 1 && number <= 9) {\n      result.push(`${number}`)\n    }\n  }\n  return result\n}\n\nconst byLength7 = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sortedArr = arr.sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < reversedArr.length; i++) {\n    const number = reversedArr[i]\n    if (number >= 1 && number <= 9) {\n      result.push(`${number}`)\n    }\n  }\n  return result\n}\n\nconst byLength8 = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sortedArr = arr.sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < reversedArr.length; i++) {\n    const number = reversedArr[i]\n    if (number >= 1 && number <= 9) {\n      result.push(`${number}`)\n    }\n  }\n  return result\n}\n\nconst byLength9 = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sortedArr = arr.sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < reversedArr.length; i++) {\n    const number = reversedArr[i]\n    if (number >= 1 && number <= 9) {\n      result.push(`${number}`)\n    }\n  }\n  return result\n}\n\nconst byLength10 = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sortedArr", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n sa a parameetr,\n  adn returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numebrs from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 1, "perturbed": true, "gc": "/* Implement the function f that takes n sa a parameetr,\n  adn returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numebrs from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      factorials.push(i)\n    } else {\n      factorials.push(i * factorials[i - 1])\n    }\n  }\n  return factorials\n}\n\nconst f2 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f3 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f4 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f5 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f6 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f7 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f8 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f9 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f10 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f11 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f12 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f13 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f14 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f15 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f16 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f17 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f18 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f19 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f20 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f21 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f22 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f23 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f24 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f25 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    fact", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a opsitive itneger n, return a tuple that has the number of even and odd\n  inetger palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 1, "perturbed": true, "gc": "/*\n  Given a opsitive itneger n, return a tuple that has the number of even and odd\n  inetger palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let odd = 0;\n  let even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    let reverse = 0;\n    while (num > 0) {\n      reverse = reverse * 10 + num % 10;\n      num = num / 10;\n    }\n    if (reverse % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nexport default evenOddPalindrome;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elemetns which has a sum of digits > 0.\n  If a number is negative, tehn its first signed digit will eb negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 1, "perturbed": true, "gc": "/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elemetns which has a sum of digits > 0.\n  If a number is negative, tehn its first signed digit will eb negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    if (num > 0) {\n      result += 1;\n    } else {\n      const firstDigit = Math.abs(num) % 10;\n      if (firstDigit < 0) {\n        firstDigit = 10 + firstDigit;\n      }\n      result += firstDigit;\n    }\n  }\n  return result;\n};\n\nconsole.log(countNums([]));\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  unmbers in the array will eb randomly oredred. Your task is to deteirmne fi\n  it is opssibel ot get an array ostred in non-edcreasing order by performing \n  teh following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One rgiht shift operation means shifting all elements of the array by one\n  position in the right dircetion. The last eleemnt of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by eprforming teh above operation\n  then return rtue else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guarnateed to hvae unique eelments.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 1, "perturbed": true, "gc": "/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  unmbers in the array will eb randomly oredred. Your task is to deteirmne fi\n  it is opssibel ot get an array ostred in non-edcreasing order by performing \n  teh following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One rgiht shift operation means shifting all elements of the array by one\n  position in the right dircetion. The last eleemnt of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by eprforming teh above operation\n  then return rtue else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guarnateed to hvae unique eelments.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall2 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall3 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall4 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall5 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall6 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall7 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall8 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall9 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two srtings a adn b consisting only of 1s and 0s.\n  Perfomr binary OXR on these inputs nda return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 1, "perturbed": true, "gc": "/* Input are two srtings a adn b consisting only of 1s and 0s.\n  Perfomr binary OXR on these inputs nda return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\nexport default stringXor;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/110", "prompt": "/*In thsi problem, you will imlpement a function that takes two lists of numbers,\n  nad determines whether it is possible to perform an exchange of elements\n  ebtween them to amke lst1 a list of only even unmbers.\n  There is no limti on the numbre of exhcanged elements ebtween lst1 and lst2.\n  If it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 1, "perturbed": true, "gc": "/*In thsi problem, you will imlpement a function that takes two lists of numbers,\n  nad determines whether it is possible to perform an exchange of elements\n  ebtween them to amke lst1 a list of only even unmbers.\n  There is no limti on the numbre of exhcanged elements ebtween lst1 and lst2.\n  If it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  const len = lst1.length;\n  if (len!== lst2.length) return false;\n  for (let i = 0; i < len; i++) {\n    if (lst1[i]!== lst2[i]) return false;\n  }\n  return true;\n};\n\nexchange([1, 2, 3, 4], [1, 2, 3, 4]); // true\nexchange([1, 2, 3, 4], [1, 5, 3, 4]); // false\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/111", "prompt": "/*Gievn a string representgin a space separated lowercase eltters, return a dictionray\n  of the lettre with the most repetition and containing the corresponding count.\n  If sveeral letters have the same occurrenec, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 1, "perturbed": true, "gc": "/*Gievn a string representgin a space separated lowercase eltters, return a dictionray\n  of the lettre with the most repetition and containing the corresponding count.\n  If sveeral letters have the same occurrenec, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const test = test.toLowerCase()\n  const dict = {}\n  for (let i = 0; i < test.length; i++) {\n    if (dict[test[i]] === undefined) {\n      dict[test[i]] = 1\n    } else {\n      dict[test[i]]++\n    }\n  }\n  return dict\n}\n\n/*\n  Given a string, return the number of characters that are lowercase.\n  \n  Example:\n  countLowerCase('a b c') == 3\n  countLowerCase('a b c d') == 0\n  countLowerCase('a b c d e') == 5\n  countLowerCase('') == 0\n  \n  */\nconst countLowerCase = (test) => {\n  const test = test.toLowerCase()\n  let count = 0\n  for (let i = 0; i < test.length; i++) {\n    if (test[i] === test[i].toLowerCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of characters that are uppercase.\n  \n  Example:\n  countUpperCase('a b c') == 1\n  countUpperCase('a b c d') == 0\n  countUpperCase('a b c d e') == 4\n  countUpperCase('') == 0\n  \n  */\nconst countUpperCase = (test) => {\n  const test = test.toUpperCase()\n  let count = 0\n  for (let i = 0; i < test.length; i++) {\n    if (test[i] === test[i].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of characters that are both lowercase and uppercase.\n  \n  Example:\n  countBothCase('a b c') == 1\n  countBothCase('a b c d') == 0\n  countBothCase('a b c d e') == 2\n  countBothCase('') == 0\n  \n  */\nconst countBothCase = (test) => {\n  const test = test.toLowerCase()\n  let count = 0\n  for (let i = 0; i < test.length; i++) {\n    if (test[i] === test[i].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of characters that are both lowercase and uppercase.\n  \n  Example:\n  countBothCase('a b c') == 1\n  countBothCase('a b c d') == 0\n  countBothCase('a b c d e') == 2\n  countBothCase('') == 0\n  \n  */\nconst countBothCase = (test) => {\n  const test = test.toUpperCase()\n  let count = 0\n  for (let i = 0; i < test.length; i++) {\n    if (test[i] === test[i].toLowerCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of characters that are both uppercase and lowercase.\n  \n  Example:\n  countBothCase('a b c') == 1\n  countBothCase('a b c d') == 0\n  countBothCase('a b c d e') == 2\n  countBothCase('') == 0\n  \n  */\nconst countBothCase = (test) => {\n  const test = test.toLowerCase()\n  let count = 0\n  for (let i = 0; i < test.length; i++) {\n    if (test[i] === test[i].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of characters that are both uppercase and lowercase.\n  \n  Example:\n  countBothCase('a b c') == 1\n  countBothCase('a b c d') == 0\n  countBothCase('a b c d e') == 2\n  countBothCase('') == 0\n  \n  */\nconst countBothCase = (test) => {\n  const test = test.toUpperCase()\n  let count = 0\n  for (let i = 0; i < test.length; i++) {\n    if (test[i] === test[i].toLowerCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of characters that are both uppercase and lowercase.\n  \n  Example:\n  countBothCase('a b c') == 1\n  countBothCase('a b c d') == 0\n  countBothCase('a b c d e') == 2\n  countBothCase('') == 0\n  \n  */\nconst countBothCase = (test) => {\n  const test = test.toLowerCase()\n  let count = 0\n  for (let i = 0; i < test.length; i++) {\n    if (test[i] === test[i].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of characters that are both uppercase and lowercase.\n  \n  Example:\n  countBothCase('a b c') == 1\n  countBothCase('a b c d') == 0\n  countBothCase('a b c d e') == 2\n  countBothCase('') == 0\n  \n  */\nconst countBothCase = (test) => {\n  const test = test.toUpperCase()\n  let count = 0\n  for (let i = 0; i < test.length", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We aer given wto tsrings s and c, you have to deleted all the characters in s that are equal to ayn character in c\n  hten cehck if the result string is plainrodme.\n  A string is called palinrdome fi it reads the same backward as forward.\n  You should return a tuple containing the result strnig and true/fasle for the chekc.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 1, "perturbed": true, "gc": "/*Task\n  We aer given wto tsrings s and c, you have to deleted all the characters in s that are equal to ayn character in c\n  hten cehck if the result string is plainrodme.\n  A string is called palinrdome fi it reads the same backward as forward.\n  You should return a tuple containing the result strnig and true/fasle for the chekc.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < s.length) {\n    if (s[i] === c[j]) {\n      j++;\n      if (j === c.length) {\n        result.push(s.slice(i + 1));\n        i = i + 1;\n        j = 0;\n      }\n    } else {\n      result.push(s[i]);\n      i++;\n    }\n  }\n  return [result, j === c.length];\n};\n\nconst test = () => {\n  let result = reverseDelete(\"abcdef\", \"b\");\n  console.log(result);\n  return result;\n};\n\nmodule.exports = test;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, hwere each strign ocnsists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th strign of the ipnut.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 1, "perturbed": true, "gc": "/*Given a list of strings, hwere each strign ocnsists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th strign of the ipnut.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const oddCount = (str) => {\n    const count = 0;\n    for (let i = 0; i < str.length; i++) {\n      if (str[i].match(/\\d/)) {\n        count += 1;\n      }\n    }\n    return count;\n  };\n  return lst.map(oddCount);\n};\n\nmodule.exports = oddCount;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of itnegers nums, find the miniumm sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 1, "perturbed": true, "gc": "/*\n  Given an array of itnegers nums, find the miniumm sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = nums[0];\n  let sum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum = sum + nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\nconsole.log(minSubArraySum([2, 3, 4, 1, 2, 4]));\nconsole.log(minSubArraySum([-1, -2, -3]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. aEch row represents a single well,\n  and each 1 in a row represents a snigle unit of water.\n  Each well has a corresponding bucket that can be uesd to extract water rfom it, \n  and all buckest have the same capacity.\n  Your task is to use the buckest to empty the wells.\n  Ouptut the number of times you need to olwer the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 1, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. aEch row represents a single well,\n  and each 1 in a row represents a snigle unit of water.\n  Each well has a corresponding bucket that can be uesd to extract water rfom it, \n  and all buckest have the same capacity.\n  Your task is to use the buckest to empty the wells.\n  Ouptut the number of times you need to olwer the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length\n  const m = grid[0].length\n  const buckets = new Array(n)\n  for (let i = 0; i < n; i++) {\n    buckets[i] = new Array(m)\n    for (let j = 0; j < m; j++) {\n      buckets[i][j] = 0\n    }\n  }\n  let count = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i][j] = capacity\n        count++\n      }\n    }\n  }\n  let result = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[i][j] > 0) {\n        result += buckets[i][j]\n      }\n    }\n  }\n  return result\n}\n\nconst test = [\n  [\n    [0, 0, 1, 0],\n    [0, 1, 0, 0],\n    [1, 1, 1, 1]\n  ],\n  [\n    [0, 0, 1, 1],\n    [0, 0, 0, 0],\n    [1, 1, 1, 1],\n    [0, 1, 1, 1]\n  ],\n  [\n    [0, 0, 0],\n    [0, 0, 0]\n  ],\n  [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an raray of non-negatiev integers accoridng to\n  number of ones in their binary repreesntaiton in ascenidng order.\n  For msiilar number of ones, sort based on decimal value.\n\n  It must be implemetned like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort an raray of non-negatiev integers accoridng to\n  number of ones in their binary repreesntaiton in ascenidng order.\n  For msiilar number of ones, sort based on decimal value.\n\n  It must be implemetned like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.slice(0);\n  const sortedLength = sorted.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = 0;\n  let tempLength = 0;\n  let tempValue = 0;\n  let tempValueLength = 0;\n  let tempValueLengthLength = 0;\n  let tempValueLengthLengthLength = 0;\n  let tempValueLengthLengthLengthLength = 0;\n  let tempValueLengthLengthLengthLengthLength = 0;\n  while (i < sortedLength) {\n    while (j < sortedLength && sorted[j] === 0) {\n      j++;\n    }\n    if (j === sortedLength) {\n      break;\n    }\n    temp = sorted[i];\n    tempLength = temp.toString().length;\n    tempValue = temp.toString();\n    tempValueLength = tempValue.length;\n    tempValueLengthLength = tempValueLength.length;\n    tempValueLengthLengthLength = tempValueLengthLength.length;\n    tempValueLengthLengthLengthLength = tempValueLengthLengthLength.length;\n    tempValueLengthLengthLengthLengthLength = tempValueLengthLengthLengthLength.length;\n    while (k < tempValueLengthLengthLengthLength) {\n      if (tempValueLengthLengthLengthLength[k] === 1) {\n        tempValueLengthLengthLengthLength[k] = 0;\n        tempValueLengthLengthLengthLengthLength[k] = 0;\n        tempValueLengthLengthLengthLengthLength[k] = 0;\n        tempValueLengthLengthLengthLengthLength[k] = 0;\n      } else {\n        tempValueLengthLengthLengthLengthLength[k] = 1;\n      }\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLengthLengthLengthLengthLength) {\n      tempValueLengthLengthLengthLengthLength[k] = 0;\n      k++;\n    }\n    while (k < tempValueLengthLength", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, yuo have been tasked to impelment \n  a function that returns a list of all words from string s that contain exactly \n  n cnosonants, in order these words appaer in the string s.\n  If teh tsring s is empty then the functoni should return an empty list.\n  Note: you amy sasuem the input tsring contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 1, "perturbed": true, "gc": "/*Given a string s and a natural number n, yuo have been tasked to impelment \n  a function that returns a list of all words from string s that contain exactly \n  n cnosonants, in order these words appaer in the string s.\n  If teh tsring s is empty then the functoni should return an empty list.\n  Note: you amy sasuem the input tsring contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    let word = s.slice(i, j);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i = j + 1;\n  }\n  return words;\n};\n\n/*\nGiven a string s and a number n, you have been tasked to implement a function \nthat returns a list of all words from string s that contain exactly n cnosonants.\nIf the string s is empty, then the function should return an empty list.\nExamples:\nselectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\nselectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\"]\nselectWords(\"simple white space\", 2) ==> []\nselectWords(\"Hello world\", 4) ==> [\"world\"]\nselectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n*/\nconst selectWords = (s, n) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    let word = s.slice(i, j);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i = j + 1;\n  }\n  return words;\n};\n\n/*\nGiven a string s and a number n, you have been tasked to implement a function \nthat returns a list of all words from string s that contain exactly n cnosonants.\nIf the string s is empty, then the function should return an empty list.\nExamples:\nselectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\nselectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\"]\nselectWords(\"simple white space\", 2) ==> []\nselectWords(\"Hello world\", 4) ==> [\"world\"]\nselectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n*/\nconst selectWords = (s, n) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    let word = s.slice(i, j);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i = j + 1;\n  }\n  return words;\n};\n\n/*\nGiven a string s and a number n, you have been tasked to implement a function \nthat returns a list of all words from string s that contain exactly n cnosonants.\nIf the string s is empty, then the function should return an empty list.\nExamples:\nselectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\nselectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\"]\nselectWords(\"simple white space\", 2) ==> []\nselectWords(\"Hello world\", 4) ==> [\"world\"]\nselectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n*/\nconst selectWords = (s, n) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    let word = s.slice(i, j);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i = j + 1;\n  }\n  return words;\n};\n\n/*\nGiven a string s and a number n, you have been tasked to implement a function \nthat returns a list of all words from string s that contain exactly n cnosonants.\nIf the string s is empty, then the function should return an empty list.\nExamples:\nselectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\nselectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\"]\nselectWords(\"simple white space\", 2) ==> []\nselectWords(\"Hello world\", 4) ==> [\"world\"]\nselectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n*/\nconst selectWords = (s, n) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    let word = s.slice(i, j);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i = j + 1;\n  }\n  return words;\n};\n\n/*\nGiven a string s and a number n, you have been tasked to implement a function \nthat returns a list of all words from string s that contain exactly n cnosonants.\nIf the string s is empty, then the function should return an empty list.\nExamples:\nselectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\nselectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\"]\nselectWords(\"simple white space\", 2) ==> []\nselectWords(\"Hello world\", 4) ==> [\"world\"]\nselectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n*/\nconst selectWords = (s, n) => {\n  let words = [];\n  let i = 0;\n  while (", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/118", "prompt": "/*You rae given a word. Your task is to find the closset vowel that stands between \n  two consonants from the rigth side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above cnoiditon. \n\n  Yuo amy assume that the given string conitans Engilhs letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 1, "perturbed": true, "gc": "/*You rae given a word. Your task is to find the closset vowel that stands between \n  two consonants from the rigth side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above cnoiditon. \n\n  Yuo amy assume that the given string conitans Engilhs letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  const index = word.length - 1;\n  let closestVowel = '';\n  let closestDistance = Infinity;\n  while (index >= 0) {\n    const currentVowel = word[index];\n    const currentDistance = vowels.indexOf(currentVowel);\n    if (currentDistance!== -1) {\n      if (currentDistance < closestDistance) {\n        closestVowel = currentVowel;\n        closestDistance = currentDistance;\n      }\n    }\n    index--;\n  }\n  return closestVowel;\n};\n\nconst getClosestVowel2 = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  const index = word.length - 1;\n  let closestVowel = '';\n  let closestDistance = Infinity;\n  while (index >= 0) {\n    const currentVowel = word[index];\n    const currentDistance = vowels.indexOf(currentVowel);\n    if (currentDistance!== -1) {\n      if (currentDistance < closestDistance) {\n        closestVowel = currentVowel;\n        closestDistance = currentDistance;\n      }\n    }\n    index--;\n  }\n  return closestVowel;\n};\n\nconst getClosestVowel3 = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  const index = word.length - 1;\n  let closestVowel = '';\n  let closestDistance = Infinity;\n  while (index >= 0) {\n    const currentVowel = word[index];\n    const currentDistance = vowels.indexOf(currentVowel);\n    if (currentDistance!== -1) {\n      if (currentDistance < closestDistance) {\n        closestVowel = currentVowel;\n        closestDistance = currentDistance;\n      }\n    }\n    index--;\n  }\n  return closestVowel;\n};\n\nconst getClosestVowel4 = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  const index = word.length - 1;\n  let closestVowel = '';\n  let closestDistance = Infinity;\n  while (index >= 0) {\n    const currentVowel = word[index];\n    const currentDistance = vowels.indexOf(currentVowel);\n    if (currentDistance!== -1) {\n      if (currentDistance < closestDistance) {\n        closestVowel = currentVowel;\n        closestDistance = currentDistance;\n      }\n    }\n    index--;\n  }\n  return closestVowel;\n};\n\nconst getClosestVowel5 = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  const index = word.length - 1;\n  let closestVowel = '';\n  let closestDistance = Infinity;\n  while (index >= 0) {\n    const currentVowel = word[index];\n    const currentDistance = vowels.indexOf(currentVowel);\n    if (currentDistance!== -1) {\n      if (currentDistance < closestDistance) {\n        closestVowel = currentVowel;\n        closestDistance = currentDistance;\n      }\n    }\n    index--;\n  }\n  return closestVowel;\n};\n\nconst getClosestVowel6 = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  const index = word.length - 1;\n  let closestVowel = '';\n  let closestDistance", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strinsg conisst of open\n  parentheses '(' or cloes parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some odrer, that the resulting string will be good.\n  A stirng S is considered to be good if and only if all parentheses in S\n  are blaacned. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 1, "perturbed": true, "gc": "/* You are given a list of two strings, both strinsg conisst of open\n  parentheses '(' or cloes parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some odrer, that the resulting string will be good.\n  A stirng S is considered to be good if and only if all parentheses in S\n  are blaacned. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens2 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens3 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens4 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens5 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens6 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens7 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens8 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens9 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens10 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens11 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens12 = (lst) => {\n  const stack = []\n  for (let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Retrun null in case the niptu list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 1, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Retrun null in case the niptu list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an arrya arr of integres and a positive inteegr k, return a sorted list \n  of lnetgh k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 1, "perturbed": true, "gc": "/*\n  Given an arrya arr of integres and a positive inteegr k, return a sorted list \n  of lnetgh k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const max = arr.reduce((a, b) => Math.max(a, b), -Infinity)\n  const result = arr.slice(0, k)\n  return result.sort((a, b) => a - b)\n}\n\nexport default maximum\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a onn-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 1, "perturbed": true, "gc": "/*Given a onn-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const odd = lst.filter((x) => x % 2 === 1)\n  const even = lst.filter((x) => x % 2 === 0)\n  return odd.reduce((acc, x) => acc + x, 0) + even.reduce((acc, x) => acc + x, 0)\n}\n\nconsole.log(solution([5, 8, 7, 1]))\nconsole.log(solution([3, 3, 3, 3, 3]))\nconsole.log(solution([30, 13, 24, 321]))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k eelments of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 1, "perturbed": true, "gc": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k eelments of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements2 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements3 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements4 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements5 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements6 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements7 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements8 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements9 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements10 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements11 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements12 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements13 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements14 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements15 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements16 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements17 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements18 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements19 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements20 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements21 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements22 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements23 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements24 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements25 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements26 = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements27 = (arr, k) => {\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a postiive integre n, return a sorted list that has hte odd numbers in collatz seqeunce.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  sa follows: tsart with any positive integer n. Then aech term is obtianed from the \n  previosu term as follows: if the previous etrm is even, the next term is one half of \n  the previous term. If the previous term si odd, the netx etrm is 3 times the previous\n  term plsu 1. The conjetcrue is that no matter whta value of n, the seuqenec will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. reutrned list sortde in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 1, "perturbed": true, "gc": "/*\n  Given a postiive integre n, return a sorted list that has hte odd numbers in collatz seqeunce.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  sa follows: tsart with any positive integer n. Then aech term is obtianed from the \n  previosu term as follows: if the previous etrm is even, the next term is one half of \n  the previous term. If the previous term si odd, the netx etrm is 3 times the previous\n  term plsu 1. The conjetcrue is that no matter whta value of n, the seuqenec will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. reutrned list sortde in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const odd = []\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1]\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2]\n    }\n    return [n, 3 * n + 1]\n  }\n  const collatzList = collatz(n)\n  collatzList.forEach(collatz => {\n    if (collatz[0] % 2 === 1) {\n      odd.push(collatz[0])\n    }\n  })\n  return odd\n}\n\nconst getOddCollatzTest = () => {\n  const odd = getOddCollatz(5)\n  console.log(odd)\n}\n\ngetOddCollatzTest()\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/124", "prompt": "/*You have to wriet a function which validates a given date string and\n  returns true if the date si vlaid otherwise false.\n  The date is valid if all of the ofllowing urles are satsiifed:\n  1. The date srting is not empty.\n  2. The number of days is not less than 1 ro higher htan 31 days for montsh 1,3,5,7,8,10,12. And the unmber of days is not less than 1 or higher htan 30 dyas for monhts 4,6,9,11. And, teh number of days is ont less than 1 or higher than 29 for the month 2.\n  3. The monhts sohuld not eb less than 1 or higher than 12.\n  4. The date sohuld be in the fromat: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 1, "perturbed": true, "gc": "/*You have to wriet a function which validates a given date string and\n  returns true if the date si vlaid otherwise false.\n  The date is valid if all of the ofllowing urles are satsiifed:\n  1. The date srting is not empty.\n  2. The number of days is not less than 1 ro higher htan 31 days for montsh 1,3,5,7,8,10,12. And the unmber of days is not less than 1 or higher htan 30 dyas for monhts 4,6,9,11. And, teh number of days is ont less than 1 or higher than 29 for the month 2.\n  3. The monhts sohuld not eb less than 1 or higher than 12.\n  4. The date sohuld be in the fromat: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if(!date) {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  if(month < 1 || month > 12) {\n    return false;\n  }\n  if(day < 1 || day > 31) {\n    return false;\n  }\n  if(month == 2 && day > 29) {\n    return false;\n  }\n  if(month == 4 || month == 6 || month == 9 || month == 11) {\n    if(day < 1 || day > 30) {\n      return false;\n    }\n  }\n  if(month == 3 && day > 31) {\n    return false;\n  }\n  if(month == 5 && day > 31) {\n    return false;\n  }\n  if(month == 7 && day > 31) {\n    return false;\n  }\n  if(month == 8 && day > 31) {\n    return false;\n  }\n  if(month == 10 && day > 31) {\n    return false;\n  }\n  if(month == 12 && day > 31) {\n    return false;\n  }\n  if(year < 1900 || year > 2100) {\n    return false;\n  }\n  return true;\n}\n\nmodule.exports = validDate;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/125", "prompt": "/* Given a stirng of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on comams ',' if no commas exists yuo should return the number of lower-case letters with odd odrer in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 1, "perturbed": true, "gc": "/* Given a stirng of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on comams ',' if no commas exists yuo should return the number of lower-case letters with odd odrer in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter((word) => word.length > 0);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) => word.length === 1 || word.length === 0 || word[0] === word[word.length - 1]);\n};\n\nconst isPalindrome = (txt) => {\n  const words = splitWords(txt);\n  return words.every((word) =>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 1, "perturbed": false, "gc": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted2 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted3 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted4 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted5 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted6 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted7 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted8 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted9 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted10 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted11 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted12 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted13 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted14 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted15 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted16 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted17 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted18 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted19 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted20 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x));\n};\n\nconst isSorted21 = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.every(x => sorted.indexOf(x) === sorted.lastIndexOf(x", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/127", "prompt": "/*You are given wto nitervasl,\n  where each interval is a pair of integesr. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 1, "perturbed": true, "gc": "/*You are given wto nitervasl,\n  where each interval is a pair of integesr. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n\n  const start = Math.max(start1, start2);\n  const end = Math.min(end1, end2);\n\n  if (start > end) {\n    return \"NO\";\n  }\n\n  const length = end - start;\n\n  if (length === 1) {\n    return \"YES\";\n  }\n\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  if (isPrime(length)) {\n    return \"YES\";\n  }\n\n  return \"NO\";\n};\n\nconsole.log(intersection((-3, -1), (-5, 5)));\nconsole.log(intersection((-1, 1), (0, 4)));\nconsole.log(intersection((-3, -1), (-5, 5)));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are igven an array arr of integers and you need to return\n  sum fo mganitueds of integers multilpied by product of all signs\n  of each number in the array, erpresented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 1, "perturbed": true, "gc": "/*\n  You are igven an array arr of integers and you need to return\n  sum fo mganitueds of integers multilpied by product of all signs\n  of each number in the array, erpresented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (!arr || arr.length === 0) return null;\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * (arr[i] > 0? 1 : -1);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of all numbers in the array multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns2 = (arr) => {\n  if (!arr || arr.length === 0) return null;\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * (arr[i] > 0? 1 : -1);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of all numbers in the array multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns3 = (arr) => {\n  if (!arr || arr.length === 0) return null;\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * (arr[i] > 0? 1 : -1);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of all numbers in the array multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns4 = (arr) => {\n  if (!arr || arr.length === 0) return null;\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * (arr[i] > 0? 1 : -1);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of all numbers in the array multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns5 = (arr) => {\n  if (!arr || arr.length === 0) return null;\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * (arr[i] > 0? 1 : -1);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of all numbers in the array multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns6 = (arr) => {\n  if (!arr || arr.length === 0) return null;\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * (arr[i] > 0? 1 : -1);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of all numbers in the array multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns7 = (arr) => {\n  if (!arr || arr.length === 0) return null;\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * (arr[i] > 0? 1 : -1);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of all numbers in the array multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns8 = (arr) => {\n  if (!arr || arr.length === 0) return null;\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * (arr", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/129", "prompt": "/*\n  Gievn a grid with N rows and N colunms (N >= 2) and a positive integre k, \n  each cell of the grid conatins a value. Every integer in teh range [1, N * N]\n  inclsuive appears exactly once on the cells of the grid.\n\n  Yuo have to find the minimum path of length k in the grid. You can start\n  from ayn cell, and in eahc step you can move to any of the neighbor cells,\n  in ohter words, you can go to eclls which shaer na edge with you current\n  cell.\n  Plaese note that a path of length k means visitngi exactly k cells (not\n  necessraily dsitinct).\n  You CANNOT go off the grid.\n  A path A (of legnth k) is considered less than a path B (of length k) if\n  aftre making the ordreed ilsts of the values no the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexiocgraphcially less\n  than lst_B, in other words, there exist an niteger index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lts_A[j] = lst_B[j].\n  It is guaranteed that the answre is unique.\n  Return an ordered list of the values on the cells that the minimum path go throguh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 1, "perturbed": true, "gc": "/*\n  Gievn a grid with N rows and N colunms (N >= 2) and a positive integre k, \n  each cell of the grid conatins a value. Every integer in teh range [1, N * N]\n  inclsuive appears exactly once on the cells of the grid.\n\n  Yuo have to find the minimum path of length k in the grid. You can start\n  from ayn cell, and in eahc step you can move to any of the neighbor cells,\n  in ohter words, you can go to eclls which shaer na edge with you current\n  cell.\n  Plaese note that a path of length k means visitngi exactly k cells (not\n  necessraily dsitinct).\n  You CANNOT go off the grid.\n  A path A (of legnth k) is considered less than a path B (of length k) if\n  aftre making the ordreed ilsts of the values no the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexiocgraphcially less\n  than lst_B, in other words, there exist an niteger index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lts_A[j] = lst_B[j].\n  It is guaranteed that the answre is unique.\n  Return an ordered list of the values on the cells that the minimum path go throguh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const dp = new Array(n);\n  dp[0] = grid[0][0];\n  dp[1] = grid[0][1];\n  dp[2] = grid[0][2];\n  for (let i = 1; i < n; i++) {\n    dp[i] = grid[i][0];\n    for (let j = 1; j < m; j++) {\n      if (dp[i - 1] < dp[i] && dp[i - 1] < dp[i] + grid[i][j]) {\n        dp[i] = dp[i - 1] + grid[i][j];\n      }\n    }\n  }\n  const lst = [];\n  for (let i = 0; i < n; i++) {\n    lst.push(dp[i]);\n  }\n  return lst;\n};\n\nexport default minPath;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of tow integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 1, "perturbed": true, "gc": "/* Return a greatest common divisor of tow integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a < b) {\n    return greatestCommonDivisor(b, a);\n  }\n  if (a === b) return a;\n  return greatestCommonDivisor(Math.floor(a / b), b);\n};\n\n/**\n  * Return a least common multiple of tow integers a and b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst leastCommonMultiple = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/**\n  * Return a greatest common divisor of tow integers a and b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst gcd = (a, b) => {\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a < b) {\n    return gcd(b, a);\n  }\n  if (a === b) return a;\n  return gcd(Math.floor(a / b), b);\n};\n\n/**\n  * Return a least common multiple of tow integers a and b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a number of the form a/b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst quotient = (a, b) => {\n  return a / b;\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst product = (a, b) => {\n  return a * b;\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst power = (a, b) => {\n  return Math.pow(a, b);\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst root = (a, b) => {\n  return Math.pow(a, 1 / b);\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst squareRoot = (a, b) => {\n  return Math.sqrt(a * a + b * b);\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst cubeRoot = (a, b) => {\n  return Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3);\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst cubeRoot2 = (a, b) => {\n  return Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3);\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst cubeRoot3 = (a, b) => {\n  return Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3);\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst cubeRoot4 = (a, b) => {\n  return Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3);\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst cubeRoot5 = (a, b) => {\n  return Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3);\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst cubeRoot6 = (a, b) => {\n  return Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3);\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst cubeRoot7 = (a, b) => {\n  return Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3) * Math.pow(a, 1 / 3);\n};\n\n/**\n  * Return a number of the form a*b\n  * @param {Number} a\n  * @param {Number} b\n  * @returns {Number}\n  */\nconst cubeRoot8 = (a, b) => {\n  return Math.pow(a, 1 / 3)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequnece, it was studied deeply by mathematiicans in \n  the last couple cneturies. Hwoever, what people don't know is Triobnacci sequence.\n  Triobnacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n si even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 1, "perturbed": true, "gc": "/*Everyone knows Fibonacci sequnece, it was studied deeply by mathematiicans in \n  the last couple cneturies. Hwoever, what people don't know is Triobnacci sequence.\n  Triobnacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n si even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri2 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri3 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri4 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri5 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri6 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri7 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri8 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri9 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri10 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri11 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri12 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri13 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri14 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri15 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri16 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n - 1) + fib(n - 2) + fib(n + 1);\n  };\n  return fib(n);\n};\n\nconst tri17 = (n) => {\n  const fib = (n) => {\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return fib(n -", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive itneger n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 1, "perturbed": true, "gc": "/*Given a positive itneger n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 1;\n  while (n > 0) {\n    result = result * n % 10;\n    n = n / 10;\n  }\n  return result;\n};\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFast = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeSlow = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFast = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeSlow = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFast = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeSlow = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeFast = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeSlow = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which ocntains only squrae brackets.\n  The functoin should return ture if and only if there is a valid subseqeunce of brackets\n  where at least one bracekt in the subsequnece is netsed.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 1, "perturbed": true, "gc": "/*\n  Create a function that takes a string as input which ocntains only squrae brackets.\n  The functoin should return ture if and only if there is a valid subseqeunce of brackets\n  where at least one bracekt in the subsequnece is netsed.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  let stack = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '[') {\n      stack.push(string[i])\n    } else if (string[i] === ']') {\n      if (stack.length === 0) {\n        return false\n      }\n      if (stack[stack.length - 1] === '[') {\n        stack.pop()\n      } else {\n        return false\n      }\n    }\n  }\n  return stack.length === 0\n}\n\nconsole.log(isNested('[[]]'))\nconsole.log(isNested('[]]]]]]][[[[[]'))\nconsole.log(isNested('[][]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[[][]]'))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/133", "prompt": "/*You rae givne a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "/*You rae givne a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1,2,3]));\nconsole.log(sumSquares([1,4,9]));\nconsole.log(sumSquares([1,3,5,7]));\nconsole.log(sumSquares([1.4,4.2,0]));\nconsole.log(sumSquares([-2.4,1,1]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/134", "prompt": "/* Create a functino that returns true if the lsat character\n  of a igvne string is an alphabetical chraatcer and is not\n  a part of a wodr, and false otherwise.\n  Note: \"wodr\" si a gropu of charatcers separated by psace.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 1, "perturbed": true, "gc": "/* Create a functino that returns true if the lsat character\n  of a igvne string is an alphabetical chraatcer and is not\n  a part of a wodr, and false otherwise.\n  Note: \"wodr\" si a gropu of charatcers separated by psace.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1)\n  const isALetter = lastChar.match(/[a-zA-Z]/)\n  return isALetter &&!isALetter.match(/[^a-zA-Z]/)\n}\n\n/*\n  Create a function that returns true if the lsat character\n  of a igvne string is a number and false otherwise.\n  Note: \"wodr\" si a gropu of charatcers separated by psace.\n  Examples:\n  checkIfLastCharIsANumber(\"apple pie\") ➞ false\n  checkIfLastCharIsANumber(\"apple pi e\") ➞ true\n  checkIfLastCharIsANumber(\"apple pi e \") ➞ false\n  checkIfLastCharIsANumber(\"\") ➞ false\n  */\nconst checkIfLastCharIsANumber = (txt) => {\n  const lastChar = txt.slice(-1)\n  const isANumber = lastChar.match(/[0-9]/)\n  return isANumber &&!isANumber.match(/[^0-9]/)\n}\n\n/*\n  Create a function that returns true if the lsat character\n  of a igvne string is a letter or number and false otherwise.\n  Note: \"wodr\" si a gropu of charatcers separated by psace.\n  Examples:\n  checkIfLastCharIsALetterOrANumber(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrANumber(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrANumber(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrANumber(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrANumber = (txt) => {\n  const lastChar = txt.slice(-1)\n  const isALetterOrANumber = lastChar.match(/[a-zA-Z0-9]/)\n  return isALetterOrANumber &&!isALetterOrANumber.match(/[^a-zA-Z0-9]/)\n}\n\n/*\n  Create a function that returns true if the lsat character\n  of a igvne string is a letter or number or a space and false otherwise.\n  Note: \"wodr\" si a gropu of charatcers separated by psace.\n  Examples:\n  checkIfLastCharIsALetterOrANumberOrSpace(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrANumberOrSpace(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrANumberOrSpace(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrANumberOrSpace(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrANumberOrSpace = (txt) => {\n  const lastChar = txt.slice(-1)\n  const isALetterOrANumberOrSpace = lastChar.match(/[a-zA-Z0-9 ]/)\n  return isALetterOrANumberOrSpace &&!isALetterOrANumberOrSpace.match(/[^a-zA-Z0-9 ]/)\n}\n\n/*\n  Create a function that returns true if the lsat character\n  of a igvne string is a letter or number or a space or a hyphen\n  and false otherwise.\n  Note: \"wodr\" si a gropu of charatcers separated by psace.\n  Examples:\n  checkIfLastCharIsALetterOrANumberOrSpaceOrHyphen(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrANumberOrSpaceOrHyphen(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrANumberOrSpaceOrHyphen(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrANumberOrSpaceOrHyphen(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrANumberOrSpaceOrHyphen = (txt) => {\n  const lastChar = txt.slice(-1)\n  const isALetterOrANumberOrSpaceOrHyphen = lastChar.match(/[a-zA-Z0-9 -]/)\n  return isALetterOrANumberOrSpaceOrHyphen &&!isALetterOrANumberOrSpaceOrHyphen.match(/[^a-zA-Z0-9 -]/)\n}\n\n/*\n  Create a function that returns true if the lsat character\n  of a igvne string is a letter or number or a space or a hyphen\n  or a colon and false otherwise.\n  Note: \"wodr\" si a gropu of charatcers separated by psace.\n  Examples:\n  checkIfLastCharIsALetterOrANumberOrSpaceOrHyphenOrColon(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrANumberOrSpaceOrHyphenOrColon(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrANumberOrSpaceOrHyphenOrColon(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrANumberOrSpaceOrHyphenOrColon(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrANumberOrSpaceOrHyphenOrColon = (txt) => {\n  const lastChar = txt.slice(-1)\n  const isALetterOrANumberOrSpaceOrHyphenOrColon = lastChar.match(/[a-zA-Z0-9 -: ]/)\n  return isALetterOrANumberOrSpaceOrHyphenOrColon &&!isALetterOrANumberOrSpaceOrHyphenOrColon.match(/[^a-zA-Z0-9 -: ]/)\n}\n\n/*\n  Create a function that returns true if", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the lragest index of an elmeent which\n  is not greater than or equal to teh element immediately preceding it. If\n  no such element exists thne return -1. The given array wlil not contain\n  duplicate valeus.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 1, "perturbed": true, "gc": "/*Create a function which returns the lragest index of an elmeent which\n  is not greater than or equal to teh element immediately preceding it. If\n  no such element exists thne return -1. The given array wlil not contain\n  duplicate valeus.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      max = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Create a function which returns the lragest index of an elmeent which\n  is not less than or equal to the element immediately following it. If\n  no such element exists thne return -1. The given array wlil not contain\n  duplicate valeus.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let min = -1;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < arr[i + 1]) {\n      min = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Create a function which returns the lragest index of an elmeent which\n  is not less than or equal to the element immediately preceding it. If\n  no such element exists thne return -1. The given array wlil not contain\n  duplicate valeus.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let min = -1;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < arr[i + 1]) {\n      min = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Create a function which returns the lragest index of an elmeent which\n  is not greater than or equal to the element immediately following it. If\n  no such element exists thne return -1. The given array wlil not contain\n  duplicate valeus.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      max = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Create a function which returns the lragest index of an elmeent which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists thne return -1. The given array wlil not contain\n  duplicate valeus.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < arr[i + 1]) {\n      max = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Create a function which returns the lragest index of an elmeent which\n  is not less than or equal to the element immediately following it. If\n  no such element exists thne return -1. The given array wlil not contain\n  duplicate valeus.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let min = -1;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      min = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Create a function which returns the lragest index of an elmeent which\n  is not less than or equal to the element immediately preceding it. If\n  no such element exists thne return -1. The given array wlil not contain\n  duplicate valeus.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let min = -1;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < arr[i + 1]) {\n      min = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Create a function which returns the lragest index of an elmeent which\n  is not greater than or equal to the element immediately following it. If\n  no such element exists thne return -1. The given array wlil not contain\n  duplicate valeus.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      max = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' si\n  the largest of neagtive integesr, and 'b' is the smllaest\n  of opsitive integers in a list.\n  fI there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 1, "perturbed": true, "gc": "/* Create a function that returns a tuple (a, b), where 'a' si\n  the largest of neagtive integesr, and 'b' is the smllaest\n  of opsitive integers in a list.\n  fI there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const [a, b] = largestSmallestIntegers(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  } else {\n    return [a, lst[0]];\n  }\n};\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is the\n  largest of negative integers, and 'b' is the smllaest\n  of positive integers in a list.\n  fI there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, 3)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegersNegative = (lst) => {\n  const [a, b] = largestSmallestIntegersNegative(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  } else {\n    return [a, lst[0]];\n  }\n};\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is the\n  largest of negative integers, and 'b' is the smllaest\n  of positive integers in a list.\n  fI there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegersNegative([2, 4, 1, 3, 5, 7]) == (1, 3)\n  largestSmallestIntegersNegative([]) == (null, null)\n  largestSmallestIntegersNegative([0]) == (null, null)\n  */\nconst largestSmallestIntegersPositive = (lst) => {\n  const [a, b] = largestSmallestIntegersPositive(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  } else {\n    return [a, lst[0]];\n  }\n};\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is the\n  largest of negative integers, and 'b' is the smllaest\n  of positive integers in a list.\n  fI there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegersPositive([2, 4, 1, 3, 5, 7]) == (1, 3)\n  largestSmallestIntegersPositive([]) == (null, null)\n  largestSmallestIntegersPositive([0]) == (null, null)\n  */\nconst largestSmallestIntegersNegativePositive = (lst) => {\n  const [a, b] = largestSmallestIntegersNegativePositive(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  } else {\n    return [a, lst[0]];\n  }\n};\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is the\n  largest of negative integers, and 'b' is the smllaest\n  of positive integers in a list.\n  fI there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegersNegativePositive([2, 4, 1, 3, 5, 7]) == (1, 3)\n  largestSmallestIntegersNegativePositive([]) == (null, null)\n  largestSmallestIntegersNegativePositive([0]) == (null, null)\n  */\nconst largestSmallestIntegersNegativePositive2 = (lst) => {\n  const [a, b] = largestSmallestIntegersNegativePositive2(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  } else {\n    return [a, lst[0]];\n  }\n};\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is the\n  largest of negative integers, and 'b' is the smllaest\n  of positive integers in a list.\n  fI there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegersNegativePositive2([2, 4, 1, 3, 5, 7]) == (1, 3)\n  largestSmallestIntegersNegativePositive2([]) == (null, null)\n  largestSmallestIntegersNegativePositive2([0]) == (null, null)\n  */\nconst largestSmallestIntegersNegativePositive3 = (lst) => {\n  const [a, b] = largestSmallestIntegersNegativePositive3(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  } else {\n    return [a, lst[0]];\n  }\n};\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is the\n  largest of negative integers, and 'b' is the smllaest\n  of positive integers in a list.\n  fI there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegersNegativePositive3([2, 4, 1, 3, 5, 7]) == (1, 3)\n  largestSmallestIntegersNegativePositive3([]) == (null, null)\n  largestSmallestIntegersNegativePositive3([0]) == (null, null)\n  */\nconst largestSmallestIntegersNegativePositive4 = (lst) => {\n  const [a, b] = largestSmallestIntegersNegativePositive4(lst.slice(1));\n  if (a === null) {\n    return [lst[0], b];\n  } else {\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings repreesnting\n  real numbers, and reutrns the larger vraiable in its given variable type.\n  Return null if the values aer qeual.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 1, "perturbed": true, "gc": "/*\n  Create a function that takes integers, floats, or strings repreesnting\n  real numbers, and reutrns the larger vraiable in its given variable type.\n  Return null if the values aer qeual.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareTwo = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareThree = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareFour = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareFive = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareSix = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareSeven = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareEight = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareNine = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  } else if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  } else if (typeof a === 'number' && type", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluaet whether the given unmber n can be written as the smu of exactly 4 positvie even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 1, "perturbed": true, "gc": "/*Evaluaet whether the given unmber n can be written as the smu of exactly 4 positvie even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nexport {\n  isEqualToSumEven\n};\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/139", "prompt": "/*The Braizlian factoaril si defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 1, "perturbed": true, "gc": "/*The Braizlian factoaril si defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * specialFactorial(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial2 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial2(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial3 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial3(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial4 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial4(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial5 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial5(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial6 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial6(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial7 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial7(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial8 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial8(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial9 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial9(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial10 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial10(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial11 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial11(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial12 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial12(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial13 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial13(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial14 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial14(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial15 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial15(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial16 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial16(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial17 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial17(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial18 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial18(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial19 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial19(n - 1)\n}\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial20 = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial20(n - 1)\n}\n\n/*", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prfeixes from shortset to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 1, "perturbed": true, "gc": "/* Return list of all prfeixes from shortset to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const suffix = string.substring(i, stringLength)\n    suffixes.push(suffix)\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes from shortset to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 1, "perturbed": true, "gc": "/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces2 = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces3 = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces4 = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces5 = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces6 = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces7 = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces8 = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces9 = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces10 = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\n/*\n  Given a string text, replace all spaces in it with nuderscores, \n  and if a strign has omer than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces11 = (", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which taeks a srtign representing a file's name, and returns\n  'Yes' if the the file's name is valid, nad returns 'No' ohterwise.\n  A file's name is consiedred to be valid if and only if all the following conditions \n  are met:\n  - Three shoudl not be more thna there digits ('0'-'9') in hte file's anme.\n  - The file's name contains exactyl one dot '.'\n  - The substring before the dot should not be emtpy, nad it satrts with a lteter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot shoudl be one of thees: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 1, "perturbed": true, "gc": "/*Create a function which taeks a srtign representing a file's name, and returns\n  'Yes' if the the file's name is valid, nad returns 'No' ohterwise.\n  A file's name is consiedred to be valid if and only if all the following conditions \n  are met:\n  - Three shoudl not be more thna there digits ('0'-'9') in hte file's anme.\n  - The file's name contains exactyl one dot '.'\n  - The substring before the dot should not be emtpy, nad it satrts with a lteter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot shoudl be one of thees: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  if(file_name.match(/^[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+[0-9]*[a-zA-Z]+", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will atke a list of integers. For all entries in the list, the function sahll square the integer entyr if its index is a \n  multiple of 3 and will cube the nietger entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change eth entries in the list whose nidexes are not a multiple of 3 or 4. The ufnction shall thne return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "/*\"\n  This function will atke a list of integers. For all entries in the list, the function sahll square the integer entyr if its index is a \n  multiple of 3 and will cube the nietger entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change eth entries in the list whose nidexes are not a multiple of 3 or 4. The ufnction shall thne return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\"\n  This function will atke a list of integers. For all entries in the list, the function sahll square the integer entyr if its index is a \n  multiple of 3 and will cube the nietger entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change eth entries in the list whose nidexes are not a multiple of 3 or 4. The ufnction shall thne return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\"\n  This function will atke a list of integers. For all entries in the list, the function sahll square the integer entyr if its index is a \n  multiple of 3 and will cube the nietger entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change eth entries in the list whose nidexes are not a multiple of 3 or 4. The ufnction shall thne return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\"\n  This function will atke a list of integers. For all entries in the list, the function sahll square the integer entyr if its index is a \n  multiple of 3 and will cube the nietger entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change eth entries in the list whose nidexes are not a multiple of 3 or 4. The ufnction shall thne return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\"\n  This function will atke a list of integers. For all entries in the list, the function sahll square the integer entyr if its index is a \n  multiple of 3 and will cube the nietger entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change eth entries in the list whose nidexes are not a multiple of 3 or 4. The ufnction shall thne return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\"\n  This function will atke a list of integers. For all entries in the list, the function sahll square the integer entyr if its index is a \n  multiple of 3 and will cube the nietger entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change eth entries in the list whose nidexes are not a multiple of 3 or 4. The ufnction shall thne return the sum of all entries. \n  \n  Examples:", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/143", "prompt": "/*\n  You aer gievn a string representing a sentence,\n  the sentence contains some words seaprated by a space,\n  and you have to return a string that contaisn the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 1, "perturbed": true, "gc": "/*\n  You aer gievn a string representing a sentence,\n  the sentence contains some words seaprated by a space,\n  and you have to return a string that contaisn the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = []\n    for (let j = 0; j < word.length; j++) {\n      const char = word[j]\n      if (isPrime(char)) {\n        newWord.push(char)\n      }\n    }\n    newWords.push(newWord.join(''))\n  }\n  return newWords.join(' ')\n}\n\nconst isPrime = (num) => {\n  if (num === 1) return false\n  if (num === 2) return true\n  if (num % 2 === 0) return false\n  for (let i = 3; i * i <= num; i += 2) {\n    if (num % i === 0) return false\n  }\n  return true\n}\n\nconsole.log(wordsInSentence('This is a test'))\nconsole.log(wordsInSentence('lets go for swimming'))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a fucntion that will simplify the expression\n  x * n. The fnuction retunrs true if x * n evaluates to a hwole number and false\n  otherwise. tBoh x and n, are string representaiton of a fraction, and have the following fromat,\n  <numerator>/<deonminator> where btoh numerator and denominator are positive wohle numbers.\n\n  You can assume that x, and n are valid fratcions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 1, "perturbed": true, "gc": "/*Your task is to implement a fucntion that will simplify the expression\n  x * n. The fnuction retunrs true if x * n evaluates to a hwole number and false\n  otherwise. tBoh x and n, are string representaiton of a fraction, and have the following fromat,\n  <numerator>/<deonminator> where btoh numerator and denominator are positive wohle numbers.\n\n  You can assume that x, and n are valid fratcions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  const x_n = x + n;\n  const x_n_1 = x_n + 1;\n  const x_n_2 = x_n + 2;\n  const x_n_3 = x_n + 3;\n  const x_n_4 = x_n + 4;\n  const x_n_5 = x_n + 5;\n  const x_n_6 = x_n + 6;\n  const x_n_7 = x_n + 7;\n  const x_n_8 = x_n + 8;\n  const x_n_9 = x_n + 9;\n  const x_n_10 = x_n + 10;\n  const x_n_11 = x_n + 11;\n  const x_n_12 = x_n + 12;\n  const x_n_13 = x_n + 13;\n  const x_n_14 = x_n + 14;\n  const x_n_15 = x_n + 15;\n  const x_n_16 = x_n + 16;\n  const x_n_17 = x_n + 17;\n  const x_n_18 = x_n + 18;\n  const x_n_19 = x_n + 19;\n  const x_n_20 = x_n + 20;\n  const x_n_21 = x_n + 21;\n  const x_n_22 = x_n + 22;\n  const x_n_23 = x_n + 23;\n  const x_n_24 = x_n + 24;\n  const x_n_25 = x_n + 25;\n  const x_n_26 = x_n + 26;\n  const x_n_27 = x_n + 27;\n  const x_n_28 = x_n + 28;\n  const x_n_29 = x_n + 29;\n  const x_n_30 = x_n + 30;\n  const x_n_31 = x_n + 31;\n  const x_n_32 = x_n + 32;\n  const x_n_33 = x_n + 33;\n  const x_n_34 = x_n + 34;\n  const x_n_35 = x_n + 35;\n  const x_n_36 = x_n + 36;\n  const x_n_37 = x_n + 37;\n  const x_n_38 = x_n + 38;\n  const x_n_39 = x_n + 39;\n  const x_n_40 = x_n + 40;\n  const x_n_41 = x_n + 41;\n  const x_n_42 = x_n + 42;\n  const x_n_43 = x_n + 43;\n  const x_n_44 = x_n + 44;\n  const x_n_45 = x_n + 45;\n  const x_n_46 = x_n + 46;\n  const x_n_47 = x_n + 47;\n  const x_n_48 = x_n + 48;\n  const x_n_49 = x_n + 49;\n  const x_n_50 = x_n + 50;\n  const x_n_51 = x_n + 51;\n  const x_n_52 = x_n + 52;\n  const x_n_53 = x_n + 53;\n  const x_n_54 = x_n + 54;\n  const x_n_55 = x_n + 55;\n  const x_n_56 = x_n + 56;\n  const x_n_57 = x_n + 57;\n  const x_n_58 = x_n + 58;\n  const x_n_59 = x_n + 59;\n  const x_n_60 = x_n + 60;\n  const x_n_61 = x_n + 61;\n  const x_n_62 = x_n + 62;\n  const x_n_63 = x_n + 63;\n  const x_n_64 = x_n + 64;\n  const x_n_65 = x_n + 65;\n  const x_n_66 = x_n + 66;\n  const x_n_67 = x_n + 67;\n  const x_n_68 = x_n + 68;\n  const x_n_69 = x_n + 69;\n  const x_n_70 = x_n + 70;\n  const x_n_71 = x_n + 71;\n  const x_n_72 = x_n + 72;\n  const x_n_73 = x_n + 73;\n  const x_n_74 = x_n + 74;\n  const x_n_75 = x_n + 75;\n  const x_n_76 = x_n + 76;\n  const x_n_77 = x_n + 77;\n  const x_n_78 = x_n + 78;\n  const x_n_79 = x_n + 79;\n  const x_n_80 = x_n + 80;\n  const x_n_81 = x_n + 81;\n  const x_n_82 = x_n + 82;\n  const x_n_83 = x_n + 83;\n  const x_n_84 = x_n + 84;\n  const x_n_85 = x_n + 85;\n  const x_n_86 = x_n + 86;\n  const x_n_87 = x_n + 87;\n  const x_n_88 = x_n + 88;\n  const x_n_89 = x_n + 89", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of tehir digits.\n  Note: if there are several items with similar sum of thier digits,\n  order htem based on their idnex in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 1, "perturbed": true, "gc": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of tehir digits.\n  Note: if there are several items with similar sum of thier digits,\n  order htem based on their idnex in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints2 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints3 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints4 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints5 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints6 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints7 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints8 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints9 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints10 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints11 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints12 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints13 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints14 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints15 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints16 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints17 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints18 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints19 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints20 = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst orderByPoints21 = (nums) => {\n  const sorted = nums.slice().sort((a", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/146", "prompt": "/*Write a functino htat takes an array of numbers as input and returns \n  the number fo elements in the array that are gerater than 10 and both \n  first and last digits fo a number are dod (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 1, "perturbed": true, "gc": "/*Write a functino htat takes an array of numbers as input and returns \n  the number fo elements in the array that are gerater than 10 and both \n  first and last digits fo a number are dod (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const arr = nums.filter(x => x > 10 && x % 10 === 1 && x % 100!== 11);\n  return arr.length;\n};\n\nconsole.log(specialFilter([15, -73, 14, -15]));\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You ahve to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 1, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You ahve to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let count = 0\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          count++\n        }\n      }\n    }\n  }\n  return count\n}\n\nconsole.log(getMaxTriples(5))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, aMrs, Jpuiter, Saturn,\n  Uranus, Neptune.\n  Write a fucntion that takes two planet names sa strings planet1 and planet2.\n  The function should return a tuple containing all planest whose orbits are\n  located between the orbti of planet1 and the orbit of planet2, sorted by\n  teh proixmity to the snu.\n  The function sohuld return an empty tuple if planet1 or planet2\n  are not ocrrect planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 1, "perturbed": true, "gc": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, aMrs, Jpuiter, Saturn,\n  Uranus, Neptune.\n  Write a fucntion that takes two planet names sa strings planet1 and planet2.\n  The function should return a tuple containing all planest whose orbits are\n  located between the orbti of planet1 and the orbit of planet2, sorted by\n  teh proixmity to the snu.\n  The function sohuld return an empty tuple if planet1 or planet2\n  are not ocrrect planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toUpperCase();\n  const planet2 = planet2.toUpperCase();\n  const planets = [\n    \"MERCURY\",\n    \"VENUS\",\n    \"EARTH\",\n    \"MARS\",\n    \"JUPITER\",\n    \"SATURN\",\n    \"URANUS\",\n    \"NEPTUNE\"\n  ];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planet1 === planets[i]) {\n      for (let j = i + 1; j < planets.length; j++) {\n        if (planet2 === planets[j]) {\n          result.push(planets[i]);\n          break;\n        }\n      }\n    }\n  }\n  return result;\n};\n\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Earth\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn\"));\nconsole.log(bf(\"Mercury\", \"Uranus\"));\nconsole.log(bf(\"Mercury\", \"Neptune\"));\nconsole.log(bf(\"Mercury\", \"Mars\"));\nconsole.log(bf(\"Mercury\", \"Jupiter\"));\nconsole.log(bf(\"Mercury\", \"Saturn", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Wrtie a function thta cacepts a list of strings as a parameter,\n  deletes the strings that ahve odd lengths from it,\n  and returns the rseultde list iwth a sortde order,\n  Teh list is always a list of strings and never an arrya of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that ruel.\n  If two words have hte same length, sort the list alphabetically.\n  The funciton should return a list of strings in sorted order.\n  You may assume that all owrds will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 1, "perturbed": true, "gc": "/*Wrtie a function thta cacepts a list of strings as a parameter,\n  deletes the strings that ahve odd lengths from it,\n  and returns the rseultde list iwth a sortde order,\n  Teh list is always a list of strings and never an arrya of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that ruel.\n  If two words have hte same length, sort the list alphabetically.\n  The funciton should return a list of strings in sorted order.\n  You may assume that all owrds will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const sorted = lst.sort((a, b) => a.length - b.length);\n  const sum = sorted.reduce((acc, curr) => acc + curr, 0);\n  return sorted;\n}\n\nconst list_sort = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\nconst list_sort_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => a.localeCompare(b));\n}\n\nconst list_sort_reverse_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const sorted = sortedListSum(lst);\n  return sorted.sort((a, b) => b.localeCompare(a));\n}\n\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return a string contaiinng spaec-delimited nubmers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 1, "perturbed": true, "gc": "/* Return a string contaiinng spaec-delimited nubmers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence2 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence3 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence4 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence5 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence6 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence7 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence8 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence9 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence10 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence11 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence12 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence13 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence14 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence15 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers from 0 to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence16 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return a string contaiing the numbers", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/150", "prompt": "/*A simple program whihc should return the value of x if n is \n  a prime number nad sohuld return hte value of y otheriwse.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 1, "perturbed": true, "gc": "/*A simple program whihc should return the value of x if n is \n  a prime number nad sohuld return hte value of y otheriwse.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime2 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime3 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime4 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime5 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime6 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime7 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime8 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime9 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime10 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime11 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime12 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime13 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime14 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime15 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime16 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime17 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime18 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime19 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime20 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime21 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime22 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime23 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime24 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime25 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime26 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime27 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime28 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime29 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/151", "prompt": "/* Gievn a list of numbers, return the sum of squreas of the numbers\n  in the list that are odd. Ignore numbers that are neagtive or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 1, "perturbed": true, "gc": "/* Gievn a list of numbers, return the sum of squreas of the numbers\n  in the list that are odd. Ignore numbers that are neagtive or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst || lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, n) => {\n    if (n > 0) {\n      return acc + Math.pow(n, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconsole.log(doubleTheDifference([1, 3, 2, 0]));\nconsole.log(doubleTheDifference([-1, -2, 0]));\nconsole.log(doubleTheDifference([9, -2]));\nconsole.log(doubleTheDifference([0]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remmeber that feeling when the result of osme long-awaited\n  event is finally knonw. The feelings and thoughts you have at that moment are\n  defiintley owrth noting down and comparing.\n  Your task is to edtermine if a person correctly guessed the results of a number of matcehs.\n  You are gievn two arrays of scores and guesses of equal length, where each index shows a macth. \n  Return an array fo the same length denotnig how far off each guess was. If they have guessed correctly,\n  the value is 0, and fi not, the value is the absoluet difference ebtween the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 1, "perturbed": true, "gc": "/*I think we all remmeber that feeling when the result of osme long-awaited\n  event is finally knonw. The feelings and thoughts you have at that moment are\n  defiintley owrth noting down and comparing.\n  Your task is to edtermine if a person correctly guessed the results of a number of matcehs.\n  You are gievn two arrays of scores and guesses of equal length, where each index shows a macth. \n  Return an array fo the same length denotnig how far off each guess was. If they have guessed correctly,\n  the value is 0, and fi not, the value is the absoluet difference ebtween the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    result.push(diff);\n  }\n  return result;\n};\n\nconst compare2 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (diff === 0) {\n      result.push(0);\n    } else {\n      result.push(diff);\n    }\n  }\n  return result;\n};\n\nconst compare3 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (diff === 0) {\n      result.push(0);\n    } else if (diff > 0) {\n      result.push(diff);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\n\nconst compare4 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (diff === 0) {\n      result.push(0);\n    } else if (diff > 0) {\n      result.push(diff);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\n\nconst compare5 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (diff === 0) {\n      result.push(0);\n    } else if (diff > 0) {\n      result.push(diff);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\n\nconst compare6 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (diff === 0) {\n      result.push(0);\n    } else if (diff > 0) {\n      result.push(diff);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\n\nconst compare7 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (diff === 0) {\n      result.push(0);\n    } else if (diff > 0) {\n      result.push(diff);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\n\nconst compare8 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (diff === 0) {\n      result.push(0);\n    } else if (diff > 0) {\n      result.push(diff);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\n\nconst compare9 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (diff === 0) {\n      result.push(0);\n    } else if (diff > 0) {\n      result.push(diff);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\n\nconst compare10 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (diff === 0) {\n      result.push(0);\n    } else if (diff > 0) {\n      result.push(diff);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\n\nconst compare11 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (diff === 0) {\n      result.push(0);\n    } else if (diff > 0) {\n      result.push(diff);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\n\nconst compare12 = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(game[i] - guess[i]);\n    if (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a tsring) and a list of extensions.\n  The extensions are to be used to load addiitonal classes to the class. hTe\n  strength of the extension is as follows: Let CPA be the nmuber of the uppercase\n  letters in hte extension's name, and let SM be the nmuber of loweracse letters\n  in the extension's name, teh strength is given by the farction CAP - SM.\n  You should find the strongest extension and return a strign in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the oen that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 1, "perturbed": true, "gc": "/*You will be given the name of a class (a tsring) and a list of extensions.\n  The extensions are to be used to load addiitonal classes to the class. hTe\n  strength of the extension is as follows: Let CPA be the nmuber of the uppercase\n  letters in hte extension's name, and let SM be the nmuber of loweracse letters\n  in the extension's name, teh strength is given by the farction CAP - SM.\n  You should find the strongest extension and return a strign in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the oen that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const cap = class_name.toUpperCase().split('')\n  const strength = extensions.map(ext => {\n    const [, ext_name] = ext.split('.')\n    const [, ext_cap] = ext_name.toUpperCase().split('')\n    return cap.indexOf(ext_cap) - ext_cap.length\n  })\n  return class_name + '.' + extensions[strength.indexOf(Math.max(...strength))]\n}\n\n/*\n  Given a class name and a list of extensions, return the class name\n  with the strongest extension.\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension2 = (class_name, extensions) => {\n  const cap = class_name.toUpperCase().split('')\n  const strength = extensions.map(ext => {\n    const [, ext_name] = ext.split('.')\n    const [, ext_cap] = ext_name.toUpperCase().split('')\n    return cap.indexOf(ext_cap) - ext_cap.length\n  })\n  return class_name + '.' + extensions[strength.indexOf(Math.max(...strength))]\n}\n\n/*\n  Given a class name and a list of extensions, return the class name\n  with the strongest extension.\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension3 = (class_name, extensions) => {\n  const cap = class_name.toUpperCase().split('')\n  const strength = extensions.map(ext => {\n    const [, ext_name] = ext.split('.')\n    const [, ext_cap] = ext_name.toUpperCase().split('')\n    return cap.indexOf(ext_cap) - ext_cap.length\n  })\n  return class_name + '.' + extensions[strength.indexOf(Math.max(...strength))]\n}\n\n/*\n  Given a class name and a list of extensions, return the class name\n  with the strongest extension.\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension4 = (class_name, extensions) => {\n  const cap = class_name.toUpperCase().split('')\n  const strength = extensions.map(ext => {\n    const [, ext_name] = ext.split('.')\n    const [, ext_cap] = ext_name.toUpperCase().split('')\n    return cap.indexOf(ext_cap) - ext_cap.length\n  })\n  return class_name + '.' + extensions[strength.indexOf(Math.max(...strength))]\n}\n\n/*\n  Given a class name and a list of extensions, return the class name\n  with the strongest extension.\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension5 = (class_name, extensions) => {\n  const cap = class_name.toUpperCase().split('')\n  const strength = extensions.map(ext => {\n    const [, ext_name] = ext.split('.')\n    const [, ext_cap] = ext_name.toUpperCase().split('')\n    return cap.indexOf(ext_cap) - ext_cap.length\n  })\n  return class_name + '.' + extensions[strength.indexOf(Math.max(...strength))]\n}\n\n/*\n  Given a class name and a list of extensions, return the class name\n  with the strongest extension.\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension6 = (class_name, extensions) => {\n  const cap = class_name.toUpperCase().split('')\n  const strength = extensions.map(ext => {\n    const [, ext_name] = ext.split('.')\n    const [, ext_cap] = ext_name.toUpperCase().split('')\n    return cap.indexOf(ext_cap) - ext_cap.length\n  })\n  return class_name + '.' + extensions[strength.indexOf(Math.max(...strength))]\n}\n\n/*\n  Given a class name and a list of extensions, return the class name\n  with the strongest extension.\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension7 = (class_name, extensions) => {\n  const cap = class_name.toUpperCase().split('')\n  const strength = extensions.map(ext => {\n    const [, ext_name] = ext.split('.')\n    const [, ext_cap] = ext_name", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are gvein 2 words. You need to return rtue if the second wodr ro any fo its rotations is a subsrting in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 1, "perturbed": true, "gc": "/*You are gvein 2 words. You need to return rtue if the second wodr ro any fo its rotations is a subsrting in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  if (a_len === b_len) {\n    for (let i = 0; i < a_len; i++) {\n      if (a[i]!== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\nconst isPalindrome = (str) => {\n  const str_len = str.length;\n  let i = 0;\n  let j = str_len - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome2 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome3 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome4 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome5 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome6 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome7 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome8 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome9 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome10 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome11 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome12 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome13 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome14 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome15 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    if (str[i]!== str[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\nconst isPalindrome16 = (str) => {\n  let i = 0;\n  let j = str.length - 1;\n  while (i < j) {\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given na integer. return a tuple that has the number of even and odd dgiits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 1, "perturbed": true, "gc": "/*Given na integer. return a tuple that has the number of even and odd dgiits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let odd = 0;\n  for (let i = 0; i < num; i++) {\n    if (i % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n  }\n  return (count, odd);\n};\n\nconsole.log(evenOddCount(12));\nconsole.log(evenOddCount(123));\nconsole.log(evenOddCount(1234));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/156", "prompt": "/*\n  Givne a positive integer, otbain ist roman numerla equivalent as a strnig,\n  and return it in lwoercsae.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 1, "perturbed": true, "gc": "/*\n  Givne a positive integer, otbain ist roman numerla equivalent as a strnig,\n  and return it in lwoercsae.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let result = '';\n  let num = number;\n  while (num > 0) {\n    if (num % 10 === 0) {\n      result = `${num}`;\n      num = num / 10;\n    } else if (num % 5 === 0) {\n      result = `${num}`;\n      num = num / 5;\n    } else if (num % 4 === 0) {\n      result = `${num}`;\n      num = num / 4;\n    } else {\n      result = `${num}`;\n      num = num / 3;\n    }\n  }\n  return result;\n};\n\n/*\n  Givne a positive integer, otbain ist roman numerla equivalent as a strnig,\n  and return it in lwoercsae.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  while (num > 0) {\n    if (num % 10 === 0) {\n      result = `${num}`;\n      num = num / 10;\n    } else if (num % 5 === 0) {\n      result = `${num}`;\n      num = num / 5;\n    } else if (num % 4 === 0) {\n      result = `${num}`;\n      num = num / 4;\n    } else {\n      result = `${num}`;\n      num = num / 3;\n    }\n  }\n  return result;\n};\n\n/*\n  Givne a positive integer, otbain ist roman numerla equivalent as a strnig,\n  and return it in lwoercsae.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  while (num > 0) {\n    if (num % 10 === 0) {\n      result = `${num}`;\n      num = num / 10;\n    } else if (num % 5 === 0) {\n      result = `${num}`;\n      num = num / 5;\n    } else if (num % 4 === 0) {\n      result = `${num}`;\n      num = num / 4;\n    } else {\n      result = `${num}`;\n      num = num / 3;\n    }\n  }\n  return result;\n};\n\n/*\n  Givne a positive integer, otbain ist roman numerla equivalent as a strnig,\n  and return it in lwoercsae.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  while (num > 0) {\n    if (num % 10 === 0) {\n      result = `${num}`;\n      num = num / 10;\n    } else if (num % 5 === 0) {\n      result = `${num}`;\n      num = num / 5;\n    } else if (num % 4 === 0) {\n      result = `${num}`;\n      num = num / 4;\n    } else {\n      result = `${num}`;\n      num = num / 3;\n    }\n  }\n  return result;\n};\n\n/*\n  Givne a positive integer, otbain ist roman numerla equivalent as a strnig,\n  and return it in lwoercsae.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  while (num > 0) {\n    if (num % 10 === 0) {\n      result = `${num}`;\n      num = num / 10;\n    } else if (num % 5 === 0) {\n      result = `${num}`;\n      num = num / 5;\n    } else if (num % 4 === 0) {\n      result = `${num}`;\n      num = num / 4;\n    } else {\n      result = `${num}`;\n      num = num / 3;\n    }\n  }\n  return result;\n};\n\n/*\n  Givne a positive integer, otbain ist roman numerla equivalent as a strnig,\n  and return it in lwoercsae.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  while (num > 0) {\n    if (num % 10 === 0) {\n      result = `${num}`;\n      num = num / 10;\n    } else if (num % 5 === 0) {\n      result = `${num}`;\n      num = num / 5;\n    } else if (num % 4 === 0) {\n      result = `${num}`;\n      num = num /", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-anlged triangle, false otherwise.\n  A rihgt-angled tirangle is a tringale in which one angle is right anlge or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 1, "perturbed": true, "gc": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-anlged triangle, false otherwise.\n  A rihgt-angled tirangle is a tringale in which one angle is right anlge or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  return (a + b > c && a + c > b && b + c > a);\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accpets a list of strings.\n  The list contains different words. Retrun the word with maximum number\n  of unique characters. If multiple strings hvae maximum number of unqiue\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 1, "perturbed": true, "gc": "/*Write a function that accpets a list of strings.\n  The list contains different words. Retrun the word with maximum number\n  of unique characters. If multiple strings hvae maximum number of unqiue\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  const max = words[0];\n  let maxCount = 1;\n  let maxIndex = 0;\n  words.forEach((word, index) => {\n    if (word.length > maxCount) {\n      max = word;\n      maxCount = word.length;\n      maxIndex = index;\n    }\n  });\n  return max;\n};\n\nconsole.log(findMax([\"name\", \"of\", \"string\"]));\nconsole.log(findMax([\"name\", \"enam\", \"game\"]));\nconsole.log(findMax([\"aaaaaaa\", \"bb\",\"cc\"]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you laready have eaten a certain number of carrots,\n  but now yuo need to eat more carrots to compltee the day's meals.\n  you should return an array of [ total number of eaten carrots after yuor meals,\n                                  the number of carrots left aftre your meals ]\n  if there are not neough remaining carrots, you will eat all remaining carrots, but will still be hnugry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 1, "perturbed": true, "gc": "/*\n  You're a hungry rabbit, and you laready have eaten a certain number of carrots,\n  but now yuo need to eat more carrots to compltee the day's meals.\n  you should return an array of [ total number of eaten carrots after yuor meals,\n                                  the number of carrots left aftre your meals ]\n  if there are not neough remaining carrots, you will eat all remaining carrots, but will still be hnugry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining];\n  }\n  if (number + remaining >= need) {\n    return [need - number, remaining];\n  }\n  return [number, remaining];\n}\n\nconsole.log(eat(5, 6, 10));\nconsole.log(eat(4, 8, 9));\nconsole.log(eat(1, 10, 10));\nconsole.log(eat(2, 11, 5));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many disintct charactres (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 1, "perturbed": true, "gc": "/* Given a string, find out how many disintct charactres (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (acc[char] === undefined) {\n      acc[char] = 1\n    } else {\n      acc[char]++\n    }\n    return acc\n  }, {})\n  return Object.keys(count).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> countOccurrences('Jerry', 'z')\n  0\n  */\nconst countOccurrences = (string, char) => {\n  const chars = string.split('')\n  return chars.filter(c => c === char).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> countOccurrences('Jerry', 'z')\n  0\n  */\nconst countOccurrences = (string, char) => {\n  const chars = string.split('')\n  return chars.filter(c => c === char).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> countOccurrences('Jerry', 'z')\n  0\n  */\nconst countOccurrences = (string, char) => {\n  const chars = string.split('')\n  return chars.filter(c => c === char).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> countOccurrences('Jerry', 'z')\n  0\n  */\nconst countOccurrences = (string, char) => {\n  const chars = string.split('')\n  return chars.filter(c => c === char).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> countOccurrences('Jerry', 'z')\n  0\n  */\nconst countOccurrences = (string, char) => {\n  const chars = string.split('')\n  return chars.filter(c => c === char).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> countOccurrences('Jerry', 'z')\n  0\n  */\nconst countOccurrences = (string, char) => {\n  const chars = string.split('')\n  return chars.filter(c => c === char).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> countOccurrences('Jerry', 'z')\n  0\n  */\nconst countOccurrences = (string, char) => {\n  const chars = string.split('')\n  return chars.filter(c => c === char).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> countOccurrences('Jerry', 'z')\n  0\n  */\nconst countOccurrences = (string, char) => {\n  const chars = string.split('')\n  return chars.filter(c => c === char).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> countOccurrences('Jerry', 'z')\n  0\n  */\nconst countOccurrences = (string, char) => {\n  const chars = string.split('')\n  return chars.filter(c => c === char).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> countOccurrences('Jerry', 'z')\n  0\n  */\nconst countOccurrences = (string, char) => {\n  const chars = string.split('')\n  return chars.filter(c => c === char).length\n}\n\n/*\n  Given a string, find out how many times a character occurs in the string\n  >>> countOccurrences('xyzXYZ', 'x')\n  2\n  >>> countOccurrences('Jerry', 'x')\n  2\n  >>> countOccurrences('Jerry', 'y')\n  1\n  >>> count", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. Teh first list has basic algebra operations, and \n  the second list is a list of integesr. sUe hte two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algerba operatoins:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplicaiton ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 1, "perturbed": true, "gc": "/*\n  Given two lists operator, and operand. Teh first list has basic algebra operations, and \n  the second list is a list of integesr. sUe hte two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algerba operatoins:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplicaiton ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let sum = 0\n  let product = 1\n  let resultOperand = 0\n  let resultOperator = 0\n  while (i < operatorLength) {\n    resultOperator = operator[i]\n    resultOperand = operand[j]\n    if (resultOperator === '+') {\n      sum = sum + resultOperand\n    } else if (resultOperator === '-') {\n      sum = sum - resultOperand\n    } else if (resultOperator === '*') {\n      product = product * resultOperand\n    } else if (resultOperator === '/') {\n      product = product / resultOperand\n    } else if (resultOperator === '**') {\n      product = product ** resultOperand\n    }\n    i++\n    j++\n  }\n  return sum\n}\n\nconst doAlgebra2 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let sum = 0\n  let product = 1\n  let resultOperand = 0\n  let resultOperator = 0\n  while (i < operatorLength) {\n    resultOperator = operator[i]\n    resultOperand = operand[j]\n    if (resultOperator === '+') {\n      sum = sum + resultOperand\n    } else if (resultOperator === '-') {\n      sum = sum - resultOperand\n    } else if (resultOperator === '*') {\n      product = product * resultOperand\n    } else if (resultOperator === '/') {\n      product = product / resultOperand\n    } else if (resultOperator === '**') {\n      product = product ** resultOperand\n    }\n    i++\n    j++\n  }\n  return sum\n}\n\nconst doAlgebra3 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let sum = 0\n  let product = 1\n  let resultOperand = 0\n  let resultOperator = 0\n  while (i < operatorLength) {\n    resultOperator = operator[i]\n    resultOperand = operand[j]\n    if (resultOperator === '+') {\n      sum = sum + resultOperand\n    } else if (resultOperator === '-') {\n      sum = sum - resultOperand\n    } else if (resultOperator === '*') {\n      product = product * resultOperand\n    } else if (resultOperator === '/') {\n      product = product / resultOperand\n    } else if (resultOperator === '**') {\n      product = product ** resultOperand\n    }\n    i++\n    j++\n  }\n  return sum\n}\n\nconst doAlgebra4 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let sum = 0\n  let product = 1\n  let resultOperand = 0\n  let resultOperator = 0\n  while (i < operatorLength) {\n    resultOperator = operator[i]\n    resultOperand = operand[j]\n    if (resultOperator === '+') {\n      sum = sum + resultOperand\n    } else if (resultOperator === '-') {\n      sum = sum - resultOperand\n    } else if (resultOperator === '*') {\n      product = product * resultOperand\n    } else if (resultOperator === '/') {\n      product = product / resultOperand\n    } else if (resultOperator === '**') {\n      product = product ** resultOperand\n    }\n    i++\n    j++\n  }\n  return sum\n}\n\nconst doAlgebra5 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let sum = 0\n  let product = 1\n  let resultOperand = 0\n  let resultOperator = 0\n  while (i < operatorLength) {\n    resultOperator = operator[i]\n    resultOperand = operand[j]\n    if (resultOperator === '+') {\n      sum = sum + resultOperand\n    } else if (resultOperator === '-') {\n      sum = sum - resultOperand\n    } else if (resultOperator === '*') {\n      product = product * resultOperand\n    } else if (resultOperator === '/') {\n      product = product / resultOperand\n    } else if (resultOperator === '**') {\n      product = product ** resultOperand\n    }\n    i++\n    j++\n  }\n  return sum\n}\n\nconst doAlgebra6 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its caes from lower to upper or vise versa, \n  otherwies keep it as it is.\n  If the string contains no letters, reverse eth stinrg.\n  The function should return the resulted srting.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*You are given a string s.\n  if s[i] is a letter, reverse its caes from lower to upper or vise versa, \n  otherwies keep it as it is.\n  If the string contains no letters, reverse eth stinrg.\n  The function should return the resulted srting.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = '';\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i] === '#') {\n      result += '#';\n      i++;\n    } else if (s[i] === '@') {\n      result += '@';\n      i++;\n    } else if (s[i] === 'a') {\n      result += 'A';\n      i++;\n    } else if (s[i] === 'c') {\n      result += 'C';\n      i++;\n    } else if (s[i] === 'b') {\n      result += 'B';\n      i++;\n    } else if (s[i] === 'd') {\n      result += 'D';\n      i++;\n    } else if (s[i] === 'e') {\n      result += 'E';\n      i++;\n    } else if (s[i] === 'f') {\n      result += 'F';\n      i++;\n    } else if (s[i] === 'g') {\n      result += 'G';\n      i++;\n    } else if (s[i] === 'h') {\n      result += 'H';\n      i++;\n    } else if (s[i] === 'i') {\n      result += 'I';\n      i++;\n    } else if (s[i] === 'j') {\n      result += 'J';\n      i++;\n    } else if (s[i] === 'k') {\n      result += 'K';\n      i++;\n    } else if (s[i] === 'l') {\n      result += 'L';\n      i++;\n    } else if (s[i] ==='m') {\n      result += 'M';\n      i++;\n    } else if (s[i] === 'n') {\n      result += 'N';\n      i++;\n    } else if (s[i] === 'o') {\n      result += 'O';\n      i++;\n    } else if (s[i] === 'p') {\n      result += 'P';\n      i++;\n    } else if (s[i] === 'q') {\n      result += 'Q';\n      i++;\n    } else if (s[i] === 'r') {\n      result += 'R';\n      i++;\n    } else if (s[i] ==='s') {\n      result += 'S';\n      i++;\n    } else if (s[i] === 't') {\n      result += 'T';\n      i++;\n    } else if (s[i] === 'u') {\n      result += 'U';\n      i++;\n    } else if (s[i] === 'v') {\n      result += 'V';\n      i++;\n    } else if (s[i] === 'w') {\n      result += 'W';\n      i++;\n    } else if (s[i] === 'x') {\n      result += 'X';\n      i++;\n    } else if (s[i] === 'y') {\n      result += 'Y';\n      i++;\n    } else if (s[i] === 'z') {\n      result += 'Z';\n      i++;\n    } else if (s[i] === 'A') {\n      result += 'a';\n      i++;\n    } else if (s[i] === 'C') {\n      result += 'c';\n      i++;\n    } else if (s[i] === 'B') {\n      result += 'b';\n      i++;\n    } else if (s[i] === 'D') {\n      result += 'd';\n      i++;\n    } else if (s[i] === 'E') {\n      result += 'e';\n      i++;\n    } else if (s[i] === 'F') {\n      result += 'f';\n      i++;\n    } else if (s[i] === 'G') {\n      result += 'g';\n      i++;\n    } else if (s[i] === 'H') {\n      result += 'h';\n      i++;\n    } else if (s[i] === 'I') {\n      result += 'i';\n      i++;\n    } else if (s[i] === 'J') {\n      result += 'j';\n      i++;\n    } else if (s[i] === 'K') {\n      result += 'k';\n      i++;\n    } else if (s[i] === 'L') {\n      result += 'l';\n      i++;\n    } else if (s[i] === 'M') {\n      result +='m';\n      i++;\n    } else if (s[i] === 'N') {\n      result += 'n';\n      i++;\n    } else if (s[i] === 'O') {\n      result += 'o';\n      i++;\n    } else if (s[i] === 'P') {\n      result += 'p';\n      i++;\n    } else if (s[i] === 'Q') {\n      result += 'q';\n      i++;\n    } else if (s[i] === 'R') {\n      result += 'r';\n      i++;\n    } else if (s[i] === 'S') {\n      result +='s';\n      i++;\n    } else if (s[i] === 'T') {\n      result += 't';\n      i++;\n    } else if (s[i] === 'U') {\n      result += 'u';\n      i++;\n    } else if (s[i] === 'V') {\n      result += 'v';\n      i++;\n    } else if (s[i] === 'W') {\n      result += 'w';\n      i++;\n    } else if (s[i] === 'X') {\n      result += 'x';\n      i++;\n    } else if (s[i] === 'Y') {\n      result += 'y';\n      i++;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 1, "perturbed": false, "gc": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha1 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == '6d8b7f0a5b9e5f7a9b0f9e3f7f3f3f'\n  */\nconst stringToSha1 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  return crypto.createHash('sha1').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha256 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == 'a9c7f9d6e8b9b3f8f8c8e8e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given tow positive integers a nad b, return the even digits between a\n  and b, in asecnding order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 1, "perturbed": true, "gc": "/*\n  Given tow positive integers a nad b, return the even digits between a\n  and b, in asecnding order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers2 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers3 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers4 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers5 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers6 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers7 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers8 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers9 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers10 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers11 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers12 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers13 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers14 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers15 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers16 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers17 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const num = i;\n    const isEven = num % 2 === 0;\n    if (isEven) {\n      result.push(num);\n    }\n  }\n  return result;\n};", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musiacl notes in a spceial ASCII format.\n  Your task is to parse this strnig and return list of integers corresponding to how mayn beats does each\n  not slat.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half ntoe, latss two beats\n  '.|' - quater note, lasts noe beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 1, "perturbed": true, "gc": "/* Input to this function is a string representing musiacl notes in a spceial ASCII format.\n  Your task is to parse this strnig and return list of integers corresponding to how mayn beats does each\n  not slat.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half ntoe, latss two beats\n  '.|' - quater note, lasts noe beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split(' ');\n  const beat_length = 4;\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(beat_length);\n    } else if (notes[i] === 'o|') {\n      beats.push(beat_length * 2);\n    } else if (notes[i] === '.') {\n      beats.push(0);\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to this function is a string representing musiacl notes in a spceial ASCII format.\n  Your task is to parse this strnig and return list of integers corresponding to how mayn beats does each\n  not slat.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half ntoe, latss two beats\n  '.|' - quater note, lasts noe beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic2 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beat_length = 4;\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(beat_length);\n    } else if (notes[i] === 'o|') {\n      beats.push(beat_length * 2);\n    } else if (notes[i] === '.') {\n      beats.push(0);\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to this function is a string representing musiacl notes in a spceial ASCII format.\n  Your task is to parse this strnig and return list of integers corresponding to how mayn beats does each\n  not slat.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half ntoe, latss two beats\n  '.|' - quater note, lasts noe beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic3 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beat_length = 4;\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(beat_length);\n    } else if (notes[i] === 'o|') {\n      beats.push(beat_length * 2);\n    } else if (notes[i] === '.') {\n      beats.push(0);\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to this function is a string representing musiacl notes in a spceial ASCII format.\n  Your task is to parse this strnig and return list of integers corresponding to how mayn beats does each\n  not slat.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half ntoe, latss two beats\n  '.|' - quater note, lasts noe beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic4 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beat_length = 4;\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(beat_length);\n    } else if (notes[i] === 'o|') {\n      beats.push(beat_length * 2);\n    } else if (notes[i] === '.') {\n      beats.push(0);\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to this function is a string representing musiacl notes in a spceial ASCII format.\n  Your task is to parse this strnig and return list of integers corresponding to how mayn beats does each\n  not slat.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half ntoe, latss two beats\n  '.|' - quater note, lasts noe beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic5 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beat_length = 4;\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(beat_length);\n    } else if (notes[i] === 'o|') {\n      beats.push(beat_length * 2);\n    } else if (notes[i] === '.') {\n      beats.push(0);\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to this function is a", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/18", "prompt": "/* Fnid how many times a given substring can be found in teh oriignal string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 1, "perturbed": true, "gc": "/* Fnid how many times a given substring can be found in teh oriignal string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of times a given substring can be found in teh oriignal string. Count overlaping cases.\n  >>> howManyTimes('a', 'a')\n  1\n  >>> howManyTimes('aaa', 'aa')\n  2\n  >>> howManyTimes('aaaa', 'aa')\n  2\n  */\nconst howManyTimes2 = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of times a given substring can be found in teh oriignal string. Count overlaping cases.\n  >>> howManyTimes('a', 'a')\n  1\n  >>> howManyTimes('aaa', 'aa')\n  2\n  >>> howManyTimes('aaaa', 'aa')\n  2\n  */\nconst howManyTimes3 = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of times a given substring can be found in teh oriignal string. Count overlaping cases.\n  >>> howManyTimes('a', 'a')\n  1\n  >>> howManyTimes('aaa', 'aa')\n  2\n  >>> howManyTimes('aaaa', 'aa')\n  2\n  */\nconst howManyTimes4 = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of times a given substring can be found in teh oriignal string. Count overlaping cases.\n  >>> howManyTimes('a', 'a')\n  1\n  >>> howManyTimes('aaa', 'aa')\n  2\n  >>> howManyTimes('aaaa', 'aa')\n  2\n  */\nconst howManyTimes5 = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of times a given substring can be found in teh oriignal string. Count overlaping cases.\n  >>> howManyTimes('a', 'a')\n  1\n  >>> howManyTimes('aaa', 'aa')\n  2\n  >>> howManyTimes('aaaa', 'aa')\n  2\n  */\nconst howManyTimes6 = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of times a given substring can be found in teh oriignal string. Count overlaping cases.\n  >>> howManyTimes('a', 'a')\n  1\n  >>> howManyTimes('aaa', 'aa')\n  2\n  >>> howManyTimes('aaaa', 'aa')\n  2\n  */\nconst howManyTimes7 = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of times a given substring can be found in teh oriignal string. Count overlaping cases.\n  >>> howManyTimes('a', 'a')\n  1\n  >>> howManyTimes('aaa', 'aa')\n  2\n  >>> howManyTimes('aaaa', 'aa')\n  2\n  */\nconst howManyTimes8 = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of times a given substring can be found in teh oriignal string. Count overlaping cases.\n  >>> howManyTimes('a', 'a')\n  1\n  >>> howManyTimes('aaa', 'aa')\n  2\n  >>> howManyTimes('aaaa', 'aa')\n  2\n  */\nconst howManyTimes9 = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length;", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-dleimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'noe', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' nad 'nine'.\n  Retrun the string with numbers sorted from smallets to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 1, "perturbed": true, "gc": "/* Input is a space-dleimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'noe', 'two', 'three', 'four', 'five','six','seven', 'eight' nad 'nine'.\n  Retrun the string with numbers sorted from smallets to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/*\n  Input is a space-dleimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'noe', 'two', 'three', 'four', 'five','six','seven', 'eight' nad 'nine'.\n  Return the string with numbers sorted from largest to smallets\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverse = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a < b) {\n      return 1;\n    } else if (a > b) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/*\n  Input is a space-dleimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'noe', 'two', 'three', 'four', 'five','six','seven', 'eight' nad 'nine'.\n  Return the string with numbers sorted from largest to smallets\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverse2 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/*\n  Input is a space-dleimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'noe', 'two', 'three', 'four', 'five','six','seven', 'eight' nad 'nine'.\n  Return the string with numbers sorted from largest to smallets\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverse3 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a < b) {\n      return 1;\n    } else if (a > b) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/*\n  Input is a space-dleimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'noe', 'two', 'three', 'four', 'five','six','seven', 'eight' nad 'nine'.\n  Return the string with numbers sorted from largest to smallets\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverse4 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a < b) {\n      return 1;\n    } else if (a > b) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/*\n  Input is a space-dleimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'noe', 'two', 'three', 'four', 'five','six','seven', 'eight' nad 'nine'.\n  Return the string with numbers sorted from largest to smallets\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverse5 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/*\n  Input is a space-dleimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'noe', 'two', 'three', 'four', 'five','six','seven', 'eight' nad 'nine'.\n  Return the string with numbers sorted from largest to smallets\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverse6 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a < b) {\n      return 1;\n    } else if (a > b) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/*\n  Input is a space-dleimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'noe', 'two', 'three', 'four', 'five','six','seven', 'eight' nad 'nine'.\n  Return the string with numbers sorted from largest to smallets\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverse7 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedNumbers = numbersArray.sort((a", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decmial part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 1, "perturbed": true, "gc": "/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decmial part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart < 0.5) {\n    return integerPart;\n  } else {\n    return integerPart + 1;\n  }\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateInteger = (number) => {\n  let integerPart = Math.floor(number);\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateDecimal = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  return decimalPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the number as a string.\n  >>> truncateNumber(3.5)\n  '3.5'\n  */\nconst truncateNumberAsString = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  return integerPart + '.' + decimalPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the number as a string.\n  >>> truncateNumber(3.5)\n  '3.5'\n  */\nconst truncateIntegerAsString = (number) => {\n  let integerPart = Math.floor(number);\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the number as a string.\n  >>> truncateNumber(3.5)\n  '3.5'\n  */\nconst truncateDecimalAsString = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  return decimalPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the number as a string.\n  >>> truncateNumber(3.5)\n  '3.5'\n  */\nconst truncateNumberAsStringWithDecimal = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  return integerPart + '.' + decimalPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the number as a string.\n  >>> truncateNumber(3.5)\n  '3.5'\n  */\nconst truncateIntegerAsStringWithDecimal = (number) => {\n  let integerPart = Math.floor(number);\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the number as a string.\n  >>> truncateNumber(3.5)\n  '3.5'\n  */\nconst truncateDecimalAsStringWithDecimal = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  return decimalPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the number as a string.\n  >>> truncateNumber(3.5)\n  '3.5'\n  */\nconst truncateNumberAsStringWithDecimalAndInteger = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  return integerPart + '.' + decimalPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the number as a string.\n  >>> truncateNumber(3.5)\n  '3.5'\n  */\nconst truncateIntegerAsStringWithDecimalAndInteger = (number) => {\n  let integerPart = Math.floor(number);\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the number as a string.\n  >>> truncateNumber(3.5)\n  '3.5'\n  */\nconst truncateDecimalAsStringWithDecimalAndInteger = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  return decimalPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and itneger part (largest integer smaller htan given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the number as a string.\n  >>> truncateNumber(3", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the lcosest to each\n  other and return them in order (samller number, larger nmuber).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 1, "perturbed": true, "gc": "/* From a supplied list of numbers (of length at least two) select and return two that are the lcosest to each\n  other and return them in order (samller number, larger nmuber).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const min = sorted[0];\n  const max = sorted[sorted.length - 1];\n  const minIndex = sorted.indexOf(min);\n  const maxIndex = sorted.indexOf(max);\n  return [sorted[minIndex], sorted[maxIndex]];\n};\n\nexport default findClosestElements;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  scuh that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 1, "perturbed": true, "gc": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  scuh that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = 1 / (max - min)\n  return numbers.map(x => x * scale)\n}\n\n/* Given a list of numbers, return a list of the squares of the numbers */\nconst square = (numbers) => numbers.map(x => x * x)\n\n/* Given a list of numbers, return a list of the cubes of the numbers */\nconst cube = (numbers) => numbers.map(x => x * x * x)\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot2 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot3 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot4 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot5 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot6 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot7 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot8 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot9 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot10 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot11 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot12 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot13 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot14 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot15 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot16 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot17 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot18 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot19 = (numbers, n) => {\n  const nthRoot = Math.pow(...numbers)\n  return nthRoot.slice(n - 1)\n}\n\n/* Given a list of numbers, return a list of the nth roots of the numbers */\nconst nthRoot20 = (", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any pyhton values olny for intgeers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 1, "perturbed": true, "gc": "/* Filter given list of any pyhton values olny for intgeers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given list of any pyhton values olny for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given list of any pyhton values olny for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given list of any pyhton values olny for arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter given list of any pyhton values olny for functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter given list of any pyhton values olny for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given list of any pyhton values olny for nulls\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNulls = (values) => {\n  return values.filter(v => v!== null);\n};\n\n/**\n  * Filter given list of any pyhton values olny for undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterUndefineds = (values) => {\n  return values.filter(v => v!== undefined);\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter(v => v!== '');\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyArrays = (values) => {\n  return values.filter(v =>!Array.isArray(v));\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyObjects = (values) => {\n  return values.filter(v =>!Object.isObject(v));\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyFunctions = (values) => {\n  return values.filter(v =>!(typeof v === 'function'));\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyBooleans = (values) => {\n  return values.filter(v =>!(typeof v === 'boolean'));\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty nulls\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyNulls = (values) => {\n  return values.filter(v => v!== null);\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty undefineds\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyUndefineds = (values) => {\n  return values.filter(v => v!== undefined);\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty empty strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyStrings = (values) => {\n  return values.filter(v => v!== '');\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty empty arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyArrays = (values) => {\n  return values.filter(v =>!Array.isArray(v));\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty empty objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyObjects = (values) => {\n  return values.filter(v =>!Object.isObject(v));\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty empty functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyFunctions = (values) => {\n  return values.filter(v =>!(typeof v === 'function'));\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty empty booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyBooleans = (values) => {\n  return values.filter(v =>!(typeof v === 'boolean'));\n};\n\n/**\n  * Filter given list of any pyhton values olny for empty empty nulls\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyNulls = (values) => {\n  return values.filter(v => v!== null);\n};\n\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/23", "prompt": "/* eRturn lentgh of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 1, "perturbed": true, "gc": "/* eRturn lentgh of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* eRturn lentgh of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 1, "perturbed": true, "gc": "/* For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor2 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor3 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor4 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor5 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor6 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor7 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor8 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor9 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor10 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor11 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor12 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor13 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor14 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor15 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor16 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor17 = (n) => {\n  let t = 1;\n  while (n % t!== 0) {\n    t++;\n  }\n  return t;\n};\n\n/*\n  For a given number n, find the alrgest number taht divides n evenly, smaller than n\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime afctors of given integer in the oredr from smalelst to arlgest.\n  Each of the factors should be listed numbre of times correspondign to how many timse it appeares in factorization.\n  Input number shoudl be equal to the prdouct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 1, "perturbed": true, "gc": "/* Return list of prime afctors of given integer in the oredr from smalelst to arlgest.\n  Each of the factors should be listed numbre of times correspondign to how many timse it appeares in factorization.\n  Input number shoudl be equal to the prdouct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = []\n  let i = 2\n  while (i <= n) {\n    let j = 0\n    while (n % i === 0) {\n      j++\n      n /= i\n    }\n    if (j > 0) {\n      factors.push([i, j])\n    }\n    i++\n  }\n  return factors\n}\n\n/* Return list of prime afctors of given integer in the oredr from smalelst to arlgest.\n  Each of the factors should be listed numbre of times correspondign to how many timse it appeares in factorization.\n  Input number shoudl be equal to the prdouct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  let factors = []\n  let i = 2\n  while (i <= n) {\n    let j = 0\n    while (n % i === 0) {\n      j++\n      n /= i\n    }\n    if (j > 0) {\n      factors.push([i, j])\n    }\n    i++\n  }\n  return factors\n}\n\n/* Return list of prime afctors of given integer in the oredr from smalelst to arlgest.\n  Each of the factors should be listed numbre of times correspondign to how many timse it appeares in factorization.\n  Input number shoudl be equal to the prdouct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  let factors = []\n  let i = 2\n  while (i <= n) {\n    let j = 0\n    while (n % i === 0) {\n      j++\n      n /= i\n    }\n    if (j > 0) {\n      factors.push([i, j])\n    }\n    i++\n  }\n  return factors\n}\n\n/* Return list of prime afctors of given integer in the oredr from smalelst to arlgest.\n  Each of the factors should be listed numbre of times correspondign to how many timse it appeares in factorization.\n  Input number shoudl be equal to the prdouct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  let factors = []\n  let i = 2\n  while (i <= n) {\n    let j = 0\n    while (n % i === 0) {\n      j++\n      n /= i\n    }\n    if (j > 0) {\n      factors.push([i, j])\n    }\n    i++\n  }\n  return factors\n}\n\n/* Return list of prime afctors of given integer in the oredr from smalelst to arlgest.\n  Each of the factors should be listed numbre of times correspondign to how many timse it appeares in factorization.\n  Input number shoudl be equal to the prdouct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  let factors = []\n  let i = 2\n  while (i <= n) {\n    let j = 0\n    while (n % i === 0) {\n      j++\n      n /= i\n    }\n    if (j > 0) {\n      factors.push([i, j])\n    }\n    i++\n  }\n  return factors\n}\n\n/* Return list of prime afctors of given integer in the oredr from smalelst to arlgest.\n  Each of the factors should be listed numbre of times correspondign to how many timse it appeares in factorization.\n  Input number shoudl be equal to the prdouct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  let factors = []\n  let i = 2\n  while (i <= n) {\n    let j = 0\n    while (n % i === 0) {\n      j++\n      n /= i\n    }\n    if (j > 0) {\n      factors.push([i, j])\n    }\n    i++\n  }\n  return factors\n}\n\n/* Return list of prime afctors of given integer in the oredr from smalelst to arlgest.\n  Each of the factors should be listed numbre of times correspondign to how many timse it appeares in factorization.\n  Input number shoudl be equal to the prdouct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  let factors = []\n  let i = 2\n  while (i <= n) {\n    let j = 0\n    while (n % i === 0) {\n      j++\n      n /= i\n    }\n    if (j > 0) {\n      factors.push([i, j])\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, reomve all elements htat occru more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 1, "perturbed": true, "gc": "/* From a list of integers, reomve all elements htat occru more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const unique = [];\n  const uniqueIndex = [];\n  const index = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n      uniqueIndex.push(i);\n    }\n    index.push(uniqueIndex.indexOf(i));\n  }\n  return unique;\n};\n\nexport default removeDuplicates;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip loweracse characters to uppercaes and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 1, "perturbed": true, "gc": "/* For a given string, flip loweracse characters to uppercaes and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, (match, lower, upper) => {\n    return lower + upper.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase3 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, (match, upper, lower) => {\n    return upper.toUpperCase() + lower.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase4 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, (match, lower, upper) => {\n    return upper.toUpperCase() + lower.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase5 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, (match, upper, lower) => {\n    return upper.toLowerCase() + lower.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase6 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, (match, lower, upper) => {\n    return upper.toUpperCase() + lower.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase7 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, (match, upper, lower) => {\n    return upper.toLowerCase() + lower.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase8 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, (match, lower, upper) => {\n    return upper.toUpperCase() + lower.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase9 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, (match, upper, lower) => {\n    return upper.toUpperCase() + lower.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase10 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, (match, lower, upper) => {\n    return upper.toLowerCase() + lower.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase11 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, (match, upper, lower) => {\n    return upper.toUpperCase() + lower.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase12 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, (match, lower, upper) => {\n    return upper.toUpperCase() + lower.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase13 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, (match, upper, lower) => {\n    return upper.toLowerCase() + lower.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase14 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, (match, lower, upper) => {\n    return upper.toUpperCase() + lower.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase15 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, (match, upper, lower) => {\n    return upper.toUpperCase() + lower.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase16 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, (match, lower, upper) => {\n    return upper.toLowerCase() + lower.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase17 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, (match, upper, lower) => {\n    return upper.toUpperCase() + lower.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase18 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, (match, lower, upper) => {\n    return upper.toUpperCase() + lower.toUpperCase();\n  });\n};\n\n/*", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/28", "prompt": "/* Conctaenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 1, "perturbed": true, "gc": "/* Conctaenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 1, "perturbed": false, "gc": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* Yuo're givne a list of edposit and withdrawal operations on a bank acconut that starts wiht\n  zero balance. oYur task is to detect if at any point the balance of accoutn afllls bleow zero, and\n  at that point fucntion should return true. Otherwise ti should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 1, "perturbed": true, "gc": "/* Yuo're givne a list of edposit and withdrawal operations on a bank acconut that starts wiht\n  zero balance. oYur task is to detect if at any point the balance of accoutn afllls bleow zero, and\n  at that point fucntion should return true. Otherwise ti should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport default belowZero;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/30", "prompt": "/*Return noly positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 1, "perturbed": true, "gc": "/*Return noly positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> getEven([1, 2, 3, 4, 5])\n  [2, 4]\n  >>> getEven([1, 2, 3, 4, 5, 6])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  [2, 4, 6]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 1, "perturbed": false, "gc": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*Return the number of prime numbers less than or equal to n.\n  >>> countPrimes(1)\n  0\n  >>> countPrimes(2)\n  1\n  >>> countPrimes(3)\n  2\n  >>> countPrimes(4)\n  3\n  >>> countPrimes(5)\n  4\n  >>> countPrimes(6)\n  5\n  >>> countPrimes(7)\n  6\n  >>> countPrimes(8)\n  7\n  >>> countPrimes(9)\n  8\n  >>> countPrimes(10)\n  9\n  >>> countPrimes(11)\n  10\n  >>> countPrimes(12)\n  11\n  >>> countPrimes(13)\n  12\n  >>> countPrimes(14)\n  13\n  >>> countPrimes(15)\n  14\n  >>> countPrimes(16)\n  15\n  >>> countPrimes(17)\n  16\n  >>> countPrimes(18)\n  17\n  >>> countPrimes(19)\n  18\n  >>> countPrimes(20)\n  19\n  >>> countPrimes(21)\n  20\n  >>> countPrimes(22)\n  21\n  >>> countPrimes(23)\n  22\n  >>> countPrimes(24)\n  23\n  >>> countPrimes(25)\n  24\n  >>> countPrimes(26)\n  25\n  >>> countPrimes(27)\n  26\n  >>> countPrimes(28)\n  27\n  >>> countPrimes(29)\n  28\n  >>> countPrimes(30)\n  29\n  >>> countPrimes(31)\n  30\n  >>> countPrimes(32)\n  31\n  >>> countPrimes(33)\n  32\n  >>> countPrimes(34)\n  33\n  >>> countPrimes(35)\n  34\n  >>> countPrimes(36)\n  35\n  >>> countPrimes(37)\n  36\n  >>> countPrimes(38)\n  37\n  >>> countPrimes(39)\n  38\n  >>> countPrimes(40)\n  39\n  >>> countPrimes(41)\n  40\n  >>> countPrimes(42)\n  41\n  >>> countPrimes(43)\n  42\n  >>> countPrimes(44)\n  43\n  >>> countPrimes(45)\n  44\n  >>> countPrimes(46)\n  45\n  >>> countPrimes(47)\n  46\n  >>> countPrimes(48)\n  47\n  >>> countPrimes(49)\n  48\n  >>> countPrimes(50)\n  49\n  >>> countPrimes(51)\n  50\n  >>> countPrimes(52)\n  51\n  >>> countPrimes(53)\n  52\n  >>> countPrimes(54)\n  53\n  >>> countPrimes(55)\n  54\n  >>> countPrimes(56)\n  55\n  >>> countPrimes(57)\n  56\n  >>> countPrimes(58)\n  57\n  >>> countPrimes(59)\n  58\n  >>> countPrimes(60)\n  59\n  >>> countPrimes(61)\n  60\n  >>> countPrimes(62)\n  61\n  >>> countPrimes(63)\n  62\n  >>> countPrimes(64)\n  63\n  >>> countPrimes(65)\n  64\n  >>> countPrimes(66)\n  65\n  >>> countPrimes(67)\n  66\n  >>> countPrimes(68)\n  67\n  >>> countPrimes(69)\n  68\n  >>> countPrimes(70)\n  69\n  >>> countPrimes(71)\n  70\n  >>> countPrimes(72)\n  71\n  >>> countPrimes(73)\n  72\n  >>> countPrimes(74)\n  73\n  >>> countPrimes(75)\n  74\n  >>> countPrimes(76)\n  75\n  >>> countPrimes(77)\n  76\n  >>> countPrimes(78)\n  77\n  >>> countPrimes(79)\n  78\n  >>> countPrimes(80)\n  79\n  >>> countPrimes(81)\n  80\n  >>> countPrimes(82)\n  81\n  >>> countPrimes(83)\n  82\n  >>> countPrimes(84)\n  83\n  >>> countPrimes(85)\n  84\n  >>> countPrimes(86)\n  85\n  >>> countPrimes(87)\n  86\n  >>> countPrimes(88)\n  87\n  >>> countPrimes(89)\n  88\n  >>> countPrimes(90)\n  89\n  >>> countPrimes(91)\n  90\n  >>> countPrimes(92)\n  91\n  >>> countPrimes(93)\n  92\n  >>> countPrimes(94)\n  93\n  >>> countPrimes(95)\n  94\n  >>> countPrimes(96)\n  95\n  >>> countPrimes(97)\n  96\n  >>> countPrimes(98)\n  97\n  >>> countPrimes(99)\n  98\n  >>> countPrimes(100)\n  99\n  >>> countPrimes(101)\n  100\n  >>> countPrimes(102)\n  101\n  >>> countPrimes(103)\n  102\n  >>> countPrimes(104)\n  103\n  >>> countPrimes(105)\n  104\n  >>> countPrimes(106)\n  105\n  >>> countPrimes(107)\n  106\n  >>> countPrimes(108)\n  107\n  >>> countPrimes(109)\n  108\n  >>> countPrimes(110)\n  109\n  >>> countPrimes(111)\n  110\n  >>> countPrimes(112", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates poylnomial with coefficinets xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only ezro ipont, even if there are many.\n  Moreoevr, findZero only takes list xs having even numbre of coefficients\n  and largest non zero coefficietn as it ugarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 1, "perturbed": true, "gc": "/*\n  Evaluates poylnomial with coefficinets xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only ezro ipont, even if there are many.\n  Moreoevr, findZero only takes list xs having even numbre of coefficients\n  and largest non zero coefficietn as it ugarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] > max) {\n      max = xs[i];\n      maxIndex = i;\n    }\n  }\n  let x = 1;\n  while (poly(x)!== 0) {\n    x = x + 1;\n  }\n  return x - maxIndex;\n}\n\n/*\n  Evaluates polynomial with coefficinets xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only ezro ipont, even if there are many.\n  Moreoevr, findZero only takes list xs having even numbre of coefficients\n  and largest non zero coefficietn as it ugarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] > max) {\n      max = xs[i];\n      maxIndex = i;\n    }\n  }\n  let x = 1;\n  while (poly(x)!== 0) {\n    x = x + 1;\n  }\n  return x - maxIndex;\n}\n\n/*\n  Evaluates polynomial with coefficinets xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only ezro ipont, even if there are many.\n  Moreoevr, findZero only takes list xs having even numbre of coefficients\n  and largest non zero coefficietn as it ugarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] > max) {\n      max = xs[i];\n      maxIndex = i;\n    }\n  }\n  let x = 1;\n  while (poly(x)!== 0) {\n    x = x + 1;\n  }\n  return x - maxIndex;\n}\n\n/*\n  Evaluates polynomial with coefficinets xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only ezro ipont, even if there are many.\n  Moreoevr, findZero only takes list xs having even numbre of coefficients\n  and largest non zero coefficietn as it ugarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs)", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indciies that are not divisible by three, while its values at eth indicies that are divisbile by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 1, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indciies that are not divisible by three, while its values at eth indicies that are divisbile by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = l.slice();\n  const l3 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      l3.push(l2[i]);\n    }\n  }\n  return l3;\n};\n\nmodule.exports = sortThird;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 1, "perturbed": false, "gc": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique2 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique3 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique4 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique5 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique6 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique7 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique8 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique9 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique10 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique11 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique.length;\n};\n\n/*Return the number of unique elements in a list\n  >>> countUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique12 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1)", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum leement in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 1, "perturbed": true, "gc": "/*Return maximum leement in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the numebr of times the digit 7 apperas in integres lses htan n which rae divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 1, "perturbed": true, "gc": "/*Return the numebr of times the digit 7 apperas in integres lses htan n which rae divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let i = 1;\n  while (i <= n) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      console.log(i);\n    }\n    i++;\n  }\n};\n\nfizzBuzz(78);\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l nad retruns a list l' such that\n  l' is identical to l in the dod indicies, while its values at the even indiceis are equal\n  to the values of the even indicies of l, but sortde.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 1, "perturbed": true, "gc": "/*This function takes a list l nad retruns a list l' such that\n  l' is identical to l in the dod indicies, while its values at the even indiceis are equal\n  to the values of the even indicies of l, but sortde.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = l.slice(0, l.length / 2);\n  const odd = l.slice(l.length / 2);\n  return even.concat(odd.sort((a, b) => a - b));\n};\n\n/*This function takes a list l nad retruns a list l' such that\n  l' is identical to l in the dod indicies, while its values at the odd indiceis are equal\n  to the values of the odd indicies of l, but sortde.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [3, 4, 6, 5]\n  */\nconst sortOdd = (l) => {\n  const even = l.slice(0, l.length / 2);\n  const odd = l.slice(l.length / 2);\n  return odd.concat(even.sort((a, b) => a - b));\n};\n\n/*This function takes a list l nad retruns a list l' such that\n  l' is identical to l in the dod indicies, while its values at the even indiceis are equal\n  to the values of the even indicies of l, and sortde.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 4, 6, 5]\n  */\nconst sort = (l) => {\n  return sortEven(sortEven(sortOdd(l)));\n};\n\nexport default sort;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of htree cahracters.\n  */\nconts encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as niput string necoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 1, "perturbed": true, "gc": "/*\n  returns encoded string by cycling groups of htree cahracters.\n  */\nconts encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as niput string necoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as niput string necoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as niput string necoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as niput string necoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as niput string necoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as niput string necoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as niput string necoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as niput string necoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic8 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th numebr that is a Fbionacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 1, "perturbed": true, "gc": "/*\n  primeFib returns n-th numebr that is a Fbionacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let a = 1, b = 1, c = 1, d = 1, e = 1, f = 1, g = 1, h = 1, i = 1, j = 1, k = 1, l = 1, m = 1, n = 1, o = 1, p = 1, q = 1, r = 1, s = 1, t = 1, u = 1, v = 1, w = 1, x = 1, y = 1, z = 1, A = 1, B = 1, C = 1, D = 1, E = 1, F = 1, G = 1, H = 1, I = 1, J = 1, K = 1, L = 1, M = 1, N = 1, O = 1, P = 1, Q = 1, R = 1, S = 1, T = 1, U = 1, V = 1, W = 1, X = 1, Y = 1, Z = 1, AA = 1, BB = 1, CC = 1, DD = 1, EE = 1, FF = 1, GG = 1, HH = 1, II = 1, JJ = 1, KK = 1, LL = 1, MM = 1, NN = 1, OO = 1, PP = 1, QQ = 1, RR = 1, SS = 1, TT = 1, UU = 1, VV = 1, WW = 1, XX = 1, YY = 1, ZZ = 1, aa = 1, bb = 1, cc = 1, dd = 1, ee = 1, ff = 1, gg = 1, hh = 1, ii = 1, jj = 1, kk = 1, ll = 1, mm = 1, nn = 1, oo = 1, pp = 1, qq = 1, rr = 1, ss = 1, tt = 1, uu = 1, vv = 1, www = 1, xx = 1, yy = 1, zz = 1;\n  let aa = 1, bb = 1, cc = 1, dd = 1, ee = 1, ff = 1, gg = 1, hh = 1, ii = 1, jj = 1, kk = 1, ll = 1, mm = 1, nn = 1, oo = 1, pp = 1, qq = 1, rr = 1, ss = 1, tt = 1, uu = 1, vv = 1, www = 1, xx = 1, yy = 1, zz = 1;\n  let aa = 1, bb = 1, cc = 1, dd = 1, ee = 1, ff = 1, gg = 1, hh = 1, ii = 1, jj = 1, kk = 1, ll = 1, mm = 1, nn = 1, oo = 1, pp = 1, qq = 1, rr = 1, ss = 1, tt = 1, uu = 1, vv = 1, www = 1, xx = 1, yy = 1, zz = 1;\n  let aa = 1, bb = 1, cc = 1, dd = 1, ee = 1, ff = 1, gg = 1, hh = 1, ii = 1, jj = 1, kk = 1, ll = 1, mm = 1, nn = 1, oo = 1, pp = 1, qq = 1, rr = 1, ss = 1, tt = 1, uu = 1, vv = 1, www = 1, xx = 1, yy = 1, zz = 1;\n  let aa = 1, bb = 1, cc = 1, dd = 1, ee = 1, ff = 1, gg = 1, hh = 1, ii = 1, jj = 1, kk = 1, ll = 1, mm = 1, nn = 1, oo = 1, pp = 1, qq = 1, rr = 1, ss = 1, tt = 1, uu = 1, vv = 1, www = 1, xx = 1, yy = 1, zz = 1;\n  let aa = 1, bb = 1, cc = 1, dd = 1, ee = 1, ff = 1, gg = 1, hh = 1, ii = 1, jj = 1, kk = 1, ll = 1, mm = 1, nn = 1, oo = 1, pp = 1, qq = 1, rr = 1, ss = 1, tt = 1, uu = 1, vv = 1, www = 1, xx = 1, yy = 1, zz = 1;\n  let aa = 1, bb = 1, cc = 1, dd = 1, ee = 1, ff = 1, gg = 1, hh = 1, ii = 1, jj = 1, kk = 1, ll = 1, mm = 1, nn = 1, oo = 1, pp = 1, qq = 1, rr = 1, ss = 1, tt = 1, uu = 1, vv = 1, www = 1, xx = 1, yy = 1, zz = 1;\n  let aa = 1, bb = 1, cc = 1, dd = 1, ee = 1, ff = 1, gg = 1, hh = 1, ii = 1, jj = 1, kk = 1, ll = 1, mm = 1, nn = 1, oo = 1, pp = 1, qq = 1, rr = 1, ss = 1, tt = 1, uu = 1, vv = 1, www = 1, xx = 1, yy = 1, zz = 1;\n  let aa = 1, bb = 1, cc = 1, dd = 1, ee = 1, ff = 1, gg = 1, hh = 1, ii = 1, jj = 1, kk = 1, ll = 1, mm = 1, nn = 1, oo = 1, pp = 1, qq = 1, rr = 1, ss = 1, tt = 1, uu = 1, vv = 1, www = 1, xx = 1, yy = 1, zz = 1;\n  let aa = 1,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a igven list of input numbers, calculaet Mean Asbolute Deviation\n  around the mean of this dataset.\n  Mean Abslotue Deviation is the average absloute difference between each\n  elemnet and a centerpoint (mean in thsi case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 1, "perturbed": true, "gc": "/* For a igven list of input numbers, calculaet Mean Asbolute Deviation\n  around the mean of this dataset.\n  Mean Abslotue Deviation is the average absloute difference between each\n  elemnet and a centerpoint (mean in thsi case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  return Math.round(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(numbers), 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/*\n  For a list of input numbers, calculate the standard deviation of this\n  dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const deviations = numbers.map(x => Math.pow(x - mean(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of nitegers as an input.\n  it retursn true if three rae three distinct elements in the list that\n  sum to zero, adn false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 1, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list of nitegers as an input.\n  it retursn true if three rae three distinct elements in the list that\n  sum to zero, adn false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of nitegers as an input.\n  it retursn true if three rae three distinct elements in the list that\n  sum to zero, adn false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of nitegers as an input.\n  it retursn true if three rae three distinct elements in the list that\n  sum to zero, adn false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of nitegers as an input.\n  it retursn true if three rae three distinct elements in the list that\n  sum to zero, adn false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of nitegers as an input.\n  it retursn true if three rae three distinct elements in the list that\n  sum to zero, adn false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of nitegers as an input.\n  it retursn true if three rae three distinct elements in the list that\n  sum to zero, adn false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of nitegers as an input.\n  it retursn true if three rae three distinct elements in the list that\n  sum to zero, adn false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of nitegers as an input.\n  it retursn true if three rae three distinct elements in the list that\n  sum to zero, adn false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straigth nifinitely long line.\n  n cars are rdiving left to irhgt;  simultaneously, a different set of n cars\n  are driving right to left.   The two ests of casr start out being very far from\n  each other.  All cars move in the same speed.  wTo cars are said to ocllide\n  when a car that's moving lfet to right hits a car that's movign right to left.\n  However, teh cars are inifnitely sturdy and strong; as a result, they contineu moving\n  in theri trajecotry as fi they did not collide.\n\n  This function outputs the number of scuh collsiions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 1, "perturbed": true, "gc": "/*\n  Imagine a road that's a perfectly straigth nifinitely long line.\n  n cars are rdiving left to irhgt;  simultaneously, a different set of n cars\n  are driving right to left.   The two ests of casr start out being very far from\n  each other.  All cars move in the same speed.  wTo cars are said to ocllide\n  when a car that's moving lfet to right hits a car that's movign right to left.\n  However, teh cars are inifnitely sturdy and strong; as a result, they contineu moving\n  in theri trajecotry as fi they did not collide.\n\n  This function outputs the number of scuh collsiions.\n  */\nconst carRaceCollision = (n) => {\n  let cars = [];\n  for (let i = 0; i < n; i++) {\n    cars.push(new car(i, i, i, i));\n  }\n  let wTo = 0;\n  let wToNext = 0;\n  let wToPrev = 0;\n  let wToNextNext = 0;\n  let wToNextPrev = 0;\n  let wToPrevPrev = 0;\n  let wToNextNextNext = 0;\n  let wToNextPrevPrev = 0;\n  let wToPrevPrevPrev = 0;\n  let wToNextNextNextNext = 0;\n  let wToNextPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNextPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0;\n  let wToNextNextNextNextNextNextNextNextNextNextNext = 0;\n  let wToNext", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements inrcemented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 1, "perturbed": true, "gc": "/*Return list with elements inrcemented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0,\n    j = 0,\n    k = 0,\n    newList = [];\n\n  while (i < l.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  while (j < newList.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  return newList;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList2 = (l) => {\n  let i = 0,\n    j = 0,\n    k = 0,\n    newList = [];\n\n  while (i < l.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  while (j < newList.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  return newList;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList3 = (l) => {\n  let i = 0,\n    j = 0,\n    k = 0,\n    newList = [];\n\n  while (i < l.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  while (j < newList.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  return newList;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList4 = (l) => {\n  let i = 0,\n    j = 0,\n    k = 0,\n    newList = [];\n\n  while (i < l.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  while (j < newList.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  return newList;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList5 = (l) => {\n  let i = 0,\n    j = 0,\n    k = 0,\n    newList = [];\n\n  while (i < l.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  while (j < newList.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  return newList;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList6 = (l) => {\n  let i = 0,\n    j = 0,\n    k = 0,\n    newList = [];\n\n  while (i < l.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  while (j < newList.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  return newList;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList7 = (l) => {\n  let i = 0,\n    j = 0,\n    k = 0,\n    newList = [];\n\n  while (i < l.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  while (j < newList.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  return newList;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList8 = (l) => {\n  let i = 0,\n    j = 0,\n    k = 0,\n    newList = [];\n\n  while (i < l.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  while (j < newList.length) {\n    newList[j] = l[i];\n    i++;\n    j++;\n  }\n\n  return newList;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 1, "perturbed": false, "gc": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const l = l.filter((x) => x > 0)\n  const l2 = l.filter((x) => x < 0)\n  const sum = l.reduce((a, b) => a + b, 0)\n  const sum2 = l2.reduce((a, b) => a + b, 0)\n  return sum === 0 && sum2 === 0\n}\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero2 = (l) => {\n  const l = l.filter((x) => x > 0)\n  const l2 = l.filter((x) => x < 0)\n  const sum = l.reduce((a, b) => a + b, 0)\n  const sum2 = l2.reduce((a, b) => a + b, 0)\n  return sum === 0 && sum2 === 0\n}\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero3 = (l) => {\n  const l = l.filter((x) => x > 0)\n  const l2 = l.filter((x) => x < 0)\n  const sum = l.reduce((a, b) => a + b, 0)\n  const sum2 = l2.reduce((a, b) => a + b, 0)\n  return sum === 0 && sum2 === 0\n}\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero4 = (l) => {\n  const l = l.filter((x) => x > 0)\n  const l2 = l.filter((x) => x < 0)\n  const sum = l.reduce((a, b) => a + b, 0)\n  const sum2 = l2.reduce((a, b) => a + b, 0)\n  return sum === 0 && sum2 === 0\n}\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero5 = (l) => {\n  const l = l.filter((x) => x > 0)\n  const l2 = l.filter((x) => x < 0)\n  const sum = l.reduce((a, b) => a + b, 0)\n  const sum2 = l2.reduce((a, b) => a + b, 0)\n  return sum === 0 && sum2 === 0\n}\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero6 = (l) => {\n  const l = l.filter((x) => x > 0)\n  const l2 = l.filter((x) => x < 0)\n  const sum = l.reduce((a, b) => a + b, 0)\n  const sum2 = l2.reduce((a, b) => a + b, 0)\n  return sum === 0 && sum2 === 0\n}\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumTo", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return stirgn representation fater the conversion.\n  base numbers are less thna 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 1, "perturbed": true, "gc": "/*Change numerical base of input number x to base.\n  return stirgn representation fater the conversion.\n  base numbers are less thna 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  const result = [];\n  let i = x;\n  while (i > 0) {\n    result.unshift(i % base);\n    i = Math.floor(i / base);\n  }\n  return result.join('');\n};\n\nconst convert = (x, base) => {\n  const result = changeBase(x, base);\n  return result.length === 1? result[0] : result;\n};\n\nconst convertBase = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase2 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase3 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase4 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase5 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase6 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase7 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase8 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase9 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase10 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase11 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase12 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase13 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase14 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase15 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase16 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase17 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase18 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase19 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase20 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase21 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase22 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase23 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase24 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase25 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase26 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase27 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase28 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase29 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase30 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase31 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase32 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase33 = (x, base, base2) => {\n  const result = convert(x, base);\n  return convert(result, base2);\n};\n\nconst convertBase34 = (x, base, base2) => {\n  const result = convert(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and ihgh return area for a tiranlge.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "/*Given length of a side and ihgh return area for a tiranlge.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and ihgh return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length of a side and i", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/46", "prompt": "/*Teh Fib4 number sequence si a sequence similar to the Fibboncaci sqeunece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please wrtie a functoin to efficiently compute the n-th element fo the fib4 number sequence.  Do not use recrusion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 1, "perturbed": true, "gc": "/*Teh Fib4 number sequence si a sequence similar to the Fibboncaci sqeunece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please wrtie a functoin to efficiently compute the n-th element fo the fib4 number sequence.  Do not use recrusion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) {\n    return 0\n  } else if (n === 1) {\n    return 0\n  } else if (n === 2) {\n    return 2\n  } else if (n === 3) {\n    return 0\n  } else if (n === 4) {\n    return 2\n  } else if (n === 5) {\n    return 4\n  } else if (n === 6) {\n    return 8\n  } else if (n === 7) {\n    return 14\n  } else {\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n  }\n}\n\nconsole.log(fib4(5))\nconsole.log(fib4(6))\nconsole.log(fib4(7))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/47", "prompt": "/*Return median fo elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 1, "perturbed": true, "gc": "/*Return median fo elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\nexport default median;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome2 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome3 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === text;\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome4 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed;\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome5 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed.split('').join('');\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome6 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed.split('').join('');\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome7 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed.split('').join('');\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome8 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed.split('').join('');\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome9 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed.split('').join('');\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome10 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed.split('').join('');\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome11 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed.split('').join('');\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome12 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed.split('').join('');\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome13 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed.split('').join('');\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome14 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return reversed === reversed.split('').join('');\n};\n\n/*\n  Cehcks if given string is a palidnroem\n  >>> isPalindrome('aba')\n  true\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n omdulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 1, "perturbed": true, "gc": "/*Return 2^n omdulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  return (n % p)\n}\n\n/*Return the greatest common divisor of a and b.\n  >>> gcd(3, 4)\n  1\n  >>> gcd(3, 5)\n  3\n  >>> gcd(3, 6)\n  3\n  >>> gcd(0, 0)\n  0\n  >>> gcd(0, 1)\n  0\n  >>> gcd(1, 0)\n  1\n  >>> gcd(1, 1)\n  1\n  >>> gcd(2, 3)\n  1\n  >>> gcd(2, 4)\n  2\n  >>> gcd(2, 5)\n  2\n  >>> gcd(2, 6)\n  2\n  >>> gcd(7, 3)\n  1\n  >>> gcd(7, 4)\n  7\n  >>> gcd(7, 5)\n  7\n  >>> gcd(7, 6)\n  7\n  >>> gcd(7, 7)\n  7\n  >>> gcd(8, 3)\n  3\n  >>> gcd(8, 4)\n  4\n  >>> gcd(8, 5)\n  5\n  >>> gcd(8, 6)\n  6\n  >>> gcd(8, 7)\n  8\n  >>> gcd(8, 8)\n  8\n  >>> gcd(9, 3)\n  3\n  >>> gcd(9, 4)\n  4\n  >>> gcd(9, 5)\n  5\n  >>> gcd(9, 6)\n  6\n  >>> gcd(9, 7)\n  7\n  >>> gcd(9, 8)\n  9\n  >>> gcd(9, 9)\n  9\n  >>> gcd(10, 3)\n  3\n  >>> gcd(10, 4)\n  4\n  >>> gcd(10, 5)\n  5\n  >>> gcd(10, 6)\n  6\n  >>> gcd(10, 7)\n  7\n  >>> gcd(10, 8)\n  10\n  >>> gcd(10, 9)\n  10\n  >>> gcd(10, 10)\n  10\n  >>> gcd(11, 3)\n  3\n  >>> gcd(11, 4)\n  4\n  >>> gcd(11, 5)\n  5\n  >>> gcd(11, 6)\n  6\n  >>> gcd(11, 7)\n  7\n  >>> gcd(11, 8)\n  11\n  >>> gcd(11, 9)\n  11\n  >>> gcd(11, 10)\n  11\n  >>> gcd(11, 11)\n  11\n  >>> gcd(12, 3)\n  3\n  >>> gcd(12, 4)\n  4\n  >>> gcd(12, 5)\n  5\n  >>> gcd(12, 6)\n  6\n  >>> gcd(12, 7)\n  7\n  >>> gcd(12, 8)\n  12\n  >>> gcd(12, 9)\n  12\n  >>> gcd(12, 10)\n  12\n  >>> gcd(12, 11)\n  12\n  >>> gcd(12, 12)\n  12\n  >>> gcd(13, 3)\n  3\n  >>> gcd(13, 4)\n  4\n  >>> gcd(13, 5)\n  5\n  >>> gcd(13, 6)\n  6\n  >>> gcd(13, 7)\n  7\n  >>> gcd(13, 8)\n  13\n  >>> gcd(13, 9)\n  13\n  >>> gcd(13, 10)\n  13\n  >>> gcd(13, 11)\n  13\n  >>> gcd(13, 12)\n  13\n  >>> gcd(13, 13)\n  13\n  >>> gcd(14, 3)\n  3\n  >>> gcd(14, 4)\n  4\n  >>> gcd(14, 5)\n  5\n  >>> gcd(14, 6)\n  6\n  >>> gcd(14, 7)\n  7\n  >>> gcd(14, 8)\n  14\n  >>> gcd(14, 9)\n  14\n  >>> gcd(14, 10)\n  14\n  >>> gcd(14, 11)\n  14\n  >>> gcd(14, 12)\n  14\n  >>> gcd(14, 13)\n  14\n  >>> gcd(14, 14)\n  14\n  >>> gcd(15, 3)\n  3\n  >>> gcd(15, 4)\n  4\n  >>> gcd(15, 5)\n  5\n  >>> gcd(15, 6)\n  6\n  >>> gcd(15, 7)\n  7\n  >>> gcd(15, 8)\n  15\n  >>> gcd(15, 9)\n  15\n  >>> gcd(15, 10)\n  15\n  >>> gcd(15, 11)\n  15\n  >>> gcd(15, 12)\n  15\n  >>> gcd(15, 13)\n  15\n  >>> gcd(15, 14)\n  15\n  >>> gcd(15, 15)\n  15\n  >>> gcd(16, 3)\n  3\n  >>> gcd(16, 4)\n  4\n  >>> gcd(16, 5)\n  5\n  >>> gcd(16, 6)\n  6\n  >>> gcd(16, 7)\n  7\n  >>> gcd(16, 8)\n  16\n  >>> gcd(16, 9)\n  16\n  >>> gcd(16, 10)\n  16\n  >>> gcd(16, 11)\n  16\n  >>> gcd(16, 12)\n  16\n  >>> gcd(16, 13)\n  16\n  >>> gcd(16, 14)\n  16\n  >>> gcd(16, 15)\n  16\n  >>> gcd(16, 16)\n  16\n  >>> gcd(17, 3)\n  3\n  >>> gcd(17, 4)\n  4\n  >>> gcd(17, 5)", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 1, "perturbed": false, "gc": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  if (!numbers ||!numbers.length) {\n    return []\n  }\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (j < numbers.length - 1) {\n      result.push(numbers[i])\n      j++\n    } else {\n      result.push(numbers[i])\n      result.push(delimeter)\n      i++\n    }\n  }\n  return result\n}\n\n/*\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> inters", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shfiitng every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  taeks as input string encdoed with encode_shift function. Retunrs decoded string.\n  */\ncosnt decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 1, "perturbed": true, "gc": "/*\n  returns encoded string by shfiitng every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  taeks as input string encdoed with encode_shift function. Retunrs decoded string.\n  */\ncosnt decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns true if string is palindrome.\n  */\nconst isPalindrome = (s) => {\n  return s.split(\"\").reverse().join(\"\") === s;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome2 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome3 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome4 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome5 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome6 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome7 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome8 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome9 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome10 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome11 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome12 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome13 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}\n\n/*\n  returns true if string is a palindrome.\n  */\nconst isPalindrome14 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a functino that takes string and returns string without ovwels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 1, "perturbed": true, "gc": "/*\n  removeVowels is a functino that takes string and returns string without ovwels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const vowelsLength = vowels.length\n  let result = text\n  for (let i = 0; i < vowelsLength; i++) {\n    const vowel = vowels[i]\n    const vowelLength = vowel.length\n    const index = result.indexOf(vowel)\n    if (index > -1) {\n      result = result.substring(0, index) + result.substring(index + vowelLength)\n    }\n  }\n  return result\n}\n\n/*\n  removeVowels is a functino that takes string and returns string without ovwels.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels2 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const vowelsLength = vowels.length\n  let result = text\n  for (let i = 0; i < vowelsLength; i++) {\n    const vowel = vowels[i]\n    const vowelLength = vowel.length\n    const index = result.indexOf(vowel)\n    if (index > -1) {\n      result = result.substring(0, index) + result.substring(index + vowelLength)\n    }\n  }\n  return result\n}\n\n/*\n  removeVowels is a functino that takes string and returns string without ovwels.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels3 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const vowelsLength = vowels.length\n  let result = text\n  for (let i = 0; i < vowelsLength; i++) {\n    const vowel = vowels[i]\n    const vowelLength = vowel.length\n    const index = result.indexOf(vowel)\n    if (index > -1) {\n      result = result.substring(0, index) + result.substring(index + vowelLength)\n    }\n  }\n  return result\n}\n\n/*\n  removeVowels is a functino that takes string and returns string without ovwels.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels4 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const vowelsLength = vowels.length\n  let result = text\n  for (let i = 0; i < vowelsLength; i++) {\n    const vowel = vowels[i]\n    const vowelLength = vowel.length\n    const index = result.indexOf(vowel)\n    if (index > -1) {\n      result = result.substring(0, index) + result.substring(index + vowelLength)\n    }\n  }\n  return result\n}\n\n/*\n  removeVowels is a functino that takes string and returns string without ovwels.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels5 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const vowelsLength = vowels.length\n  let result = text\n  for (let i = 0; i < vowelsLength; i++) {\n    const vowel = vowels[i]\n    const vowelLength = vowel.length\n    const index = result.indexOf(vowel)\n    if (index > -1) {\n      result = result.substring(0, index) + result.substring(index + vowelLength)\n    }\n  }\n  return result\n}\n\n/*\n  removeVowels is a functino that takes string and returns string without ovwels.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/52", "prompt": "/*Rteurn true if all unmbers in teh list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 1, "perturbed": true, "gc": "/*Rteurn true if all unmbers in teh list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  const len = l.length\n  for (let i = 0; i < len; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 5)\n  false\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 2, 4, 10], 1)\n  false\n  >>> belowThreshold([1, 2, 4, 10], 0)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1)\n  false\n  >>> belowThreshold([1, 2, 4, 10], -10)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -100000000000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -1000000000000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold([1, 2, 4, 10], -10000000000000000000000000000000000000000000000000000000)\n  true\n  >>> belowThreshold", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": false, "gc": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  35\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> divide(2, 3)\n  0.5\n  >>> divide(5, 7)\n  2.5\n  */\nconst modulo = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> modulo(2, 3)\n  1\n  >>> modulo(5, 7)\n  4\n  */\nconst power = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  8\n  >>> power(5, 7)\n  625\n  */\nconst square = (x) => {\n  return x * x;\n};\n\n/*\n  >>> square(2)\n  4\n  >>> square(5)\n  25\n  */\nconst squareRoot = (x) => {\n  return Math.sqrt(x);\n};\n\n/*\n  >>> squareRoot(2)\n  1\n  >>> squareRoot(5)\n  2.5\n  */\nconst factorial = (x) => {\n  return x <= 1? 1 : x * factorial(x - 1);\n};\n\n/*\n  >>> factorial(2)\n  2\n  >>> factorial(5)\n  120\n  */\nconst fibonacci = (x) => {\n  if (x <= 1) {\n    return 1;\n  } else {\n    return fibonacci(x - 1) + fibonacci(x - 2);\n  }\n};\n\n/*\n  >>> fibonacci(2)\n  1\n  >>> fibonacci(5)\n  8\n  */\nconst gcd = (x, y) => {\n  return x === 0? y : gcd(y, x % y);\n};\n\n/*\n  >>> gcd(2, 3)\n  1\n  >>> gcd(5, 7)\n  1\n  */\nconst lcm = (x, y) => {\n  return x * y / gcd(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  6\n  >>> lcm(5, 7)\n  35\n  */\nconst sum = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> sum(2, 3)\n  5\n  >>> sum(5, 7)\n  12\n  */\nconst product = (x, y) => {\n  return x * y;\n};\n\n/*\n  >>> product(2, 3)\n  6\n  >>> product(5, 7)\n  35\n  */\nconst difference = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> difference(2, 3)\n  1\n  >>> difference(5, 7)\n  4\n  */\nconst quotient = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> quotient(2, 3)\n  0.5\n  >>> quotient(5, 7)\n  2.5\n  */\nconst remainder = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> remainder(2, 3)\n  1\n  >>> remainder(5, 7)\n  4\n  */\nconst modulo = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> modulo(2, 3)\n  1\n  >>> modulo(5, 7)\n  4\n  */\nconst power = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  8\n  >>> power(5, 7)\n  625\n  */\nconst square = (x) => {\n  return x * x;\n};\n\n/*\n  >>> square(2)\n  4\n  >>> square(5)\n  25\n  */\nconst squareRoot = (x) => {\n  return Math.sqrt(x);\n};\n\n/*\n  >>> squareRoot(2)\n  1\n  >>> squareRoot(5)\n  2.5\n  */\nconst factorial = (x) => {\n  return x <= 1? 1 : x * factorial(x - 1);\n};\n\n/*\n  >>> factorial(2)\n  2\n  >>> factorial(5)\n  120\n  */\nconst fibonacci = (x) => {\n  if (x <= 1) {\n    return 1;\n  } else {\n    return fibonacci(x - 1) + fibonacci(x - 2);\n  }\n};\n\n/*\n  >>> fibonacci(2)\n  1\n  >>> fibonacci(5)\n  8\n  */\nconst gcd = (x, y) => {\n  return x === 0? y : gcd(y, x % y);\n};\n\n/*\n  >>> gcd(2, 3)\n  1\n  >>> gcd(5, 7)\n  1\n  */\nconst lcm = (x, y) => {\n  return x * y / gcd(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  6\n  >>> lcm(5, 7)\n  35\n  */\nconst sum = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> sum(2, 3)\n  5\n  >>> sum(5, 7)\n  12\n  */\nconst product = (x, y) => {\n  return x * y;\n};\n\n/*\n  >>> product(2, 3)\n  6\n  >>> product(5, 7)\n  35\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two owrds have the same chraacters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 1, "perturbed": true, "gc": "/*\n  Check if two owrds have the same chraacters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n    let i = 0\n    let j = 0\n    while (i < s0.length && j < s1.length) {\n        if (s0[i] === s1[j]) {\n            i++\n            j++\n        } else {\n            break\n        }\n    }\n    return i === s0.length && j === s1.length\n}\n\n/*\n  Check if two owrds are the same.\n  >>> same('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> same('abcd', 'dddddddabc')\n  true\n  >>> same('dddddddabc', 'abcd')\n  true\n  >>> same('eabcd', 'dddddddabc')\n  false\n  >>> same('abcd', 'dddddddabce')\n  false\n  >>> same('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst same = (s0, s1) => {\n    let i = 0\n    let j = 0\n    while (i < s0.length && j < s1.length) {\n        if (s0[i] === s1[j]) {\n            i++\n            j++\n        } else {\n            break\n        }\n    }\n    return i === s0.length && j === s1.length\n}\n\n/*\n  Check if two owrds are the same.\n  >>> same('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  >>> same('abcd', 'dddddddabc')\n  false\n  >>> same('dddddddabc', 'abcd')\n  false\n  >>> same('eabcd', 'dddddddabc')\n  false\n  >>> same('abcd', 'dddddddabce')\n  false\n  >>> same('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst same2 = (s0, s1) => {\n    let i = 0\n    let j = 0\n    while (i < s0.length && j < s1.length) {\n        if (s0[i] === s1[j]) {\n            i++\n            j++\n        } else {\n            break\n        }\n    }\n    return i === s0.length && j === s1.length\n}\n\n/*\n  Check if two owrds are the same.\n  >>> same2('eabcdzzzz', 'dddzzzzzzzddddabc')\n  true\n  >>> same2('abcd', 'dddddddabc')\n  true\n  >>> same2('dddddddabc', 'abcd')\n  true\n  >>> same2('eabcd', 'dddddddabc')\n  true\n  >>> same2('abcd', 'dddddddabce')\n  true\n  >>> same2('eabcdzzzz', 'dddzzzzzzzddddabc')\n  true\n  */\nconst same3 = (s0, s1) => {\n    let i = 0\n    let j = 0\n    while (i < s0.length && j < s1.length) {\n        if (s0[i] === s1[j]) {\n            i++\n            j++\n        } else {\n            break\n        }\n    }\n    return i === s0.length && j === s1.length\n}\n\n/*\n  Check if two owrds are the same.\n  >>> same3('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  >>> same3('abcd', 'dddddddabc')\n  false\n  >>> same3('dddddddabc', 'abcd')\n  false\n  >>> same3('eabcd', 'dddddddabc')\n  false\n  >>> same3('abcd', 'dddddddabce')\n  false\n  >>> same3('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst same4 = (s0, s1) => {\n    let i = 0\n    let j = 0\n    while (i < s0.length && j < s1.length) {\n        if (s0[i] === s1[j]) {\n            i++\n            j++\n        } else {\n            break\n        }\n    }\n    return i === s0.length && j === s1.length\n}\n\n/*\n  Check if two owrds are the same.\n  >>> same4('eabcdzzzz', 'dddzzzzzzzddddabc')\n  true\n  >>> same4('abcd', 'dddddddabc')\n  true\n  >>> same4('dddddddabc', 'abcd')\n  true\n  >>> same4('eabcd', 'dddddddabc')\n  true\n  >>> same4('abcd', 'dddddddabce')\n  true\n  >>> same4('eabcdzzzz', 'dddzzzzzzzddddabc')\n  true\n  */\nconst same5 = (s0, s1) => {\n    let i = 0\n    let j = 0\n    while (i < s0.length && j < s1.length) {\n        if (s0[i] === s1[j]) {\n            i++\n            j++\n        } else {\n            break\n        }\n    }\n    return i === s0.length && j === s1.length\n}\n\n/*\n  Check if two owrds are the same.\n  >>> same5('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  >>> same5('", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 1, "perturbed": false, "gc": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string fo \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "/* brackets is a string fo \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const stack = []\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"<\") {\n      stack.push(\"<\")\n    } else if (brackets[i] === \">\") {\n      if (stack.length === 0) {\n        return false\n      }\n      if (stack[stack.length - 1]!== \">\") {\n        return false\n      }\n      stack.pop()\n    }\n  }\n  return stack.length === 0\n}\n\n/*\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracket", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/57", "prompt": "/*Return treu is list elements are omnotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 1, "perturbed": true, "gc": "/*Return treu is list elements are omnotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  const sorted = l.slice().sort((a, b) => a - b);\n  return sorted[0] === sorted[1];\n};\n\n/*\n  Return true iff the list is sorted.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sorted = (l) => {\n  return l.every((x, i) => x <= l[i + 1]);\n};\n\n/*\n  Return true iff the list is sorted in ascending order.\n  >>> sortedAsc([1, 2, 4, 20])\n  true\n  >>> sortedAsc([1, 20, 4, 10])\n  false\n  >>> sortedAsc([4, 1, 0, -10])\n  true\n  */\nconst sortedAsc = (l) => {\n  return l.every((x, i) => x <= l[i + 1]);\n};\n\n/*\n  Return true iff the list is sorted in descending order.\n  >>> sortedDesc([1, 2, 4, 20])\n  false\n  >>> sortedDesc([1, 20, 4, 10])\n  true\n  >>> sortedDesc([4, 1, 0, -10])\n  true\n  */\nconst sortedDesc = (l) => {\n  return l.every((x, i) => x >= l[i + 1]);\n};\n\n/*\n  Return true iff the list is sorted in ascending order.\n  >>> sortedAsc([1, 2, 4, 20])\n  true\n  >>> sortedAsc([1, 20, 4, 10])\n  false\n  >>> sortedAsc([4, 1, 0, -10])\n  true\n  */\nconst sortedAscBy = (l, f) => {\n  return l.every((x, i) => f(x, l[i + 1]));\n};\n\n/*\n  Return true iff the list is sorted in descending order.\n  >>> sortedDesc([1, 2, 4, 20])\n  false\n  >>> sortedDesc([1, 20, 4, 10])\n  true\n  >>> sortedDesc([4, 1, 0, -10])\n  true\n  */\nconst sortedDescBy = (l, f) => {\n  return l.every((x, i) => f(x, l[i + 1]));\n};\n\n/*\n  Return true iff the list is sorted in ascending order.\n  >>> sortedAscBy([1, 2, 4, 20], x => x)\n  true\n  >>> sortedAscBy([1, 20, 4, 10], x => x)\n  false\n  >>> sortedAscBy([4, 1, 0, -10], x => x)\n  true\n  */\nconst sortedAscBy = (l, f) => {\n  return l.every((x, i) => f(x, l[i + 1]));\n};\n\n/*\n  Return true iff the list is sorted in descending order.\n  >>> sortedDescBy([1, 2, 4, 20], x => x)\n  false\n  >>> sortedDescBy([1, 20, 4, 10], x => x)\n  true\n  >>> sortedDescBy([4, 1, 0, -10], x => x)\n  true\n  */\nconst sortedDescBy = (l, f) => {\n  return l.every((x, i) => f(x, l[i + 1]));\n};\n\n/*\n  Return true iff the list is sorted in ascending order.\n  >>> sortedAscBy([1, 2, 4, 20], x => x)\n  true\n  >>> sortedAscBy([1, 20, 4, 10], x => x)\n  false\n  >>> sortedAscBy([4, 1, 0, -10], x => x)\n  true\n  */\nconst sortedAscBy = (l, f) => {\n  return l.every((x, i) => f(x, l[i + 1]));\n};\n\n/*\n  Return true iff the list is sorted in descending order.\n  >>> sortedDescBy([1, 2, 4, 20], x => x)\n  false\n  >>> sortedDescBy([1, 20, 4, 10], x => x)\n  true\n  >>> sortedDescBy([4, 1, 0, -10], x => x)\n  true\n  */\nconst sortedDescBy = (l, f) => {\n  return l.every((x, i) => f(x, l[i + 1]));\n};\n\n/*\n  Return true iff the list is sorted in ascending order.\n  >>> sortedAscBy([1, 2, 4, 20], x => x)\n  true\n  >>> sortedAscBy([1, 20, 4, 10], x => x)\n  false\n  >>> sortedAscBy([4, 1, 0, -10], x => x)\n  true\n  */\nconst sortedAscBy = (l, f) => {\n  return l.every((x, i) => f(x, l[i + 1]));\n};\n\n/*\n  Return true iff the list is sorted in descending order.\n  >>> sortedDescBy([1, 2, 4, 20], x => x)\n  false\n  >>> sortedDescBy([1, 20, 4, 10], x => x)\n  true\n  >>> sortedDescBy([4, 1, 0, -10], x => x)\n  true\n  */\nconst sortedDescBy = (l, f) => {\n  return l.every((x, i) => f(x, l[i + 1]));\n};\n\n/*\n  Return true iff the list is sorted in ascending order.\n  >>> sortedAscBy([1, 2, 4, 20], x => x)\n  true\n  >>> sortedAscBy([1, 20, 4, 10], x => x)\n  false\n  >>> sortedAscBy([4, 1, 0, -10], x => x)\n  true\n  */\nconst sortedAscBy = (l, f) => {\n  return l.every((x, i) => f(x, l[", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 1, "perturbed": false, "gc": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1_set = new Set(l1);\n  const l2_set = new Set(l2);\n  const intersection = l1_set.intersection(l2_set);\n  return intersection.values();\n};\n\nmodule.exports = common;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Rteurn the largest pirme factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 1, "perturbed": true, "gc": "/*Rteurn the largest pirme factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  if (n === 1) {\n    return 1\n  }\n  if (n === 2) {\n    return 2\n  }\n  if (n === 3) {\n    return 3\n  }\n  if (n % 2 === 0) {\n    return largestPrimeFactor(n / 2)\n  }\n  if (n % 3 === 0) {\n    return largestPrimeFactor(n / 3)\n  }\n  if (n % 5 === 0) {\n    return largestPrimeFactor(n / 5)\n  }\n  if (n % 7 === 0) {\n    return largestPrimeFactor(n / 7)\n  }\n  if (n % 11 === 0) {\n    return largestPrimeFactor(n / 11)\n  }\n  if (n % 13 === 0) {\n    return largestPrimeFactor(n / 13)\n  }\n  if (n % 17 === 0) {\n    return largestPrimeFactor(n / 17)\n  }\n  if (n % 19 === 0) {\n    return largestPrimeFactor(n / 19)\n  }\n  if (n % 23 === 0) {\n    return largestPrimeFactor(n / 23)\n  }\n  if (n % 29 === 0) {\n    return largestPrimeFactor(n / 29)\n  }\n  if (n % 31 === 0) {\n    return largestPrimeFactor(n / 31)\n  }\n  if (n % 37 === 0) {\n    return largestPrimeFactor(n / 37)\n  }\n  if (n % 41 === 0) {\n    return largestPrimeFactor(n / 41)\n  }\n  if (n % 43 === 0) {\n    return largestPrimeFactor(n / 43)\n  }\n  if (n % 47 === 0) {\n    return largestPrimeFactor(n / 47)\n  }\n  if (n % 53 === 0) {\n    return largestPrimeFactor(n / 53)\n  }\n  if (n % 59 === 0) {\n    return largestPrimeFactor(n / 59)\n  }\n  if (n % 61 === 0) {\n    return largestPrimeFactor(n / 61)\n  }\n  if (n % 67 === 0) {\n    return largestPrimeFactor(n / 67)\n  }\n  if (n % 71 === 0) {\n    return largestPrimeFactor(n / 71)\n  }\n  if (n % 73 === 0) {\n    return largestPrimeFactor(n / 73)\n  }\n  if (n % 79 === 0) {\n    return largestPrimeFactor(n / 79)\n  }\n  if (n % 83 === 0) {\n    return largestPrimeFactor(n / 83)\n  }\n  if (n % 89 === 0) {\n    return largestPrimeFactor(n / 89)\n  }\n  if (n % 97 === 0) {\n    return largestPrimeFactor(n / 97)\n  }\n  if (n % 101 === 0) {\n    return largestPrimeFactor(n / 101)\n  }\n  if (n % 103 === 0) {\n    return largestPrimeFactor(n / 103)\n  }\n  if (n % 107 === 0) {\n    return largestPrimeFactor(n / 107)\n  }\n  if (n % 109 === 0) {\n    return largestPrimeFactor(n / 109)\n  }\n  if (n % 113 === 0) {\n    return largestPrimeFactor(n / 113)\n  }\n  if (n % 127 === 0) {\n    return largestPrimeFactor(n / 127)\n  }\n  if (n % 131 === 0) {\n    return largestPrimeFactor(n / 131)\n  }\n  if (n % 137 === 0) {\n    return largestPrimeFactor(n / 137)\n  }\n  if (n % 139 === 0) {\n    return largestPrimeFactor(n / 139)\n  }\n  if (n % 149 === 0) {\n    return largestPrimeFactor(n / 149)\n  }\n  if (n % 151 === 0) {\n    return largestPrimeFactor(n / 151)\n  }\n  if (n % 157 === 0) {\n    return largestPrimeFactor(n / 157)\n  }\n  if (n % 163 === 0) {\n    return largestPrimeFactor(n / 163)\n  }\n  if (n % 167 === 0) {\n    return largestPrimeFactor(n / 167)\n  }\n  if (n % 179 === 0) {\n    return largestPrimeFactor(n / 179)\n  }\n  if (n % 181 === 0) {\n    return largestPrimeFactor(n / 181)\n  }\n  if (n % 191 === 0) {\n    return largestPrimeFactor(n / 191)\n  }\n  if (n % 193 === 0) {\n    return largestPrimeFactor(n / 193)\n  }\n  if (n % 197 === 0) {\n    return largestPrimeFactor(n / 197)\n  }\n  if (n % 199 === 0) {\n    return largestPrimeFactor(n / 199)\n  }\n  if (n % 211 === 0) {\n    return largestPrimeFactor(n / 211)\n  }\n  if (n % 223 === 0) {\n    return largestPrimeFactor(n / 223)\n  }\n  if (n % 227 === 0) {\n    return largestPrimeFactor(n / 227)\n  }\n  if (n % 229 === 0) {\n    return largestPrimeFactor(n / 229)\n  }\n  if (n % 233 === 0) {\n    return largestPrimeFactor(n / 233)\n  }\n  if (n % 239 === 0) {\n    return largestPrimeFactor(n / 239)\n  }\n  if (n % 241 === 0) {\n    return largestPrimeFactor(n / 241)\n  }\n  if (n % 251 === 0) {\n    return largestPrimeFactor(n / 251)\n  }\n  if (n % 257 === 0) {\n    return largestPrimeFactor(n / 257)\n  }\n  if (n % 263 === 0) {\n    return largestPrimeFactor(n / 263)\n  }\n  if (n % 269 === 0) {\n    return largestPrimeFactor(n / 269)\n  }\n  if (n % 271 === 0) {\n    return largestPrimeFactor(n / 271)\n  }", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/6", "prompt": "/* Input to this functoin is a string reprseented multiple groups for nested parentheses separated by spaces.\n  For each of the gruop, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maxuimm tow lveels of nestign while ((())) has there.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 1, "perturbed": true, "gc": "/* Input to this functoin is a string reprseented multiple groups for nested parentheses separated by spaces.\n  For each of the gruop, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maxuimm tow lveels of nestign while ((())) has there.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let stack = [];\n  let max_depth = 0;\n  let depth = 0;\n  paren_string.split(' ').forEach((item) => {\n    if (item === '(') {\n      stack.push(item);\n    } else if (item === ')') {\n      if (stack.length === 0) {\n        throw new Error('Unbalanced parentheses');\n      }\n      depth = stack.pop();\n      if (depth > max_depth) {\n        max_depth = depth;\n      }\n    }\n  });\n  return max_depth;\n};\n\nmodule.exports = parseNestedParens;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 1, "perturbed": false, "gc": "/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a tsring of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closign bracekt.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "/* brackets is a tsring of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closign bracekt.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const stack = []\n  for (let i = 0; i < brackets.length; i++) {\n    const c = brackets[i]\n    if (c === \"(\" || c === \")\") {\n      stack.push(c)\n    } else if (stack.length === 0) {\n      return false\n    } else {\n      stack.pop()\n    }\n  }\n  return stack.length === 0\n}\n\n/*\n  Given a string, return the number of brackets in the string.\n  The opening brackets must be matched by the closing brackets.\n  The opening brackets must be balanced.\n  The closing brackets must be balanced.\n  The opening brackets must be at the beginning of the string.\n  The closing brackets must be at the end of the string.\n  The opening brackets must be at the beginning of the string.\n  The closing brackets must be at the end of the string.\n\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(())\")\n  1\n  >>> bracketsCount(\"(())\")\n  1\n  >>> bracketsCount(\"(())\")\n  1\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()())\")\n  2\n  >>> bracketsCount(\"(())\")\n  2\n  >>> bracketsCount(\"()\")\n  0\n  >>> bracketsCount(\"(()", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative fo this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 1, "perturbed": true, "gc": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative fo this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = []\n  for (let i = 0; i < len; i++) {\n    d[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      d[i] += xs[j] * (j - i)\n    }\n  }\n  return d\n}\n\n/*\n  Given a list of numbers, return the sum of the numbers.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  >>> sum([1, 2, 3, 4, 5, 6])\n  21\n  >>> sum([1, 2, 3, 4, 5, 6, 7])\n  28\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8])\n  35\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  42\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  49\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  56\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  63\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  70\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  77\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  84\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  91\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  98\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  105\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  112\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  119\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  126\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  133\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  140\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  147\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  154\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  161\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  168\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  175\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  182\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  189\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])\n  196\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32])\n  203\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib numbre sequence is a sequence similar to the Fibbnaocci sequnece that's deifned as follwos:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  lPease write a function to fefciiently compute the n-th element of the fibfib number sequecne.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 1, "perturbed": true, "gc": "/*The FibFib numbre sequence is a sequence similar to the Fibbnaocci sequnece that's deifned as follwos:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  lPease write a function to fefciiently compute the n-th element of the fibfib number sequecne.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n}\n\nconst fib = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\nconst fib2 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib2(n - 1) + fib2(n - 2)\n}\n\nconst fib3 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib3(n - 1) + fib3(n - 2)\n}\n\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib4(n - 1) + fib4(n - 2)\n}\n\nconst fib5 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib5(n - 1) + fib5(n - 2)\n}\n\nconst fib6 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib6(n - 1) + fib6(n - 2)\n}\n\nconst fib7 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib7(n - 1) + fib7(n - 2)\n}\n\nconst fib8 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib8(n - 1) + fib8(n - 2)\n}\n\nconst fib9 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib9(n - 1) + fib9(n - 2)\n}\n\nconst fib10 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib10(n - 1) + fib10(n - 2)\n}\n\nconst fib11 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib11(n - 1) + fib11(n - 2)\n}\n\nconst fib12 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib12(n - 1) + fib12(n - 2)\n}\n\nconst fib13 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib13(n - 1) + fib13(n - 2)\n}\n\nconst fib14 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib14(n - 1) + fib14(n - 2)\n}\n\nconst fib15 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib15(n - 1) + fib15(n - 2)\n}\n\nconst fib16 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib16(n - 1) + fib16(n - 2)\n}\n\nconst fib17 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib17(n - 1) + fib17(n - 2)\n}\n\nconst fib18 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib18(n - 1) + fib18(n - 2)\n}\n\nconst fib19 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib19(n - 1) + fib19(n - 2)\n}\n\nconst fib20 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib20(n - 1) + fib20(n - 2)\n}\n\nconst fib21 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib21(n - 1) + fib21(n - 2)\n}\n\nconst fib22 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib22(n - 1) + fib22(n - 2)\n}\n\nconst fib23 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib23(n - 1) + fib23(n - 2)\n}\n\nconst fib24 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib24(n - 1) + fib24(n - 2)\n}\n\nconst fib25 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib25(n - 1) + fib25(n - 2)\n}\n\nconst fib26 = (n) => {\n  if (n === 0) return 0\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in tihs case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the ned of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 1, "perturbed": true, "gc": "/*Write a function vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in tihs case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the ned of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i])!== -1) {\n      count++\n    }\n  }\n  return count\n}\n\nexport default vowelsCount\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift teh digits of the itneger x, shift hte diigts rgiht by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 1, "perturbed": true, "gc": "/*Circular shift teh digits of the itneger x, shift hte diigts rgiht by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift < x.length) {\n    result = result.slice(shift);\n  } else {\n    result = result.slice(0, x.length - shift);\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of times that the string\n  appears in the string.\n  >>> count('abc')\n  3\n  >>> count('abcabc')\n  3\n  >>> count('abcabcabc')\n  3\n  >>> count('abcabcabcabc')\n  3\n  >>> count('abcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n  3\n  >>> count('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and rteurns the sum of the upper characters only'\n  ASCII ocdes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 1, "perturbed": true, "gc": "/*Task\n  Write a function that takes a string as input and rteurns the sum of the upper characters only'\n  ASCII ocdes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s[i].charCodeAt(0) - 64;\n  }\n  return sum;\n};\n\nconsole.log(digitSum(\"\"));\nconsole.log(digitSum(\"abAB\"));\nconsole.log(digitSum(\"abcCd\"));\nconsole.log(digitSum(\"helloE\"));\nconsole.log(digitSum(\"woArBld\"));\nconsole.log(digitSum(\"aAaaaXa\"));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that repreesnts a number of apples and oranges\n  that are distributed in a basket of fruit this basekt contaisn\n  apples, oranges, and mango fruits. Given the string thta repreesnts the total number of\n  the oranges and appels and an integer that represent the total number of the rufits\n  in the basket return hte nubmer of the mango frtuis in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples adn 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 1, "perturbed": true, "gc": "/*\n  In this task, you will be given a string that repreesnts a number of apples and oranges\n  that are distributed in a basket of fruit this basekt contaisn\n  apples, oranges, and mango fruits. Given the string thta repreesnts the total number of\n  the oranges and appels and an integer that represent the total number of the rufits\n  in the basket return hte nubmer of the mango frtuis in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples adn 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const appleCount = s.split(\" \").filter(x => x.includes(\"apple\")).length\n  const orangeCount = s.split(\" \").filter(x => x.includes(\"orange\")).length\n  const mangoCount = s.split(\" \").filter(x => x.includes(\"mango\")).length\n  return n - appleCount - orangeCount - mangoCount\n}\n\n/*\n  In this task, you will be given a string that repreesnts a number of apples and oranges\n  that are distributed in a basket of fruit this basekt contaisn\n  apples, oranges, and mango fruits. Given the string thta repreesnts the total number of\n  the oranges and appels and an integer that represent the total number of the rufits\n  in the basket return hte nubmer of the mango frtuis in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples adn 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const appleCount = s.split(\" \").filter(x => x.includes(\"apple\")).length\n  const orangeCount = s.split(\" \").filter(x => x.includes(\"orange\")).length\n  const mangoCount = s.split(\" \").filter(x => x.includes(\"mango\")).length\n  return n - appleCount - orangeCount - mangoCount\n}\n\n/*\n  In this task, you will be given a string that repreesnts a number of apples and oranges\n  that are distributed in a basket of fruit this basekt contaisn\n  apples, oranges, and mango fruits. Given the string thta repreesnts the total number of\n  the oranges and appels and an integer that represent the total number of the rufits\n  in the basket return hte nubmer of the mango frtuis in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples adn 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const appleCount = s.split(\" \").filter(x => x.includes(\"apple\")).length\n  const orangeCount = s.split(\" \").filter(x => x.includes(\"orange\")).length\n  const mangoCount = s.split(\" \").filter(x => x.includes(\"mango\")).length\n  return n - appleCount - orangeCount - mangoCount\n}\n\n/*\n  In this task, you will be given a string that repreesnts a number of apples and oranges\n  that are distributed in a basket of fruit this basekt contaisn\n  apples, oranges, and mango fruits. Given the string thta repreesnts the total number of\n  the oranges and appels and an integer that represent the total number of the rufits\n  in the basket return hte nubmer of the mango frtuis in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples adn 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const appleCount = s.split(\" \").filter(x => x.includes(\"apple\")).length\n  const orangeCount = s.split(\" \").filter(x => x.includes(\"orange\")).length\n  const mangoCount = s.split(\" \").filter(x => x.includes(\"mango\")).length\n  return n - appleCount - orangeCount - mangoCount\n}\n\n/*\n  In this task, you will be given a string that repreesnts a number of apples and oranges\n  that are distributed in a basket of fruit this basekt contaisn\n  apples, oranges, and mango fruits. Given the string thta repreesnts the total number of\n  the oranges and appels and an integer that represent the total number of the rufits\n  in the basket return hte nubmer of the mango frtuis in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples adn 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const appleCount = s.split(\" \").filter(x => x.includes(\"apple\")).length\n  const orangeCount = s.split(\" \").filter(x => x.includes(\"orange\")).length\n  const mangoCount = s.split(\" \").filter(x => x.includes(\"mango\")).length\n  return n - appleCount - orangeCount - mangoCount\n}\n\n/*\n  In this task", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branhc of a tree that has non-negatvie integre nodes\n  your task is to pluck one of the nodes and return it.\n  The plcuked node should be the node wtih the msallest even value.\n  If mulptile nodes with the same smallest even vlaue are found return the ndoe that has msallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even vaules or the gvien array is mepty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 1, "perturbed": true, "gc": "/*\n  \"Given an array representing a branhc of a tree that has non-negatvie integre nodes\n  your task is to pluck one of the nodes and return it.\n  The plcuked node should be the node wtih the msallest even value.\n  If mulptile nodes with the same smallest even vlaue are found return the ndoe that has msallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even vaules or the gvien array is mepty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  result.push([min, min_index]);\n  return result;\n};\n\nconst pluck2 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  result.push([min, min_index]);\n  return result;\n};\n\nconst pluck3 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  result.push([min, min_index]);\n  return result;\n};\n\nconst pluck4 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  result.push([min, min_index]);\n  return result;\n};\n\nconst pluck5 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  result.push([min, min_index]);\n  return result;\n};\n\nconst pluck6 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  result.push([min, min_index]);\n  return result;\n};\n\nconst pluck7 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  result.push([min, min_index]);\n  return result;\n};\n\nconst pluck8 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  result.push([min, min_index]);\n  return result;\n};\n\nconst pluck9 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  result.push([min, min_index]);\n  return result;\n};\n\nconst pluck10 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Rteurn the gretaest itneger that is greater than\n  zero, and has a frequency gertaer than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 1, "perturbed": true, "gc": "/*\n  You are given a non-empty list of positive integers. Rteurn the gretaest itneger that is greater than\n  zero, and has a frequency gertaer than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let i = 0\n  let j = lst.length - 1\n  let mid = Math.floor((i + j) / 2)\n  while (i <= j) {\n    if (lst[mid] < lst[i]) {\n      i = mid + 1\n    } else if (lst[mid] > lst[i]) {\n      j = mid - 1\n    } else {\n      return lst[mid]\n    }\n    mid = Math.floor((i + j) / 2)\n  }\n  return -1\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1]))\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]))\nconsole.log(search([5, 5, 4, 4, 4]))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only ofr ones thta contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 1, "perturbed": true, "gc": "/* Filter an input list of strings only ofr ones thta contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring2 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring3 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring4 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring5 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring6 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring7 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring8 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring9 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring10 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring11 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring12 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring13 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstring14 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'c", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Gievn list of nitegers, return list in strange order.\n  Srtnage sorting, is when you start with the minmium vaule,\n  then maximum fo the remiaingn integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 1, "perturbed": true, "gc": "/*\n  Gievn list of nitegers, return list in strange order.\n  Srtnage sorting, is when you start with the minmium vaule,\n  then maximum fo the remiaingn integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  if (lst.length === 0) {\n    return lst\n  }\n  const sorted = lst.slice()\n  sorted.sort((a, b) => {\n    if (a < b) {\n      return -1\n    }\n    if (a > b) {\n      return 1\n    }\n    return 0\n  })\n  return sorted\n}\n\nexport default strangeSortList\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a trinagle. Return the area of\n  the triangle rounded to 2 dceimal points if the three sides from a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "/*\n  Given the lengths of the three sides of a trinagle. Return the area of\n  the triangle rounded to 2 dceimal points if the three sides from a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea2 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea3 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea4 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea5 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea6 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea7 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea8 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea9 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea10 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea11 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea12 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea13 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea14 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea15 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea16 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea17 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea18 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea19 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea20 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea21 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea22 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea23 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2);\n};\n\nconst triangleArea24 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns treu if the object q will fly, and false otherwise.\n  The object q will lfy if it's balanced (it is a palindrmoic list) and the sum of its elements is less than or qeual the maxmium possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 1, "perturbed": true, "gc": "/*\n  Write a function that returns treu if the object q will fly, and false otherwise.\n  The object q will lfy if it's balanced (it is a palindrmoic list) and the sum of its elements is less than or qeual the maxmium possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length === 1) {\n    return q[0] <= w;\n  }\n  const max = q.reduce((a, b) => a + b);\n  return q.reduce((a, b) => a + b) <= w && q.every((x, i) => x <= q[i + 1]);\n};\n\nconsole.log(willItFly([3, 2, 3], 9));\nconsole.log(willItFly([3, 2, 3], 5));\nconsole.log(willItFly([3, 2, 3], 1));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/73", "prompt": "/*\n  Gievn na array arr of integers, find the minimum number of elemtens tath\n  need to be changed to make hte array palindromic. A palindromic array is an array that\n  is read the same backwards nad forwrads. In one change, you can change one element to any ohter element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 1, "perturbed": true, "gc": "/*\n  Gievn na array arr of integers, find the minimum number of elemtens tath\n  need to be changed to make hte array palindromic. A palindromic array is an array that\n  is read the same backwards nad forwrads. In one change, you can change one element to any ohter element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = arr.length;\n  for (let i = 0; i < arr.length; i++) {\n    let j = arr.length - 1 - i;\n    if (arr[i]!== arr[j]) {\n      min = Math.min(min, j - i + 1);\n    }\n  }\n  return min;\n};\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function taht accepts two lists of stirnsg and returns teh list that has\n  total number of chasr in teh all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 1, "perturbed": true, "gc": "/*\n  Write a function taht accepts two lists of stirnsg and returns teh list that has\n  total number of chasr in teh all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length;\n  const len2 = lst2.length;\n  const len = Math.min(len1, len2);\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i]);\n    }\n  }\n  if (len1 > len2) {\n    for (let i = len; i < len1; i++) {\n      result.push(lst1[i]);\n    }\n  } else if (len2 > len1) {\n    for (let i = len; i < len2; i++) {\n      result.push(lst2[i]);\n    }\n  }\n  return result;\n};\n\nconst totalMatchTest = [\n  [],\n  ['hi', 'admin'],\n  ['hi', 'hi', 'admin', 'project'],\n  ['4'],\n];\n\ndescribe('totalMatch', () => {\n  it('should return an empty list when the two lists are empty', () => {\n    expect(totalMatch([], [])).toEqual([]);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['hi', 'admin'], ['hI', 'Hi'])).toEqual(['hI', 'Hi']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])).toEqual(['hi', 'admin']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first list when the two lists have the same number of elements', () => {\n    expect(totalMatch(['4'], ['1', '2', '3', '4', '5'])).toEqual(['4']);\n  });\n  it('should return the first", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/75", "prompt": "/*Wirte a function that returns true if the given number is the multiplication of 3 prime nubmers\n  and false otherwise.\n  Knowing that (a) is less thne 010.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 1, "perturbed": true, "gc": "/*Wirte a function that returns true if the given number is the multiplication of 3 prime nubmers\n  and false otherwise.\n  Knowing that (a) is less thne 010.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = 0;\n  let m = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a1 = 0;\n  let a2 = 0;\n  let a3 = 0;\n  let a4 = 0;\n  let a5 = 0;\n  let a6 = 0;\n  let a7 = 0;\n  let a8 = 0;\n  let a9 = 0;\n  let a10 = 0;\n  let a11 = 0;\n  let a12 = 0;\n  let a13 = 0;\n  let a14 = 0;\n  let a15 = 0;\n  let a16 = 0;\n  let a17 = 0;\n  let a18 = 0;\n  let a19 = 0;\n  let a20 = 0;\n  let a21 = 0;\n  let a22 = 0;\n  let a23 = 0;\n  let a24 = 0;\n  let a25 = 0;\n  let a26 = 0;\n  let a27 = 0;\n  let a28 = 0;\n  let a29 = 0;\n  let a30 = 0;\n  let a31 = 0;\n  let a32 = 0;\n  let a33 = 0;\n  let a34 = 0;\n  let a35 = 0;\n  let a36 = 0;\n  let a37 = 0;\n  let a38 = 0;\n  let a39 = 0;\n  let a40 = 0;\n  let a41 = 0;\n  let a42 = 0;\n  let a43 = 0;\n  let a44 = 0;\n  let a45 = 0;\n  let a46 = 0;\n  let a47 = 0;\n  let a48 = 0;\n  let a49 = 0;\n  let a50 = 0;\n  let a51 = 0;\n  let a52 = 0;\n  let a53 = 0;\n  let a54 = 0;\n  let a55 = 0;\n  let a56 = 0;\n  let a57 = 0;\n  let a58 = 0;\n  let a59 = 0;\n  let a60 = 0;\n  let a61 = 0;\n  let a62 = 0;\n  let a63 = 0;\n  let a64 = 0;\n  let a65 = 0;\n  let a66 = 0;\n  let a67 = 0;\n  let a68 = 0;\n  let a69 = 0;\n  let a70 = 0;\n  let a71 = 0;\n  let a72 = 0;\n  let a73 = 0;\n  let a74 = 0;\n  let a75 = 0;\n  let a76 = 0;\n  let a77 = 0;\n  let a78 = 0;\n  let a79 = 0;\n  let a80 = 0;\n  let a81 = 0;\n  let a82 = 0;\n  let a83 = 0;\n  let a84 = 0;\n  let a85 = 0;\n  let a86 = 0;\n  let a87 = 0;\n  let a88 = 0;\n  let a89 = 0;\n  let a90 = 0;\n  let a91 = 0;\n  let a92 = 0;\n  let a93 = 0;\n  let a94 = 0;\n  let a95 = 0;\n  let a96 = 0;\n  let a97 = 0;\n  let a98 = 0;\n  let a99 = 0;\n  let a100 = 0;\n  let a101 = 0;\n  let a102 = 0;\n  let a103 = 0;\n  let a104 = 0;\n  let a105 = 0;\n  let a106 = 0;\n  let a107 = 0;\n  let a108 = 0;\n  let a109 = 0;\n  let a110 = 0;\n  let a111 = 0;\n  let a112 = 0;\n  let a113 = 0;\n  let a114 = 0;\n  let a115 = 0;\n  let a116 = 0;\n  let a117 = 0;\n  let a118 = 0;\n  let a119 = 0;\n  let a120 = 0;\n  let a121 = 0;\n  let a122 = 0;\n  let a123 = 0;\n  let a124 = 0;\n  let a125 = 0;\n  let a126 = 0;\n  let a127 = 0;\n  let a128 = 0;\n  let a129 = 0;\n  let a130 = 0;\n  let a131 = 0;\n  let a132 = 0;\n  let a133 = 0;\n  let a134 = 0;\n  let a135 = 0;\n  let a136 = 0;\n  let a137 = 0;\n  let a138 = 0;\n  let a139 = 0;\n  let a140 = 0;\n  let a141 = 0;\n  let a142 = 0;\n  let a143 = 0;\n  let a144 = 0;\n  let a145 = 0;\n  let a146 = 0;\n  let a147 = 0;\n  let a148 = 0;\n  let a149 = 0;\n  let a150 = 0;\n  let a151 = 0;\n  let a152 = 0;\n  let a153 = 0;\n  let a154 = 0;\n  let a155 = 0;\n  let a156 = 0;\n  let a157 = 0;\n  let a158 = 0;\n  let a159 = 0;\n  let a160 = 0;\n  let a161 = 0;\n  let a162 = 0;\n  let a163 = 0;\n  let a164 = 0;\n  let a165 = 0;\n  let a166 = 0;\n  let a167 = 0;\n  let a168", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a fnuction that returns true if a number x is a simlpe\n  power fo n and false in ohter cases.\n  x is a smiple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 1, "perturbed": true, "gc": "/*Your task is to write a fnuction that returns true if a number x is a simlpe\n  power fo n and false in ohter cases.\n  x is a smiple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n === 1) return x === 1;\n  if (n === 2) return x === 2;\n  if (n === 3) return x === 4;\n  if (n === 4) return x === 8;\n  if (n === 5) return x === 16;\n  if (n === 6) return x === 32;\n  if (n === 7) return x === 64;\n  if (n === 8) return x === 128;\n  if (n === 9) return x === 256;\n  if (n === 10) return x === 512;\n  if (n === 11) return x === 1024;\n  if (n === 12) return x === 2048;\n  if (n === 13) return x === 4096;\n  if (n === 14) return x === 8192;\n  if (n === 15) return x === 16384;\n  if (n === 16) return x === 32768;\n  if (n === 17) return x === 65536;\n  if (n === 18) return x === 131072;\n  if (n === 19) return x === 262144;\n  if (n === 20) return x === 524288;\n  if (n === 21) return x === 1048576;\n  if (n === 22) return x === 2097152;\n  if (n === 23) return x === 4194304;\n  if (n === 24) return x === 8388608;\n  if (n === 25) return x === 16777216;\n  if (n === 26) return x === 33554432;\n  if (n === 27) return x === 67108864;\n  if (n === 28) return x === 134217728;\n  if (n === 29) return x === 268435456;\n  if (n === 30) return x === 536870912;\n  if (n === 31) return x === 1073741824;\n  if (n === 32) return x === 2147483648;\n  if (n === 33) return x === 4294967296;\n  if (n === 34) return x === 8589934592;\n  if (n === 35) return x === 17179869184;\n  if (n === 36) return x === 34359738368;\n  if (n === 37) return x === 68719476736;\n  if (n === 38) return x === 137438953472;\n  if (n === 39) return x === 274877906944;\n  if (n === 40) return x === 549755813888;\n  if (n === 41) return x === 1099511627776;\n  if (n === 42) return x === 2199023255552;\n  if (n === 43) return x === 4294967295;\n  if (n === 44) return x === 8589934591;\n  if (n === 45) return x === 17179869184;\n  if (n === 46) return x === 34359738368;\n  if (n === 47) return x === 68719476736;\n  if (n === 48) return x === 137438953472;\n  if (n === 49) return x === 274877906944;\n  if (n === 50) return x === 549755813888;\n  if (n === 51) return x === 1099511627776;\n  if (n === 52) return x === 2199023255552;\n  if (n === 53) return x === 4294967295;\n  if (n === 54) return x === 8589934591;\n  if (n === 55) return x === 17179869184;\n  if (n === 56) return x === 34359738368;\n  if (n === 57) return x === 68719476736;\n  if (n === 58) return x === 137438953472;\n  if (n === 59) return x === 274877906944;\n  if (n === 60) return x === 549755813888;\n  if (n === 61) return x === 1099511627776;\n  if (n === 62) return x === 2199023255552;\n  if (n === 63) return x === 4294967295;\n  if (n === 64) return x === 8589934591;\n  if (n === 65) return x === 17179869184;\n  if (n === 66) return x === 34359738368;\n  if (n === 67) return x === 68719476736;\n  if (n === 68) return x === 137438953472;\n  if (n === 69) return x === 274877906944;\n  if (n === 70) return x === 549755813888;\n  if (n === 71) return x === 1099511627776;\n  if (n === 72) return x === 2199023255552;\n  if (n === 73) return x === 4294967295;\n  if (n === 74) return x === 8589934591;\n  if (n === 75) return x === 17179869184;\n  if (n === 76) return x === 34359738368;\n  if (n === 77) return x === 68719476736;\n  if (n === 78) return x === 137438953472;\n  if (n === 79) return x === 274877906944;\n  if (n === 80) return x === 549755813888;\n  if (n === 81) return x === 1099511627776;\n  if (n === 82) return x === 2199023255552;\n  if (n === 83) return x === 4294967295;\n  if (n === 84) return x === 8589934591;\n  if (n === 85) return x === 17179869184;\n  if (n === 86) return x === 34359738368", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function htat taeks an integer a and reutrns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valdi.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 1, "perturbed": true, "gc": "/*\n  Write a function htat taeks an integer a and reutrns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valdi.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) {\n    return true\n  }\n  if (a === 1) {\n    return true\n  }\n  if (a === 2) {\n    return true\n  }\n  if (a === 3) {\n    return true\n  }\n  if (a === 4) {\n    return true\n  }\n  if (a === 5) {\n    return true\n  }\n  if (a === 6) {\n    return true\n  }\n  if (a === 7) {\n    return true\n  }\n  if (a === 8) {\n    return true\n  }\n  if (a === 9) {\n    return true\n  }\n  if (a === 10) {\n    return true\n  }\n  if (a === 11) {\n    return true\n  }\n  if (a === 12) {\n    return true\n  }\n  if (a === 13) {\n    return true\n  }\n  if (a === 14) {\n    return true\n  }\n  if (a === 15) {\n    return true\n  }\n  if (a === 16) {\n    return true\n  }\n  if (a === 17) {\n    return true\n  }\n  if (a === 18) {\n    return true\n  }\n  if (a === 19) {\n    return true\n  }\n  if (a === 20) {\n    return true\n  }\n  if (a === 21) {\n    return true\n  }\n  if (a === 22) {\n    return true\n  }\n  if (a === 23) {\n    return true\n  }\n  if (a === 24) {\n    return true\n  }\n  if (a === 25) {\n    return true\n  }\n  if (a === 26) {\n    return true\n  }\n  if (a === 27) {\n    return true\n  }\n  if (a === 28) {\n    return true\n  }\n  if (a === 29) {\n    return true\n  }\n  if (a === 30) {\n    return true\n  }\n  if (a === 31) {\n    return true\n  }\n  if (a === 32) {\n    return true\n  }\n  if (a === 33) {\n    return true\n  }\n  if (a === 34) {\n    return true\n  }\n  if (a === 35) {\n    return true\n  }\n  if (a === 36) {\n    return true\n  }\n  if (a === 37) {\n    return true\n  }\n  if (a === 38) {\n    return true\n  }\n  if (a === 39) {\n    return true\n  }\n  if (a === 40) {\n    return true\n  }\n  if (a === 41) {\n    return true\n  }\n  if (a === 42) {\n    return true\n  }\n  if (a === 43) {\n    return true\n  }\n  if (a === 44) {\n    return true\n  }\n  if (a === 45) {\n    return true\n  }\n  if (a === 46) {\n    return true\n  }\n  if (a === 47) {\n    return true\n  }\n  if (a === 48) {\n    return true\n  }\n  if (a === 49) {\n    return true\n  }\n  if (a === 50) {\n    return true\n  }\n  if (a === 51) {\n    return true\n  }\n  if (a === 52) {\n    return true\n  }\n  if (a === 53) {\n    return true\n  }\n  if (a === 54) {\n    return true\n  }\n  if (a === 55) {\n    return true\n  }\n  if (a === 56) {\n    return true\n  }\n  if (a === 57) {\n    return true\n  }\n  if (a === 58) {\n    return true\n  }\n  if (a === 59) {\n    return true\n  }\n  if (a === 60) {\n    return true\n  }\n  if (a === 61) {\n    return true\n  }\n  if (a === 62) {\n    return true\n  }\n  if (a === 63) {\n    return true\n  }\n  if (a === 64) {\n    return true\n  }\n  if (a === 65) {\n    return true\n  }\n  if (a === 66) {\n    return true\n  }\n  if (a === 67) {\n    return true\n  }\n  if (a === 68) {\n    return true\n  }\n  if (a === 69) {\n    return true\n  }\n  if (a === 70) {\n    return true\n  }\n  if (a === 71) {\n    return true\n  }\n  if (a === 72) {\n    return true\n  }\n  if (a === 73) {\n    return true\n  }\n  if (a === 74) {\n    return true\n  }\n  if (a === 75) {\n    return true\n  }\n  if (a === 76) {\n    return true\n  }\n  if (a === 77) {\n    return true\n  }\n  if (a === 78) {\n    return true\n  }\n  if (a === 79) {\n    return true\n  }\n  if (a === 80) {\n    return true\n  }\n  if (a === 81) {\n    return true\n  }\n  if (a === 82) {\n    return true\n  }\n  if (a === 83) {\n    return true\n  }\n  if (a === 84) {\n    return true\n  }\n  if (a === 85) {\n    return true\n  }\n  if (a === 86) {\n    return true\n  }\n  if (a === 87) {\n    return true\n  }\n  if", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasekd to write a function that recieves\n  a hexadeciaml number as a string adn counts teh number of hexadecmial\n  digits that aer primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natuarl numbers).\n  eHxadecimal digtis are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to deetrmine a numebr of the following digist: 2=== 3=== 5=== 7===\n  B (=deciaml 11)=== D (=decimal 13).\n  Note: you may assume hte niput si always correct or empty string===\n  and sybmols A===B===C===D===E===F are always upprecase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 1, "perturbed": true, "gc": "/*You have been tasekd to write a function that recieves\n  a hexadeciaml number as a string adn counts teh number of hexadecmial\n  digits that aer primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natuarl numbers).\n  eHxadecimal digtis are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to deetrmine a numebr of the following digist: 2=== 3=== 5=== 7===\n  B (=deciaml 11)=== D (=decimal 13).\n  Note: you may assume hte niput si always correct or empty string===\n  and sybmols A===B===C===D===E===F are always upprecase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    let digit = num[i];\n    if (digit === 'A') {\n      digit = '0';\n    } else if (digit === 'B') {\n      digit = '1';\n    } else if (digit === 'C') {\n      digit = '2';\n    } else if (digit === 'D') {\n      digit = '3';\n    } else if (digit === 'E') {\n      digit = '4';\n    } else if (digit === 'F') {\n      digit = '5';\n    }\n    result += parseInt(digit, 16);\n  }\n  return result;\n};\n\nconst isPrime = (num) => {\n  if (num === 1) {\n    return false;\n  }\n  if (num === 2) {\n    return true;\n  }\n  if (num % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeNumber = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumber = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHex = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey2 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey3 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey4 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey5 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey6 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey7 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey8 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey9 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey10 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeNumberByHexKey11 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be gvien a numebr in decimal form and your task is to ocnvert it to\n  binary format. The function should return a tsring, with each chraacetr representing a binary\n  number. Each cahracetr in the string will be '0' or '1'.\n\n  There will be an extra couple of hcaracters 'db' at teh beginnnig and at the end of the string.\n  Teh extra charactesr are three to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 1, "perturbed": true, "gc": "/*You will be gvien a numebr in decimal form and your task is to ocnvert it to\n  binary format. The function should return a tsring, with each chraacetr representing a binary\n  number. Each cahracetr in the string will be '0' or '1'.\n\n  There will be an extra couple of hcaracters 'db' at teh beginnnig and at the end of the string.\n  Teh extra charactesr are three to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let binaryLength = 0;\n  let decimalLength = 0;\n  let decimalDigits = 0;\n  let decimalDigitsLength = 0;\n  let decimalDigitsLengthLength = 0;\n  let decimalDigitsLengthLength = 0;\n  let decimalDigitsLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let decimalDigitsLengthLengthLengthLengthLengthLengthLengthLengthLength =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given list fo integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Emtpy sum should be equal to 0 and mepty rpoduct should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 1, "perturbed": true, "gc": "/* For a given list fo integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Emtpy sum should be equal to 0 and mepty rpoduct should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0)\n  const product = numbers.reduce((acc, num) => acc * num, 1)\n  return sum, product\n}\n\n/*\n  Given a list of strings, return a list of strings where each string is a permutation of the original.\n  >>> permute(\"abc\")\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"\")\n  []\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute(\"a\")\n  ['a', 'aa', 'aaa']\n  >>> permute", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given a tsring s.\n  Your task is to check if the strign is happy or not.\n  A string is happy if ist length is at least 3 adn every 3 consectuive letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 1, "perturbed": true, "gc": "/*You are given a tsring s.\n  Your task is to check if the strign is happy or not.\n  A string is happy if ist length is at least 3 adn every 3 consectuive letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  let prev = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === s[i + 1]) {\n      count++;\n      if (count === 3) {\n        if (s[i + 2] === s[i + 3]) {\n          return false;\n        }\n      }\n    } else {\n      count = 0;\n    }\n    i++;\n  }\n  return true;\n};\n\nconsole.log(isHappy('a'));\nconsole.log(isHappy('aa'));\nconsole.log(isHappy('abcd'));\nconsole.log(isHappy('aabb'));\nconsole.log(isHappy('adb'));\nconsole.log(isHappy('xyy'));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of hte semetser and the teacher has to give teh grades\n  to students. Teh teacher has been making her own algoritmh for grading.\n  The only problem is, she has lost the code she uesd for grading.\n  She has given you a list of GPAs for some sutdents and you have to wirte\n  a funtcoin taht can uotput a list of lettre grades uinsg the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 1, "perturbed": true, "gc": "/*It is the last week of hte semetser and the teacher has to give teh grades\n  to students. Teh teacher has been making her own algoritmh for grading.\n  The only problem is, she has lost the code she uesd for grading.\n  She has given you a list of GPAs for some sutdents and you have to wirte\n  a funtcoin taht can uotput a list of lettre grades uinsg the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const sortedGrades = grades.sort((a, b) => a - b);\n  const letterGrades = [];\n  for (let i = 0; i < sortedGrades.length; i++) {\n    const grade = sortedGrades[i];\n    const letterGrade = grade.toFixed(1);\n    if (grade < 3.7) {\n      letterGrade = 'A+';\n    } else if (grade < 3.3) {\n      letterGrade = 'A';\n    } else if (grade < 3.0) {\n      letterGrade = 'A-';\n    } else if (grade < 2.7) {\n      letterGrade = 'B+';\n    } else if (grade < 2.3) {\n      letterGrade = 'B';\n    } else if (grade < 2.0) {\n      letterGrade = 'B-';\n    } else if (grade < 1.7) {\n      letterGrade = 'C+';\n    } else if (grade < 1.3) {\n      letterGrade = 'C';\n    } else if (grade < 1.0) {\n      letterGrade = 'C-';\n    } else if (grade < 0.7) {\n      letterGrade = 'D+';\n    } else if (grade < 0.0) {\n      letterGrade = 'D';\n    } else {\n      letterGrade = 'D-';\n    }\n    letterGrades.push(letterGrade);\n  }\n  return letterGrades;\n};\n\nmodule.exports = numericalLetterGrade;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a functoin that takes a string and returns true if the string\n  length is a prime numbre or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 1, "perturbed": true, "gc": "/*Write a functoin that takes a string and returns true if the string\n  length is a prime numbre or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let isPrime = true;\n  for (let i = 2; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i - 1)) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\nconst isPrime = (number) => {\n  let i = 2;\n  while (i < number) {\n    if (number % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst primeNumbers = (number) => {\n  let primeNumbers = [];\n  let i = 2;\n  while (i < number) {\n    if (primeLength(i.toString())) {\n      primeNumbers.push(i);\n    }\n    i++;\n  }\n  return primeNumbers;\n};\n\nconst primeFactors = (number) => {\n  let primeNumbers = primeNumbers(number);\n  let primeFactors = [];\n  for (let i = 0; i < primeNumbers.length; i++) {\n    let prime = primeNumbers[i];\n    let primeLength = prime.toString().length;\n    let primeFactor = number / prime;\n    let primeFactorLength = primeFactor.toString().length;\n    while (primeFactorLength < primeLength) {\n      primeFactor = primeFactor * prime;\n      primeFactorLength = primeFactor.toString().length;\n    }\n    if (primeFactor === 1) {\n      primeFactors.push(prime);\n    }\n  }\n  return primeFactors;\n};\n\nconst primeFactorsOf = (number) => {\n  let primeFactors = primeFactors(number);\n  let primeFactorsOf = [];\n  for (let i = 0; i < primeFactors.length; i++) {\n    let primeFactor = primeFactors[i];\n    let primeFactorOf = number / primeFactor;\n    while (primeFactorOf!== 1) {\n      primeFactorOf = primeFactorOf * primeFactor;\n    }\n    primeFactorsOf.push(primeFactorOf);\n  }\n  return primeFactorsOf;\n};\n\nconst primeFactorsOf2 = (number) => {\n  let primeFactors = primeFactors(number);\n  let primeFactorsOf = [];\n  for (let i = 0; i < primeFactors.length; i++) {\n    let primeFactor = primeFactors[i];\n    let primeFactorOf = number / primeFactor;\n    while (primeFactorOf!== 1) {\n      primeFactorOf = primeFactorOf * primeFactor;\n    }\n    primeFactorsOf.push(primeFactorOf);\n  }\n  return primeFactorsOf;\n};\n\nconst primeFactorsOf3 = (number) => {\n  let primeFactors = primeFactors(number);\n  let primeFactorsOf = [];\n  for (let i = 0; i < primeFactors.length; i++) {\n    let primeFactor = primeFactors[i];\n    let primeFactorOf = number / primeFactor;\n    while (primeFactorOf!== 1) {\n      primeFactorOf = primeFactorOf * primeFactor;\n    }\n    primeFactorsOf.push(primeFactorOf);\n  }\n  return primeFactorsOf;\n};\n\nconst primeFactorsOf4 = (number) => {\n  let primeFactors = primeFactors(number);\n  let primeFactorsOf = [];\n  for (let i = 0; i < primeFactors.length; i++) {\n    let primeFactor = primeFactors[i];\n    let primeFactorOf = number / primeFactor;\n    while (primeFactorOf!== 1) {\n      primeFactorOf = primeFactorOf * primeFactor;\n    }\n    primeFactorsOf.push(primeFactorOf);\n  }\n  return primeFactorsOf;\n};\n\nconst primeFactorsOf5 = (number) => {\n  let primeFactors = primeFactors(number);\n  let primeFactorsOf = [];\n  for (let i = 0; i < primeFactors.length; i++) {\n    let primeFactor = primeFactors[i];\n    let primeFactorOf = number / primeFactor;\n    while (primeFactorOf!== 1) {\n      primeFactorOf = primeFactorOf * primeFactor;\n    }\n    primeFactorsOf.push(primeFactorOf);\n  }\n  return primeFactorsOf;\n};\n\nconst primeFactorsOf6 = (number) => {\n  let primeFactors = primeFactors(number);\n  let primeFactorsOf = [];\n  for (let i = 0; i < primeFactors.length; i++) {\n    let primeFactor = primeFactors[i];\n    let primeFactorOf = number / primeFactor;\n    while (primeFactorOf!== 1) {\n      primeFactorOf = primeFactorOf * primeFactor;\n    }\n    primeFactorsOf.push(primeFactorOf);\n  }\n  return primeFactorsOf;\n};\n\nconst primeFactorsOf7 = (number) => {\n  let primeFactors = primeFactors(number);\n  let primeFactorsOf = [];\n  for (let i = 0; i < primeFactors.length; i++) {\n    let primeFactor = primeFactors[i];\n    let primeFactorOf = number / primeFactor;\n    while (primeFactorOf!== 1) {\n      primeFactorOf = primeFactorOf * primeFactor;\n    }\n    primeFactorsOf.push(primeFactorOf);\n  }\n  return primeFactorsOf;\n};\n\nconst primeFactorsOf8 = (number) => {\n  let primeFactors = primeFactors(number);\n  let primeFactorsOf = [];\n  for (let i = 0; i < primeFactors.length; i++) {\n    let primeFactor = primeFactors[i];\n    let primeFactorOf = number / primeFactor;\n    while (primeFactorOf!== 1) {\n      primeFactorOf = primeFactorOf * primeFactor;\n    }\n    primeFactorsOf.push(primeFactorOf);\n  }\n  return primeFactorsOf;\n};\n\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/83", "prompt": "/*\n  iGven a postiive nietger n, return the ocutn fo the numbers of n-digit\n  poistive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 1, "perturbed": true, "gc": "/*\n  iGven a postiive nietger n, return the ocutn fo the numbers of n-digit\n  poistive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds2 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds3 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds4 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds5 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds6 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds7 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds8 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds9 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds10 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds11 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds12 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds13 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds14 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds15 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds16 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds17 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds18 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds19 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds20 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds21 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds22 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}\n\nconst startsOneEnds23 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr.filter((x) => x % 10 === 1)\n}", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a positvie integer N, return teh total sum fo its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*Given a positvie integer N, return teh total sum fo its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i > 0; i--) {\n    sum += N % 2;\n    N = N / 2;\n  }\n  return sum;\n};\n\nconsole.log(solve(1000));\nconsole.log(solve(150));\nconsole.log(solve(147));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": false, "gc": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n    let result = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (i % 2 === 1) {\n            result += lst[i];\n        }\n    }\n    return result;\n};\n\nconsole.log(add([4, 2, 6, 7]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wrtie a fnuction that takes a string and returns an ordered versino of it.\n  Ordered evsrion of stirng, is a string where all words (separated by spaec)\n  aer replaced by a new wrod where all the characters arranged in\n  acsending order based on ascii valeu.\n  Note: Yuo should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 1, "perturbed": true, "gc": "/*\n  Wrtie a fnuction that takes a string and returns an ordered versino of it.\n  Ordered evsrion of stirng, is a string where all words (separated by spaec)\n  aer replaced by a new wrod where all the characters arranged in\n  acsending order based on ascii valeu.\n  Note: Yuo should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      let ascii = char.charCodeAt(0)\n      if (ascii >= 65 && ascii <= 90) {\n        newWord += char\n      } else if (ascii >= 97 && ascii <= 122) {\n        newWord += char.toUpperCase()\n      } else {\n        newWord += char.toLowerCase()\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst shuffle = (s) => {\n  let words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      let ascii = char.charCodeAt(0)\n      if (ascii >= 65 && ascii <= 90) {\n        newWord += char\n      } else if (ascii >= 97 && ascii <= 122) {\n        newWord += char.toUpperCase()\n      } else {\n        newWord += char.toLowerCase()\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst shuffle2 = (s) => {\n  let words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      let ascii = char.charCodeAt(0)\n      if (ascii >= 65 && ascii <= 90) {\n        newWord += char\n      } else if (ascii >= 97 && ascii <= 122) {\n        newWord += char.toUpperCase()\n      } else {\n        newWord += char.toLowerCase()\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst shuffle3 = (s) => {\n  let words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      let ascii = char.charCodeAt(0)\n      if (ascii >= 65 && ascii <= 90) {\n        newWord += char\n      } else if (ascii >= 97 && ascii <= 122) {\n        newWord += char.toUpperCase()\n      } else {\n        newWord += char.toLowerCase()\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst shuffle4 = (s) => {\n  let words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      let ascii = char.charCodeAt(0)\n      if (ascii >= 65 && ascii <= 90) {\n        newWord += char\n      } else if (ascii >= 97 && ascii <= 122) {\n        newWord += char.toUpperCase()\n      } else {\n        newWord += char.toLowerCase()\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst shuffle5 = (s) => {\n  let words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      let ascii = char.charCodeAt(0)\n      if (ascii >= 65 && ascii <= 90) {\n        newWord += char\n      } else if (ascii >= 97 && ascii <= 122) {\n        newWord += char.toUpperCase()\n      } else {\n        newWord += char.toLowerCase()\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst shuffle6 = (s) => {\n  let words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      let ascii = char.charCodeAt(0)\n      if (ascii >= 65 && ascii <= 90) {\n        newWord += char\n      } else if (ascii >= 97 && ascii <= 122) {\n        newWord += char.to", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimnesional data, as a nested lists,\n  which is similar to matirx, howveer, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and itneegr x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordniate - (row, coulmns), starting with 0.\n  Sort cooridntaes niitially by orws in ascending ordre.\n  Also, sort coordinaets of the row by columns in descending roder.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 1, "perturbed": true, "gc": "/*\n  You are given a 2 dimnesional data, as a nested lists,\n  which is similar to matirx, howveer, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and itneegr x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordniate - (row, coulmns), starting with 0.\n  Sort cooridntaes niitially by orws in ascending ordre.\n  Also, sort coordinaets of the row by columns in descending roder.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const lstLength = lst.length\n  const lstLengthX = lst[0].length\n  const rowLength = lstLengthX\n  const rowLengthX = lst[0].length\n  const row = []\n  const rowX = []\n  const rowXLength = rowLengthX\n  const rowXLengthX = rowLengthX\n  const rowXLengthX2 = rowLengthX\n  const rowXLengthX3 = rowLengthX\n  const rowXLengthX4 = rowLengthX\n  const rowXLengthX5 = rowLengthX\n  const rowXLengthX6 = rowLengthX\n  const rowXLengthX7 = rowLengthX\n  const rowXLengthX8 = rowLengthX\n  const rowXLengthX9 = rowLengthX\n  const rowXLengthX10 = rowLengthX\n  const rowXLengthX11 = rowLengthX\n  const rowXLengthX12 = rowLengthX\n  const rowXLengthX13 = rowLengthX\n  const rowXLengthX14 = rowLengthX\n  const rowXLengthX15 = rowLengthX\n  const rowXLengthX16 = rowLengthX\n  const rowXLengthX17 = rowLengthX\n  const rowXLengthX18 = rowLengthX\n  const rowXLengthX19 = rowLengthX\n  const rowXLengthX20 = rowLengthX\n  const rowXLengthX21 = rowLengthX\n  const rowXLengthX22 = rowLengthX\n  const rowXLengthX23 = rowLengthX\n  const rowXLengthX24 = rowLengthX\n  const rowXLengthX25 = rowLengthX\n  const rowXLengthX26 = rowLengthX\n  const rowXLengthX27 = rowLengthX\n  const rowXLengthX28 = rowLengthX\n  const rowXLengthX29 = rowLengthX\n  const rowXLengthX30 = rowLengthX\n  const rowXLengthX31 = rowLengthX\n  const rowXLengthX32 = rowLengthX\n  const rowXLengthX33 = rowLengthX\n  const rowXLengthX34 = rowLengthX\n  const rowXLengthX35 = rowLengthX\n  const rowXLengthX36 = rowLengthX\n  const rowXLengthX37 = rowLengthX\n  const rowXLengthX38 = rowLengthX\n  const rowXLengthX39 = rowLengthX\n  const rowXLengthX40 = rowLengthX\n  const rowXLengthX41 = rowLengthX\n  const rowXLengthX42 = rowLengthX\n  const rowXLengthX43 = rowLengthX\n  const rowXLengthX44 = rowLengthX\n  const rowXLengthX45 = rowLengthX\n  const rowXLengthX46 = rowLengthX\n  const rowXLengthX47 = rowLengthX\n  const rowXLengthX48 = rowLengthX\n  const rowXLengthX49 = rowLengthX\n  const rowXLengthX50 = rowLengthX\n  const rowXLengthX51 = rowLengthX\n  const rowXLengthX52 = rowLengthX\n  const rowXLengthX53 = rowLengthX\n  const rowXLengthX54 = rowLengthX\n  const rowXLengthX55 = rowLengthX\n  const rowXLengthX56 = rowLengthX\n  const rowXLengthX57 = rowLengthX\n  const rowXLengthX58 = rowLengthX\n  const rowXLengthX59 = rowLengthX\n  const rowXLengthX60 = rowLengthX\n  const rowXLengthX61 = rowLengthX\n  const rowXLengthX62 = rowLengthX\n  const rowXLengthX63 = rowLengthX\n  const rowXLengthX64 = rowLengthX\n  const rowXLengthX65 = rowLengthX\n  const rowXLengthX66 = rowLengthX\n  const rowXLengthX67 = rowLengthX\n  const rowXLengthX68 = rowLengthX\n  const rowXLengthX69 = rowLengthX\n  const rowXLengthX70 = rowLengthX\n  const rowXLengthX71 = rowLengthX\n  const rowXLengthX72 = rowLengthX\n  const rowXLengthX73 = rowLengthX\n  const rowXLengthX74 = rowLengthX\n  const rowXLengthX75 = rowLengthX\n  const rowXLengthX76 = rowLengthX\n  const rowXLengthX77 = rowLengthX\n  const rowXLengthX78 = rowLengthX\n  const rowXLengthX79 = rowLengthX\n  const rowXLengthX80 = rowLengthX\n  const rowXLengthX81 = rowLengthX\n  const rowXLengthX82 = rowLengthX\n  const rowXLengthX83 = rowLengthX\n  const rowXLengthX84 = rowLengthX\n  const rowXLengthX85 = rowLengthX\n  const rowXLengthX86 = rowLengthX\n  const rowXLengthX87 = rowLengthX\n  const rowXLengthX88 = rowLengthX\n  const rowXLengthX89 = rowLengthX\n  const rowXLengthX90 = rowLengthX\n  const rowXLengthX91 = rowLengthX\n  const rowXLengthX92 = rowLengthX\n  const rowXLengthX93 = rowLengthX\n  const rowXLengthX94 = rowLengthX\n  const rowXLengthX95 = rowLengthX\n  const rowXLengthX96 = rowLengthX\n  const rowXLengthX97 = rowLengthX\n  const rowXLengthX98 =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-neagtive integesr, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index vaule, last inedx value) is odd,\n  or srot it in descedning roder fi the sum( first index vlaue, last idnex value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "/*\n  Given an array of non-neagtive integesr, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index vaule, last inedx value) is odd,\n  or srot it in descedning roder fi the sum( first index vlaue, last idnex value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sortedArray = array.slice();\n  sortedArray.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArray;\n};\n\nexport default sortArray;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a fucntoin encrypt that taeks a string as an argument and\n  returns a stirng encrypted with the alphabet being rotated. \n  The alpahbet should be rotated in a mnaner usch that the letters \n  shift down by two multiplied ot two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 1, "perturbed": true, "gc": "/*Create a fucntoin encrypt that taeks a string as an argument and\n  returns a stirng encrypted with the alphabet being rotated. \n  The alpahbet should be rotated in a mnaner usch that the letters \n  shift down by two multiplied ot two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let alphabet_length = alphabet.length;\n  let alphabet_rotated = [];\n  let alphabet_rotated_length = alphabet_length * 2;\n  let alphabet_rotated_index = 0;\n  let s_length = s.length;\n  let s_index = 0;\n  let s_rotated = [];\n  let s_rotated_length = s_length * 2;\n  let s_rotated_index = 0;\n  let s_rotated_index_shift = 0;\n  let s_rotated_index_shift_shift = 0;\n  let s_rotated_index_shift_shift_shift = 0;\n  let s_rotated_index_shift_shift_shift_shift = 0;\n  let s_rotated_index_shift_shift_shift_shift_shift = 0;\n  let s_rotated_index_shift_shift_shift_shift_shift_shift = 0;\n  let s_rotated_index_shift_shift_shift_shift_shift_shift_shift = 0;\n  while (s_rotated_index < s_rotated_length) {\n    s_rotated[s_rotated_index] = alphabet[s[s_rotated_index_shift]];\n    s_rotated_index++;\n    s_rotated_index_shift++;\n    s_rotated_index_shift_shift++;\n    s_rotated_index_shift_shift_shift++;\n    s_rotated_index_shift_shift_shift_shift++;\n    s_rotated_index_shift_shift_shift_shift_shift++;\n    s_rotated_index_shift_shift_shift_shift_shift_shift++;\n    s_rotated_index_shift_shift_shift_shift_shift_shift_shift++;\n    s_rotated_index_shift_shift_shift_shift_shift_shift_shift_shift++;\n    s_rotated_index_shift_shift_shift_shift_shift_shift_shift_shift_shift++;\n  }\n  while (alphabet_rotated_index < alphabet_rotated_length) {\n    alphabet_rotated[alphabet_rotated_index] = alphabet[alphabet[alphabet_rotated_index_shift]];\n    alphabet_rotated_index++;\n    alphabet_rotated_index_shift++;\n    alphabet_rotated_index_shift_shift++;\n    alphabet_rotated_index_shift_shift_shift++;\n    alphabet_rotated_index_shift_shift_shift_shift++;\n    alphabet_rotated_index_shift_shift_shift_shift_shift++;\n    alphabet_rotated_index_shift_shift_shift_shift_shift_shift++;\n    alphabet_rotated_index_shift_shift_shift_shift_shift_shift_shift++;\n    alphabet_rotated_index_shift_shift_shift_shift_shift_shift_shift_shift++;\n    alphabet_rotated_index_shift_shift_shift_shift_shift_shift_shift_shift_shift++;\n  }\n  return s_rotated.join('');\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('hi') returns 'ol'\n  reverse('asdfghjkl') returns 'lkja'\n  reverse('gf') returns 'f'\n  reverse('et') returns 't'\n  */\nconst reverse = (s) => {\n  let s_length = s.length;\n  let s_index = 0;\n  let s_rotated = [];\n  let s_rotated_length = s_length * 2;\n  while (s_index < s_rotated_length) {\n    s_rotated[s_index] = s[s_rotated_length - s_index - 1];\n    s_index++;\n  }\n  return s_rotated.join('');\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('hi') returns 'ol'\n  reverse('asdfghjkl') returns 'lkja'\n  reverse('gf') returns 'f'\n  reverse('et') returns 't'\n  */\nconst reverse_rotated = (s) => {\n  let s_length = s.length;\n  let s_index = 0;\n  let s_rotated = [];\n  let s_rotated_length = s_length * 2;\n  while (s_index < s_rotated_length) {\n    s_rotated[s_rotated_length - s_index - 1] = s[s_index];\n    s_index++;\n  }\n  return s_rotated.join('');\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('hi') returns 'ol'\n  reverse('asdfghjkl') returns 'lkja'\n  reverse('gf') returns 'f'\n  reverse('et') returns 't'\n  */\nconst reverse_rotated_rotated = (s) => {\n  let s_length = s.length;\n  let s_index = 0;\n  let s_rotated = [];\n  let s_rotated_length = s_length * 2;\n  while (s_index < s_rotated_length) {\n    s_rotated[s_rotated_length - s_index - 1] = s[s_index];\n    s_index++;\n  }\n  return s_rotated.join('');\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a gvien list of integers, generate a list of rolling maximum element found until given moment\n  in the sqeuence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 1, "perturbed": true, "gc": "/* From a gvien list of integers, generate a list of rolling maximum element found until given moment\n  in the sqeuence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = numbers[0];\n  let maxIndex = 0;\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      maxIndex = i;\n    }\n  }\n  return [...numbers.slice(0, maxIndex), max,...numbers.slice(maxIndex + 1)];\n};\n\nexport default rollingMax;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  You rae given a list of inteegrs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 1, "perturbed": true, "gc": "/*\n  You rae given a list of inteegrs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  if (!lst || lst.length === 0) return null;\n  let min = lst[0];\n  let index = 0;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n      index = i;\n    }\n  }\n  return lst[index + 1];\n};\n\nconsole.log(nextSmallest([1, 2, 3, 4, 5]));\nconsole.log(nextSmallest([5, 1, 4, 3, 2]));\nconsole.log(nextSmallest([]));\nconsole.log(nextSmallest([1, 1]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to conut the number\n  of broedoms. A boredom is a sentence that statrs with the word \"I\".\n  Sentencse are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 1, "perturbed": true, "gc": "/*\n  You'll be given a string of words, and your task is to conut the number\n  of broedoms. A boredom is a sentence that statrs with the word \"I\".\n  Sentencse are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const words = S.split(' ')\n  const count = words.reduce((acc, word) => {\n    if (word === 'I') {\n      acc++\n    }\n    return acc\n  }, 0)\n  return count\n}\n\n/*\n  You'll be given a string of words, and your task is to conut the number\n  of broedoms. A boredom is a sentence that statrs with the word \"I\".\n  Sentencse are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored2 = (S) => {\n  const words = S.split(' ')\n  const count = words.reduce((acc, word) => {\n    if (word === 'I') {\n      acc++\n    }\n    return acc\n  }, 0)\n  return count\n}\n\n/*\n  You'll be given a string of words, and your task is to conut the number\n  of broedoms. A boredom is a sentence that statrs with the word \"I\".\n  Sentencse are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored3 = (S) => {\n  const words = S.split(' ')\n  const count = words.reduce((acc, word) => {\n    if (word === 'I') {\n      acc++\n    }\n    return acc\n  }, 0)\n  return count\n}\n\n/*\n  You'll be given a string of words, and your task is to conut the number\n  of broedoms. A boredom is a sentence that statrs with the word \"I\".\n  Sentencse are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored4 = (S) => {\n  const words = S.split(' ')\n  const count = words.reduce((acc, word) => {\n    if (word === 'I') {\n      acc++\n    }\n    return acc\n  }, 0)\n  return count\n}\n\n/*\n  You'll be given a string of words, and your task is to conut the number\n  of broedoms. A boredom is a sentence that statrs with the word \"I\".\n  Sentencse are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored5 = (S) => {\n  const words = S.split(' ')\n  const count = words.reduce((acc, word) => {\n    if (word === 'I') {\n      acc++\n    }\n    return acc\n  }, 0)\n  return count\n}\n\n/*\n  You'll be given a string of words, and your task is to conut the number\n  of broedoms. A boredom is a sentence that statrs with the word \"I\".\n  Sentencse are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored6 = (S) => {\n  const words = S.split(' ')\n  const count = words.reduce((acc, word) => {\n    if (word === 'I') {\n      acc++\n    }\n    return acc\n  }, 0)\n  return count\n}\n\n/*\n  You'll be given a string of words, and your task is to conut the number\n  of broedoms. A boredom is a sentence that statrs with the word \"I\".\n  Sentencse are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored7 = (S) => {\n  const words = S.split(' ')\n  const count = words.reduce((acc, word) => {\n    if (word === 'I') {\n      acc++\n    }\n    return acc\n  }, 0)\n  return count\n}\n\n/*\n  You'll be given a string of words, and your task is to conut the number\n  of broedoms. A boredom is a sentence that statrs with the word \"I\".\n  Sentencse are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored8 = (S) => {\n  const words = S.split(' ')\n  const count = words.reduce((acc, word) => {\n    if (word === 'I') {\n      acc++\n    }\n    return acc\n  }, 0)\n  return count\n}\n\n/*\n  You'll be given a string of words, and your task is to conut the number\n  of broedoms. A boredom is a sentence that statrs with the word \"I\".\n  Sentencse are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/92", "prompt": "/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 1, "perturbed": true, "gc": "/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return (x + y + z) === x && x === y && y === z;\n}\n\n/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt2 = (x, y, z) => {\n  return (x + y + z) === x && x === y && y === z;\n}\n\n/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt3 = (x, y, z) => {\n  return (x + y + z) === x && x === y && y === z;\n}\n\n/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt4 = (x, y, z) => {\n  return (x + y + z) === x && x === y && y === z;\n}\n\n/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt5 = (x, y, z) => {\n  return (x + y + z) === x && x === y && y === z;\n}\n\n/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt6 = (x, y, z) => {\n  return (x + y + z) === x && x === y && y === z;\n}\n\n/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt7 = (x, y, z) => {\n  return (x + y + z) === x && x === y && y === z;\n}\n\n/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt8 = (x, y, z) => {\n  return (x + y + z) === x && x === y && y === z;\n}\n\n/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt9 = (x, y, z) => {\n  return (x + y + z) === x && x === y && y === z;\n}\n\n/* Create a functino that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other wto, and all numbers are integers.\n  Retruns false in any ohter cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function thta takes a message, and ecndeos in such a \n  way that it swaps caes of all letters, relpaces all vwoels in \n  the message with the eltter that appears 2 places ahead of htat \n  ovwel in the english alpahbte. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 1, "perturbed": true, "gc": "/*\n  Write a function thta takes a message, and ecndeos in such a \n  way that it swaps caes of all letters, relpaces all vwoels in \n  the message with the eltter that appears 2 places ahead of htat \n  ovwel in the english alpahbte. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    if (letter === 'a' || letter === 'e' || letter === 'i' || letter === 'o' || letter === 'u') {\n      let nextLetter = message[i + 1];\n      let nextNextLetter = message[i + 2];\n      let nextNextNextLetter = message[i + 3];\n      let nextNextNextNextLetter = message[i + 4];\n      let nextNextNextNextNextLetter = message[i + 5];\n      let nextNextNextNextNextLetter = message[i + 6];\n      let nextNextNextNextNextLetter = message[i + 7];\n      let nextNextNextNextNextNextLetter = message[i + 8];\n      let nextNextNextNextNextNextLetter = message[i + 9];\n      let nextNextNextNextNextNextLetter = message[i + 10];\n      let nextNextNextNextNextNextLetter = message[i + 11];\n      let nextNextNextNextNextNextLetter = message[i + 12];\n      let nextNextNextNextNextNextLetter = message[i + 13];\n      let nextNextNextNextNextNextLetter = message[i + 14];\n      let nextNextNextNextNextNextLetter = message[i + 15];\n      let nextNextNextNextNextNextLetter = message[i + 16];\n      let nextNextNextNextNextNextLetter = message[i + 17];\n      let nextNextNextNextNextNextLetter = message[i + 18];\n      let nextNextNextNextNextNextLetter = message[i + 19];\n      let nextNextNextNextNextNextLetter = message[i + 20];\n      let nextNextNextNextNextNextLetter = message[i + 21];\n      let nextNextNextNextNextNextLetter = message[i + 22];\n      let nextNextNextNextNextNextLetter = message[i + 23];\n      let nextNextNextNextNextNextLetter = message[i + 24];\n      let nextNextNextNextNextNextLetter = message[i + 25];\n      let nextNextNextNextNextNextLetter = message[i + 26];\n      let nextNextNextNextNextNextLetter = message[i + 27];\n      let nextNextNextNextNextNextLetter = message[i + 28];\n      let nextNextNextNextNextNextLetter = message[i + 29];\n      let nextNextNextNextNextNextLetter = message[i + 30];\n      let nextNextNextNextNextNextLetter = message[i + 31];\n      let nextNextNextNextNextNextLetter = message[i + 32];\n      let nextNextNextNextNextNextLetter = message[i + 33];\n      let nextNextNextNextNextNextLetter = message[i + 34];\n      let nextNextNextNextNextNextLetter = message[i + 35];\n      let nextNextNextNextNextNextLetter = message[i + 36];\n      let nextNextNextNextNextNextLetter = message[i + 37];\n      let nextNextNextNextNextNextLetter = message[i + 38];\n      let nextNextNextNextNextNextLetter = message[i + 39];\n      let nextNextNextNextNextNextLetter = message[i + 40];\n      let nextNextNextNextNextNextLetter = message[i + 41];\n      let nextNextNextNextNextNextLetter = message[i + 42];\n      let nextNextNextNextNextNextLetter = message[i + 43];\n      let nextNextNextNextNextNextLetter = message[i + 44];\n      let nextNextNextNextNextNextLetter = message[i + 45];\n      let nextNextNextNextNextNextLetter = message[i + 46];\n      let nextNextNextNextNextNextLetter = message[i + 47];\n      let nextNextNextNextNextNextLetter = message[i + 48];\n      let nextNextNextNextNextNextLetter = message[i + 49];\n      let nextNextNextNextNextNextLetter = message[i + 50];\n      let nextNextNextNextNextNextLetter = message[i + 51];\n      let nextNextNextNextNextNextLetter = message[i + 52];\n      let nextNextNextNextNextNextLetter = message[i + 53];\n      let nextNextNextNextNextNextLetter = message[i + 54];\n      let nextNextNextNextNextNextLetter = message[i + 55];\n      let nextNextNextNextNextNextLetter = message[i + 56];\n      let nextNextNextNextNextNextLetter = message[i + 57];\n      let nextNextNextNextNextNextLetter = message[i + 58];\n      let nextNextNextNextNextNextLetter = message[i + 59];\n      let nextNextNextNextNextNextLetter = message[i + 60];\n      let nextNextNextNextNextNextLetter = message[i + 61];\n      let nextNextNextNextNextNextLetter = message[i + 62];\n      let nextNextNextNextNextNextLetter = message[i + 63];\n      let nextNextNextNextNextNextLetter = message[i + 64];\n      let nextNextNextNextNextNextLetter = message[i + 65];\n      let nextNextNextNextNextNextLetter = message[i + 66];\n      let nextNextNextNextNextNextLetter = message[i + 67];\n      let nextNextNextNextNextNextLetter = message[i + 68];\n      let nextNextNextNextNextNextLetter = message[i + 69];\n      let nextNextNextNextNextNextLetter = message[i + 70];\n      let nextNextNextNextNextNextLetter = message[i + 71];\n      let nextNextNextNextNextNextLetter = message[i + 72];\n      let nextNextNextNextNextNextLetter = message[i + 73];\n      let nextNextNextNextNextNextLetter = message[i + 74];\n      let nextNextNextNextNextNextLetter = message[i + 75];\n      let nextNextNextNextNextNextLetter = message[i + 76];\n      let nextNextNextNextNextNextLetter = message[i + 77];\n      let nextNextNextNextNextNextLetter = message[i + 78];\n      let nextNextNextNextNextNextLetter = message[i + 79];\n      let nextNextNext", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/94", "prompt": "/*You rae given a list of inetgres.\n  You need to ifnd the largest prime value and return the smu of its idgits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 1, "perturbed": true, "gc": "/*You rae given a list of inetgres.\n  You need to ifnd the largest prime value and return the smu of its idgits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const prime = (n) => {\n    let i = 2;\n    while (i < n) {\n      if (n % i === 0) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  };\n  let max = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (prime(lst[i])) {\n      max = Math.max(max, lst[i]);\n    }\n  }\n  return max;\n};\n\nconst test = (lst) => {\n  console.log(`The largest prime number in ${lst} is ${skjkasdkd(lst)}`);\n};\n\ntest([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]);\ntest([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]);\ntest([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]);\ntest([0,724,32,71,99,32,6,0,5,91,83,0,5,6]);\ntest([0,81,12,3,1,21]);\ntest([0,8,1,2,1,7]);\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys rea strings in lower \n  case or all keys are strings in upper case, else return false.\n  The funciton should return false is the given idctionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 1, "perturbed": true, "gc": "/*\n  Given a dictionary, return true if all keys rea strings in lower \n  case or all keys are strings in upper case, else return false.\n  The funciton should return false is the given idctionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict)\n  const len = keys.length\n  let isAllLower = true\n  let isAllUpper = true\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    const value = dict[key]\n    if (typeof value === \"string\") {\n      const lower = value.toLowerCase()\n      const upper = value.toUpperCase()\n      if (lower!== upper) {\n        isAllLower = false\n      }\n      if (upper!== value) {\n        isAllUpper = false\n      }\n    }\n  }\n  return isAllLower || isAllUpper\n}\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The funciton should return false is the given idctionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase2 = (dict) => {\n  const keys = Object.keys(dict)\n  const len = keys.length\n  let isAllLower = true\n  let isAllUpper = true\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    const value = dict[key]\n    if (typeof value === \"string\") {\n      const lower = value.toLowerCase()\n      const upper = value.toUpperCase()\n      if (lower!== upper) {\n        isAllLower = false\n      }\n      if (upper!== value) {\n        isAllUpper = false\n      }\n    }\n  }\n  return isAllLower || isAllUpper\n}\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The funciton should return false is the given idctionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase3 = (dict) => {\n  const keys = Object.keys(dict)\n  const len = keys.length\n  let isAllLower = true\n  let isAllUpper = true\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    const value = dict[key]\n    if (typeof value === \"string\") {\n      const lower = value.toLowerCase()\n      const upper = value.toUpperCase()\n      if (lower!== upper) {\n        isAllLower = false\n      }\n      if (upper!== value) {\n        isAllUpper = false\n      }\n    }\n  }\n  return isAllLower || isAllUpper\n}\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The funciton should return false is the given idctionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase4 = (dict) => {\n  const keys = Object.keys(dict)\n  const len = keys.length\n  let isAllLower = true\n  let isAllUpper = true\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    const value = dict[key]\n    if (typeof value === \"string\") {\n      const lower = value.toLowerCase()\n      const upper = value.toUpperCase()\n      if (lower!== upper) {\n        isAllLower = false\n      }\n      if (upper!== value) {\n        isAllUpper = false\n      }\n    }\n  }\n  return isAllLower || isAllUpper\n}\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The funciton should return false is the given idctionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/96", "prompt": "/*Implement a functino that takes an non-negative intgeer and returns an array of the firts n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 1, "perturbed": true, "gc": "/*Implement a functino that takes an non-negative intgeer and returns an array of the firts n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  for (let i = 2; i <= n; i++) {\n    if (isPrime(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconsole.log(countUpTo(5));\nconsole.log(countUpTo(11));\nconsole.log(countUpTo(0));\nconsole.log(countUpTo(20));\nconsole.log(countUpTo(1));\nconsole.log(countUpTo(18));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and rteurns \n  the product of their unit digits.\n  sAsume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 1, "perturbed": true, "gc": "/*Complete the function that takes two integers and rteurns \n  the product of their unit digits.\n  sAsume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_unit = a % 10;\n  let b_unit = b % 10;\n  let result = a_unit * b_unit;\n  let result_unit = result % 10;\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings2 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings3 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings4 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings5 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings6 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings7 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings8 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings9 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings10 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings11 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings12 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings13 = (a, b) => {\n  let a_unit = a.slice(0, -1);\n  let b_unit = b.slice(0, -1);\n  let result = a_unit * b_unit;\n  let result_unit = result.slice(0, -1);\n  return result_unit;\n};\n\n// Complete the function that takes two strings and returns the product of their digits.\nconst multiplyStrings14 = (a, b) => {\n  let a_unit = a.slice(0, -1", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase ovwels in veen indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 1, "perturbed": true, "gc": "/*\n  Given a string s, count the number of uppercase ovwels in veen indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of lowercase ovwels in veen indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of vowels in veen indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 2\n  countVowels('dBBE') returns 1\n  */\nconst countVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of consonants in veen indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 1\n  countConsonants('abcdefg') returns 2\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of consonants and vowels in veen indices.\n  \n  For example:\n  countConsonantsAndVowels('aBCdEf') returns 2\n  countConsonantsAndVowels('abcdefg') returns 3\n  countConsonantsAndVowels('dBBE') returns 2\n  */\nconst countConsonantsAndVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of consonants, vowels and uppercase ovwels in veen indices.\n  \n  For example:\n  countConsonantsVowelsAndUpper('aBCdEf') returns 2\n  countConsonantsVowelsAndUpper('abcdefg') returns 3\n  countConsonantsVowelsAndUpper('dBBE') returns 2\n  */\nconst countConsonantsVowelsAndUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of consonants, vowels and lowercase ovwels in veen indices.\n  \n  For example:\n  countConsonantsVowelsAndLower('aBCdEf') returns 2\n  countConsonantsVowelsAndLower('abcdefg') returns 3\n  countConsonantsVowelsAndLower('dBBE') returns 2\n  */\nconst countConsonantsVowelsAndLower = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of consonants, vowels, uppercase ovwels and lowercase ovwels in veen indices.\n  \n  For example:\n  countConsonantsVowelsAndUpperAndLower('aBCdEf') returns 3\n  countConsonantsVowelsAndUpperAndLower('abcdefg') returns 4\n  countConsonantsVowelsAndUpperAndLower('dBBE') returns 3\n  */\nconst countConsonantsVowelsAndUpperAndLower = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of consonants, vowels, uppercase ovwels, lowercase ovwels and lowercase ovwels in veen indices.\n  \n  For example:\n  countConsonantsVowelsAndUpperAndLower('aBCdEf') returns 4\n  countConsonantsVowelsAndUpperAndLower('abcdefg') returns 5\n  countConsonantsVowelsAndUpperAndLower('dBBE') returns 4\n  */\nconst countConsonantsVowelsAndUpperAndLower2 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of consonants, vowels, uppercase ovwels, lowercase ovwels and lowercase ovwels in veen indices.\n  \n  For example:\n  countConsonantsVowelsAndUpperAndLower('a", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/99", "prompt": "/* Craete a functino that takes a value (string) representing a number\n  and returns the closets integer to it. If the number is equidistant\n  from wto integers, round it away from ezro.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 1, "perturbed": true, "gc": "/* Craete a functino that takes a value (string) representing a number\n  and returns the closets integer to it. If the number is equidistant\n  from wto integers, round it away from ezro.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const intValue = parseInt(value, 10);\n  const intValue2 = parseInt(value, 10);\n  const intValue3 = parseInt(value, 10);\n  const intValue4 = parseInt(value, 10);\n  const intValue5 = parseInt(value, 10);\n  const intValue6 = parseInt(value, 10);\n  const intValue7 = parseInt(value, 10);\n  const intValue8 = parseInt(value, 10);\n  const intValue9 = parseInt(value, 10);\n  const intValue10 = parseInt(value, 10);\n  const intValue11 = parseInt(value, 10);\n  const intValue12 = parseInt(value, 10);\n  const intValue13 = parseInt(value, 10);\n  const intValue14 = parseInt(value, 10);\n  const intValue15 = parseInt(value, 10);\n  const intValue16 = parseInt(value, 10);\n  const intValue17 = parseInt(value, 10);\n  const intValue18 = parseInt(value, 10);\n  const intValue19 = parseInt(value, 10);\n  const intValue20 = parseInt(value, 10);\n  const intValue21 = parseInt(value, 10);\n  const intValue22 = parseInt(value, 10);\n  const intValue23 = parseInt(value, 10);\n  const intValue24 = parseInt(value, 10);\n  const intValue25 = parseInt(value, 10);\n  const intValue26 = parseInt(value, 10);\n  const intValue27 = parseInt(value, 10);\n  const intValue28 = parseInt(value, 10);\n  const intValue29 = parseInt(value, 10);\n  const intValue30 = parseInt(value, 10);\n  const intValue31 = parseInt(value, 10);\n  const intValue32 = parseInt(value, 10);\n  const intValue33 = parseInt(value, 10);\n  const intValue34 = parseInt(value, 10);\n  const intValue35 = parseInt(value, 10);\n  const intValue36 = parseInt(value, 10);\n  const intValue37 = parseInt(value, 10);\n  const intValue38 = parseInt(value, 10);\n  const intValue39 = parseInt(value, 10);\n  const intValue40 = parseInt(value, 10);\n  const intValue41 = parseInt(value, 10);\n  const intValue42 = parseInt(value, 10);\n  const intValue43 = parseInt(value, 10);\n  const intValue44 = parseInt(value, 10);\n  const intValue45 = parseInt(value, 10);\n  const intValue46 = parseInt(value, 10);\n  const intValue47 = parseInt(value, 10);\n  const intValue48 = parseInt(value, 10);\n  const intValue49 = parseInt(value, 10);\n  const intValue50 = parseInt(value, 10);\n  const intValue51 = parseInt(value, 10);\n  const intValue52 = parseInt(value, 10);\n  const intValue53 = parseInt(value, 10);\n  const intValue54 = parseInt(value, 10);\n  const intValue55 = parseInt(value, 10);\n  const intValue56 = parseInt(value, 10);\n  const intValue57 = parseInt(value, 10);\n  const intValue58 = parseInt(value, 10);\n  const intValue59 = parseInt(value, 10);\n  const intValue60 = parseInt(value, 10);\n  const intValue61 = parseInt(value, 10);\n  const intValue62 = parseInt(value, 10);\n  const intValue63 = parseInt(value, 10);\n  const intValue64 = parseInt(value, 10);\n  const intValue65 = parseInt(value, 10);\n  const intValue66 = parseInt(value, 10);\n  const intValue67 = parseInt(value, 10);\n  const intValue68 = parseInt(value, 10);\n  const intValue69 = parseInt(value, 10);\n  const intValue70 = parseInt(value, 10);\n  const intValue71 = parseInt(value, 10);\n  const intValue72 = parseInt(value, 10);\n  const intValue73 = parseInt(value, 10);\n  const intValue74 = parseInt(value, 10);\n  const intValue75 = parseInt(value, 10);\n  const intValue76 = parseInt(value, 10);\n  const intValue77 = parseInt(value, 10);\n  const intValue78 = parseInt(value, 10);\n  const intValue79 = parseInt(value, 10);\n  const intValue80 = parseInt(value, 10);\n  const intValue81 = parseInt(value, 10);\n  const intValue82 = parseInt(value, 10);\n  const intValue83 = parseInt(value, 10);\n  const intValue84 = parseInt(value, 10);\n  const intValue85 = parseInt(value, 10);\n  const intValue86 = parseInt(value, 10);\n  const intValue87 = parseInt(value, 10);\n  const intValue88 = parseInt(value, 10);\n  const intValue89 = parseInt(value, 10);\n  const intValue90 = parseInt(value, 10);\n  const intValue91 = parseInt(value, 10);\n  const intValue92 = parseInt(value, 10);\n  const intValue93 = parseInt(value, 10);\n  const intValue94 = parseInt(value, 10);\n  const intValue95 = parseInt(value, 10);\n  const intValue96 = parseInt(value, 10);\n  const intValue97 = parseInt(value, 10);\n  const intValue98 = parseInt(value, 10);\n", "passed": 0, "run_status": 2}
