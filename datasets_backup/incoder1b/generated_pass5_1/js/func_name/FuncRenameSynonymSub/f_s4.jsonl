{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> receiveCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> receiveCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst receiveCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "receiveCloseElements", "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> receiveCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> receiveCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst receiveCloseElements = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given number is in given list of numbers.\n * If number is in list of numbers, return true.\n * If number is not in list of numbers, return false.\n * If number is in list of numbers, return true if number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is not in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers.\n * If number is not in list of numbers, return false if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is not in list of numbers.\n * If number is in list of numbers, return true if number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is in list of numbers and number is ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> freestandingParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "freestandingParenGroups", "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> freestandingParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/gi);\n  const paren_group_list = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_open = paren_group.match(/\\(/);\n    const paren_group_close = paren_group.match(/\\)/);\n    const paren_group_paren = paren_group.match(/\\(|\\)/);\n    if (paren_group_open && paren_group_close) {\n      paren_group_paren.forEach((paren_group_paren_item) => {\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s/g, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\)\\s*\\)/, '');\n        paren_group_paren_item = paren_group_paren_item.replace(/\\s*\\(\\s*\\)/, '');\n        paren_group_paren_item = paren", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let palindromeLength = 0;\n  let palindromePrefix = '';\n  let palindromeSuffix = '';\n\n  /* Iterate through each character in the supplied string */\n  for (let i = 0; i < string.length; i++) {\n    /* If the character is a palindrome character */\n    if (isPalindrome(string[i])) {\n      /* Increment the palindrome length */\n      palindromeLength++;\n\n      /* If the palindrome length is greater than the longest palindrome length */\n      if (palindromeLength > longestPalindromeLength) {\n        /* Increment the longest palindrome length */\n        longestPalindromeLength = palindromeLength;\n        longestPalindromePrefix = string[i];\n        longestPalindromeSuffix = string[string.length - palindromeLength];\n      }\n\n      /* If the palindrome length is equal to the longest palindrome length */\n      if (palindromeLength == longestPalindromeLength) {\n        /* Increment the palindrome prefix */\n        palindromePrefix = string[i];\n\n        /* If the palindrome prefix is equal to the longest palindrome prefix */\n        if (palindromePrefix == longestPalindromePrefix) {\n          /* Increment the palindrome suffix */\n          palindromeSuffix = string[string.length - palindromeLength];\n\n          /* If the palindrome suffix is equal to the longest palindrome suffix */\n          if (palindromeSuffix == longestPalindromeSuffix) {\n            /* Append the palindrome prefix and palindrome suffix to the end of the string */\n            longestPalindrome += palindromePrefix + palindromeSuffix;\n          }\n        }\n      }\n    }\n  }\n\n  /* Return the longest palindrome */\n  return longestPalindrome;\n}\n\n/* Test if given string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let palindromeLength = 0;\n  let palindromePrefix = '';\n  let palindromeSuffix = '';\n\n  /* Iterate through each character in the supplied string */\n  for (let i = 0; i < string.length; i++) {\n    /* If the character is a palindrome character */\n    if (isPalindrome(string[i])) {\n      /* Increment the palindrome length */\n      palindromeLength++;\n\n      /* If the palindrome length is greater than the longest palindrome length */\n      if (palindromeLength > longestPalindromeLength) {\n        /* Increment the longest palindrome length */\n        longestPalindromeLength = palindromeLength;\n        longestPalindromePrefix = string[i];\n        longestPalindromeSuffix = string[string.length - palindromeLength];\n      }\n\n      /* If the palindrome length is equal to the longest palindrome length */\n      if (palindromeLength == longestPalindromeLength) {\n        /* Increment the palindrome prefix */\n        palindromePrefix = string[i];\n\n        /* If the palindrome prefix is equal to the longest palindrome prefix */\n        if (palindromePrefix == longestPalindromePrefix) {\n          /* Increment the palindrome suffix */\n          palindromeSuffix = string[string.length - palindromeLength];\n\n          /* If the palindrome suffix is equal to the longest palindrome suffix */\n          if (palindromeSuffix == longestPalindromeSuffix) {\n            /* Append the palindrome prefix and palindrome suffix to the end of the string */\n            longestPalindrome += palindromePrefix + palindromeSuffix;\n          }\n        }\n      }\n    }\n  }\n\n  /* Return the longest palindrome */\n  return longestPalindrome;\n}\n\n/* Test if given string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let palindromeLength = 0;\n  let palindromePrefix = '';\n  let palindromeSuffix = '';\n\n  /* Iterate through each character in the supplied string */\n  for (let i = 0; i < string.length; i++) {\n    /* If the character is a palindrome character */\n    if (isPalindrome(string[i])) {\n      /* Increment the palindrome length */\n      palindromeLength++;\n\n      /* If the palindrome length is greater than the longest palindrome length */\n      if (palindromeLength > longestPalindromeLength) {\n        /* Increment the longest palindrome length */\n        longestPalindromeLength = palindromeLength;\n        longestPalindromePrefix = string[i];\n        longestPalindromeSuffix = string[string.length - palindromeLength];\n      }\n\n      /* If the palindrome length is equal to the longest palindrome length */\n      if (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "holdAPile", "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(4)\n  [4, 6, 8, 10]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(5)\n  [5, 10, 15, 20, 25]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(6)\n  [6, 8, 10, 12, 15]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(7)\n  [7, 9, 11, 13, 15]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(8)\n  [8, 10, 12, 14, 16]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(9)\n  [9, 11, 13, 15, 17]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(10)\n  [10, 11, 12, 13, 14]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(11)\n  [11, 12, 13, 14, 15]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(12)\n  [12, 13, 14, 15, 16]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(13)\n  [13, 14, 15, 16, 17]\n  */\nconst holdAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n level", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "bibleString", "gc": "<|endoftext|>/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleString = (s) => {\n  let words = s.split(/,|\\s+/);\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i].trim());\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWords = (s) => {\n  let words = s.split(/,|\\s+/);\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i].trim());\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWords(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWords(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  let words = s.split(/,|\\s+/);\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i].trim());\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray2 = (s) => {\n  let words = s.split(/,|\\s+/);\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i].trim());\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray2(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray2(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray3 = (s) => {\n  let words = s.split(/,|\\s+/);\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i].trim());\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray3(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray3(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray4 = (s) => {\n  let words = s.split(/,|\\s+/);\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i].trim());\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray4(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray4(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray5 = (s) => {\n  let words = s.split(/,|\\s+/);\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i].trim());\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray5(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray5(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray6 = (s) => {\n  let words = s.split(/,|\\s+/);\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i].trim());\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray6(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray6(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray7 = (s) => {\n  let words = s.split(/,|\\s+/);\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i].trim());\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray7(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray7(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray8 = (s) => {\n  let words = s.split(/,|\\s+/);\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i].trim());\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray8(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray8(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray9", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "gc": "<|endoftext|>/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num % 2 === 0) {\n      result = num;\n    } else {\n      result = -chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest odd integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num % 2!== 0) {\n      result = num;\n    } else {\n      result = chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num > 0) {\n      result = num;\n    } else {\n      result = chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest negative integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num < 0) {\n      result = num;\n    } else {\n      result = chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num > 0) {\n      result = num;\n    } else {\n      result = chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest negative integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num < 0) {\n      result = num;\n    } else {\n      result = chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num > 0) {\n      result = num;\n    } else {\n      result = chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num > 0) {\n      result = num;\n    } else {\n      result = chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num > 0) {\n      result = num;\n    } else {\n      result = chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num > 0) {\n      result = num;\n    } else {\n      result = chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1;\n  let num;\n  if (x === 0 && y === 0) {\n    result = -1;\n  } else if (x === 0) {\n    result = y;\n  } else if (y === 0) {\n    result = x;\n  } else {\n    num = Math.floor(x / y);\n    if (num > 0) {\n      result = num;\n    } else {\n      result = chooseNum(num, y);\n    }\n  }\n  return result;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  let binCount = 0;\n  let binSum = 0;\n  let binCount2 = 0;\n  let binSum2 = 0;\n  let binCount3 = 0;\n  let binSum3 = 0;\n  let binCount4 = 0;\n  let binSum4 = 0;\n  let binCount5 = 0;\n  let binSum5 = 0;\n  let binCount6 = 0;\n  let binSum6 = 0;\n  let binCount7 = 0;\n  let binSum7 = 0;\n  let binCount8 = 0;\n  let binSum8 = 0;\n  let binCount9 = 0;\n  let binSum9 = 0;\n  let binCount10 = 0;\n  let binSum10 = 0;\n  let binCount11 = 0;\n  let binSum11 = 0;\n  let binCount12 = 0;\n  let binSum12 = 0;\n  let binCount13 = 0;\n  let binSum13 = 0;\n  let binCount14 = 0;\n  let binSum14 = 0;\n  let binCount15 = 0;\n  let binSum15 = 0;\n  let binCount16 = 0;\n  let binSum16 = 0;\n  let binCount17 = 0;\n  let binSum17 = 0;\n  let binCount18 = 0;\n  let binSum18 = 0;\n  let binCount19 = 0;\n  let binSum19 = 0;\n  let binCount20 = 0;\n  let binSum20 = 0;\n  let binCount21 = 0;\n  let binSum21 = 0;\n  let binCount22 = 0;\n  let binSum22 = 0;\n  let binCount23 = 0;\n  let binSum23 = 0;\n  let binCount24 = 0;\n  let binSum24 = 0;\n  let binCount25 = 0;\n  let binSum25 = 0;\n  let binCount26 = 0;\n  let binSum26 = 0;\n  let binCount27 = 0;\n  let binSum27 = 0;\n  let binCount28 = 0;\n  let binSum28 = 0;\n  let binCount29 = 0;\n  let binSum29 = 0;\n  let binCount30 = 0;\n  let binSum30 = 0;\n  let binCount31 = 0;\n  let binSum31 = 0;\n  let binCount32 = 0;\n  let binSum32 = 0;\n  let binCount33 = 0;\n  let binSum33 = 0;\n  let binCount34 = 0;\n  let binSum34 = 0;\n  let binCount35 = 0;\n  let binSum35 = 0;\n  let binCount36 = 0;\n  let binSum36 = 0;\n  let binCount37 = 0;\n  let binSum37 = 0;\n  let binCount38 = 0;\n  let binSum38 = 0;\n  let binCount39 = 0;\n  let binSum39 = 0;\n  let binCount40 = 0;\n  let binSum40 = 0;\n  let binCount41 = 0;\n  let binSum41 = 0;\n  let binCount42 = 0;\n  let binSum42 = 0;\n  let binCount43 = 0;\n  let binSum43 = 0;\n  let binCount44 = 0;\n  let binSum44 = 0;\n  let binCount45 = 0;\n  let binSum45 = 0;\n  let binCount46 = 0;\n  let binSum46 = 0;\n  let binCount47 = 0;\n  let binSum47 = 0;\n  let binCount48 = 0;\n  let binSum48 = 0;\n  let binCount49 = 0;\n  let binSum49 = 0;\n  let binCount50 = 0;\n  let binSum50 = 0;\n  let binCount51 = 0;\n  let binSum51 = 0;\n  let binCount52 = 0;\n  let binSum52 = 0;\n  let binCount53 = 0;\n  let binSum53 = 0;\n  let binCount54 = 0;\n  let binSum54 = 0;\n  let binCount55 = 0;\n  let binSum55 = 0;\n  let binCount56 = 0;\n  let binSum56 = 0;\n  let binCount57 = 0;\n  let binSum57 = 0;\n  let binCount58 = 0;\n  let binSum58 = 0;\n  let binCount59 = 0;\n  let binSum59 = 0;\n  let binCount60 = 0;\n  let binSum60 = 0;\n  let binCount61 = 0;\n  let binSum61 = 0;\n  let binCount62 = 0;\n  let binSum62 = 0;\n  let binCount63 = 0;\n  let binSum63 = 0;\n  let binCount64 = 0;\n  let binSum64 = 0;\n  let binCount65 = 0;\n  let binSum65 = 0;\n  let binCount66 = 0;\n  let binSum66 = 0;\n  let binCount67 = 0;\n  let binSum67 = 0;\n  let binCount68 = 0;\n  let binSum68 = 0;\n  let binCount69 = 0;\n  let binSum69 = 0;\n  let binCount70 = 0;\n  let binSum70 = 0;\n  let binCount71 = 0;\n  let binSum71 = 0;\n  let binCount72 = 0;\n  let binSum72 = 0;\n  let binCount73 = 0;\n  let binSum73 = 0;\n  let binCount74 = 0;\n  let binSum74 = 0;\n  let binCount75 = 0;\n  let binSum75 = 0;\n  let binCount76 = 0;\n  let binSum76 = 0;\n  let binCount77 = 0;\n  let binSum77 = 0;\n  let binCount78 = 0;\n  let binSum78 = 0;\n  let binCount79 = 0;\n  let binSum79 = 0;\n  let binCount80 = 0;\n  let binSum80 = 0;\n  let binCount81 = 0;\n  let binSum81 = 0;\n  let binCount82 = 0;\n  let binSum82 = 0;\n  let binCount83 = 0;\n  let binSum83 = 0;\n  let binCount84 = 0;\n  let binSum84 = 0;\n  let binCount85 = 0;\n  let binSum85 = 0;\n  let binCount86 = 0;\n  let binSum86 = 0;\n  let binCount87 = 0;\n  let binSum87 = 0;\n  let binCount88 = 0;\n  let binSum88 = 0;\n  let binCount89 = 0;\n  let binSum89 = 0;\n  let binCount90 = 0;\n  let binSum90 = 0;\n  let binCount91 = 0;\n  let binSum91 = 0;\n  let binCount92 = 0;\n  let binSum92 = 0;\n  let binCount93 = 0;\n  let binSum93 = 0;\n  let binCount94 = 0;\n  let binSum94 = 0;\n  let binCount95 = 0;\n  let binSum95 = 0;\n  let binCount96 = 0;\n  let binSum96 = 0;\n  let binCount97 = 0;\n  let binSum97 = 0;\n  let binCount98 = 0;\n  let binSum98 = 0;\n  let binCount99 = 0;\n  let binSum99 = 0;\n  let binCount100 = 0;\n  let binSum100 = 0;\n  let binCount101 = 0;\n  let binSum101 = 0;\n  let binCount102 = 0;\n  let binSum102 = 0;\n  let binCount103 = 0;\n  let binSum103 = 0;\n  let binCount104 = 0;\n  let binSum104 = 0;\n  let binCount105 = 0;\n  let binSum105 = 0;\n  let binCount106 = 0;\n  let binSum106 = 0;\n  let binCount107 = 0;\n  let binSum107 = 0;\n  let binCount108 = 0;\n  let binSum108 = 0;\n  let binCount109 = 0;\n  let binSum109 = 0;\n  let binCount110 = 0;\n  let binSum110 = 0;\n  let binCount111 = 0;\n  let binSum111 = 0;\n  let binCount112 = 0;\n  let binSum112 = 0;\n  let binCount113 = 0;\n  let binSum113 = 0;\n  let binCount114 = 0;\n  let binSum114 = 0;\n  let binCount115 = 0;\n  let binSum115 = 0;\n  let binCount116 = 0;\n  let binSum116 = 0;\n  let binCount117 = 0;\n  let binSum117 = 0;\n  let binCount118 = 0;\n  let binSum118 = 0;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneDigit([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> aloneDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneDigit = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "aloneDigit", "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneDigit([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> aloneDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  \n  while (x[digit] % 2 === 0) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2 === 0) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddDigit([15, 33, 1422, 1])\n  [152, 323, 1422]\n  >>> oddDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  \n  while (x[digit] % 2!== 0) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2!== 0) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> evenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> evenDigit([152, 323, 1422, 10])\n  []\n  */\nconst evenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  \n  while (x[digit] % 2!== 0) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2!== 0) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  \n  while (x[digit] % 2!== 0) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2!== 0) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  while (x[digit] % 2 === 1) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2 === 1) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  \n  while (x[digit] % 2!== 0) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2!== 0) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  while (x[digit] % 2 === 1) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2 === 1) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  \n  while (x[digit] % 2!== 0) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2!== 0) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  while (x[digit] % 2 === 1) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2 === 1) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  \n  while (x[digit] % 2!== 0) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2!== 0) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  while (x[digit] % 2 === 1) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2 === 1) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  \n  while (x[digit] % 2!== 0) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2!== 0) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  while (x[digit] % 2 === 1) {\n    digit++;\n  }\n  \n  while (digit < x.length) {\n    if (x[digit] % 2 === 1) {\n      result.push(x[digit]);\n      digit++;\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> ", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byDuration = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byDuration", "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byDuration = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedArray = reversed.map((num) => num.toString());\n  const reversedArrayString = reversedArray.map((num) => num.toString());\n  const reversedArrayStringArray = reversedArrayString.map((num) => num.toString());\n  const reversedArrayStringArrayString = reversedArrayStringArray.map((num) => num.toString());\n  const reversedArrayStringArrayStringString = reversedArrayStringArrayStringString.map((num) => num.toString());\n  const reversedArrayStringArrayStringStringStringString = reversedArrayStringArrayStringStringStringString.map((num) => num.toString());\n  const reversedArrayStringArrayStringStringStringStringString = reversedArrayStringArrayStringStringStringStringStringString.map((num) => num.toString());\n  const reversedArrayStringArrayStringStringStringStringStringString = reversedArrayStringArrayStringStringStringStringStringStringString.map((num) => num.toString());\n  const reversedArrayStringArrayStringStringStringStringStringStringStringString = reversedArrayStringArrayStringStringStringStringStringStringStringStringStringString.map((num) => num.toString());\n  const reversedArrayStringArrayStringStringStringStringStringStringStringStringStringString = reversedArrayStringArrayStringStringStringStringStringStringStringStringStringStringStringString.map((num) => num.toString());\n  const reversedArrayStringArrayStringStringStringStringStringStringStringStringStringStringStringStringStringString = reversedArrayStringArrayStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n// Test the function f with different values of n\nconst test = (n) => {\n  console.log(n);\n  console.log(f(n));\n};\n\n// Test the function f with different values of n\ntest(5);\ntest(6);\ntest(7);\ntest(8);\ntest(9);\ntest(10);\ntest(11);\ntest(12);\ntest(13);\ntest(14);\ntest(15);\ntest(16);\ntest(17);\ntest(18);\ntest(19);\ntest(20);\ntest(21);\ntest(22);\ntest(23);\ntest(24);\ntest(25);\ntest(26);\ntest(27);\ntest(28);\ntest(29);\ntest(30);\ntest(31);\ntest(32);\ntest(33);\ntest(34);\ntest(35);\ntest(36);\ntest(37);\ntest(38);\ntest(39);\ntest(40);\ntest(41);\ntest(42);\ntest(43);\ntest(44);\ntest(45);\ntest(46);\ntest(47);\ntest(48);\ntest(49);\ntest(50);\ntest(51);\ntest(52);\ntest(53);\ntest(54);\ntest(55);\ntest(56);\ntest(57);\ntest(58);\ntest(59);\ntest(60);\ntest(61);\ntest(62);\ntest(63);\ntest(64);\ntest(65);\ntest(66);\ntest(67);\ntest(68);\ntest(69);\ntest(70);\ntest(71);\ntest(72);\ntest(73);\ntest(74);\ntest(75);\ntest(76);\ntest(77);\ntest(78);\ntest(79);\ntest(80);\ntest(81);\ntest(82);\ntest(83);\ntest(84);\ntest(85);\ntest(86);\ntest(87);\ntest(88);\ntest(89);\ntest(90);\ntest(91);\ntest(92);\ntest(93);\ntest(94);\ntest(95);\ntest(96);\ntest(97);\ntest(98);\ntest(99);\ntest(100);\ntest(101);\ntest(102);\ntest(103);\ntest(104);\ntest(105);\ntest(106);\ntest(107);\ntest(108);\ntest(109);\ntest(110);\ntest(111);\ntest(112);\ntest(113);\ntest(114);\ntest(115);\ntest(116);\ntest(117);\ntest(118);\ntest(119);\ntest(120);\ntest(121);\ntest(122);\ntest(123);\ntest(124);\ntest(125);\ntest(126);\ntest(127);\ntest(128);\ntest(129);\ntest(130);\ntest(131);\ntest(132);\ntest(133);\ntest(134);\ntest(135);\ntest(136);\ntest(137);\ntest(138);\ntest(139);\ntest(140);\ntest(141);\ntest(142);\ntest(143);\ntest(144);\ntest(145);\ntest(146);\ntest(147);\ntest(148);\ntest(149);\ntest(150);\ntest(151);\ntest(152);\ntest(153);\ntest(154);\ntest(155);\ntest(156);\ntest(157);\ntest(158);\ntest(159);\ntest(160);\ntest(161);\ntest(162);\ntest(163);\ntest(164);\ntest(165);\ntest(166);\ntest(167);\ntest(168);\ntest(169);\ntest(170);\ntest(171);\ntest(172);\ntest(173);\ntest(174);\ntest(175);\ntest(176);\ntest(177);\ntest(178);\ntest(179);\ntest(180);\ntest(181);\ntest(182);\ntest(183);\ntest(184);\ntest(185);\ntest(186);\ntest(187);\ntest(188);\ntest(189);\ntest(190);\ntest(191);\ntest(192);\ntest(193);\ntest(194);\ntest(195);\ntest(196);\ntest(197);\ntest(198);\ntest(199);\ntest(200);\ntest(201);\ntest(202);\ntest(203);\ntest(204);\ntest(205);\ntest(206);\ntest(207);\ntest(208);\ntest(209);\ntest(210);\ntest(211);\ntest(212);\ntest(213);\ntest(214);\ntest(215);\ntest(216);\ntest(217);\ntest(218);\ntest(219);\ntest(220);\ntest(221);\ntest(222);\ntest(223);\ntest(224);\ntest(225);\ntest(226);\ntest(227);\ntest(228);\ntest(229);\ntest(230);\ntest(231);\ntest(232);\ntest(233);\ntest(234);\ntest(235);\ntest(236);\ntest(237);\ntest(238);\ntest(239);\ntest(240);\ntest(241);\ntest(242);\ntest(243);\ntest(244);\ntest(245);\ntest(246);\ntest(247);\ntest(248);\ntest(249);\ntest(250);\ntest(251);\ntest(252);\ntest(253);\ntest(254);\ntest(255);\ntest(256);\ntest(257);\ntest(258);\ntest(259);\ntest(260);\ntest(261);\ntest(262);\ntest(263);\ntest(264);\ntest(265);\ntest(266);\ntest(267);\ntest(268);\ntest(269);\ntest(270);\ntest(271);\ntest(272);\ntest(273);\ntest(274);\ntest(275);\ntest(276);\ntest(277);\ntest(278);\ntest(279);\ntest(280);\ntest(281);\ntest(282);\ntest(283);\ntest(284);\ntest(285);\ntest(286);\ntest(287);\ntest(288);\ntest(289);\ntest(290);\ntest(291);\ntest(292);\ntest(293);\ntest(294);\ntest(295);\ntest(296);\ntest(297);\ntest(298);\ntest(299);\ntest(300);\ntest(301);\ntest(302);\ntest(303);\ntest(304);\ntest(305);\ntest(306);\ntest(307);\ntest(308);\ntest(309);\ntest(310);\ntest(311);\ntest(312);\ntest(313);\ntest(314);\ntest(315);\ntest(316);\ntest(317);\ntest(318);\ntest(319);\ntest(320);\ntest(321);\ntest(322);\ntest(323);\ntest(324);\ntest(325);\ntest(326);\ntest(327);\ntest(328);\ntest(329);\ntest(330);\ntest(331);\ntest(332);\ntest(333);\ntest(334);\ntest(335);\ntest(336);\ntest(337);\ntest(338);\ntest(339);\ntest(340);\ntest(341);\ntest(342);\ntest(343);\ntest(344);\ntest(345);\ntest(346);\ntest(347);\ntest(348);\ntest(349);\ntest(350);\ntest(351);\ntest(352);\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(2, n), inclusive.\n\n// Example 1:\n\n//     Input: 3\n//     Output: (2, 1)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n//     Input: 12\n//     Output: (4, 6)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n//     1. 1 <= n <= 10^3\n//     2. returned tuple has the number of even and odd integer palindromes respectively.\n// \"\"\"\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(2, n), inclusive.\n\n// Example 1:\n\n//     Input: 3\n//     Output: (2, 1)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n//     Input: 12\n//     Output: (4, 6)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n//     1. 1 <= n <= 10^3\n//     2. returned tuple has the number of even and odd integer palindromes respectively.\n// \"\"\"\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(2, n), inclusive.\n\n// Example 1:\n\n//     Input: 3\n//     Output: (2, 1)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n//     Input: 12\n//     Output: (4, 6)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n//     1. 1 <= n <= 10^3\n//     2. returned tuple has the number of even and odd integer palindromes respectively.\n// \"\"\"\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(2, n), inclusive.\n\n// Example 1:\n\n//     Input: 3\n//     Output: (2, 1)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n//     Input: 12\n//     Output: (4, 6)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n//     1. 1 <= n <= 10^3\n//     2. returned tuple has the number of even and odd integer palindromes respectively.\n// \"\"\"\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(2, n), inclusive.\n\n// Example 1:\n\n//     Input: 3\n//     Output: (2, 1)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n//     Input: 12\n//     Output: (4, 6)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n//     1. 1 <= n <= 10^3\n//     2. returned tuple has the number of even and odd integer palindromes respectively.\n// \"\"\"\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(2, n), inclusive.\n\n// Example 1:\n\n//     Input: 3\n//     Output: (2, 1)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n//     Input: 12\n//     Output: (4, 6)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n//     1. 1 <= n <= 10^3\n//     2. returned tuple has the number of even and odd integer palindromes respectively.\n// \"\"\"\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(2, n), inclusive.\n\n// Example 1:\n\n//     Input: 3\n//     Output: (2, 1)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n//     Input: 12\n//     Output: (4, 6)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n//     1. 1 <= n <= 10^3\n//     2. returned tuple has the number of even and odd integer palindromes respectively.\n// \"\"\"\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(2, n), inclusive.\n\n// Example 1:\n\n//     Input: 3\n//     Output: (2, 1)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n//     Input: 12\n//     Output: (4, 6)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n//     1. 1 <= n <= 10^3\n//     2. returned tuple has the number of even and odd integer palindromes respectively.\n// \"\"\"\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(2, n), inclusive.\n\n// Example 1:\n\n//     Input: 3\n//     Output: (2, 1)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n//     Input: 12\n//     Output: (4, 6)\n//     Explanation:\n//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function considerNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> considerNums([]) == 0\n  >>> considerNums([-1, 11, -11]) == 1\n  >>> considerNums([1, 1, 2]) == 3\n  */\nconst considerNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "considerNums", "gc": "<|endoftext|>/*\n  Write a function considerNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> considerNums([]) == 0\n  >>> considerNums([-1, 11, -11]) == 1\n  >>> considerNums([1, 1, 2]) == 3\n  */\nconst considerNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function sumDigits which takes an array of integers and returns\n  the sum of the digits of its elements. If the array is empty, then the\n  result will be 0.\n  >>> sumDigits([]) == 0\n  >>> sumDigits([-1, 11, -11]) == 3\n  >>> sumDigits([1, 1, 2]) == 2\n  */\nconst sumDigits = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i].toString();\n  }\n  return sum;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([]) == []\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length === 0) {\n    return result;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i].toString());\n  }\n  return result;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length === 0) {\n    return result;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i].toString());\n  }\n  return result;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length === 0) {\n    return result;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i].toString());\n  }\n  return result;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length === 0) {\n    return result;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i].toString());\n  }\n  return result;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length === 0) {\n    return result;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i].toString());\n  }\n  return result;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length === 0) {\n    return result;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i].toString());\n  }\n  return result;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length === 0) {\n    return result;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i].toString());\n  }\n  return result;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length === 0) {\n    return result;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i].toString());\n  }\n  return result;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length === 0) {\n    return result;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i].toString());\n  }\n  return result;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length === 0) {\n    return result;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    result.push(arr[i].toString());\n  }\n  return result;\n};\n\n/*\n  Write a function sumDigitsToArray which takes an array of integers and returns\n  the array whose elements are the sum of the digits of its elements.\n  If the array is empty, then the result will be an empty array.\n  >>> sumDigitsToArray([-1, 11, -11]) == [3, 2]\n  >>> sumDigitsToArray([1, 1, 2]) == [1, 2]\n  */\nconst sumDigitsToArray = (arr) => {\n  let result = [];\n  if (arr.length", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  affectOneTestis([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  affectOneTestis([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst affectOneTestis = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "affectOneTestis", "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  affectOneTestis([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  affectOneTestis([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst affectOneTestis = (arr) => {\n  let arrCopy = arr.slice();\n  let arrCopyLength = arrCopy.length;\n  let arrCopyIndex = 0;\n  let arrCopyIndex2 = 0;\n  let arrCopyIndex3 = 0;\n  let arrCopyIndex4 = 0;\n  let arrCopyIndex5 = 0;\n  let arrCopyIndex6 = 0;\n  let arrCopyIndex7 = 0;\n  let arrCopyIndex8 = 0;\n  let arrCopyIndex9 = 0;\n  let arrCopyIndex10 = 0;\n  let arrCopyIndex11 = 0;\n  let arrCopyIndex12 = 0;\n  let arrCopyIndex13 = 0;\n  let arrCopyIndex14 = 0;\n  let arrCopyIndex15 = 0;\n  let arrCopyIndex16 = 0;\n  let arrCopyIndex17 = 0;\n  let arrCopyIndex18 = 0;\n  let arrCopyIndex19 = 0;\n  let arrCopyIndex20 = 0;\n  let arrCopyIndex21 = 0;\n  let arrCopyIndex22 = 0;\n  let arrCopyIndex23 = 0;\n  let arrCopyIndex24 = 0;\n  let arrCopyIndex25 = 0;\n  let arrCopyIndex26 = 0;\n  let arrCopyIndex27 = 0;\n  let arrCopyIndex28 = 0;\n  let arrCopyIndex29 = 0;\n  let arrCopyIndex30 = 0;\n  let arrCopyIndex31 = 0;\n  let arrCopyIndex32 = 0;\n  let arrCopyIndex33 = 0;\n  let arrCopyIndex34 = 0;\n  let arrCopyIndex35 = 0;\n  let arrCopyIndex36 = 0;\n  let arrCopyIndex37 = 0;\n  let arrCopyIndex38 = 0;\n  let arrCopyIndex39 = 0;\n  let arrCopyIndex40 = 0;\n  let arrCopyIndex41 = 0;\n  let arrCopyIndex42 = 0;\n  let arrCopyIndex43 = 0;\n  let arrCopyIndex44 = 0;\n  let arrCopyIndex45 = 0;\n  let arrCopyIndex46 = 0;\n  let arrCopyIndex47 = 0;\n  let arrCopyIndex48 = 0;\n  let arrCopyIndex49 = 0;\n  let arrCopyIndex50 = 0;\n  let arrCopyIndex51 = 0;\n  let arrCopyIndex52 = 0;\n  let arrCopyIndex53 = 0;\n  let arrCopyIndex54 = 0;\n  let arrCopyIndex55 = 0;\n  let arrCopyIndex56 = 0;\n  let arrCopyIndex57 = 0;\n  let arrCopyIndex58 = 0;\n  let arrCopyIndex59 = 0;\n  let arrCopyIndex60 = 0;\n  let arrCopyIndex61 = 0;\n  let arrCopyIndex62 = 0;\n  let arrCopyIndex63 = 0;\n  let arrCopyIndex64 = 0;\n  let arrCopyIndex65 = 0;\n  let arrCopyIndex66 = 0;\n  let arrCopyIndex67 = 0;\n  let arrCopyIndex68 = 0;\n  let arrCopyIndex69 = 0;\n  let arrCopyIndex70 = 0;\n  let arrCopyIndex71 = 0;\n  let arrCopyIndex72 = 0;\n  let arrCopyIndex73 = 0;\n  let arrCopyIndex74 = 0;\n  let arrCopyIndex75 = 0;\n  let arrCopyIndex76 = 0;\n  let arrCopyIndex77 = 0;\n  let arrCopyIndex78 = 0;\n  let arrCopyIndex79 = 0;\n  let arrCopyIndex80 = 0;\n  let arrCopyIndex81 = 0;\n  let arrCopyIndex82 = 0;\n  let arrCopyIndex83 = 0;\n  let arrCopyIndex84 = 0;\n  let arrCopyIndex85 = 0;\n  let arrCopyIndex86 = 0;\n  let arrCopyIndex87 = 0;\n  let arrCopyIndex88 = 0;\n  let arrCopyIndex89 = 0;\n  let arrCopyIndex90 = 0;\n  let arrCopyIndex91 = 0;\n  let arrCopyIndex92 = 0;\n  let arrCopyIndex93 = 0;\n  let arrCopyIndex94 = 0;\n  let arrCopyIndex95 = 0;\n  let arrCopyIndex96 = 0;\n  let arrCopyIndex97 = 0;\n  let arrCopyIndex98 = 0;\n  let arrCopyIndex99 = 0;\n  let arrCopyIndex100 = 0;\n  let arrCopyIndex101 = 0;\n  let arrCopyIndex102 = 0;\n  let arrCopyIndex103 = 0;\n  let arrCopyIndex104 = 0;\n  let arrCopyIndex105 = 0;\n  let arrCopyIndex106 = 0;\n  let arrCopyIndex107 = 0;\n  let arrCopyIndex108 = 0;\n  let arrCopyIndex109 = 0;\n  let arrCopyIndex110 = 0;\n  let arrCopyIndex111 = 0;\n  let arrCopyIndex112 = 0;\n  let arrCopyIndex113 = 0;\n  let arrCopyIndex114 = 0;\n  let arrCopyIndex115 = 0;\n  let arrCopyIndex116 = 0;\n  let arrCopyIndex117 = 0;\n  let arrCopyIndex118 = 0;\n  let arrCopyIndex119 = 0;\n  let arrCopyIndex120 = 0;\n  let arrCopyIndex121 = 0;\n  let arrCopyIndex122 = 0;\n  let arrCopyIndex123 = 0;\n  let arrCopyIndex124 = 0;\n  let arrCopyIndex125 = 0;\n  let arrCopyIndex126 = 0;\n  let arrCopyIndex127 = 0;\n  let arrCopyIndex128 = 0;\n  let arrCopyIndex129 = 0;\n  let arrCopyIndex130 = 0;\n  let arrCopyIndex131 = 0;\n  let arrCopyIndex132 = 0;\n  let arrCopyIndex133 = 0;\n  let arrCopyIndex134 = 0;\n  let arrCopyIndex135 = 0;\n  let arrCopyIndex136 = 0;\n  let arrCopyIndex137 = 0;\n  let arrCopyIndex138 = 0;\n  let arrCopyIndex139 = 0;\n  let arrCopyIndex140 = 0;\n  let arrCopyIndex141 = 0;\n  let arrCopyIndex142 = 0;\n  let arrCopyIndex143 = 0;\n  let arrCopyIndex144 = 0;\n  let arrCopyIndex145 = 0;\n  let arrCopyIndex146 = 0;\n  let arrCopyIndex147 = 0;\n  let arrCopyIndex148 = 0;\n  let arrCopyIndex149 = 0;\n  let arrCopyIndex150 = 0;\n  let arrCopyIndex151 = 0;\n  let arrCopyIndex152 = 0;\n  let arrCopyIndex153 = 0;\n  let arrCopyIndex154 = 0;\n  let arrCopyIndex155 = 0;\n  let arrCopyIndex156 = 0;\n  let arrCopyIndex157 = 0;\n  let arrCopyIndex158 = 0;\n  let arrCopyIndex159 = 0;\n  let arrCopyIndex160 = 0;\n  let arrCopyIndex161 = 0;\n  let arrCopyIndex162 = 0;\n  let arrCopyIndex163 = 0;\n  let arrCopyIndex164 = 0;\n  let arrCopyIndex165 = 0;\n  let arrCopyIndex166 = 0;\n  let arrCopyIndex167 = 0;\n  let arrCopyIndex168 = 0;\n  let arrCopyIndex169 = 0;\n  let arrCopyIndex170 = 0;\n  let arrCopyIndex171 = 0;\n  let arrCopyIndex172 = 0;\n  let arrCopyIndex173 = 0;\n  let arrCopyIndex174 = 0;\n  let arrCopyIndex175 = 0;\n  let arrCopyIndex176 = 0;\n  let arrCopyIndex177 = 0;\n  let arrCopyIndex178 = 0;\n  let arrCopyIndex179 = 0;\n  let arrCopyIndex180 = 0;\n  let arrCopyIndex181 = 0;\n  let arrCopyIndex182 = 0;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor('010', '110')\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "bowedStringedInstrumentXor", "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor('010', '110')\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an central of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of centrald elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst central = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "central", "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an central of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of centrald elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst central = (lst1, lst2) => {\n  let isCentral = true;\n  let isEven = true;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      isEven = false;\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      isEven = false;\n    }\n  }\n  if (isEven === true) {\n    isCentral = false;\n  }\n  return isCentral;\n};\n\n/*\n  Write a function that takes two lists of numbers, and determines whether it\n  is possible to perform an central of elements between them to make lst1 a\n  list of only odd numbers. There is no limit on the number of centrald\n  elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst centralOdd = (lst1, lst2) => {\n  let isCentral = true;\n  let isOdd = true;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 1) {\n      isOdd = false;\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 1) {\n      isOdd = false;\n    }\n  }\n  if (isOdd === true) {\n    isCentral = false;\n  }\n  return isCentral;\n};\n\n/*\n  Write a function that takes two lists of numbers, and determines whether it\n  is possible to perform an central of elements between them to make lst1 a\n  list of only even numbers. There is no limit on the number of centrald\n  elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst centralEven = (lst1, lst2) => {\n  let isCentral = true;\n  let isEven = true;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      isEven = false;\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      isEven = false;\n    }\n  }\n  if (isEven === true) {\n    isCentral = false;\n  }\n  return isCentral;\n};\n\n/*\n  Write a function that takes two lists of numbers, and determines whether it\n  is possible to perform an central of elements between them to make lst1 a\n  list of only odd numbers. There is no limit on the number of centrald\n  elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst centralOddEven = (lst1, lst2) => {\n  let isCentral = true;\n  let isOdd = true;\n  let isEven = true;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 1) {\n      isOdd = false;\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 1) {\n      isOdd = false;\n    }\n  }\n  if (isOdd === true) {\n    isCentral = false;\n  }\n  if (isEven === true) {\n    isCentral = false;\n  }\n  return isCentral;\n};\n\n/*\n  Write a function that takes two lists of numbers, and determines whether it\n  is possible to perform an central of elements between them to make lst1 a\n  list of only odd numbers. There is no limit on the number of centrald\n  elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst centralOddOdd = (lst1, lst2) => {\n  let isCentral = true;\n  let isOdd = true;\n  let isEven = true;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 1) {\n      isOdd = false;\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 1) {\n      isOdd = false;\n    }\n  }\n  if (isOdd === true) {\n    isCentral = false;\n  }\n  if (isEven === true) {\n    isCentral = false;\n  }\n  return isCentral;\n};\n\n/*\n  Write a function that takes two lists of numbers, and determines whether it\n  is possible to perform an central of elements between them to make lst1 a\n  list of only odd numbers. There is no limit on the number of centrald\n  elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst centralOddEvenOdd = (lst1, lst2) => {\n  let isCentral = true;\n  let isOdd = true;\n  let isEven = true;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 1) {\n      isOdd = false;\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 1) {\n      isOdd = false;\n    }\n  }\n  if (isOdd === true) {\n    isCentral = false;\n  }\n  if (isEven === true) {\n    isCentral = false;\n  }\n  return isCentral;\n};\n\n/*\n  Write a function that takes two lists of numbers, and determines whether it\n  is possible to perform an central of elements between them to make lst1 a\n  list of only odd numbers. There is no limit on the number of centrald\n  elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst centralOddOddEvenOddOdd = (lst1, lst2) => {\n  let isCentral = true;\n  let isOdd = true;\n  let isEven = true;", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "gc": "<|endoftext|>/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  letters.forEach((letter) => {\n    letterMap[letter] = letterMap[letter] || 0;\n    letterMap[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst letterFrequency = () => {\n  const letterMap = {};\n  const letters = histogram('a b c');\n  letters.forEach((letter) => {\n    letterMap[letter] = letterMap[letter] || 0;\n    letterMap[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  letterFrequency('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequency('a b b a') == {'a': 2, 'b': 2}\n  letterFrequency('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequency('b b b b a') == {'b': 4}\n  letterFrequency('') == {}\n\n  */\nconst letterFrequencies = () => {\n  const letterMap = {};\n  const letters = histogram('a b c');\n  letters.forEach((letter) => {\n    letterMap[letter] = letterMap[letter] || 0;\n    letterMap[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  letterFrequencies('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequencies('a b b a') == {'a': 2, 'b': 2}\n  letterFrequencies('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequencies('b b b b a') == {'b': 4}\n  letterFrequencies('') == {}\n\n  */\nconst letterFrequenciesWithLetters = () => {\n  const letterMap = {};\n  const letters = histogram('a b c');\n  letters.forEach((letter) => {\n    letterMap[letter] = letterMap[letter] || 0;\n    letterMap[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  letterFrequenciesWithLetters('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequenciesWithLetters('a b b a') == {'a': 2, 'b': 2}\n  letterFrequenciesWithLetters('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequenciesWithLetters('b b b b a') == {'b': 4}\n  letterFrequenciesWithLetters('') == {}\n\n  */\nconst letterFrequenciesWithLettersAndFrequencies = () => {\n  const letterMap = {};\n  const letters = histogram('a b c');\n  letters.forEach((letter) => {\n    letterMap[letter] = letterMap[letter] || 0;\n    letterMap[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  letterFrequenciesWithLettersAndFrequencies('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequenciesWithLettersAndFrequencies('a b b a') == {'a': 2, 'b': 2}\n  letterFrequenciesWithLettersAndFrequencies('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequenciesWithLettersAndFrequencies('b b b b a') == {'b': 4}\n  letterFrequenciesWithLettersAndFrequencies('') == {}\n\n  */\nconst letterFrequenciesWithLettersAndFrequenciesAndLetters = () => {\n  const letterMap = {};\n  const letters = histogram('a b c');\n  letters.forEach((letter) => {\n    letterMap[letter] = letterMap[letter] || 0;\n    letterMap[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  letterFrequenciesWithLettersAndFrequenciesAndLetters('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequenciesWithLettersAndFrequenciesAndLetters('a b b a') == {'a': 2, 'b': 2}\n  letterFrequenciesWithLettersAndFrequenciesAndLetters('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequenciesWithLettersAndFrequenciesAndLetters('b b b b a') == {'b': 4}\n  letterFrequenciesWithLettersAndFrequenciesAndLetters('') == {}\n\n  */\nconst letterFrequenciesWithLettersAndFrequenciesAndLettersAndFrequencies = () => {\n  const letterMap = {};\n  const letters = histogram('a b c');\n  letters.forEach((letter) => {\n    letterMap[letter] = letterMap[letter] || 0;\n    letterMap[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  letterFrequenciesWithLettersAndFrequenciesAndLettersAndFrequencies('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequenciesWithLettersAndFrequenciesAndLettersAndFrequencies('a b b a') == {'a': 2, 'b': 2}\n  letterFrequenciesWithLettersAndFrequenciesAndLettersAndFrequencies('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequenciesWithLettersAndFrequenciesAndLettersAndFrequencies('b b b b a') == {'b': 4}\n  letterFrequenciesWithLettersAndFrequenciesAndLettersAndFrequencies('') == {}\n\n  */\nconst letterFrequenciesWithLettersAndFrequenciesAndLettersAndFrequenciesAndLetters = () => {\n  const letterMap = {};\n  const letters = histogram('a b c');\n  letters.forEach((letter) => {\n    letterMap[letter] = letterMap[letter] || 0;\n    letterMap[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst invertDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "invertDelete", "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst invertDelete = (s, c) => {\n  let result = ''\n  let isPalindrome = false\n  let reverse = ''\n  let reversed = ''\n  let reversedS = ''\n  let reversedC = ''\n  let reversedSIndex = 0\n  let reversedCIndex = 0\n  let reversedSIndex2 = 0\n  let reversedCIndex2 = 0\n  let reversedSIndex3 = 0\n  let reversedCIndex3 = 0\n  let reversedSIndex4 = 0\n  let reversedCIndex4 = 0\n  let reversedSIndex5 = 0\n  let reversedCIndex5 = 0\n  let reversedSIndex6 = 0\n  let reversedCIndex6 = 0\n  let reversedSIndex7 = 0\n  let reversedCIndex7 = 0\n  let reversedSIndex8 = 0\n  let reversedCIndex8 = 0\n  let reversedSIndex9 = 0\n  let reversedCIndex9 = 0\n  let reversedSIndex10 = 0\n  let reversedCIndex10 = 0\n  let reversedSIndex11 = 0\n  let reversedCIndex11 = 0\n  let reversedSIndex12 = 0\n  let reversedCIndex12 = 0\n  let reversedSIndex13 = 0\n  let reversedCIndex13 = 0\n  let reversedSIndex14 = 0\n  let reversedCIndex14 = 0\n  let reversedSIndex15 = 0\n  let reversedCIndex15 = 0\n  let reversedSIndex16 = 0\n  let reversedCIndex16 = 0\n  let reversedSIndex17 = 0\n  let reversedCIndex17 = 0\n  let reversedSIndex18 = 0\n  let reversedCIndex18 = 0\n  let reversedSIndex19 = 0\n  let reversedCIndex19 = 0\n  let reversedSIndex20 = 0\n  let reversedCIndex20 = 0\n  let reversedSIndex21 = 0\n  let reversedCIndex21 = 0\n  let reversedSIndex22 = 0\n  let reversedCIndex22 = 0\n  let reversedSIndex23 = 0\n  let reversedCIndex23 = 0\n  let reversedSIndex24 = 0\n  let reversedCIndex24 = 0\n  let reversedSIndex25 = 0\n  let reversedCIndex25 = 0\n  let reversedSIndex26 = 0\n  let reversedCIndex26 = 0\n  let reversedSIndex27 = 0\n  let reversedCIndex27 = 0\n  let reversedSIndex28 = 0\n  let reversedCIndex28 = 0\n  let reversedSIndex29 = 0\n  let reversedCIndex29 = 0\n  let reversedSIndex30 = 0\n  let reversedCIndex30 = 0\n  let reversedSIndex31 = 0\n  let reversedCIndex31 = 0\n  let reversedSIndex32 = 0\n  let reversedCIndex32 = 0\n  let reversedSIndex33 = 0\n  let reversedCIndex33 = 0\n  let reversedSIndex34 = 0\n  let reversedCIndex34 = 0\n  let reversedSIndex35 = 0\n  let reversedCIndex35 = 0\n  let reversedSIndex36 = 0\n  let reversedCIndex36 = 0\n  let reversedSIndex37 = 0\n  let reversedCIndex37 = 0\n  let reversedSIndex38 = 0\n  let reversedCIndex38 = 0\n  let reversedSIndex39 = 0\n  let reversedCIndex39 = 0\n  let reversedSIndex40 = 0\n  let reversedCIndex40 = 0\n  let reversedSIndex41 = 0\n  let reversedCIndex41 = 0\n  let reversedSIndex42 = 0\n  let reversedCIndex42 = 0\n  let reversedSIndex43 = 0\n  let reversedCIndex43 = 0\n  let reversedSIndex44 = 0\n  let reversedCIndex44 = 0\n  let reversedSIndex45 = 0\n  let reversedCIndex45 = 0\n  let reversedSIndex46 = 0\n  let reversedCIndex46 = 0\n  let reversedSIndex47 = 0\n  let reversedCIndex47 = 0\n  let reversedSIndex48 = 0\n  let reversedCIndex48 = 0\n  let reversedSIndex49 = 0\n  let reversedCIndex49 = 0\n  let reversedSIndex50 = 0\n  let reversedCIndex50 = 0\n  let reversedSIndex51 = 0\n  let reversedCIndex51 = 0\n  let reversedSIndex52 = 0\n  let reversedCIndex52 = 0\n  let reversedSIndex53 = 0\n  let reversedCIndex53 = 0\n  let reversedSIndex54 = 0\n  let reversedCIndex54 = 0\n  let reversedSIndex55 = 0\n  let reversedCIndex55 = 0\n  let reversedSIndex56 = 0\n  let reversedCIndex56 = 0\n  let reversedSIndex57 = 0\n  let reversedCIndex57 = 0\n  let reversedSIndex58 = 0\n  let reversedCIndex58 = 0\n  let reversedSIndex59 = 0\n  let reversedCIndex59 = 0\n  let reversedSIndex60 = 0\n  let reversedCIndex60 = 0\n  let reversedSIndex61 = 0\n  let reversedCIndex61 = 0\n  let reversedSIndex62 = 0\n  let reversedCIndex62 = 0\n  let reversedSIndex63 = 0\n  let reversedCIndex63 = 0\n  let reversedSIndex64 = 0\n  let reversedCIndex64 = 0\n  let reversedSIndex65 = 0\n  let reversedCIndex65 = 0\n  let reversedSIndex66 = 0\n  let reversedCIndex66 = 0\n  let reversedSIndex67 = 0\n  let reversedCIndex67 = 0\n  let reversedSIndex68 = 0\n  let reversedCIndex68 = 0\n  let reversedSIndex69 = 0\n  let reversedCIndex69 = 0\n  let reversedSIndex70 = 0\n  let reversedCIndex70 = 0\n  let reversedSIndex71 = 0\n  let reversedCIndex71 = 0\n  let reversedSIndex72 = 0\n  let reversedCIndex72 = 0\n  let reversedSIndex73 = 0\n  let reversedCIndex73 = 0\n  let reversedSIndex74 = 0\n  let reversedCIndex74 = 0\n  let reversedSIndex75 = 0\n  let reversedCIndex75 = 0\n  let reversedSIndex76 = 0\n  let reversedCIndex76 = 0\n  let reversedSIndex77 = 0\n  let reversedCIndex77 = 0\n  let reversedSIndex78 = 0\n  let reversedCIndex78 = 0\n  let reversedSIndex79 = 0\n  let reversedCIndex79 = 0\n  let reversedSIndex80 = 0\n  let reversedCIndex80 = 0\n  let reversedSIndex81 = 0\n  let reversedCIndex81 = 0\n  let reversedSIndex82 = 0\n  let reversedCIndex82 = 0\n  let reversedSIndex83 = 0\n  let reversedCIndex83 = 0\n  let reversedSIndex84 = 0\n  let reversedCIndex84 = 0\n  let reversedSIndex85 = 0\n  let reversedCIndex85 = 0\n  let reversedSIndex86 = 0\n  let reversed", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> curiousCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> curiousCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst curiousCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "curiousCount", "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> curiousCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> curiousCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst curiousCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length % 2 === 0) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length % 2!== 0) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length % 2 === 0) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length % 2!== 0) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length % 2!== 0) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length % 2!== 0) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length % 2!== 0) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length % 2!== 0) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minuteSubArraySum", "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArraySum = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == 6\n  */\nconst minuteSubArrayMaxSum = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArrayMaxSum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArrayMaxSum([-1, -2, -3]) == 6\n  */\nconst minuteSubArrayMinSum = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArrayMinSum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArrayMinSum([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMin = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMin([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMin([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinMax = (nums) => {\n  let sum = 0;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst soapFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "soapFill", "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst soapFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = [];\n    const buckets = new Array(m);\n    \n    for(let i = 0; i < n; i++) {\n        buckets[i] = new Array(n);\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                buckets[i][j] = 1;\n            } else {\n                buckets[i][j] = 0;\n            }\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(buckets[i][j] === capacity) {\n                result.push(0);\n            } else {\n                result.push(1);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Your SoapFill function will be called as follows:\n *\n * let result = soapFill(grid, capacity)\n * \n * console.log(result)\n * \n * Input: \n *     grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *     capacity : 1\n * Output: 6\n */\nconst soapFill2 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = [];\n    const buckets = new Array(m);\n    \n    for(let i = 0; i < n; i++) {\n        buckets[i] = new Array(n);\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                buckets[i][j] = 1;\n            } else {\n                buckets[i][j] = 0;\n            }\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(buckets[i][j] === 1) {\n                result.push(0);\n            } else {\n                result.push(1);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Your SoapFill function will be called as follows:\n *\n * let result = soapFill(grid, capacity)\n * \n * console.log(result)\n * \n * Input: \n *     grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *     capacity : 2\n * Output: 5\n */\nconst soapFill3 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = [];\n    const buckets = new Array(m);\n    \n    for(let i = 0; i < n; i++) {\n        buckets[i] = new Array(n);\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                buckets[i][j] = 1;\n            } else {\n                buckets[i][j] = 0;\n            }\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(buckets[i][j] === 1) {\n                result.push(0);\n            } else {\n                result.push(1);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Your SoapFill function will be called as follows:\n *\n * let result = soapFill(grid, capacity)\n * \n * console.log(result)\n * \n * Input: \n *     grid : [[0,0,0], [0,0,0]]\n *     capacity : 5\n * Output: 0\n */\nconst soapFill4 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = [];\n    const buckets = new Array(m);\n    \n    for(let i = 0; i < n; i++) {\n        buckets[i] = new Array(n);\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                buckets[i][j] = 1;\n            } else {\n                buckets[i][j] = 0;\n            }\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(buckets[i][j] === 1) {\n                result.push(0);\n            } else {\n                result.push(1);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Your SoapFill function will be called as follows:\n *\n * let result = soapFill(grid, capacity)\n * \n * console.log(result)\n * \n * Input: \n *     grid : [[0,0,0], [0,0,0]]\n *     capacity : 5\n * Output: 0\n */\nconst soapFill5 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = [];\n    const buckets = new Array(m);\n    \n    for(let i = 0; i < n; i++) {\n        buckets[i] = new Array(n);\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                buckets[i][j] = 1;\n            } else {\n                buckets[i][j] = 0;\n            }\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(buckets[i][j] === 1) {\n                result.push(0);\n            } else {\n                result.push(1);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Your SoapFill function will be called as follows:\n *\n * let result = soapFill(grid, capacity)\n * \n * console.log(result)\n * \n * Input: \n *     grid : [[0,0,0], [0,0,0]]\n *     capacity : 5\n * Output: 0\n */\nconst soapFill6 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = [];\n    const buckets = new Array(m);\n    \n    for(let i = 0; i < n; i++) {\n        buckets[i] = new Array(n);\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                buckets[i][j] = 1;\n            } else {\n                buckets[i][j] = 0;\n            }\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(buckets[i][j] === 1) {\n                result.push(0);\n            } else {\n                result.push(1);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Your SoapFill function will be called as follows:\n *\n * let result = soapFill(grid, capacity)\n * \n * console.log(result)\n * \n * Input: \n *     grid : [[0,0,0], [0,0,0]]\n *     capacity : 5\n * Output: 0\n */\nconst soapFill7 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = [];\n    const buckets = new Array(m);\n    \n    for(let i = 0; i < n; i++) {\n        buckets[i] = new Array(n);\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                buckets[i][j] = 1;\n            } else {\n                buckets[i][j] = 0;\n            }\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(buckets[i][j] === 1) {\n                result.push(0);\n            } else {\n                result.push(1);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Your SoapFill function will be called as follows:\n *\n * let result = soapFill(grid, capacity)\n * \n * console.log(result)\n * \n * Input: \n *     grid : [[", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  return sorted.map((num) => parseInt(num, 2));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their binary representation\n// in ascending order.\nconst sortArrayInAscendingOrder = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 2));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in descending order according to their binary representation\n// in ascending order.\nconst sortArrayInDescendingOrder = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 2));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in ascending order.\nconst sortArrayInDecimalOrder = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in descending order according to their decimal representation\n// in ascending order.\nconst sortArrayInDecimalDescendingOrder = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in descending order.\nconst sortArrayInDecimalAscendingOrder = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in descending order.\nconst sortArrayInDecimalDescendingOrderReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in ascending order.\nconst sortArrayInDecimalAscendingOrderReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in descending order.\nconst sortArrayInDecimalDescendingOrderReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in descending order.\nconst sortArrayInDecimalAscendingOrderReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in ascending order.\nconst sortArrayInDecimalDescendingOrderReversedReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in descending order.\nconst sortArrayInDecimalAscendingOrderReversedReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in ascending order.\nconst sortArrayInDecimalDescendingOrderReversedReversedReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in ascending order.\nconst sortArrayInDecimalAscendingOrderReversedReversedReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in descending order.\nconst sortArrayInDecimalDescendingOrderReversedReversedReversedReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in ascending order.\nconst sortArrayInDecimalAscendingOrderReversedReversedReversedReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in descending order.\nconst sortArrayInDecimalDescendingOrderReversedReversedReversedReversedReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in ascending order.\nconst sortArrayInDecimalAscendingOrderReversedReversedReversedReversedReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in descending order.\nconst sortArrayInDecimalDescendingOrderReversedReversedReversedReversedReversedReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in ascending order.\nconst sortArrayInDecimalAscendingOrderReversedReversedReversedReversedReversedReversedReversed = (arr) => {\n  const sorted = sortArray(arr);\n  return sorted.map((num) => parseInt(num, 10));\n};\n\n// Given an array of non-negative integers, return an array of integers that\n// are sorted in ascending order according to their decimal representation\n// in descending order.\nconst sortArrayInDecimalDescendingOrderReversedReversedReversedReversedReversedReversedReversedReversed = (arr", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  choiceDiscussion(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  choiceDiscussion(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  choiceDiscussion(\"simple white space\", 2) ==> []\n  choiceDiscussion(\"Hello world\", 4) ==> [\"world\"]\n  choiceDiscussion(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst choiceDiscussion = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "choiceDiscussion", "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  choiceDiscussion(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  choiceDiscussion(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  choiceDiscussion(\"simple white space\", 2) ==> []\n  choiceDiscussion(\"Hello world\", 4) ==> [\"world\"]\n  choiceDiscussion(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst choiceDiscussion = (s, n) => {\n  let words = [];\n  let word = '';\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n  let count = 0;\n  let j = 0;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  catchClosestVowel(\"yogurt\") ==> \"u\"\n  catchClosestVowel(\"FULL\") ==> \"U\"\n  catchClosestVowel(\"quick\") ==> \"\"\n  catchClosestVowel(\"ab\") ==> \"\"\n  */\nconst catchClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "catchClosestVowel", "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  catchClosestVowel(\"yogurt\") ==> \"u\"\n  catchClosestVowel(\"FULL\") ==> \"U\"\n  catchClosestVowel(\"quick\") ==> \"\"\n  catchClosestVowel(\"ab\") ==> \"\"\n  */\nconst catchClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelIndex = 0;\n  let vowelLength = 0;\n  let vowelWord = '';\n  let vowelWordLength = 0;\n  let vowelWordIndex = 0;\n  let vowelWordLengthIndex = 0;\n  let vowelWordIndex2 = 0;\n  let vowelWordLengthIndex2 = 0;\n  let vowelWordIndex3 = 0;\n  let vowelWordLengthIndex3 = 0;\n  let vowelWordIndex4 = 0;\n  let vowelWordLengthIndex4 = 0;\n  let vowelWordIndex5 = 0;\n  let vowelWordLengthIndex5 = 0;\n  let vowelWordIndex6 = 0;\n  let vowelWordLengthIndex6 = 0;\n  let vowelWordIndex7 = 0;\n  let vowelWordLengthIndex7 = 0;\n  let vowelWordIndex8 = 0;\n  let vowelWordLengthIndex8 = 0;\n  let vowelWordIndex9 = 0;\n  let vowelWordLengthIndex9 = 0;\n  let vowelWordIndex10 = 0;\n  let vowelWordLengthIndex10 = 0;\n  let vowelWordIndex11 = 0;\n  let vowelWordLengthIndex11 = 0;\n  let vowelWordIndex12 = 0;\n  let vowelWordLengthIndex12 = 0;\n  let vowelWordIndex13 = 0;\n  let vowelWordLengthIndex13 = 0;\n  let vowelWordIndex14 = 0;\n  let vowelWordLengthIndex14 = 0;\n  let vowelWordIndex15 = 0;\n  let vowelWordLengthIndex15 = 0;\n  let vowelWordIndex16 = 0;\n  let vowelWordLengthIndex16 = 0;\n  let vowelWordIndex17 = 0;\n  let vowelWordLengthIndex17 = 0;\n  let vowelWordIndex18 = 0;\n  let vowelWordLengthIndex18 = 0;\n  let vowelWordIndex19 = 0;\n  let vowelWordLengthIndex19 = 0;\n  let vowelWordIndex20 = 0;\n  let vowelWordLengthIndex20 = 0;\n  let vowelWordIndex21 = 0;\n  let vowelWordLengthIndex21 = 0;\n  let vowelWordIndex22 = 0;\n  let vowelWordLengthIndex22 = 0;\n  let vowelWordIndex23 = 0;\n  let vowelWordLengthIndex23 = 0;\n  let vowelWordIndex24 = 0;\n  let vowelWordLengthIndex24 = 0;\n  let vowelWordIndex25 = 0;\n  let vowelWordLengthIndex25 = 0;\n  let vowelWordIndex26 = 0;\n  let vowelWordLengthIndex26 = 0;\n  let vowelWordIndex27 = 0;\n  let vowelWordLengthIndex27 = 0;\n  let vowelWordIndex28 = 0;\n  let vowelWordLengthIndex28 = 0;\n  let vowelWordIndex29 = 0;\n  let vowelWordLengthIndex29 = 0;\n  let vowelWordIndex30 = 0;\n  let vowelWordLengthIndex30 = 0;\n  let vowelWordIndex31 = 0;\n  let vowelWordLengthIndex31 = 0;\n  let vowelWordIndex32 = 0;\n  let vowelWordLengthIndex32 = 0;\n  let vowelWordIndex33 = 0;\n  let vowelWordLengthIndex33 = 0;\n  let vowelWordIndex34 = 0;\n  let vowelWordLengthIndex34 = 0;\n  let vowelWordIndex35 = 0;\n  let vowelWordLengthIndex35 = 0;\n  let vowelWordIndex36 = 0;\n  let vowelWordLengthIndex36 = 0;\n  let vowelWordIndex37 = 0;\n  let vowelWordLengthIndex37 = 0;\n  let vowelWordIndex38 = 0;\n  let vowelWordLengthIndex38 = 0;\n  let vowelWordIndex39 = 0;\n  let vowelWordLengthIndex39 = 0;\n  let vowelWordIndex40 = 0;\n  let vowelWordLengthIndex40 = 0;\n  let vowelWordIndex41 = 0;\n  let vowelWordLengthIndex41 = 0;\n  let vowelWordIndex42 = 0;\n  let vowelWordLengthIndex42 = 0;\n  let vowelWordIndex43 = 0;\n  let vowelWordLengthIndex43 = 0;\n  let vowelWordIndex44 = 0;\n  let vowelWordLengthIndex44 = 0;\n  let vowelWordIndex45 = 0;\n  let vowelWordLengthIndex45 = 0;\n  let vowelWordIndex46 = 0;\n  let vowelWordLengthIndex46 = 0;\n  let vowelWordIndex47 = 0;\n  let vowelWordLengthIndex47 = 0;\n  let vowelWordIndex48 = 0;\n  let vowelWordLengthIndex48 = 0;\n  let vowelWordIndex49 = 0;\n  let vowelWordLengthIndex49 = 0;\n  let vowelWordIndex50 = 0;\n  let vowelWordLengthIndex50 = 0;\n  let vowelWordIndex51 = 0;\n  let vowelWordLengthIndex51 = 0;\n  let vowelWordIndex52 = 0;\n  let vowelWordLengthIndex52 = 0;\n  let vowelWordIndex53 = 0;\n  let vowelWordLengthIndex53 = 0;\n  let vowelWordIndex54 = 0;\n  let vowelWordLengthIndex54 = 0;\n  let vowelWordIndex55 = 0;\n  let vowelWordLengthIndex55 = 0;\n  let vowelWordIndex56 = 0;\n  let vowelWordLengthIndex56 = 0;\n  let vowelWordIndex57 = 0;\n  let vowelWordLengthIndex57 = 0;\n  let vowelWordIndex58 = 0;\n  let vowelWordLengthIndex58 = 0;\n  let vowelWordIndex59 = 0;\n  let vowelWordLengthIndex59 = 0;\n  let vowelWordIndex60 = 0;\n  let vowelWordLengthIndex60 = 0;\n  let vowelWordIndex61 = 0;\n  let vowelWordLengthIndex61 = 0;\n  let vowelWordIndex62 = 0;\n  let vowelWordLengthIndex62 = 0;\n  let vowelWordIndex63 = 0;\n  let vowelWordLengthIndex63 = 0;\n  let vowelWordIndex64 = 0;\n  let vowelWordLengthIndex64 = 0;\n  let vowelWordIndex65 = 0;\n  let vowelWordLengthIndex65 = 0;\n  let vowelWordIndex66 = 0;\n  let vowelWordLengthIndex66 = 0;\n  let vowelWordIndex67 = 0;\n  let vowelWordLengthIndex67 = 0;\n  let vowelWordIndex68 = 0;\n  let vowelWordLengthIndex68 = 0;\n  let vowelWordIndex69 = 0;\n  let vowelWordLengthIndex69 = 0;\n  let vowelWordIndex70 = 0;\n  let vowelWordLengthIndex70 = 0;\n  let vowelWordIndex71 = 0;\n  let vowelWordLengthIndex71 = 0;\n  let vowelWordIndex72 = 0;\n  let vowelWordLengthIndex72 = 0;\n  let vowelWordIndex73 = 0;\n  let vowelWordLengthIndex73 = 0;\n  let vowelWordIndex74 = 0;\n  let vowelWordLengthIndex74 = 0;\n  let vowelWordIndex75 = 0;\n  let vowelWordLengthIndex75 = 0;\n  let vowelWordIndex76 = 0;\n  let vowelWordLengthIndex76 = 0;\n  let vowelWordIndex77 = 0;\n  let vowelWordLengthIndex77 = 0;\n  let vowelWordIndex78 = 0;\n  let vowelWordLengthIndex78 = 0;\n  let vowelWordIndex79 = 0;\n  let vowelWordLengthIndex79 = 0;\n  let vowelWordIndex80 = 0;\n  let vowelWordLengthIndex80 = 0;\n  let vowelWordIndex81 = 0;\n  let vowelWordLengthIndex81 = 0;\n  let vowelWordIndex82 = 0;\n  let vowelWordLengthIndex82 = 0;\n  let vowelWordIndex83 = 0;\n  let vowelWordLengthIndex83 = 0;\n  let vowelWordIndex84 = 0;\n  let vowelWordLengthIndex84 = 0;\n  let vowelWordIndex85 = 0;\n  let vowelWordLengthIndex85 = 0;\n  let vowelWordIndex86 = 0;\n  let vowelWordLengthIndex86 = 0;\n  let vowelWordIndex87 = 0;\n  let vowelWordLengthIndex87 = 0;\n  let vowelWordIndex88 = 0;\n  let vowelWordLengthIndex88 = 0;\n  let vowelWordIndex89 = 0;\n  let vowelWordLengthIndex89 = 0;\n  let vowelWordIndex90 = 0;\n  let vowelWordLengthIndex90 = 0;\n  let vowelWordIndex91 = 0;\n  let vowel", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  catchParens(['()(', ')']) == 'Yes'\n  catchParens([')', ')']) == 'No'\n  */\nconst catchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "catchParens", "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  catchParens(['()(', ')']) == 'Yes'\n  catchParens([')', ')']) == 'No'\n  */\nconst catchParens = (lst) => {\n  let stack = []\n  let result = ''\n  let isBalanced = false\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length > 0) {\n        result += stack.pop()\n        isBalanced = isBalanced || (stack.length === 0)\n      }\n    }\n  }\n  return isBalanced\n}\n\nmodule.exports = catchParens\n\n},{}],3:[function(require,module,exports){\n'use strict'\n\nconst catchParens = require('./catchParens')\n\nconst isBalanced = (lst) => {\n  let stack = []\n  let result = ''\n  let isBalanced = false\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length > 0) {\n        result += stack.pop()\n        isBalanced = isBalanced || (stack.length === 0)\n      }\n    }\n  }\n  return isBalanced\n}\n\nmodule.exports = isBalanced\n\n},{\"./catchParens\":2}],4:[function(require,module,exports){\n'use strict'\n\nconst isBalanced = require('./isBalanced')\n\nconst catchParens = require('./catchParens')\n\nconst isParenthesisBalanced = (lst) => {\n  let stack = []\n  let result = ''\n  let isParenthesisBalanced = false\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length > 0) {\n        result += stack.pop()\n        isParenthesisBalanced = isParenthesisBalanced || (stack.length === 0)\n      }\n    }\n  }\n  return isParenthesisBalanced\n}\n\nmodule.exports = isParenthesisBalanced\n\n},{\"./catchParens\":2,\"./isBalanced\":5}],5:[function(require,module,exports){\n'use strict'\n\nconst isBalanced = require('./isBalanced')\n\nconst catchParens = require('./catchParens')\n\nconst isParenthesisBalanced = (lst) => {\n  let stack = []\n  let result = ''\n  let isParenthesisBalanced = false\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length > 0) {\n        result += stack.pop()\n        isParenthesisBalanced = isParenthesisBalanced || (stack.length === 0)\n      }\n    }\n  }\n  return isParenthesisBalanced\n}\n\nmodule.exports = isParenthesisBalanced\n\n},{\"./catchParens\":2,\"./isBalanced\":4}],6:[function(require,module,exports){\n'use strict'\n\nconst isParenthesisBalanced = require('./isParenthesisBalanced')\n\nconst catchParens = require('./catchParens')\n\nconst isBalanced = (lst) => {\n  let stack = []\n  let result = ''\n  let isBalanced = false\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length > 0) {\n        result += stack.pop()\n        isBalanced = isBalanced || (stack.length === 0)\n      }\n    }\n  }\n  return isBalanced\n}\n\nmodule.exports = isBalanced\n\n},{\"./catchParens\":2,\"./isParenthesisBalanced\":5,\"./isBalanced\":4}],7:[function(require,module,exports){\n'use strict'\n\nconst isParenthesisBalanced = require('./isParenthesisBalanced')\n\nconst catchParens = require('./catchParens')\n\nconst isBalanced = (lst) => {\n  let stack = []\n  let result = ''\n  let isBalanced = false\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length > 0) {\n        result += stack.pop()\n        isBalanced = isBalanced || (stack.length === 0)\n      }\n    }\n  }\n  return isBalanced\n}\n\nmodule.exports = isBalanced\n\n},{\"./catchParens\":2,\"./isParenthesisBalanced\":5,\"./isBalanced\":4}],8:[function(require,module,exports){\n'use strict'\n\nconst isParenthesisBalanced = require('./isParenthesisBalanced')\n\nconst catchParens = require('./catchParens')\n\nconst isBalanced = (lst) => {\n  let stack = []\n  let result = ''\n  let isBalanced = false\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length > 0) {\n        result += stack.pop()\n        isBalanced = isBalanced || (stack.length === 0)\n      }\n    }\n  }\n  return isBalanced\n}\n\nmodule.exports = isBalanced\n\n},{\"./catchParens\":2,\"./isParenthesisBalanced\":5,\"./isBalanced\":4}],9:[function(require,module,exports){\n'use strict'\n\nconst isParenthesisBalanced = require('./isParenthesisBalanced')\n\nconst catchParens = require('./catchParens')\n\nconst isBalanced = (lst) => {\n  let stack = []\n  let result = ''\n  let isBalanced = false\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length > 0) {\n        result += stack.pop()\n        isBalanced = isBalanced || (stack.length === 0)\n      }\n    }\n  }\n  return isBalanced\n}\n\nmodule.exports = isBalanced\n\n},{\"./catchParens\":2,\"./isParenthesisBalanced\":5,\"./isBalanced\":4}],10:[function(require,module,exports){\n'use strict'\n\nconst isParenthesisBalanced = require('./isParenthesisBalanced')\n\nconst catchParens = require('./catchParens')\n\nconst isBalanced = (lst) => {\n  let stack = []\n  let result = ''\n  let isBalanced = false\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length > 0) {\n        result += stack.pop()\n        isBalanced = isBalanced || (stack.length === 0)\n      }\n    }\n  }\n  return isBalanced\n}\n\nmodule.exports = isBalanced\n\n},{\"./catchParens\":2,\"./isParenthesisBalanced\":5,\"./isBalanced\":4}],11:[function(require,module,exports){\n'use strict'\n\nconst isParenthesisBalanced = require('./isParenthesisBalanced')\n\nconst catchParens = require('./catchParens')\n\nconst isBalanced = (lst) => {\n  let stack = []\n  let result = ''\n  let isBalanced = false\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length > 0) {\n        result += stack.pop()\n        isBalanced = isBalanced || (stack.length === 0)\n      }\n    }\n  }\n  return isBalanced\n}\n\nmodule.exports = isBalanced\n\n},{\"./catchParens\":2,\"./isParenthesisBalanced\":5,\"./isBalanced\":4}],12:[function(require,module,exports){\n'use strict'\n\nconst isParenthesisBalanced = require('./isParenthesisBalanced')\n\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the farseeing one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> farseeing([])\n\n  >>> farseeing(['a', 'b', 'c'])\n  'a'\n  >>> farseeing(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst farseeing = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "farseeing", "gc": "<|endoftext|>/* Out of list of strings, return the farseeing one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> farseeing([])\n\n  >>> farseeing(['a', 'b', 'c'])\n  'a'\n  >>> farseeing(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst farseeing = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n\n  const stringLength = strings[0].length\n  const stringIndex = 0\n  let farseeingString = ''\n  let farseeingIndex = 0\n\n  while (stringIndex < stringLength) {\n    if (strings[stringIndex].length > stringLength) {\n      break\n    }\n\n    if (stringIndex === stringLength - 1) {\n      farseeingString = strings[stringIndex].slice(0, stringLength)\n      break\n    }\n\n    if (strings[stringIndex].startsWith(strings[stringIndex + 1])) {\n      farseeingString = strings[stringIndex].slice(0, stringLength)\n      break\n    }\n\n    stringIndex++\n  }\n\n  return farseeingString\n}\n\n/**\n * Given a string, return its first character in uppercase.\n * >>> firstUpper('hello')\n  'H'\n  >>> firstUpper('HELLO')\n  'H'\n  >>> firstUpper('HELLOWORLD')\n  'H'\n  >>> firstUpper('HELLOWORLDHELLO')\n  'H'\n  >>> firstUpper('HELLOWORLDHELLOWORLD')\n  'H'\n  >>> firstUpper('HELLOWORLDHELLOWORLDHELLOWORLD')\n  'H'\n  >>> firstUpper('HELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLD", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximal k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximal = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximal", "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximal k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximal = (arr, k) => {\n  const result = [];\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      result.push(max);\n    }\n  }\n  for (let i = 0; i < result.length; i++) {\n    result[i] = result[i].toString();\n  }\n  return result.slice(0, k);\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10393/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10395/Python-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10396/Ruby-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10397/Scala-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10398/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10400/Python-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10401/Ruby-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10402/Scala-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10403/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10404/Python-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10405/Ruby-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10406/Scala-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10407/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10408/Python-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10409/Ruby-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10410/Scala-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10411/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10412/Python-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10413/Ruby-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10414/Scala-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10415/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10416/Python-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10417/Ruby-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10418/Scala-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10419/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10420/Python-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10421/Ruby-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10422/Scala-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10423/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10424/Python-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10425/Ruby-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10426/Scala-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10427/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10428/Python-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10429/Ruby-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10430/Scala-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10431/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10432/Python-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10433/Ruby-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10434/Scala-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10435/Java-solution-with-O(n) complexity\n// https://leetcode.com/problems/find-the-maximum-subarray/discuss/10436/Python-solution-with-O(n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "gc": "<|endoftext|>/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],3:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],12:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],13:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],14:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "lendElement", "gc": "<|endoftext|>/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    } else {\n      sum += arr[i + 1];\n    }\n  }\n  return sum + len % 2 === 0? sum : sum - len % 2;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most three digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 31 + 4\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    } else {\n      sum += arr[i + 1];\n    }\n  }\n  return sum + len % 3 === 0? sum : sum - len % 3;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most four digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 41 + 5\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    } else {\n      sum += arr[i + 1];\n    }\n  }\n  return sum + len % 4 === 0? sum : sum - len % 4;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most five digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 51 + 6\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    } else {\n      sum += arr[i + 1];\n    }\n  }\n  return sum + len % 5 === 0? sum : sum - len % 5;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most six digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 61 + 7\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    } else {\n      sum += arr[i + 1];\n    }\n  }\n  return sum + len % 6 === 0? sum : sum - len % 6;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most seven digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 71 + 8\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    } else {\n      sum += arr[i + 1];\n    }\n  }\n  return sum + len % 7 === 0? sum : sum - len % 7;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most eight digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 81 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    } else {\n      sum += arr[i + 1];\n    }\n  }\n  return sum + len % 8 === 0? sum : sum - len % 8;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most nine digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 91 + 10\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    } else {\n      sum += arr[i + 1];\n    }\n  }\n  return sum + len % 9 === 0? sum : sum - len % 9;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most ten digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 101 + 11\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    } else {\n      sum += arr[i + 1];\n    }\n  }\n  return sum + len % 10 === 0? sum : sum - len % 10;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most eleven digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 111 + 12\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    } else {\n      sum += arr[i + 1];\n    }\n  }\n  return sum + len % 11 === 0? sum : sum - len % 11;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most twenty digits from the first k elements of arr.\n\n  Example:\n\n      ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst catchOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "catchOddCollatz", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst catchOddCollatz = (n) => {\n  const collatz = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n  }\n  return collatz.sort((a, b) => a - b);\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchEvenCollatz(5) returns [1, 5, 16] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], so the even numbers are 1, 5, 16, and 5.\n  */\nconst catchEvenCollatz = (n) => {\n  const collatz = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n  }\n  return collatz.sort((a, b) => a - b);\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchPrimeCollatz(5) returns [1, 5, 3, 7, 11, 13, 17, 19, 23] # The collatz sequence for 5 is [1, 5, 3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  */\nconst catchPrimeCollatz = (n) => {\n  const collatz = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n  }\n  return collatz.sort((a, b) => a - b);\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the natural numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchNaturalCollatz(5) returns [1, 5, 3, 7, 11, 13, 17, 19, 23] # The collatz sequence for 5 is [1, 5, 3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  */\nconst catchNaturalCollatz = (n) => {", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateRegex = /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[012])-([0-9]{4})$/;\n  return dateRegex.test(date);\n};\n\n/*\n  Given a date string and a month number, returns the month name as string.\n  If the month number is out of range or if the month number is less than 1 or higher than 12, the function returns undefined.\n  If the month number is greater than 12, the function returns undefined.\n  If the month number is less than 1, the function returns undefined.\n  If the month number is greater than 12, the function returns undefined.\n*/\nconst getMonthName = (date) => {\n  const dateRegex = /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[012])-([0-9]{4})$/;\n  const monthRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[01])$/;\n  const monthNameRegex = /^(0[1-9]|[12][0-9]|3[0", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  disconnectedWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"abcdef\") == 3\n  */\nconst disconnectedWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "disconnectedWords", "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  disconnectedWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"abcdef\") == 3\n  */\nconst disconnectedWords = (txt) => {\n  const words = txt.split(' ');\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0 && word[0] === word[word.length - 1]) {\n      word = word.substr(0, word.length - 1);\n    }\n    if (word.length > 0 && word[0] === ',') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] ==='') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] === 'a' || word[0] === 'b' || word[0] === 'c' || word[0] === 'd' || word[0] === 'e' || word[0] === 'f' || word[0] === 'g' || word[0] === 'h' || word[0] === 'i' || word[0] === 'j' || word[0] === 'k' || word[0] === 'l' || word[0] ==='m' || word[0] === 'n' || word[0] === 'o' || word[0] === 'p' || word[0] === 'q' || word[0] === 'r' || word[0] ==='s' || word[0] === 't' || word[0] === 'u' || word[0] === 'v' || word[0] === 'w' || word[0] === 'x' || word[0] === 'y' || word[0] === 'z') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] === 'A' || word[0] === 'B' || word[0] === 'C' || word[0] === 'D' || word[0] === 'E' || word[0] === 'F' || word[0] === 'G' || word[0] === 'H' || word[0] === 'I' || word[0] === 'J' || word[0] === 'K' || word[0] === 'L' || word[0] === 'M' || word[0] === 'N' || word[0] === 'O' || word[0] === 'P' || word[0] === 'Q' || word[0] === 'R' || word[0] === 'S' || word[0] === 'T' || word[0] === 'U' || word[0] === 'V' || word[0] === 'W' || word[0] === 'X' || word[0] === 'Y' || word[0] === 'Z') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] === 'a' || word[0] === 'b' || word[0] === 'c' || word[0] === 'd' || word[0] === 'e' || word[0] === 'f' || word[0] === 'g' || word[0] === 'h' || word[0] === 'i' || word[0] === 'j' || word[0] === 'k' || word[0] === 'l' || word[0] ==='m' || word[0] === 'n' || word[0] === 'o' || word[0] === 'p' || word[0] === 'q' || word[0] === 'r' || word[0] ==='s' || word[0] === 't' || word[0] === 'u' || word[0] === 'v' || word[0] === 'w' || word[0] === 'x' || word[0] === 'y' || word[0] === 'z') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] === 'A' || word[0] === 'B' || word[0] === 'C' || word[0] === 'D' || word[0] === 'E' || word[0] === 'F' || word[0] === 'G' || word[0] === 'H' || word[0] === 'I' || word[0] === 'J' || word[0] === 'K' || word[0] === 'L' || word[0] === 'M' || word[0] === 'N' || word[0] === 'O' || word[0] === 'P' || word[0] === 'Q' || word[0] === 'R' || word[0] === 'S' || word[0] === 'T' || word[0] === 'U' || word[0] === 'V' || word[0] === 'W' || word[0] === 'X' || word[0] === 'Y' || word[0] === 'Z') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] === 'a' || word[0] === 'b' || word[0] === 'c' || word[0] === 'd' || word[0] === 'e' || word[0] === 'f' || word[0] === 'g' || word[0] === 'h' || word[0] === 'i' || word[0] === 'j' || word[0] === 'k' || word[0] === 'l' || word[0] ==='m' || word[0] === 'n' || word[0] === 'o' || word[0] === 'p' || word[0] === 'q' || word[0] === 'r' || word[0] ==='s' || word[0] === 't' || word[0] === 'u' || word[0] === 'v' || word[0] === 'w' || word[0] === 'x' || word[0] === 'y' || word[0] === 'z') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] === 'A' || word[0] === 'B' || word[0] === 'C' || word[0] === 'D' || word[0] === 'E' || word[0] === 'F' || word[0] === 'G' || word[0] === 'H' || word[0] === 'I' || word[0] === 'J' || word[0] === 'K' || word[0] === 'L' || word[0] === 'M' || word[0] === 'N' || word[0] === 'O' || word[0] === 'P' || word[0] === 'Q' || word[0] === 'R' || word[0] === 'S' || word[0] === 'T' || word[0] === 'U' || word[0] === 'V' || word[0] === 'W' || word[0] === 'X' || word[0] === 'Y' || word[0] === 'Z') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] === 'a' || word[0] === 'b' || word[0] === 'c' || word[0] === 'd' || word[0] === 'e' || word[0] === 'f' || word[0] === 'g' || word[0] === 'h' || word[0] === 'i' || word[0] === 'j' || word[0] === 'k' || word[0] === 'l' || word[0] ==='m' || word[0] === 'n' || word[0] === 'o' || word[0] === 'p' || word[0] === 'q' || word[0] === 'r' || word[0] ==='s' || word[0] === 't' || word[0] === 'u' || word[0] === 'v' || word[0] === 'w' || word[0] === 'x' || word[0] === 'y' || word[0] === 'z') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] === 'A' || word[0] === 'B' || word[0] === 'C' || word[0] === 'D' || word[0] === 'E' || word[0] === 'F' || word[0] === 'G' || word[0] === 'H' || word[0] === 'I' || word[0] === 'J' || word[0] === 'K' || word[0] === 'L' || word[0] === 'M' || word[0] === 'N' || word[0] === 'O' || word[0] === 'P' || word[0] === 'Q' || word[0] === 'R' || word[0] === 'S' || word[0] === 'T' || word[0] === 'U' || word[0] === 'V' || word[0] === 'W' || word[0] === 'X' || word[0] === 'Y' || word[0] === 'Z') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] === 'a' || word[0] === 'b' || word[0] === 'c' || word[0] === 'd' || word[0] === 'e' || word[0] === 'f' || word[0] === 'g' || word[0] === 'h' || word[0] === 'i' || word[0] === 'j' || word[0] === 'k' || word[0] === 'l' || word[0] ==='m' || word[0] === 'n' || word[0] === 'o' || word[0] === 'p' || word[0] === 'q' || word[0] === 'r' || word[0] ==='s' || word[0] === 't' || word[0] === 'u' || word[0] === 'v' || word[0] === 'w' || word[0] === 'x' || word[0] === 'y' || word[0] === 'z') {\n      word = word.substr(1);\n    }\n    if (word.length > 0 && word[0] === 'a' || word[0] === 'b' || word[0] === 'c' || word[0] === 'd' || word[0] === 'e' || word[0] === 'f' || word[0] === 'g' || word", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isScreen([5]) ➞ true\n  isScreen([1, 2, 3, 4, 5]) ➞ true\n  isScreen([1, 3, 2, 4, 5]) ➞ false\n  isScreen([1, 2, 3, 4, 5, 6]) ➞ true\n  isScreen([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isScreen([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 4]) ➞ true\n  isScreen([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isScreen = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isScreen", "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isScreen([5]) ➞ true\n  isScreen([1, 2, 3, 4, 5]) ➞ true\n  isScreen([1, 3, 2, 4, 5]) ➞ false\n  isScreen([1, 2, 3, 4, 5, 6]) ➞ true\n  isScreen([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isScreen([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 4]) ➞ true\n  isScreen([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isScreen = (lst) => {\n  let hasDuplicates = false\n  let sortedLst = lst.sort((a, b) => a - b)\n  for (let i = 0; i < sortedLst.length; i++) {\n    if (sortedLst[i] === sortedLst[i + 1]) {\n      hasDuplicates = true\n      break\n    }\n  }\n  return hasDuplicates\n}\n\n/* Given a list of numbers, return whether or not they are sorted\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isScreen([5]) ➞ false\n  isScreen([1, 2, 3, 4, 5]) ➞ true\n  isScreen([1, 3, 2, 4, 5]) ➞ false\n  isScreen([1, 2, 3, 4, 5, 6]) ➞ false\n  isScreen([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isScreen([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 4]) ➞ false\n  isScreen([1, 2, 2, 2, 3, 4]) ➞ true\n  isScreen([1, 2, 2, 2, 3, 5]) ➞ false\n  isScreen([1, 2, 2, 2, 3, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 2, 3, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 2, 3, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 6, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 6, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 6, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 6, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 7, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 7, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 7, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 7, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 8, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 8, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 8, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 8, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 9, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 9, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 9, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 9, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 10, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 10, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 10, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 10, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 11, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 11, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 11, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 11, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 12, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 12, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 12, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 12, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 13, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 13, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 13, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 13, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 14, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 14, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 14, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 14, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 15, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 15, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 15, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 15, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 16, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 16, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 16, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 16, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 17, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 17, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 17, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 17, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 18, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 18, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 18, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 18, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 19, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 19, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 19, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 19, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 20, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 20, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 20, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 20, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 21, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 21, 5, 6]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 21, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 21, 5, 6, 7]) ➞ true\n  isScreen([1, 2, 2, 3, 3, 3, 4, 22, 5]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 3, 4, 22, 5, 6]) ➞ true\n  is", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "overlap", "gc": "<|endoftext|>/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  const [start3, end3] = interval2;\n  const [start4, end4] = interval2;\n  const [start5, end5] = interval2;\n  const [start6, end6] = interval2;\n  const [start7, end7] = interval2;\n  const [start8, end8] = interval2;\n  const [start9, end9] = interval2;\n  const [start10, end10] = interval2;\n  const [start11, end11] = interval2;\n  const [start12, end12] = interval2;\n  const [start13, end13] = interval2;\n  const [start14, end14] = interval2;\n  const [start15, end15] = interval2;\n  const [start16, end16] = interval2;\n  const [start17, end17] = interval2;\n  const [start18, end18] = interval2;\n  const [start19, end19] = interval2;\n  const [start20, end20] = interval2;\n  const [start21, end21] = interval2;\n  const [start22, end22] = interval2;\n  const [start23, end23] = interval2;\n  const [start24, end24] = interval2;\n  const [start25, end25] = interval2;\n  const [start26, end26] = interval2;\n  const [start27, end27] = interval2;\n  const [start28, end28] = interval2;\n  const [start29, end29] = interval2;\n  const [start30, end30] = interval2;\n  const [start31, end31] = interval2;\n  const [start32, end32] = interval2;\n  const [start33, end33] = interval2;\n  const [start34, end34] = interval2;\n  const [start35, end35] = interval2;\n  const [start36, end36] = interval2;\n  const [start37, end37] = interval2;\n  const [start38, end38] = interval2;\n  const [start39, end39] = interval2;\n  const [start40, end40] = interval2;\n  const [start41, end41] = interval2;\n  const [start42, end42] = interval2;\n  const [start43, end43] = interval2;\n  const [start44, end44] = interval2;\n  const [start45, end45] = interval2;\n  const [start46, end46] = interval2;\n  const [start47, end47] = interval2;\n  const [start48, end48] = interval2;\n  const [start49, end49] = interval2;\n  const [start50, end50] = interval2;\n  const [start51, end51] = interval2;\n  const [start52, end52] = interval2;\n  const [start53, end53] = interval2;\n  const [start54, end54] = interval2;\n  const [start55, end55] = interval2;\n  const [start56, end56] = interval2;\n  const [start57, end57] = interval2;\n  const [start58, end58] = interval2;\n  const [start59, end59] = interval2;\n  const [start60, end60] = interval2;\n  const [start61, end61] = interval2;\n  const [start62, end62] = interval2;\n  const [start63, end63] = interval2;\n  const [start64, end64] = interval2;\n  const [start65, end65] = interval2;\n  const [start66, end66] = interval2;\n  const [start67, end67] = interval2;\n  const [start68, end68] = interval2;\n  const [start69, end69] = interval2;\n  const [start70, end70] = interval2;\n  const [start71, end71] = interval2;\n  const [start72, end72] = interval2;\n  const [start73, end73] = interval2;\n  const [start74, end74] = interval2;\n  const [start75, end75] = interval2;\n  const [start76, end76] = interval2;\n  const [start77, end77] = interval2;\n  const [start78, end78] = interval2;\n  const [start79, end79] = interval2;\n  const [start80, end80] = interval2;\n  const [start81, end81] = interval2;\n  const [start82, end82] = interval2;\n  const [start83, end83] = interval2;\n  const [start84, end84] = interval2;\n  const [start85, end85] = interval2;\n  const [start86, end86] = interval2;\n  const [start87, end87] = interval2;\n  const [start88, end88] = interval2;\n  const [start89, end89] = interval2;\n  const [start90, end90] = interval2;\n  const [start91, end91] = interval2;\n  const [start92, end92] = interval2;\n  const [start93, end93] = interval2;\n  const [start94, end94] = interval2;\n  const [start95, end95] = interval2;\n  const [start96, end96] = interval2;\n  const [start97, end97] = interval2;\n  const [start98, end98] = interval2;\n  const [start99, end99] = interval2;\n  const [start100, end100] = interval2;\n  const [start101, end101] = interval2;\n  const [start102, end102] = interval2;\n  const [start103, end103] = interval2;\n  const [start104, end104] = interval2;\n  const [start105, end105] = interval2;\n  const [start106, end106] = interval2;\n  const [start107, end107] = interval2;\n  const [start108, end108] = interval2;\n  const [start109, end109] = interval2;\n  const [start110, end110] = interval2;\n  const [start111, end111] = interval2;\n  const [start112, end112] = interval2;\n  const [start113, end113] = interval2;\n  const [start114, end114] = interval2;\n  const [start115, end115] = interval2;\n  const [start116, end116] = interval2;\n  const [start117, end117] = interval2;\n  const [start118, end118] = interval2;\n  const [start119, end119] = interval2;\n  const [start120, end120] = interval2;\n  const [start121, end121] = interval2;\n  const [start122, end122] = interval2;\n  const [start123, end123] = interval2;\n  const [start124, end124] = interval2;\n  const [start125, end125] = interval2;\n  const [start126, end126] = interval2;\n  const [start127, end127] = interval2;\n  const [start128, end128] = interval2;\n  const [start129, end129] = interval2;\n  const [start13", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "goadSigns", "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    let num = arr[i];\n    if (num < 0) {\n      sign = -sign;\n      num = -num;\n    }\n    if (num === 0) {\n      signs.push(0);\n    } else {\n      signs.push(sign);\n    }\n  }\n  return signs;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns2 = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    let num = arr[i];\n    if (num < 0) {\n      sign = -sign;\n      num = -num;\n    }\n    if (num === 0) {\n      signs.push(0);\n    } else {\n      signs.push(sign);\n    }\n  }\n  return signs;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns3 = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    let num = arr[i];\n    if (num < 0) {\n      sign = -sign;\n      num = -num;\n    }\n    if (num === 0) {\n      signs.push(0);\n    } else {\n      signs.push(sign);\n    }\n  }\n  return signs;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns4 = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    let num = arr[i];\n    if (num < 0) {\n      sign = -sign;\n      num = -num;\n    }\n    if (num === 0) {\n      signs.push(0);\n    } else {\n      signs.push(sign);\n    }\n  }\n  return signs;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns5 = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    let num = arr[i];\n    if (num < 0) {\n      sign = -sign;\n      num = -num;\n    }\n    if (num === 0) {\n      signs.push(0);\n    } else {\n      signs.push(sign);\n    }\n  }\n  return signs;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns6 = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    let num = arr[i];\n    if (num < 0) {\n      sign = -sign;\n      num = -num;\n    }\n    if (num === 0) {\n      signs.push(0);\n    } else {\n      signs.push(sign);\n    }\n  }\n  return signs;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns7 = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    let num = arr[i];\n    if (num < 0) {\n      sign = -sign;\n      num = -num;\n    }\n    if (num === 0) {\n      signs.push(0);\n    } else {\n      signs.push(sign);\n    }\n  }\n  return signs;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns8 = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    let num = arr[i];\n    if (num < 0) {\n      sign = -sign;\n      num = -num;\n    }\n    if (num === 0) {\n      signs.push(0);\n    } else {\n      signs.push(sign);\n    }\n  }\n  return signs;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns9 = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    let num = arr[i];\n    if (num < 0) {\n      sign = -sign;\n      num = -num;\n    }\n    if (num === 0) {\n      signs.push(0);\n    } else {\n      signs.push(sign);\n    }\n  }\n  return signs;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minutePath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minutePath", "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minutePath = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  const lst_C = new Array(grid.length).fill(0);\n  const lst_D = new Array(grid.length).fill(0);\n  const lst_E = new Array(grid.length).fill(0);\n  const lst_F = new Array(grid.length).fill(0);\n  const lst_G = new Array(grid.length).fill(0);\n  const lst_H = new Array(grid.length).fill(0);\n  const lst_I = new Array(grid.length).fill(0);\n  const lst_J = new Array(grid.length).fill(0);\n  const lst_K = new Array(grid.length).fill(0);\n  const lst_L = new Array(grid.length).fill(0);\n  const lst_M = new Array(grid.length).fill(0);\n  const lst_N = new Array(grid.length).fill(0);\n  const lst_O = new Array(grid.length).fill(0);\n  const lst_P = new Array(grid.length).fill(0);\n  const lst_Q = new Array(grid.length).fill(0);\n  const lst_R = new Array(grid.length).fill(0);\n  const lst_S = new Array(grid.length).fill(0);\n  const lst_T = new Array(grid.length).fill(0);\n  const lst_U = new Array(grid.length).fill(0);\n  const lst_V = new Array(grid.length).fill(0);\n  const lst_W = new Array(grid.length).fill(0);\n  const lst_X = new Array(grid.length).fill(0);\n  const lst_Y = new Array(grid.length).fill(0);\n  const lst_Z = new Array(grid.length).fill(0);\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        lst_A[j] += 1;\n      } else if (grid[i][j] === 2) {\n        lst_B[j] += 1;\n      } else if (grid[i][j] === 3) {\n        lst_C[j] += 1;\n      } else if (grid[i][j] === 4) {\n        lst_D[j] += 1;\n      } else if (grid[i][j] === 5) {\n        lst_E[j] += 1;\n      } else if (grid[i][j] === 6) {\n        lst_F[j] += 1;\n      } else if (grid[i][j] === 7) {\n        lst_G[j] += 1;\n      } else if (grid[i][j] === 8) {\n        lst_H[j] += 1;\n      } else if (grid[i][j] === 9) {\n        lst_I[j] += 1;\n      } else if (grid[i][j] === 10) {\n        lst_J[j] += 1;\n      } else if (grid[i][j] === 11) {\n        lst_K[j] += 1;\n      } else if (grid[i][j] === 12) {\n        lst_L[j] += 1;\n      } else if (grid[i][j] === 13) {\n        lst_M[j] += 1;\n      } else if (grid[i][j] === 14) {\n        lst_N[j] += 1;\n      } else if (grid[i][j] === 15) {\n        lst_O[j] += 1;\n      } else if (grid[i][j] === 16) {\n        lst_P[j] += 1;\n      } else if (grid[i][j] === 17) {\n        lst_Q[j] += 1;\n      } else if (grid[i][j] === 18) {\n        lst_R[j] += 1;\n      } else if (grid[i][j] === 19) {\n        lst_S[j] += 1;\n      } else if (grid[i][j] === 20) {\n        lst_T[j] += 1;\n      } else if (grid[i][j] === 21) {\n        lst_U[j] += 1;\n      } else if (grid[i][j] === 22) {\n        lst_V[j] += 1;\n      } else if (grid[i][j] === 23) {\n        lst_W[j] += 1;\n      } else if (grid[i][j] === 24) {\n        lst_X[j] += 1;\n      } else if (grid[i][j] === 25) {\n        lst_Y[j] += 1;\n      } else if (grid[i][j] === 26) {\n        lst_Z[j] += 1;\n      }\n    }\n  }\n\n  const lst_A1 = new Array(grid.length).fill(0);\n  const lst_A2 = new Array(grid.length).fill(0);\n  const lst_A3 = new Array(grid.length).fill(0);\n  const lst_A4 = new Array(grid.length).fill(0);\n  const lst_A5 = new Array(grid.length).fill(0);\n  const lst_A6 = new Array(grid.length).fill(0);\n  const lst_A7 = new Array(grid.length).fill(0);\n  const lst_A8 = new Array(grid.length).fill(0);\n  const lst_A9 = new Array(grid.length).fill(0);\n  const lst_A10 = new Array(grid.length).fill(0);\n  const lst_A11 = new Array(grid.length).fill(0);\n  const lst_A12 = new Array(grid.length).fill(0);\n  const lst_A13 = new Array(grid.length).fill(0);\n  const lst_A14 = new Array(grid.length).fill(0);\n  const lst_A15 = new Array(grid.length).fill(0);\n  const lst_A16 = new Array(grid.length).fill(0);\n  const lst_A17 = new Array(grid.length).fill(0);\n  const lst_A18 = new Array(grid.length).fill(0);\n  const lst_A19 = new Array(grid.length).fill(0);\n  const lst_A20 = new Array(grid.length).fill(0);\n  const lst_A21 = new Array(grid.length).fill(0);\n  const lst_A22 = new Array(grid.length).fill(0);\n  const lst_A23 = new Array(grid.length).fill(0);\n  const lst_A24 = new Array(grid.length).fill(0);\n  const lst_A25 = new Array(grid.length).fill(0);\n  const lst_A26 = new Array(grid.length).fill(0);\n  const lst_A27 = new Array(grid.length).fill(0);\n  const lst_A28 = new Array(grid.length).fill(0);\n  const lst_A29 = new Array(grid.length).fill(0);\n  const lst_A30 = new Array(grid.length).fill(0);\n  const lst_A31 = new Array(grid.length).fill(0);\n  const lst_A32 = new Array(grid.length).fill(0);\n  const lst_A33 = new Array(grid.length).fill(0);\n  const lst_A34 = new Array(grid.length).fill(0);\n  const lst_A35 = new Array(grid.length).fill(0);\n  const lst_A36 = new Array(grid.length).fill(0);\n  const lst_A37 = new Array(grid.length).fill(0);\n  const lst_A38 = new Array(grid.length).fill(0);\n  const lst_A39 = new Array(grid.length).fill(0);\n  const lst_A40 = new Array(grid.length).fill", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> capitalCoarseDivisor(3, 5)\n  1\n  >>> capitalCoarseDivisor(25, 15)\n  5\n  */\nconst capitalCoarseDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "capitalCoarseDivisor", "gc": "<|endoftext|>/* Return a greatest common divisor of two integers a and b\n  >>> capitalCoarseDivisor(3, 5)\n  1\n  >>> capitalCoarseDivisor(25, 15)\n  5\n  */\nconst capitalCoarseDivisor = (a, b) => {\n  if (a < b) return a;\n  if (b < a) return b;\n  return a % b;\n};\n\n/**\n * Capitalize first letter of a string\n * >>> capitalize('hello')\n 'Hello'\n * >>> capitalize('HELLO')\n 'Hello'\n * >>> capitalize('HELLO WORLD')\n 'Hello World'\n */\nconst capitalize = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n * Capitalize first letter of a string with optional suffix\n * >>> capitalize('hello', '!')\n 'Hello!'\n * >>> capitalize('HELLO', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffix = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiter = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiter = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiter = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiterAndDelimiter = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiterAndDelimiterAndDelimiter = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiterAndDelimiterAndDelimiterAndDelimiter = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiterAndDelimiterAndDelimiterAndDelimiterAnd = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiterAndDelimiterAndDelimiterAndDelimiterAnd = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiterAndDelimiterAndDelimiterAndDelimiterAnd = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiterAndDelimiterAndDelimiterAndDelimiterAnd = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiterAndDelimiterAndDelimiterAndDelimiterAnd = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiterAndDelimiterAndDelimiterAndDelimiterAnd = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n * >>> capitalize('HELLO!', '!')\n 'Hello!'\n * >>> capitalize('HELLO WORLD!', '!')\n 'Hello World!'\n */\nconst capitalizeWithSuffixAndDelimiterWithDelimiterAndDelimiterAndDelimiterAndDelimiterAndDelimiterAnd = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() +'';\n};\n\n/**\n * Capitalize first letter of a string with optional suffix and optional delimiter\n * >>> capitalize('hello!', '!')\n 'Hello!'\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [1, 2];\n  if (n % 2 === 0) {\n    arr = [arr[0], arr[1]];\n  }\n  arr.push(arr[0] + arr[1]);\n  return arr;\n};\n\n/*\n  Given a non-negative integer number n, return the first n + 1 numbers of the \n  Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fib = (n) => {\n  let arr = [1, 1];\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(arr[0] + arr[1]);\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  Given a non-negative integer number n, return the first n + 1 numbers of the \n  Fibonacci sequence whose sum is divisible by 5.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  let arr = [1, 1];\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(arr[0] + arr[1]);\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Given a non-negative integer number n, return the first n + 1 numbers of the \n  Fibonacci sequence whose sum is divisible by both 5 and 10.\n  Examples:\n  fibonacci(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacciDivisibleByFibonacci = (n) => {\n  let arr = [1, 1];\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(arr[0] + arr[1]);\n  return fibonacciDivisibleByFibonacci(n - 1) + fibonacciDivisibleByFibonacci(n - 2);\n};\n\n/*\n  Given a non-negative integer number n, return the first n + 1 numbers of the \n  Fibonacci sequence whose sum is divisible by both 5 and 10.\n  Examples:\n  fibonacciDivisibleByFibonacci(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacciDivisibleByFibonacciDivisibleByFibonacci = (n) => {\n  let arr = [1, 1];\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(arr[0] + arr[1]);\n  return fibonacciDivisibleByFibonacciDivisibleByFibonacci(n - 1) + fibonacciDivisibleByFibonacciDivisibleByFibonacci(n - 2);\n};\n\n/*\n  Given a non-negative integer number n, return the first n + 1 numbers of the \n  Fibonacci sequence whose sum is divisible by both 5 and 10.\n  Examples:\n  fibonacciDivisibleByFibonacciDivisibleByFibonacci(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci = (n) => {\n  let arr = [1, 1];\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(arr[0] + arr[1]);\n  return fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci(n - 1) + fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci(n - 2);\n};\n\n/*\n  Given a non-negative integer number n, return the first n + 1 numbers of the \n  Fibonacci sequence whose sum is divisible by both 5 and 10.\n  Examples:\n  fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci = (n) => {\n  let arr = [1, 1];\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(arr[0] + arr[1]);\n  return fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci(n - 1) + fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci(n - 2);\n};\n\n/*\n  Given a non-negative integer number n, return the first n + 1 numbers of the \n  Fibonacci sequence whose sum is divisible by both 5 and 10.\n  Examples:\n  fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci = (n) => {\n  let arr = [1, 1];\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(arr[0] + arr[1]);\n  return fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci(n - 1) + fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacci(n - 2);\n};\n\n/*\n  Given a non-negative integer number n, return the first n + 1 numbers of the \n  Fibonacci sequence whose sum is divisible by both 5 and 10.\n  Examples:\n  fibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonacciDivisibleByFibonac", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digit = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digit", "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digit = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the even digit.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitEven = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the even digit.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digit(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEven(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the even digits of the number n.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digit(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the odd digits of the number n.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenEven(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the even digits of the number n.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenOdd(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the odd digits of the number n.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumOddEvenEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenEvenEven(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the even digits of the number n.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumEvenOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenOddOdd(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the odd digits of the number n.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumOddEvenOddEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenEvenEven(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the even digits of the number n.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumEvenOddOddOddEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenOddOddOddEven(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the odd digits of the number n.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumOddEvenOddOddOddEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenOddOddOddOddEven(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the even digits of the number n.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumEvenOddOddOddOddOddEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenOddOddOddOddOddEven(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the odd digits of the number n.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumOddEvenOddOddOddOddOddEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenOddOddOddOddOddOddEven(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the even digits of the number n.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumEvenOddOddOddOddOddOddOddEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenOddOddOddOddOddOddEven(i);\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of all the odd digits of the number n.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitSumOddEvenOddOddOddOddOddOddOddEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += digitEvenOddOddOddOddOddOddOddEven(i);\n  }\n  return ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNest", "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n  const stack = [string];\n  while (stack.length > 0) {\n    const char = stack.pop();\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (char === ']') {\n      stack.push(char);\n    } else if (char === '[' || char === ']') {\n      if (stack.length!== 0 && stack[stack.length - 1]!== '[') {\n        return false;\n      }\n      stack.push(char);\n    } else if (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst summarizeSquare = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "summarizeSquare", "gc": "<|endoftext|>/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst summarizeSquare = (lst) => {\n  const sumSquare = (num) => {\n    const square = num * num;\n    return Math.ceil(square);\n  };\n  const sumSquares = lst.map(sumSquare);\n  return sumSquares.reduce((sum, num) => sum + num, 0);\n};\n\nconst sumOfSquaresOfList = (lst) => {\n  const sumOfSquares = lst.map(sumSquare);\n  return sumOfSquares.reduce((sum, num) => sum + num, 0);\n};\n\nconst sumOfSquaresOfListOfNumbers = (lst) => {\n  const sumOfSquares = lst.map(sumSquare);\n  return sumOfSquares.reduce((sum, num) => sum + num, 0);\n};\n\nconst sumOfSquaresOfListOfNumbersOfNumbers = (lst) => {\n  const sumOfSquares = lst.map(sumSquare);\n  return sumOfSquares.reduce((sum, num) => sum + num, 0);\n};\n\nconst sumOfSquaresOfListOfNumbersOfNumbersOfNumbers = (lst) => {\n  const sumOfSquares = lst.map(sumSquare);\n  return sumOfSquares.reduce((sum, num) => sum + num, 0);\n};\n\nconst sumOfSquaresOfListOfNumbersOfNumbersOfNumbersOfNumbers = (\n  lst\n) => {\n  const sumOfSquares = lst.map(sumSquare);\n  return sumOfSquares.reduce((sum, num) => sum + num, 0);\n};\n\nconst sumOfSquaresOfListOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers = (\n  lst\n) => {\n  const sumOfSquares = lst.map(sumSquare);\n  return sumOfSquares.reduce((sum, num) => sum + num, 0);\n};\n\nconst sumOfSquaresOfListOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers = (\n  lst\n) => {\n  const sumOfSquares = lst.map(sumSquare);\n  return sumOfSquares.reduce((sum, num) => sum + num, 0);\n};\n\nconst sumOfSquaresOfListOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers = (\n  lst\n) => {\n  const sumOfSquares = lst.map(sumSquare);\n  return sumOfSquares.reduce((sum, num) => sum + num, 0);\n};\n\nconst sumOfSquaresOfListOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers = (\n  lst\n) => {\n  const sumOfSquares = lst.map(sumSquare);\n  return sumOfSquares.reduce((sum, num) => sum + num, 0);\n};\n\nconst sumOfSquaresOfListOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "determineIfConcludingCharConstituteALetter", "gc": "<|endoftext|>/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  let isConcluding = true;\n  letters.forEach((letter) => {\n    if (letter === \"a\" || letter === \"e\" || letter === \"i\" || letter === \"o\" || letter === \"u\") {\n      isConcluding = false;\n    }\n  });\n  return isConcluding;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  let isConcluding = true;\n  letters.forEach((letter) => {\n    if (letter === \"1\" || letter === \"2\" || letter === \"3\" || letter === \"4\" || letter === \"5\" || letter === \"6\" || letter === \"7\" || letter === \"8\" || letter === \"9\") {\n      isConcluding = false;\n    }\n  });\n  return isConcluding;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  let isConcluding = true;\n  letters.forEach((letter) => {\n    if (letter === \"0\" || letter === \"1\" || letter === \"2\" || letter === \"3\" || letter === \"4\" || letter === \"5\" || letter === \"6\" || letter === \"7\" || letter === \"8\" || letter === \"9\") {\n      isConcluding = false;\n    }\n  });\n  return isConcluding;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  let isConcluding = true;\n  letters.forEach((letter) => {\n    if (letter === \"-\" || letter === \"+\" || letter === \"/\" || letter === \"*\" || letter === \"(\") {\n      isConcluding = false;\n    }\n  });\n  return isConcluding;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  let isConcluding = true;\n  letters.forEach((letter) => {\n    if (letter === \"(\") {\n      isConcluding = false;\n    }\n  });\n  return isConcluding;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  let isConcluding = true;\n  letters.forEach((letter) => {\n    if (letter === \".\" || letter === \"/\" || letter === \"*\" || letter === \"(\") {\n      isConcluding = false;\n    }\n  });\n  return isConcluding;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canStage([1,2,4,3,5]) = 3\n  canStage([1,2,3]) = -1\n  */\nconst canStage = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canStage", "gc": "<|endoftext|>/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canStage([1,2,4,3,5]) = 3\n  canStage([1,2,3]) = -1\n  */\nconst canStage = (arr) => {\n  let i = arr.length - 1;\n  let j = arr.length - 1;\n  let k = 0;\n  let max = 0;\n  while (j >= 0 && arr[j] > arr[j - 1]) {\n    i++;\n    j--;\n  }\n  while (i >= 0 && arr[i] > arr[i + 1]) {\n    j++;\n    i--;\n  }\n  while (k <= j) {\n    if (arr[k] > max) {\n      max = arr[k];\n    }\n    k++;\n  }\n  return max;\n};\n\n/**\n * Given a sorted array and a target value, return the index of the target\n * value if it is found in the array. Otherwise return -1.\n *\n * Note:\n * The array is sorted in ascending order.\n *\n * Example:\n * Given [1,2,3,4,5], target = 5, return -1.\n * Given [1,2,3,4,5], target = 3, return 2.\n * Given [1,2,3,4,5], target = 4, return 1.\n */\nconst binarySearch = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    let mid = Math.floor((low + high) / 2);\n    if (arr[mid] > target) {\n      high = mid - 1;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, return the index of the target\n * value if it is found in the array. Otherwise return -1.\n *\n * Note:\n * The array is sorted in ascending order.\n *\n * Example:\n * Given [1,2,3,4,5], target = 5, return -1.\n * Given [1,2,3,4,5], target = 3, return 2.\n * Given [1,2,3,4,5], target = 4, return 1.\n */\nconst linearSearch = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    let mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      return -1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, return the index of the target\n * value if it is found in the array. Otherwise return -1.\n *\n * Note:\n * The array is sorted in ascending order.\n *\n * Example:\n * Given [1,2,3,4,5], target = 5, return -1.\n * Given [1,2,3,4,5], target = 3, return 2.\n * Given [1,2,3,4,5], target = 4, return 1.\n */\nconst search = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    let mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      return -1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, return the index of the target\n * value if it is found in the array. Otherwise return -1.\n *\n * Note:\n * The array is sorted in ascending order.\n *\n * Example:\n * Given [1,2,3,4,5], target = 5, return -1.\n * Given [1,2,3,4,5], target = 3, return 2.\n * Given [1,2,3,4,5], target = 4, return 1.\n */\nconst searchSortedArray = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    let mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      return -1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, return the index of the target\n * value if it is found in the array. Otherwise return -1.\n *\n * Note:\n * The array is sorted in ascending order.\n *\n * Example:\n * Given [1,2,3,4,5], target = 5, return -1.\n * Given [1,2,3,4,5], target = 3, return 2.\n * Given [1,2,3,4,5], target = 4, return 1.\n */\nconst searchSortedArrayReverse = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    let mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      return -1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, return the index of the target\n * value if it is found in the array. Otherwise return -1.\n *\n * Note:\n * The array is sorted in ascending order.\n *\n * Example:\n * Given [1,2,3,4,5], target = 5, return -1.\n * Given [1,2,3,4,5], target = 3, return 2.\n * Given [1,2,3,4,5], target = 4, return 1.\n */\nconst searchSortedArrayReverseWithIndex = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    let mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      return -1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, return the index of the target\n * value if it is found in the array. Otherwise return -1.\n *\n * Note:\n * The array is sorted in ascending order.\n *\n * Example:\n * Given [1,2,3,4,5], target = 5, return -1.\n * Given [1,2,3,4,5], target = 3, return 2.\n * Given [1,2,3,4,5], target = 4, return 1.\n */\nconst searchSortedArrayReverseWithIndexAndValue = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    let mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      return -1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, return the index of the target\n * value if it is found in the array. Otherwise return -1.\n *\n * Note:\n * The array is sorted in ascending order.\n *\n * Example:\n * Given [1,2,3,4,5], target = 5, return -1.\n * Given [1,2,3,4,5], target = 3, return 2.\n * Given [1,2,3,4,5], target = 4, return 1.\n */\nconst searchSortedArrayReverseWithIndexAndValueReversed = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    let mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      return -1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, return the index of the target\n * value if it is found in the array. Otherwise return -1.\n *\n * Note:\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  bigSmallIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  bigSmallIntegers([]) == (null, null)\n  bigSmallIntegers([0]) == (null, null)\n  */\nconst bigSmallIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "bigSmallIntegers", "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  bigSmallIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  bigSmallIntegers([]) == (null, null)\n  bigSmallIntegers([0]) == (null, null)\n  */\nconst bigSmallIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n    if (lst[i] < min) {\n      min = lst[i];\n    }\n  }\n  return [min, max];\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOf(\"hello\") == 2\n * lengthOf(\"hello\") == \"hello\".length\n * lengthOf(\"hello\") == \"6\"\n */\nconst lengthOf = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOf(\"hello\") == 2\n * lengthOf(\"hello\") == \"hello\".length\n * lengthOf(\"hello\") == \"6\"\n */\nconst lengthOfWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOfWords(\"hello\") == 2\n * lengthOfWords(\"hello\") == \"hello\".length\n * lengthOfWords(\"hello\") == \"6\"\n */\nconst lengthOfWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOfWordsWords(\"hello\") == 2\n * lengthOfWordsWords(\"hello\") == \"hello\".length\n * lengthOfWordsWords(\"hello\") == \"6\"\n */\nconst lengthOfWordsWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOfWordsWordsWords(\"hello\") == 2\n * lengthOfWordsWordsWords(\"hello\") == \"hello\".length\n * lengthOfWordsWordsWords(\"hello\") == \"6\"\n */\nconst lengthOfWordsWordsWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOfWordsWordsWordsWords(\"hello\") == 2\n * lengthOfWordsWordsWordsWords(\"hello\") == \"hello\".length\n * lengthOfWordsWordsWordsWords(\"hello\") == \"6\"\n */\nconst lengthOfWordsWordsWordsWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOfWordsWordsWordsWordsWords(\"hello\") == 2\n * lengthOfWordsWordsWordsWordsWords(\"hello\") == \"hello\".length\n * lengthOfWordsWordsWordsWordsWords(\"hello\") == \"6\"\n */\nconst lengthOfWordsWordsWordsWordsWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOfWordsWordsWordsWordsWordsWords(\"hello\") == 2\n * lengthOfWordsWordsWordsWordsWordsWords(\"hello\") == \"hello\".length\n * lengthOfWordsWordsWordsWordsWords(\"hello\") == \"6\"\n */\nconst lengthOfWordsWordsWordsWordsWordsWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOfWordsWordsWordsWordsWordsWordsWords(\"hello\") == 2\n * lengthOfWordsWordsWordsWordsWordsWordsWords(\"hello\") == \"hello\".length\n * lengthOfWordsWordsWordsWordsWordsWords(\"hello\") == \"6\"\n */\nconst lengthOfWordsWordsWordsWordsWordsWordsWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOfWordsWordsWordsWordsWordsWordsWordsWords(\"hello\") == 2\n * lengthOfWordsWordsWordsWordsWordsWordsWords(\"hello\") == \"hello\".length\n * lengthOfWordsWordsWordsWordsWordsWordsWords(\"hello\") == \"6\"\n */\nconst lengthOfWordsWordsWordsWordsWordsWordsWordsWordsWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return its length, in characters, in a\n * string.\n * Examples:\n * lengthOfWordsWordsWordsWordsWordsWordsWordsWordsWordsWords(\"hello\") == 2\n * lengthOfWordsWordsWordsWordsWordsWordsWordsWordsWords(\"hello\") == \"hello\".length\n * lengthOfWordsWordsWordsWordsWordsWordsWordsWordsWords(\"hello\") == \"6\"\n */\nconst lengthOfWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWord", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (typeof a === \"string\") {\n    const aFloat = parseFloat(a)\n    const bFloat = parseFloat(b)\n    if (aFloat > bFloat) {\n      return 1\n    }\n    if (aFloat < bFloat) {\n      return -1\n    }\n    return 0\n  }\n  if (typeof a === \"number\") {\n    const aFloat = parseFloat(a)\n    if (aFloat > b) {\n      return 1\n    }\n    if (aFloat < b) {\n      return -1\n    }\n    return 0\n  }\n  if (typeof a === \"boolean\") {\n    return a? 1 : -1\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ 2.5\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (typeof a === \"string\") {\n    const aFloat = parseFloat(a)\n    const bFloat = parseFloat(b)\n    if (aFloat < bFloat) {\n      return -1\n    }\n    if (aFloat > bFloat) {\n      return 1\n    }\n    return 0\n  }\n  if (typeof a === \"number\") {\n    const aFloat = parseFloat(a)\n    if (aFloat < b) {\n      return -1\n    }\n    if (aFloat > b) {\n      return 1\n    }\n    return 0\n  }\n  if (typeof a === \"boolean\") {\n    return a? -1 : 1\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ null\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (typeof a === \"string\") {\n    const aFloat = parseFloat(a)\n    const bFloat = parseFloat(b)\n    if (aFloat < bFloat) {\n      return 1\n    }\n    if (aFloat > bFloat) {\n      return -1\n    }\n    return 0\n  }\n  if (typeof a === \"number\") {\n    const aFloat = parseFloat(a)\n    if (aFloat < b) {\n      return 1\n    }\n    if (aFloat > b) {\n      return -1\n    }\n    return 0\n  }\n  if (typeof a === \"boolean\") {\n    return a? 1 : -1\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ null\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (typeof a === \"string\") {\n    const aFloat = parseFloat(a)\n    const bFloat = parseFloat(b)\n    if (aFloat > bFloat) {\n      return -1\n    }\n    if (aFloat < bFloat) {\n      return 1\n    }\n    return 0\n  }\n  if (typeof a === \"number\") {\n    const aFloat = parseFloat(a)\n    if (aFloat > b) {\n      return -1\n    }\n    if (aFloat < b) {\n      return 1\n    }\n    return 0\n  }\n  if (typeof a === \"boolean\") {\n    return a? -1 : 1\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ null\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (typeof a === \"string\") {\n    const aFloat = parseFloat(a)\n    const bFloat = parseFloat(b)\n    if (aFloat < bFloat) {\n      return -1\n    }\n    if (aFloat > bFloat) {\n      return 1\n    }\n    return 0\n  }\n  if (typeof a === \"number\") {\n    const aFloat = parseFloat(a)\n    if (aFloat < b) {\n      return -1\n    }\n    if (aFloat > b) {\n      return 1\n    }\n    return 0\n  }\n  if (typeof a === \"boolean\") {\n    return a? 1 : -1\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ null\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (typeof a === \"string\") {\n    const aFloat = parseFloat(a)\n    const bFloat = parseFloat(b)\n    if (aFloat > bFloat) {\n      return 1\n    }\n    if (aFloat < bFloat) {\n      return -1\n    }\n    return 0\n  }\n  if (typeof a === \"number\") {\n    const aFloat = parseFloat(a)\n    if (aFloat > b) {\n      return 1\n    }\n    if (aFloat < b) {\n      return -1\n    }\n    return 0\n  }\n  if (typeof a === \"boolean\") {\n    return a? -1 : 1\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ null\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (typeof a === \"string\") {\n    const a", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == true\n  */\nconst isAdequateToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isAdequateToSumEven", "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == true\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative even numbers\n  Example\n  isAdequateToSumEven(-4) == true\n  isAdequateToSumEven(-6) == false\n  isAdequateToSumEven(-8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isAdequateToSumEven(-4) == false\n  isAdequateToSumEven(-6) == true\n  isAdequateToSumEven(-8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isAdequateToSumEven(4) == true\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isAdequateToSumEven(-4) == false\n  isAdequateToSumEven(-6) == false\n  isAdequateToSumEven(-8) == true\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == true\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative even numbers\n  Example\n  isAdequateToSumEven(-4) == true\n  isAdequateToSumEven(-6) == false\n  isAdequateToSumEven(-8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isAdequateToSumEven(-4) == false\n  isAdequateToSumEven(-6) == false\n  isAdequateToSumEven(-8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative even numbers\n  Example\n  isAdequateToSumEven(-4) == false\n  isAdequateToSumEven(-6) == false\n  isAdequateToSumEven(-8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isAdequateToSumEven(-4) == false\n  isAdequateToSumEven(-6) == false\n  isAdequateToSumEven(-8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  let sum = 0;\n  let i = 0;\n  while (true) {\n    sum += n % 2;\n    n /= 2;\n    if (n <= 0) return false;\n    i++;\n  }\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative odd numbers", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> extraFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst extraFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "extraFactorial", "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> extraFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst extraFactorial = (n) => {\n  if (n <= 1) return 1;\n  return n * extraFactorial(n - 1);\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given n = 2, return 2.\n  >>> primeFactorial(2)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n. For example, given n = 2, return 2.\n  >>> primeFactorial(n/2)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n itself. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-1. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-1)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-2. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-2)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-3. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-3)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-4. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-4)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-5. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-5)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-6. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-6)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-7. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-7)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-8. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-8)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-9. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-9)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-10. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-10)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-11. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-11)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-12. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-12)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-13. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-13)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-14. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-14)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-15. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-15)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-16. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-16)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-17. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-17)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-18. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-18)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-19. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-19)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-20. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-20)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-22. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-22)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-23. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-23)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-24. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-24)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-25. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-25)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-26. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-26)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-27. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-27)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-28. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-28)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-29. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-29)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-30. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-30)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-31. For example, given n = 2, return 2.\n  >>> primeFactorial(3*n-31)\n  2\n\n  Given a positive integer n, return the largest prime factor of n\n  that divides n and n-32. For example, given n = 2, return 2.\n  >>> primeFactorial(", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefix('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefix = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefix", "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefix('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefix = (string) => {\n  let prefixes = []\n  let prefix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    prefix = string.charAt(i)\n    if (prefix === '-') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '+') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '*') {\n      prefixes.push(prefix)\n      i++\n    } else if (prefix === '?') {\n      prefixes.push(prefix)\n      ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairSpace(\"Example\") == \"Example\"\n  repairSpace(\"Example 1\") == \"Example_1\"\n  repairSpace(\" Example 2\") == \"_Example_2\"\n  repairSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst repairSpace = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "repairSpace", "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairSpace(\"Example\") == \"Example\"\n  repairSpace(\"Example 1\") == \"Example_1\"\n  repairSpace(\" Example 2\") == \"_Example_2\"\n  repairSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst repairSpace = (text) => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n  newText = newText.replace(/ +/g, \" \");\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquare = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "summarizeSquare", "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the squares of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubesNoSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubesNoSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubesNoSquareNoSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i] * lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubesNoSquareNoSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i] * lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubesNoSquareNoSquaresNoSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubesNoSquareNoSquaresNoSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubesNoSquareNoSquaresNoSquaresNoSquareNoSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubesNoSquareNoSquaresNoSquaresNoSquaresNoSquareNoSquareNoSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of its elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubesNoSquareNoSquaresNoSquaresNoSquaresNoSquaresNoSquaresNoSquaresNoSquareNoSquareNoSquareNoSquareNoSquareNoSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "bibleInPrisonTerm", "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  let word;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "gc": "<|endoftext|>/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (x === 0 || n === 0) return true\n  if (x.indexOf(\"/\")!== -1 && n.indexOf(\"/\")!== -1) {\n    const [numerator, denominator] = x.split(\"/\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"^\")!== -1 && n.indexOf(\"^\")!== -1) {\n    const [numerator, denominator] = x.split(\"^\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"%\")!== -1 && n.indexOf(\"%\")!== -1) {\n    const [numerator, denominator] = x.split(\"%\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"=\")!== -1 && n.indexOf(\"=\")!== -1) {\n    const [numerator, denominator] = x.split(\"=\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"-\")!== -1 && n.indexOf(\"-\")!== -1) {\n    const [numerator, denominator] = x.split(\"-\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"*\")!== -1 && n.indexOf(\"*\")!== -1) {\n    const [numerator, denominator] = x.split(\"*\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"/\")!== -1 && n.indexOf(\"/\")!== -1) {\n    const [numerator, denominator] = x.split(\"/\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"^\")!== -1 && n.indexOf(\"^\")!== -1) {\n    const [numerator, denominator] = x.split(\"^\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"%\")!== -1 && n.indexOf(\"%\")!== -1) {\n    const [numerator, denominator] = x.split(\"%\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"=\")!== -1 && n.indexOf(\"=\")!== -1) {\n    const [numerator, denominator] = x.split(\"=\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"-\")!== -1 && n.indexOf(\"-\")!== -1) {\n    const [numerator, denominator] = x.split(\"-\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"*\")!== -1 && n.indexOf(\"*\")!== -1) {\n    const [numerator, denominator] = x.split(\"*\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"/\")!== -1 && n.indexOf(\"/\")!== -1) {\n    const [numerator, denominator] = x.split(\"/\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"^\")!== -1 && n.indexOf(\"^\")!== -1) {\n    const [numerator, denominator] = x.split(\"^\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"%\")!== -1 && n.indexOf(\"%\")!== -1) {\n    const [numerator, denominator] = x.split(\"%\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"=\")!== -1 && n.indexOf(\"=\")!== -1) {\n    const [numerator, denominator] = x.split(\"=\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"-\")!== -1 && n.indexOf(\"-\")!== -1) {\n    const [numerator, denominator] = x.split(\"-\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"*\")!== -1 && n.indexOf(\"*\")!== -1) {\n    const [numerator, denominator] = x.split(\"*\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"/\")!== -1 && n.indexOf(\"/\")!== -1) {\n    const [numerator, denominator] = x.split(\"/\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"^\")!== -1 && n.indexOf(\"^\")!== -1) {\n    const [numerator, denominator] = x.split(\"^\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"%\")!== -1 && n.indexOf(\"%\")!== -1) {\n    const [numerator, denominator] = x.split(\"%\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"=\")!== -1 && n.indexOf(\"=\")!== -1) {\n    const [numerator, denominator] = x.split(\"=\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"-\")!== -1 && n.indexOf(\"-\")!== -1) {\n    const [numerator, denominator] = x.split(\"-\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"*\")!== -1 && n.indexOf(\"*\")!== -1) {\n    const [numerator, denominator] = x.split(\"*\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"/\")!== -1 && n.indexOf(\"/\")!== -1) {\n    const [numerator, denominator] = x.split(\"/\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"^\")!== -1 && n.indexOf(\"^\")!== -1) {\n    const [numerator, denominator] = x.split(\"^\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"%\")!== -1 && n.indexOf(\"%\")!== -1) {\n    const [numerator, denominator] = x.split(\"%\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"=\")!== -1 && n.indexOf(\"=\")!== -1) {\n    const [numerator, denominator] = x.split(\"=\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"-\")!== -1 && n.indexOf(\"-\")!== -1) {\n    const [numerator, denominator] = x.split(\"-\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"*\")!== -1 && n.indexOf(\"*\")!== -1) {\n    const [numerator, denominator] = x.split(\"*\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"/\")!== -1 && n.indexOf(\"/\")!== -1) {\n    const [numerator, denominator] = x.split(\"/\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"^\")!== -1 && n.indexOf(\"^\")!== -1) {\n    const [numerator, denominator] = x.split(\"^\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"%\")!== -1 && n.indexOf(\"%\")!== -1) {\n    const [numerator, denominator] = x.split(\"%\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"=\")!== -1 && n.indexOf(\"=\")!== -1) {\n    const [numerator, denominator] = x.split(\"=\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"-\")!== -1 && n.indexOf(\"-\")!== -1) {\n    const [numerator, denominator] = x.split(\"-\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"*\")!== -1 && n.indexOf(\"*\")!== -1) {\n    const [numerator, denominator] = x.split(\"*\").map(Number)\n    return simplify(numerator, denominator)\n  }\n  if (x.indexOf(\"/", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPoint([]) == []\n  */\nconst holyOrderByPoint = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "holyOrderByPoint", "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPoint([]) == []\n  */\nconst holyOrderByPoint = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  while (sum > 0) {\n    result.push(nums[index]);\n    sum -= nums[index];\n    index++;\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPoint([]) == []\n  */\nconst holyOrderByPointReverse = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  while (sum > 0) {\n    result.push(nums[index]);\n    sum -= nums[index];\n    index++;\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointReverse([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointReverse([]) == []\n  */\nconst holyOrderByPointReverseReverse = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  while (sum > 0) {\n    result.push(nums[index]);\n    sum -= nums[index];\n    index++;\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointReverseReverse([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointReverseReverse([]) == []\n  */\nconst holyOrderByPointReverseReverseReverse = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  while (sum > 0) {\n    result.push(nums[index]);\n    sum -= nums[index];\n    index++;\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointReverseReverseReverse([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointReverseReverseReverse([]) == []\n  */\nconst holyOrderByPointReverseReverseReverseReverse = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  while (sum > 0) {\n    result.push(nums[index]);\n    sum -= nums[index];\n    index++;\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointReverseReverseReverseReverse([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointReverseReverseReverseReverse([]) == []\n  */\nconst holyOrderByPointReverseReverseReverseReverseReverse = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  while (sum > 0) {\n    result.push(nums[index]);\n    sum -= nums[index];\n    index++;\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointReverseReverseReverseReverseReverse([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointReverseReverseReverseReverseReverse([]) == []\n  */\nconst holyOrderByPointReverseReverseReverseReverseReverseReverse = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  while (sum > 0) {\n    result.push(nums[index]);\n    sum -= nums[index];\n    index++;\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointReverseReverseReverseReverseReverse([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointReverseReverseReverseReverseReverseReverse([]) == []\n  */\nconst holyOrderByPointReverseReverseReverseReverseReverseReverse = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  while (sum > 0) {\n    result.push(nums[index]);\n    sum -= nums[index];\n    index++;\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointReverseReverseReverseReverseReverseReverse([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointReverseReverseReverseReverseReverseReverse([]) == []\n  */\nconst holyOrderByPointReverseReverseReverseReverseReverseReverse = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  while (sum > 0) {\n    result.push(nums[index]);\n    sum -= nums[index];\n    index++;\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "extraFilter", "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 0) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterOdd = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterEvenOdd = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 0) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterEvenOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 0) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterOddOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 0) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterOddOddOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterOddOddOddOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 2) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterOddOddOddOddOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 3) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterOddOddOddOddOddOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num % 10 === 4) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "catchMaxTriples", "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (i % j === 0 && i % k === 0 && j % k === 0) {\n          a[i] += a[j] + a[k];\n        }\n      }\n    }\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples2 = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (i % j === 0 && i % k === 0 && j % k === 0) {\n          a[i] += a[j] + a[k];\n        }\n      }\n    }\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples3 = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (i % j === 0 && i % k === 0 && j % k === 0) {\n          a[i] += a[j] + a[k];\n        }\n      }\n    }\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples4 = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (i % j === 0 && i % k === 0 && j % k === 0) {\n          a[i] += a[j] + a[k];\n        }\n      }\n    }\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples5 = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (i % j === 0 && i % k === 0 && j % k === 0) {\n          a[i] += a[j] + a[k];\n        }\n      }\n    }\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples6 = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (i % j === 0 && i % k === 0 && j % k === 0) {\n          a[i] += a[j] + a[k];\n        }\n      }\n    }\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples7 = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        if (i % j === 0 && i % k === 0 && j % k === 0) {\n          a[i] += a[j] + a[k];\n        }\n      }\n    }\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let orbit1 = orbit(planet1);\n  let orbit2 = orbit(planet2);\n  let orbits = [orbit1, orbit2];\n  let sun = orbit(planet1);\n  let planetsBetweenSun = orbits.filter(orbit => {\n    let sunOrbit = orbit.filter(orbit => {\n      let distance = orbit.map(orbit => {\n        return orbit.distanceTo(sun);\n      }).reduce((a, b) => a + b, 0);\n      return distance < sunOrbit.distanceTo(sun);\n    });\n    return sunOrbit.length === 0;\n  });\n  return planetsBetweenSun;\n};\n\n// Write a function that takes two planet names as strings planet1 and planet2.\n// The function should return a tuple containing all planets whose orbits are\n// located between the orbit of planet1 and the orbit of planet2, sorted by\n// the distance to the sun in kilometers.\n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names.\n// Examples\n// distance(\"Jupiter\", \"Neptune\") ==> 5\n// distance(\"Earth\", \"Mercury\") ==> 4\n// distance(\"Mercury\", \"Uranus\") ==> 3\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\") ==> 2\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\") ==> 1\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ==> 0\n// distance(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\", \"Neptune\") ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "screenTiltSum", "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum = (lst) => {\n  const res = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    if (i % 2 === 0) {\n      res.push(sum);\n      sum = 0;\n    }\n  }\n  if (sum > 0) {\n    res.push(sum);\n  }\n  return res;\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltMean = (lst) => {\n  const res = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    if (i % 2 === 0) {\n      res.push(sum / lst.length);\n      sum = 0;\n    }\n  }\n  if (sum > 0) {\n    res.push(sum / lst.length);\n  }\n  return res;\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltVariance = (lst) => {\n  const res = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    if (i % 2 === 0) {\n      res.push(sum / lst.length);\n      sum = 0;\n    }\n  }\n  if (sum > 0) {\n    res.push(sum / lst.length);\n  }\n  return res;\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltVariance2 = (lst, mean) => {\n  const res = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    if (i % 2 === 0) {\n      res.push(sum / lst.length);\n      sum = 0;\n    }\n  }\n  if (sum > 0) {\n    res.push(sum / lst.length);\n  }\n  return res;\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltVariance3 = (lst, variance) => {\n  const res = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    if (i % 2 === 0) {\n      res.push(sum / lst.length);\n      sum = 0;\n    }\n  }\n  if (sum > 0) {\n    res.push(sum / lst.length);\n  }\n  return res;\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltVariance4 = (lst, variance2) => {\n  const res = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    if (i % 2 === 0) {\n      res.push(sum / lst.length);\n      sum = 0;\n    }\n  }\n  if (sum > 0) {\n    res.push(sum / lst.length);\n  }\n  return res;\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltVariance5 = (lst, variance3) => {\n  const res = [];\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    if (i % 2 === 0) {\n      res.push(sum / lst.length);\n      sum = 0;\n    }\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> bowedStringedInstrumentSuccession(0)\n  '0'\n  >>> bowedStringedInstrumentSuccession(5)\n  '0 1 2 3 4 5'\n  */\nconst bowedStringedInstrumentSuccession = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "bowedStringedInstrumentSuccession", "gc": "<|endoftext|>/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> bowedStringedInstrumentSuccession(0)\n  '0'\n  >>> bowedStringedInstrumentSuccession(5)\n  '0 1 2 3 4 5'\n  */\nconst bowedStringedInstrumentSuccession = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst bowedStringedInstrument = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return bowedStringedInstrumentSuccession(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrument = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return bowedStringedInstrument(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrumentSuccession = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrument = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringedInstrumentSuccession(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrumentSuccession = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrument = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringedInstrumentSuccession(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrumentSuccession = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrument = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringedInstrumentSuccession(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrumentSuccession = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrument = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringedInstrumentSuccession(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrumentSuccession = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrument = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringedInstrumentSuccession(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrumentSuccession = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrument = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringedInstrumentSuccession(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrumentSuccession = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrument = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringedInstrumentSuccession(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrumentSuccession = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrument = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringedInstrumentSuccession(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedInstrumentSuccession = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result +='';\n  }\n  return result;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringedIn", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrYttrium", "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium2 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium3 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium4 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium5 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium6 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium7 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium8 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium9 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium10 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium11 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x >= n || y >= n) {\n    return 0\n  }\n  if (n % 2 === 0) {\n    return y\n  }\n  if (n % 3 === 0) {\n    return x\n  }\n  if (n % 5 === 0) {\n    return y\n  }\n  return xOrYttrium(Math.floor(n / 2), y, x)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == 0\n  doubleTheDeviation([9, -2]) == 81\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDeviation", "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == 0\n  doubleTheDeviation([9, -2]) == 81\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 2 + 0 + 0 = 6\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 2 + 0 + 0 = 6\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 5 and ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 2 + 0 + 0 = 6\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 5 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 7 and ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 2 + 0 + 0 = 6\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 7 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 9 and ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 2 + 0 + 0 = 6\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 9 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 11 and ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 2 + 0 + 0 = 6\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 11 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 13 and ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 2 + 0 + 0 = 6\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 13 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 17 and ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 2 + 0 + 0 = 6\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 17 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 19 and ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 2 + 0 + 0 = 6\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 19 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 23 and ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 2 + 0 + 0 = 6\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 23 === 0) {\n      sum += lst[i] * lst[i];\n    }", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const [total] = scores.length;\n  const [correct] = guesses.reduce((acc, curr, index) => {\n    if (curr!== -1) {\n      acc[index] = Math.abs(curr - scores[index]);\n    }\n    return acc;\n  }, []);\n  return [...Array(total).keys()].map(i => correct[i]? correct[i] : Math.abs(correct[i] - scores[i]));\n};\n\n/*\n  Given a game of tic-tac-toe, return an array of all possible moves possible from the current player's current position\n  to the opponent's current position. \n  \n  \n  example:\n\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n  moves([[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]) -> [[1,0],[0,1],[1,0],[0,1],[1,0],[0,1]]\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for hardExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst hardExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "hardExtension", "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst hardExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  let extension_extensions = extensions;\n\n  for (let i = 0; i < extension_extensions.length; i++) {\n    let extension = extension_extensions[i];\n    let extension_strength = extension_strength + extension.length;\n    if (extension_strength > extension_class) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions replaced by their strongest extension.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst hardExtension_strongest = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  let extension_extensions = extensions;\n\n  for (let i = 0; i < extension_extensions.length; i++) {\n    let extension = extension_extensions[i];\n    let extension_strength = extension_strength + extension.length;\n    if (extension_strength > extension_class) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions replaced by their strongest extension.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst hardExtension_strongest_extension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  let extension_extensions = extensions;\n\n  for (let i = 0; i < extension_extensions.length; i++) {\n    let extension = extension_extensions[i];\n    let extension_strength = extension_strength + extension.length;\n    if (extension_strength > extension_class) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions replaced by their strongest extension.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst hardExtension_strongest_extension_strongest = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  let extension_extensions = extensions;\n\n  for (let i = 0; i < extension_extensions.length; i++) {\n    let extension = extension_extensions[i];\n    let extension_strength = extension_strength + extension.length;\n    if (extension_strength > extension_class) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions replaced by their strongest extension.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst hardExtension_strongest_extension_strongest_extension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  let extension_extensions = extensions;\n\n  for (let i = 0; i < extension_extensions.length; i++) {\n    let extension = extension_extensions[i];\n    let extension_strength = extension_strength + extension.length;\n    if (extension_strength > extension_class) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions replaced by their strongest extension.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst hardExtension_strongest_extension_strongest_extension_strongest = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  let extension_extensions = extensions;\n\n  for (let i = 0; i < extension_extensions.length; i++) {\n    let extension = extension_extensions[i];\n    let extension_strength = extension_strength + extension.length;\n    if (extension_strength > extension_class) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions replaced by their strongest extension.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst hardExtension_strongest_extension_strongest_extension_strongest_extension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  let extension_extensions = extensions;\n\n  for (let i = 0; i < extension_extensions.length; i++) {\n    let extension = extension_extensions[i];\n    let extension_strength = extension_strength + extension.length;\n    if (extension_strength > extension_class) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions replaced by their strongest extension.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst hardExtension_strongest_extension_strongest_extension_strongest_extension_strongest = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  let extension_extensions = extensions;\n\n  for (let i = 0; i < extension_extensions.length; i++) {\n    let extension = extension_extensions[i];\n    let extension_strength = extension_strength + extension.length;\n    if (extension_strength > extension_class) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions replaced by their strongest extension.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst hardExtension_strongest_extension_strongest_extension_strongest_extension_strongest_extension_strongest = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  let extension_extensions = extensions;\n\n  for (let i = 0; i < extension_extensions.length; i++) {\n    let extension = extension_extensions[i];\n    let extension_strength = extension_strength + extension.length;\n    if (extension_strength > extension_class) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let aArray = a.split('');\n  let bArray = b.split('');\n  let aLength = aArray.length;\n  let bLength = bArray.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  let aRot = 0;\n  let bRot = 0;\n  let aMatch = false;\n  let bMatch = false;\n  let aMatchRot = false;\n  let bMatchRot = false;\n  let aMatchRotRot = false;\n  let bMatchRotRot = false;\n  let aMatchRotRotRot = false;\n  let bMatchRotRotRot = false;\n  let aMatchRotRotRotRot = false;\n  let bMatchRotRotRotRot = false;\n  let aMatchRotRotRotRotRot = false;\n  let bMatchRotRotRotRotRot = false;\n  let aMatchRotRotRotRotRotRot = false;\n  let bMatchRotRotRotRotRotRot = false;\n  let aMatchRotRotRotRotRotRotRot = false;\n  let bMatchRotRotRotRotRotRotRot = false;\n  let aMatchRotRotRotRotRotRotRotRotRotRot = false;\n  let bMatchRotRotRotRotRotRotRotRotRotRotRot = false;\n  let aMatchRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRotRot", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = num; i >= 0; i--) {\n    if (i % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return an array that has all the characters in that string in sorted order.\n\n   Example:\n      sortedString('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      sortedString('hello123') ==> ['h', 'e', 'l', 'l', 'o', '3']\n  */\nconst sortedString = (str) => {\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str[i]);\n  }\n  arr.sort();\n  return arr;\n};\n\n/*Given a string, return an array that has all the characters in that string in reverse sorted order.\n\n   Example:\n      reversedSortedString('hello') ==> ['o', 'h', 'l', 'l', 'e']\n      reversedSortedString('hello123') ==> ['3', '2', '1', '0', '1']\n  */\nconst reversedSortedString = (str) => {\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str[i]);\n  }\n  arr.sort((a, b) => b - a);\n  return arr;\n};\n\n/*Given a string, return an array that has all the characters in that string in sorted order and in reverse sorted order.\n\n   Example:\n      sortedAndReversedString('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      sortedAndReversedString('hello123') ==> ['h', 'e', 'l', 'l', 'o', '3']\n  */\nconst sortedAndReversedString = (str) => {\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str[i]);\n  }\n  arr.sort((a, b) => b - a);\n  return arr.concat(sortedString(str));\n};\n\n/*Given a string, return an array that has all the characters in that string in sorted order and in reverse sorted order.\n\n   Example:\n      sortedAndReversedAndSortedString('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      sortedAndReversedAndSortedString('hello123') ==> ['h', 'e', 'l', 'l', 'o', '3']\n  */\nconst sortedAndReversedAndSortedString = (str) => {\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str[i]);\n  }\n  arr.sort((a, b) => b - a);\n  return arr.concat(sortedAndReversedString(str));\n};\n\n/*Given a string, return an array that has all the characters in that string in sorted order and in reverse sorted order and in sorted order.\n\n   Example:\n      sortedAndSortedAndReversedAndSortedString('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      sortedAndSortedAndReversedAndSortedString('hello123') ==> ['h', 'e', 'l', 'l', 'o', '3']\n  */\nconst sortedAndSortedAndReversedAndSortedString = (str) => {\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str[i]);\n  }\n  arr.sort((a, b) => b - a);\n  return arr.concat(sortedAndReversedAndSortedString(str));\n};\n\n/*Given a string, return an array that has all the characters in that string in sorted order and in reverse sorted order and in sorted order and in reverse sorted order.\n\n   Example:\n      sortedAndSortedAndReversedAndSortedAndReversedAndSortedString('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      sortedAndSortedAndReversedAndSortedAndReversedAndSortedString('hello123') ==> ['h', 'e', 'l', 'l', 'o', '3']\n  */\nconst sortedAndSortedAndReversedAndSortedAndReversedAndSortedString = (str) => {\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str[i]);\n  }\n  arr.sort((a, b) => b - a);\n  return arr.concat(sortedAndReversedAndSortedAndReversedAndSortedString(str));\n};\n\n/*Given a string, return an array that has all the characters in that string in sorted order and in reverse sorted order and in sorted order and in reverse sorted order.\n\n   Example:\n      sortedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      sortedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString('hello123') ==> ['h', 'e', 'l', 'l', 'o', '3']\n  */\nconst sortedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString = (str) => {\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str[i]);\n  }\n  arr.sort((a, b) => b - a);\n  return arr.concat(sortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString(str));\n};\n\n/*Given a string, return an array that has all the characters in that string in sorted order and in reverse sorted order and in sorted order and in reverse sorted order.\n\n   Example:\n      sortedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      sortedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString('hello123') ==> ['h', 'e', 'l', 'l', 'o', '3']\n  */\nconst sortedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString = (str) => {\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str[i]);\n  }\n  arr.sort((a, b) => b - a);\n  return arr.concat(sortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString(str));\n};\n\n/*Given a string, return an array that has all the characters in that string in sorted order and in reverse sorted order and in sorted order and in reverse sorted order.\n\n   Example:\n      sortedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      sortedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString('hello123') ==> ['h', 'e', 'l', 'l', 'o', '3']\n  */\nconst sortedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString = (str) => {\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str[i]);\n  }\n  arr.sort((a, b) => b - a);\n  return arr.concat(sortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedString(str));\n};\n\n/*Given a string, return an array that has all the characters in that string in sorted order and in reverse sorted order and in sorted order and in reverse sorted order.\n\n   Example:\n      sortedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversedAndSortedAndReversed", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRoman(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRoman = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRoman(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toUpperCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRomanLow(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRomanLow(19) == 'XIX'\n  >>> intToRomanLow(152) == 'CLI'\n  >>> intToRomanLow(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRomanLow(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toUpperCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRomanLow(19) == 'XIX'\n  >>> intToRomanLow(152) == 'CLI'\n  >>> intToRomanLow(426) == 'CDXVI'\n  */\nconst intToRomanLower = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRomanLower(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRomanLower(19) == 'XIX'\n  >>> intToRomanLower(152) == 'CLI'\n  >>> intToRomanLower(426) == 'CDXVI'\n  */\nconst intToRomanUpper = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRomanUpper(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toUpperCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRomanUpper(19) == 'XIX'\n  >>> intToRomanUpper(152) == 'CLI'\n  >>> intToRomanUpper(426) == 'CDXVI'\n  */\nconst intToRomanUpper = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRomanUpper(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRomanUpper(19) == 'XIX'\n  >>> intToRomanUpper(152) == 'CLI'\n  >>> intToRomanUpper(426) == 'CDXVI'\n  */\nconst intToRomanLower = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRomanLower(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toUpperCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRomanLower(19) == 'XIX'\n  >>> intToRomanLower(152) == 'CLI'\n  >>> intToRomanLower(426) == 'CDXVI'\n  */\nconst intToRomanLower = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRomanLower(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRomanLower(19) == 'XIX'\n  >>> intToRomanLower(152) == 'CLI'\n  >>> intToRomanLower(426) == 'CDXVI'\n  */\nconst intToRomanUpper = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRomanUpper(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toUpperCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRomanUpper(19) == 'XIX'\n  >>> intToRomanUpper(152) == 'CLI'\n  >>> intToRomanUpper(426) == 'CDXVI'\n  */\nconst intToRomanUpper = (number) => {\n  const digits = Math.floor(Math.log10(number));\n  const roman = '';\n  for (let i = 0; i < digits; i++) {\n    roman += intToRomanUpper(number % 10);\n    number = Math.floor(number / 10);\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to a roman numeral equivalent in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRo", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantTriangle(3, 4, 5) == true\n  goodSlantTriangle(1, 2, 3) == false\n  */\nconst goodSlantTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "goodSlantTriangle", "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantTriangle(3, 4, 5) == true\n  goodSlantTriangle(1, 2, 3) == false\n  */\nconst goodSlantTriangle = (a, b, c) => {\n  let aLength = Math.abs(a),\n    bLength = Math.abs(b),\n    cLength = Math.abs(c);\n  if (aLength > bLength && bLength > cLength) {\n    return true;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides of a rectangle. Return true if the three\n  sides form a right-angled rectangle, false otherwise.\n  A right-angled rectangle is a rectangle in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantRectangle(3, 4, 5) == true\n  goodSlantRectangle(1, 2, 3) == false\n  */\nconst goodSlantRectangle = (a, b, c) => {\n  let aLength = Math.abs(a),\n    bLength = Math.abs(b),\n    cLength = Math.abs(c);\n  if (aLength > bLength && bLength > cLength) {\n    return true;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides of a circle. Return true if the three\n  sides form a right-angled circle, false otherwise.\n  A right-angled circle is a circle in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantCircle(3, 4, 5) == true\n  goodSlantCircle(1, 2, 3) == false\n  */\nconst goodSlantCircle = (a, b, c) => {\n  let aLength = Math.abs(a),\n    bLength = Math.abs(b),\n    cLength = Math.abs(c);\n  if (aLength > bLength && bLength > cLength) {\n    return true;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides of a square. Return true if the three\n  sides form a right-angled square, false otherwise.\n  A right-angled square is a square in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantSquare(3, 4, 5) == true\n  goodSlantSquare(1, 2, 3) == false\n  */\nconst goodSlantSquare = (a, b, c) => {\n  let aLength = Math.abs(a),\n    bLength = Math.abs(b),\n    cLength = Math.abs(c);\n  if (aLength > bLength && bLength > cLength) {\n    return true;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides of a pentagon. Return true if the three\n  sides form a right-angled pentagon, false otherwise.\n  A right-angled pentagon is a pentagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantPentagon(3, 4, 5) == true\n  goodSlantPentagon(1, 2, 3) == false\n  */\nconst goodSlantPentagon = (a, b, c) => {\n  let aLength = Math.abs(a),\n    bLength = Math.abs(b),\n    cLength = Math.abs(c);\n  if (aLength > bLength && bLength > cLength) {\n    return true;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides of a hexagon. Return true if the three\n  sides form a right-angled hexagon, false otherwise.\n  A right-angled hexagon is a hexagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantHexagon(3, 4, 5) == true\n  goodSlantHexagon(1, 2, 3) == false\n  */\nconst goodSlantHexagon = (a, b, c) => {\n  let aLength = Math.abs(a),\n    bLength = Math.abs(b),\n    cLength = Math.abs(c);\n  if (aLength > bLength && bLength > cLength) {\n    return true;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides of a heptagon. Return true if the three\n  sides form a right-angled heptagon, false otherwise.\n  A right-angled heptagon is a heptagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantHeptagon(3, 4, 5) == true\n  goodSlantHeptagon(1, 2, 3) == false\n  */\nconst goodSlantHeptagon = (a, b, c) => {\n  let aLength = Math.abs(a),\n    bLength = Math.abs(b),\n    cLength = Math.abs(c);\n  if (aLength > bLength && bLength > cLength) {\n    return true;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides of a decagon. Return true if the three\n  sides form a right-angled decagon, false otherwise.\n  A right-angled decagon is a decagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantDecagon(3, 4, 5) == true\n  goodSlantDecagon(1, 2, 3) == false\n  */\nconst goodSlantDecagon = (a, b, c) => {\n  let aLength = Math.abs(a),\n    bLength = Math.abs(b),\n    cLength = Math.abs(c);\n  if (aLength > bLength && bLength > cLength) {\n    return true;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides of a dodecagon. Return true if the three\n  sides form a right-angled dodecagon, false otherwise.\n  A right-angled dodecagon is a dodecagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantDodecagon(3, 4, 5) == true\n  goodSlantDodecagon(1, 2, 3) == false\n  */\nconst goodSlantDodecagon = (a, b, c) => {\n  let aLength = Math.abs(a),\n    bLength = Math.abs(b),\n    cLength = Math.abs(c);\n  if (aLength > bLength && bLength > cLength) {\n    return true;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides of a octagon. Return true if the three\n  sides form a right-angled octagon, false otherwise.\n  A right-angled octagon is a octagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantOctagon(3, 4, 5) == true\n  goodSlantOctagon(1, 2, 3) == false\n  */\nconst goodSlantOctagon = (a, b, c) => {\n  let aLength = Math.abs(a),\n    bLength = Math.abs(b),\n    cLength = Math.abs(c);\n  if (aLength > bLength && bLength > cLength) {\n    return true;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides of a dodecagon. Return true if the three\n  sides form a right-angled dodecagon, false otherwise.\n  A right-angled dodecagon is a dodecagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantDodecagon(3, 4, 5) == true\n  goodSlantDodecagon(1, 2, 3) == false\n  */\nconst goodSlantDodecagon = (a, b, c) => {\n  let aLength", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMax([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "receiveMax", "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMax([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word = \"\";\n  let uniqueChars = 0;\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n    if (word.length < uniqueChars) {\n      uniqueChars = word.length;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with minimum number\n  of unique characters. If multiple strings have minimum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMin([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMin([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMin([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMin = (words) => {\n  let min = 0;\n  let minWord = \"\";\n  let word = \"\";\n  let uniqueChars = 0;\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > min) {\n      min = word.length;\n      minWord = word;\n    }\n    if (word.length < uniqueChars) {\n      uniqueChars = word.length;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMaxUnique([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMaxUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMaxUnique([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMaxUnique = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word = \"\";\n  let uniqueChars = 0;\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n    if (word.length < uniqueChars) {\n      uniqueChars = word.length;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with minimum number\n  of unique characters. If multiple strings have minimum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMinUnique([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMinUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMinUnique([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMinUnique = (words) => {\n  let min = 0;\n  let minWord = \"\";\n  let word = \"\";\n  let uniqueChars = 0;\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > min) {\n      min = word.length;\n      minWord = word;\n    }\n    if (word.length < uniqueChars) {\n      uniqueChars = word.length;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMaxUnique([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMaxUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMaxUnique([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMaxUniqueUnique = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word = \"\";\n  let uniqueChars = 0;\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n    if (word.length < uniqueChars) {\n      uniqueChars = word.length;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with minimum number\n  of unique characters. If multiple strings have minimum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMinUnique([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMinUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMinUnique([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMinUniqueUnique = (words) => {\n  let min = 0;\n  let minWord = \"\";\n  let word = \"\";\n  let uniqueChars = 0;\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > min) {\n      min = word.length;\n      minWord = word;\n    }\n    if (word.length < uniqueChars) {\n      uniqueChars = word.length;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMaxUniqueUnique([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMaxUniqueUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMaxUniqueUnique([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMaxUniqueUnique = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word = \"\";\n  let uniqueChars = 0;\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n    if (word.length < uniqueChars) {\n      uniqueChars = word.length;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with minimum number\n  of unique characters. If multiple strings have minimum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMinUniqueUnique([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMinUniqueUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMinUniqueUnique([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMinUniqueUnique = (words) => {\n  let min = 0;\n  let minWord = \"\";\n  let word = \"\";\n  let uniqueChars = 0;\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > min) {\n      min = word.length;\n      minWord = word;\n    }\n    if (word.length < uniqueChars) {\n      uniqueChars = word.length;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMaxUniqueUnique([\"name\", \"of\", \"string", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "feed", "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const totalCarrots = Math.ceil(number / need);\n  const remainingCarrots = number - totalCarrots * need;\n  const carrots = Math.ceil(remainingCarrots / need);\n  return [totalCarrots, carrots];\n};\n\n/*\n  You are a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const totalCarrots = Math.ceil(number / need);\n  const remainingCarrots = number - totalCarrots * need;\n  const carrots = Math.ceil(remainingCarrots / need);\n  return [totalCarrots, carrots];\n};\n\n/*\n  You are a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const totalCarrots = Math.ceil(number / need);\n  const remainingCarrots = number - totalCarrots * need;\n  const carrots = Math.ceil(remainingCarrots / need);\n  return [totalCarrots, carrots];\n};\n\n/*\n  You are a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const totalCarrots = Math.ceil(number / need);\n  const remainingCarrots = number - totalCarrots * need;\n  const carrots = Math.ceil(remainingCarrots / need);\n  return [totalCarrots, carrots];\n};\n\n/*\n  You are a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const totalCarrots = Math.ceil(number / need);\n  const remainingCarrots = number - totalCarrots * need;\n  const carrots = Math.ceil(remainingCarrots / need);\n  return [totalCarrots, carrots];\n};\n\n/*\n  You are a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "considerClearcutCharacters", "gc": "<|endoftext|>/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let charCount = 0;\n  let lowerCaseCount = 0;\n  let upperCaseCount = 0;\n  let numberCount = 0;\n  let symbolCount = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      charCount++;\n    } else if (char === '-') {\n      lowerCaseCount++;\n    } else if (char === '_') {\n      upperCaseCount++;\n    } else if (char === '0') {\n      numberCount++;\n    } else if (char === '!') {\n      symbolCount++;\n    }\n  }\n\n  return charCount + (lowerCaseCount * 2) + (upperCaseCount * 2) + (numberCount * 2) + (symbolCount * 2);\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutWords = (string) => {\n  let wordCount = 0;\n  let lowerCaseCount = 0;\n  let upperCaseCount = 0;\n  let numberCount = 0;\n  let symbolCount = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      wordCount++;\n    } else if (char === '-') {\n      lowerCaseCount++;\n    } else if (char === '_') {\n      upperCaseCount++;\n    } else if (char === '0') {\n      numberCount++;\n    } else if (char === '!') {\n      symbolCount++;\n    }\n  }\n\n  return wordCount + (lowerCaseCount * 2) + (upperCaseCount * 2) + (numberCount * 2) + (symbolCount * 2);\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutWords('xyzXYZ')\n  3\n  >>> considerClearcutWords('Jerry')\n  4\n  */\nconst considerClearcutWordsNoCase = (string) => {\n  let wordCount = 0;\n  let lowerCaseCount = 0;\n  let upperCaseCount = 0;\n  let numberCount = 0;\n  let symbolCount = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      wordCount++;\n    } else if (char === '-') {\n      lowerCaseCount++;\n    } else if (char === '_') {\n      upperCaseCount++;\n    } else if (char === '0') {\n      numberCount++;\n    } else if (char === '!') {\n      symbolCount++;\n    }\n  }\n\n  return wordCount + (lowerCaseCount * 2) + (upperCaseCount * 2) + (numberCount * 2) + (symbolCount * 2);\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutWordsNoCase('xyzXYZ')\n  3\n  >>> considerClearcutWordsNoCase('Jerry')\n  4\n  */\nconst considerClearcutWordsNoCaseNoCase = (string) => {\n  let wordCount = 0;\n  let lowerCaseCount = 0;\n  let upperCaseCount = 0;\n  let numberCount = 0;\n  let symbolCount = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      wordCount++;\n    } else if (char === '-') {\n      lowerCaseCount++;\n    } else if (char === '_') {\n      upperCaseCount++;\n    } else if (char === '0') {\n      numberCount++;\n    } else if (char === '!') {\n      symbolCount++;\n    }\n  }\n\n  return wordCount + (lowerCaseCount * 2) + (upperCaseCount * 2) + (numberCount * 2) + (symbolCount * 2);\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutWordsNoCaseNoCase('xyzXYZ')\n  3\n  >>> considerClearcutWordsNoCaseNoCase('Jerry')\n  4\n  */\nconst considerClearcutWordsNoCaseNoCaseNoCase = (string) => {\n  let wordCount = 0;\n  let lowerCaseCount = 0;\n  let upperCaseCount = 0;\n  let numberCount = 0;\n  let symbolCount = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      wordCount++;\n    } else if (char === '-') {\n      lowerCaseCount++;\n    } else if (char === '_') {\n      upperCaseCount++;\n    } else if (char === '0') {\n      numberCount++;\n    } else if (char === '!') {\n      symbolCount++;\n    }\n  }\n\n  return wordCount + (lowerCaseCount * 2) + (upperCaseCount * 2) + (numberCount * 2) + (symbolCount * 2);\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutWordsNoCaseNoCaseNoCase('xyzXYZ')\n  3\n  >>> considerClearcutWordsNoCaseNoCaseNoCaseNoCase('Jerry')\n  4\n  */\nconst considerClearcutWordsNoCaseNoCaseNoCaseNoCase = (string) => {\n  let wordCount = 0;\n  let lowerCaseCount = 0;\n  let upperCaseCount = 0;\n  let numberCount = 0;\n  let symbolCount = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      wordCount++;\n    } else if (char === '-') {\n      lowerCaseCount++;\n    } else if (char === '_') {\n      upperCaseCount++;\n    } else if (char === '0') {\n      numberCount++;\n    } else if (char === '!') {\n      symbolCount++;\n    }\n  }\n\n  return wordCount + (lowerCaseCount * 2) + (upperCaseCount * 2) + (numberCount * 2) + (symbolCount * 2);\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutWordsNoCaseNoCaseNoCaseNoCase('xyzXYZ')\n  3\n  >>> considerClearcutWordsNoCaseNoCaseNoCaseNoCaseNoCase('Jerry')\n  4\n  */\nconst considerClearcutWordsNoCaseNoCaseNoCaseNoCaseNoCase = (string) => {\n  let wordCount = 0;\n  let lowerCaseCount = 0;\n  let upperCaseCount = 0;\n  let numberCount = 0;\n  let symbolCount = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      wordCount++;\n    } else if (char === '-') {\n      lowerCaseCount++;\n    } else if (char === '_') {\n      upperCaseCount++;\n    } else if (char === '0') {\n      numberCount++;\n    } else if (char === '!') {\n      symbolCount++;\n    }\n  }\n\n  return wordCount + (lowerCaseCount * 2) + (upperCaseCount * 2) + (numberCount * 2) + (symbolCount * 2);\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutWordsNoCaseNoCaseNoCaseNoCaseNoCase('xyzXYZ')\n  3\n  >>> considerClearcutWordsNoCaseNoCaseNoCaseNoCaseNoCaseNoCase('Jerry')\n  4\n  */\nconst considerClearcutWordsNoCaseNoCaseNoCaseNoCaseNoCaseNoCase = (string) => {\n  let wordCount = 0;\n  let lowerCaseCount = 0;\n  let upperCaseCount = 0;\n  let numberCount = 0;\n  let symbolCount = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      wordCount++;\n    } else if (", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst sufficeAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "sufficeAlgebra", "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst sufficeAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length;\n  const result = 0;\n  for (let i = 0; i < operatorLength; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst prefixAlgebra = (operator, operand) => {\n  const operatorList = operator.split('-');\n  const operandList = operand.split('-');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length;\n  const result = 0;\n  for (let i = 0; i < operatorLength; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst postfixAlgebra = (operator, operand) => {\n  const operatorList = operator.split('*');\n  const operandList = operand.split('*');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length;\n  const result = 0;\n  for (let i = 0; i < operatorLength; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst powerAlgebra = (operator, operand) => {\n  const operatorList = operator.split('/');\n  const operandList = operand.split('/');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length;\n  const result = 0;\n  for (let i = 0; i < operatorLength; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst powerAlgebra = (operator, operand) => {\n  const operatorList = operator.split('^');\n  const operandList = operand.split('^');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length;\n  const result = 0;\n  for (let i = 0; i < operatorLength; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst powerAlgebra = (operator, operand) => {\n  const operatorList = operator.split('*');\n  const operandList = operand.split('*');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length;\n  const result = 0;\n  for (let i = 0; i < operatorLength; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  resolve(\"1234\") = \"4321\"\n  resolve(\"ab\") = \"AB\"\n  resolve(\"#a@C\") = \"#A@c\"\n  */\nconst resolve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "resolve", "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  resolve(\"1234\") = \"4321\"\n  resolve(\"ab\") = \"AB\"\n  resolve(\"#a@C\") = \"#A@c\"\n  */\nconst resolve = (s) => {\n  let res = '';\n  let letters = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let temp = '';\n  \n  while(i < l) {\n    letters = s.charAt(i);\n    \n    if(letters === 'a' || letters === 'A') {\n      letters = letters.toUpperCase();\n      \n      if(letters === 'A') {\n        letters = 'a';\n      }\n      \n      if(letters === 'a') {\n        letters = 'A';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'A') {\n        letters = 'a';\n      }\n      \n      if(letters === 'a') {\n        letters = 'A';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a') {\n        letters = 'a';\n      }\n      \n      if(letters === 'A') {\n        letters = 'A';\n      }\n      \n      if(letters === 'a", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "bowedStringedInstrumentToMd5", "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5WithEmptyString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5WithEmptyString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5WithEmptyStringAndEmptyString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5WithEmptyStringAndEmptyString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5WithEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyStringAndEmptyString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  renderInteger(2, 8) => [2, 4, 6, 8]\n  renderInteger(8, 2) => [2, 4, 6, 8]\n  renderInteger(10, 14) => []\n  */\nconst renderInteger = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "renderInteger", "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  renderInteger(2, 8) => [2, 4, 6, 8]\n  renderInteger(8, 2) => [2, 4, 6, 8]\n  renderInteger(10, 14) => []\n  */\nconst renderInteger = (a, b) => {\n  const digits = Array.from({ length: b }, (_, i) => i);\n  const evenDigits = digits.filter(d => d % 2 === 0);\n  return evenDigits.map(d => d % 10 + d).sort();\n};\n\n/*\n  Given a string, return the string in all uppercase.\n\n  For example:\n  upperCase('Hello World') => 'HELLO WORLD'\n  upperCase('Hello World!') => 'HELLO WORLD!'\n  upperCase('Hello World!', true) => 'Hello World!'\n  */\nconst upperCase = (str, caseSensitive = false) => {\n  return str\n   .toLowerCase()\n   .split(\"\")\n   .map(c => c.toUpperCase())\n   .filter(c => c!== \"\")\n   .map(c => c + (caseSensitive? \" \" : \"\"));\n};\n\n/*\n  Given a string, return the string in all lowercase.\n\n  For example:\n  lowerCase('Hello World') => 'hello world'\n  lowerCase('Hello World!') => 'hello world!'\n  lowerCase('Hello World!', true) => 'hello world!'\n  */\nconst lowerCase = (str, caseSensitive = false) => {\n  return str\n   .toLowerCase()\n   .split(\"\")\n   .map(c => c.toLowerCase())\n   .filter(c => c!== \"\")\n   .map(c => c + (caseSensitive? \" \" : \"\"));\n};\n\n/*\n  Given a string, return the string in all uppercase and lowercase.\n\n  For example:\n  capitalize('Hello World') => 'Hello World'\n  capitalize('Hello World!') => 'Hello World!'\n  capitalize('Hello World!', true) => 'Hello World!'\n  */\nconst capitalize = (str, caseSensitive = false) => {\n  return str\n   .toLowerCase()\n   .split(\"\")\n   .map(c => c.toUpperCase())\n   .filter(c => c!== \"\")\n   .map(c => c + (caseSensitive? \" \" : \"\"));\n};\n\n/*\n  Given a string, return the string in all uppercase and lowercase with spaces.\n\n  For example:\n  capitalizeSpace('Hello World') => 'Hello World'\n  capitalizeSpace('Hello World!') => 'Hello World!'\n  capitalizeSpace('Hello World!', true) => 'Hello World!'\n  */\nconst capitalizeSpace = (str, caseSensitive = false) => {\n  return str\n   .toLowerCase()\n   .split(\"\")\n   .map(c => c.toUpperCase())\n   .filter(c => c!== \"\")\n   .map(c => c + (caseSensitive? \" \" : \"\"));\n};\n\n/*\n  Given a string, return the string in all uppercase and lowercase with spaces and dashes.\n\n  For example:\n  capitalizeDash('Hello World') => 'Hello World'\n  capitalizeDash('Hello World!') => 'Hello World!'\n  capitalizeDash('Hello World!', true) => 'Hello World!'\n  */\nconst capitalizeDash = (str, caseSensitive = false) => {\n  return str\n   .toLowerCase()\n   .split(\"\")\n   .map(c => c.toUpperCase())\n   .filter(c => c!== \"\")\n   .map(c => c + (caseSensitive? \" \" : \"\"));\n};\n\n/*\n  Given a string, return the string in all uppercase and lowercase with spaces and dashes and underscores.\n\n  For example:\n  capitalizeUnderscore('Hello World') => 'Hello World'\n  capitalizeUnderscore('Hello World!') => 'Hello World!'\n  capitalizeUnderscore('Hello World!', true) => 'Hello World!'\n  */\nconst capitalizeUnderscore = (str, caseSensitive = false) => {\n  return str\n   .toLowerCase()\n   .split(\"\")\n   .map(c => c.toUpperCase())\n   .filter(c => c!== \"\")\n   .map(c => c + (caseSensitive? \" \" : \"\"));\n};\n\n/*\n  Given a string, return the string in all uppercase and lowercase with spaces and dashes and underscores and dashes.\n\n  For example:\n  capitalizeDashUnderscore('Hello World') => 'Hello World'\n  capitalizeDashUnderscore('Hello World!') => 'Hello World!'\n  capitalizeDashUnderscore('Hello World!', true) => 'Hello World!'\n  */\nconst capitalizeDashUnderscore = (str, caseSensitive = false) => {\n  return str\n   .toLowerCase()\n   .split(\"\")\n   .map(c => c.toUpperCase())\n   .filter(c => c!== \"\")\n   .map(c => c + (caseSensitive? \" \" : \"\"));\n};\n\n/*\n  Given a string, return the string in all uppercase and lowercase with spaces and dashes and underscores and dashes and underscores.\n\n  For example:\n  capitalizeUnderscoreDashUnderscore('Hello World') => 'Hello World'\n  capitalizeUnderscoreDashUnderscore('Hello World!') => 'Hello World!'\n  capitalizeUnderscoreDashUnderscore('Hello World!', true) => 'Hello World!'\n  */\nconst capitalizeUnderscoreDashUnderscore = (str, caseSensitive = false) => {\n  return str\n   .toLowerCase()\n   .split(\"\")\n   .map(c => c.toUpperCase())\n   .filter(c => c!== \"\")\n   .map(c => c + (caseSensitive? \" \" : \"\"));\n};\n\n/*\n  Given a string, return the string in all uppercase and lowercase with spaces and dashes and underscores and dashes and underscores.\n\n  For example:\n  capitalizeUnderscoreDashUnderscore('Hello World') => 'Hello World'\n  capitalizeUnderscoreDashUnderscore('Hello World!') => 'Hello World!'\n  capitalizeUnderscoreDashUnderscore('Hello World!', true) => 'Hello World!'\n  */\nconst capitalizeUnderscoreDashUnderscoreDashUnderscore = (str, caseSensitive = false) => {\n  return str\n   .toLowerCase()\n   .split(\"\")\n   .map(c => c.toUpperCase())\n   .filter(c => c!== \"\")\n   .map(c => c + (caseSensitive? \" \" : \"\"));\n};\n\n/*\n  Given a string, return the string in all uppercase and lowercase with spaces and dashes and underscores and dashes and underscores and dashes.\n\n  For example:\n  capitalizeUnderscoreDashUnderscoreDashUnderscore('Hello World') => 'Hello World'\n  capitalizeUnderscoreDashUnderscoreDashUnderscore('Hello World!') => 'Hello World!'\n  capitalizeUnderscoreDashUnderscoreDashUnderscore('Hello World!', true) => 'Hello World!'\n  */\nconst capitalizeUnderscoreDashUnderscoreDashUnderscoreDashUnderscore = (str, caseSensitive = false) => {\n  return str\n   .toLowerCase()\n   .split(\"\")\n   .map(c => c.toUpperCase())\n   .filter(c => c!== \"\")\n   .map(c => c + (caseSensitive? \" \" : \"\"));\n};\n\n/*\n  Given a string, return the string in all uppercase and lowercase with spaces and dashes and underscores and dashes and underscores and dashes and underscores and dashes.\n\n  For example:\n  capitalizeUnderscoreDashUnderscoreDashUnderscore('Hello World') => 'Hello World'\n  capitalizeUnderscoreDashUnderscoreDashUnderscore('Hello World!') => 'Hello World!'\n  capitalizeUnderscoreDashUnderscoreDashUnderscore('Hello World!', true) => ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "gc": "<|endoftext|>/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const note_beats = note.split(\" \");\n    notes_beats.push(parseInt(note_beats[0], 10));\n  }\n  return notes_beats;\n};\n\n/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const note_beats = note.split(\" \");\n    notes_beats.push(parseInt(note_beats[0], 10));\n  }\n  return notes_beats;\n};\n\n/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const note_beats = note.split(\" \");\n    notes_beats.push(parseInt(note_beats[0], 10));\n  }\n  return notes_beats;\n};\n\n/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const note_beats = note.split(\" \");\n    notes_beats.push(parseInt(note_beats[0], 10));\n  }\n  return notes_beats;\n};\n\n/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const note_beats = note.split(\" \");\n    notes_beats.push(parseInt(note_beats[0], 10));\n  }\n  return notes_beats;\n};\n\n/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const note_beats = note.split(\" \");\n    notes_beats.push(parseInt(note_beats[0], 10));\n  }\n  return notes_beats;\n};\n\n/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const note_beats = note.split(\" \");\n    notes_beats.push(parseInt(note_beats[0], 10));\n  }\n  return notes_beats;\n};\n\n/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const note_beats = note", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "gc": "<|endoftext|>/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === substring) {\n      count++;\n      index++;\n    }\n    index++;\n  }\n  return count;\n};\n\n/**\n * Given a string, return all possible permutations of the given string.\n * If there are duplicate permutations, only the first occurrence is returned.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutations, return the permutations in an array.\n * If there are multiple permutation", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedArray = numberArray.sort((a, b) => {\n    return a - b;\n  });\n  return sortedArray.join(' ');\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n  Given a string, return the first letter of the string capitalized.\n  >>> capitalize('hello')\n  'Hello'\n  */\nconst capitalize = (str) => {\n  return str.charAt(", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateInteger = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the fractional part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the mantissa of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentFractionMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentExponentMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentExponentFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentExponentFractionMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentExponentExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentExponentExponentMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentExponentExponentFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentExponentExponentFractionMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentExponentExponentExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst receiveClosestChemicalElement = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "receiveClosestChemicalElement", "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst receiveClosestChemicalElement = (numbers) => {\n  const [minDistance, closestChemicalElement] = numbers.reduce((minDistance, currentNumber) => {\n    const currentChemicalElement = currentNumber.toUpperCase();\n    const closestChemicalElement = chemicalElements.find(chemicalElement => chemicalElement.name === currentChemicalElement);\n    return minDistance < closestChemicalElement? minDistance : closestChemicalElement;\n  }, Number.NEGATIVE_INFINITY);\n  return [minDistance, closestChemicalElement];\n};\n\nconst getChemicalElementsOfChemicalElement = (chemicalElement) => {\n  const chemicalElements = chemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n  return chemicalElements;\n};\n\nconst getChemicalElementsOfChemicalElements = (chemicalElements) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements;\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElement = (chemicalElements, chemicalElement) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElements = (chemicalElements, chemicalElements) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElement = (chemicalElements, chemicalElements, chemicalElement) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElements = (chemicalElements, chemicalElements, chemicalElements) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElement = (chemicalElements, chemicalElements, chemicalElements, chemicalElement) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElement = (chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElement) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElement = (chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElement) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElement = (chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElement) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElement = (chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElement) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElement = (chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElement) => {\n  const chemicalElementsOfChemicalElements = chemicalElements.map(chemicalElement => chemicalElement);\n  return chemicalElementsOfChemicalElements.filter(chemicalElement => chemicalElement.name === chemicalElement);\n};\n\nconst getChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElementsOfChemicalElement = (chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElements, chemicalElement) => {\n  const chemicalElementsOfChemicalElement", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const range = range === 0? 0 : range;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  const result = numbers.map(n => n * factor);\n  return result;\n};\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst getRandomInt = () => Math.floor(Math.random() * 10000);\n\nconst getRandomFloat = () => Math.random() * 100;\n\nconst ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given list of any python values only for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number' && isFinite(value));\n};\n\n/**\n * Filter given list of any python values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  [5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filter given list of any python values only for None\n  >>> filterNone([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterNone = (values) => {\n  return values.filter(value => value === null);\n};\n\n/**\n * Filter given list of any python values only for empty list\n  >>> filterEmpty([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmpty = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty dict\n  >>> filterEmptyDict({})\n  {}\n  >>> filterEmptyDict({'a': 'b'})\n  {}\n  >>> filterEmptyDict({'a': 'b'})\n  {'a': 'b'}\n  */\nconst filterEmptyDict = (values) => {\n  return values.filter(value => Object.keys(value).length === 0);\n};\n\n/**\n * Filter given list of any python values only for empty string\n  >>> filterEmptyString('abc')\n  ''\n  >>> filterEmptyString('abc')\n  ''\n  >>> filterEmptyString('abc')\n  'abc'\n  */\nconst filterEmptyString = (value) => {\n  return value === ''? [] : value;\n};\n\n/**\n * Filter given list of any python values only for empty array\n  >>> filterEmptyArray([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptyArray([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptyArray([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyArray = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty object\n  >>> filterEmptyObject({a: 'b'})\n  {}\n  >>> filterEmptyObject({a: 'b'})\n  {}\n  >>> filterEmptyObject({a: 'b'})\n  {'a': 'b'}\n  */\nconst filterEmptyObject = (values) => {\n  return values.filter(value => Object.keys(value).length === 0);\n};\n\n/**\n * Filter given list of any python values only for empty function\n  >>> filterEmptyFunction(() => {})\n  {}\n  >>> filterEmptyFunction(() => {})\n  {}\n  >>> filterEmptyFunction(() => {})\n  {}\n  */\nconst filterEmptyFunction = (value) => {\n  return value? [] : value;\n};\n\n/**\n * Filter given list of any python values only for empty iterable\n  >>> filterEmptyIterable([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptyIterable([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptyIterable([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyIterable = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty generator\n  >>> filterEmptyGenerator(() => {})\n  {}\n  >>> filterEmptyGenerator(() => {})\n  {}\n  >>> filterEmptyGenerator(() => {})\n  {}\n  */\nconst filterEmptyGenerator = (value) => {\n  return value? [] : value;\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty map\n  >>> filterEmptyMap({a: 'b'})\n  {}\n  >>> filterEmptyMap({a: 'b'})\n  {}\n  >>> filterEmptyMap({a: 'b'})\n  {'a': 'b'}\n  */\nconst filterEmptyMap = (values) => {\n  return values.filter(value => Object.keys(value).length === 0);\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet({a: 'b'})\n  {}\n  >>> filterEmptySet({a: 'b'})\n  {}\n  >>> filterEmptySet({a: 'b'})\n  {'a': 'b'}\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty list\n  >>> filterEmptyList([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptyList([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptyList([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyList = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty tuple\n  >>> filterEmptyTuple([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptyTuple([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptyTuple([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyTuple = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  []\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty dict\n  >>> filterEmptyDict([1, 2, 3, 'abc', {}, []])\n  {}\n  >>> filterEmptyDict([1, 2, 3, 'abc', {}, []])\n  {}\n  >>> filterEmptyDict([1, 2, 3, 'abc', {}, []])\n  {'a': 'b'}\n  */\nconst filterEmptyDict = (values) => {\n  return values.filter(value => Object.keys(value).length === 0);\n};\n\n/**\n * Filter given list of any python values only for empty string\n  >>> filterEmptyString([1, 2, 3, 'abc', {}, []])\n  ''\n  >>> filterEmptyString([1, 2, 3, 'abc', {}, []])\n  ''\n  >>> filterEmptyString([1, 2, 3, 'abc', {}, []])\n  'abc'\n  */", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "gc": "<|endoftext|>/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n// Return true if string starts with given prefix\nconst startsWith = (string, prefix) => {\n  return string.slice(0, prefix.length) === prefix\n}\n\n// Return true if string ends with given suffix\nconst endsWith = (string, suffix) => {\n  return string.slice(string.length - suffix.length) === suffix\n}\n\n// Return true if string contains given substring\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstring = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstring = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if string contains given substring\nconst containsSubstring = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring, substring.length)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring, substring.length)\n}\n\n// Return true if string contains given substring\nconst containsSubstringSubstring = (string, substring) => {\n  return string.includes(substring, substring.length)\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring, substring, substring.length)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring, substring, substring.length)\n}\n\n// Return true if string contains given substring\nconst containsSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring, substring, substring.length)\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring, substring, substring, substring.length)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring, substring, substring, substring.length)\n}\n\n// Return true if string contains given substring\nconst containsSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring, substring, substring, substring.length)\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string contains given substring\nconst containsSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string contains given substring\nconst containsSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string contains given substring\nconst containsSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string contains given substring\nconst containsSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string contains given substring\nconst containsSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring, substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring, substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string contains given substring\nconst containsSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring, substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring, substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring, substring, substring, substring, substring, substring, substring, substring, substring.length)\n}\n\n// Return true if string contains given substring\nconst containsSub", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> bigDivisor(15)\n  5\n  */\nconst bigDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "bigDivisor", "gc": "<|endoftext|>/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> bigDivisor(15)\n  5\n  */\nconst bigDivisor = (n) => {\n  let i = 1;\n  let result = 1;\n  while (result < n) {\n    if (n % i === 0) {\n      result = i;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigDivisor(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let i = 1;\n  let result = 1;\n  while (result < n) {\n    if (n % i === 0) {\n      result = i;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigPower = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigPower(2, 15)\n * 4\n */\nconst bigMultiply = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigMultiply(2, 15)\n * 4\n */\nconst bigDivide = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigDivide(2, 15)\n * 4\n */\nconst bigModulus = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulus(2, 15)\n * 4\n */\nconst bigPow = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigPow(2, 15)\n * 4\n */\nconst bigMultiplyPow = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigMultiplyPow(2, 15)\n * 4\n */\nconst bigDividePow = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigDividePow(2, 15)\n * 4\n */\nconst bigModulusPow = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulusPow(2, 15)\n * 4\n */\nconst bigPowerModulus = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigPowerModulus(2, 15)\n * 4\n */\nconst bigPowerModulusPow = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigPowerModulusPow(2, 15)\n * 4\n */\nconst bigPowerModulusDivide = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigPowerModulusDivide(2, 15)\n * 4\n */\nconst bigPowerModulusDividePow = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigPowerModulusDividePow(2, 15)\n * 4\n */\nconst bigPowerModulusDividePowModulus = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigPowerModulusDividePowModulus(2, 15)\n * 4\n */\nconst bigPowerModulusDividePowModulusPow = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigPowerModulusDividePowModulusPow(2, 15)\n * 4\n */\nconst bigPowerModulusDividePowModulusDivide = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigPowerModulusDividePowModulusDivide(2, 15)\n * 4\n */\nconst bigPowerModulusDividePowModulusDividePow = (base, exponent) => {\n  let result = 1;\n  while (exponent > 0) {\n    if (exponent % 2 === 0) {\n      result = base * result;\n    }\n    exponent--;\n    base *= base;\n  }\n  return result;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize8 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize9 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize10 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize11 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize12 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    factors.push(factor);\n    factor *= factor;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize13 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (factor ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> getRidOfDuplicate([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst getRidOfDuplicate = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "getRidOfDuplicate", "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> getRidOfDuplicate([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst getRidOfDuplicate = (numbers) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToInt('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToInt = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToInt('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArray = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArray('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithComma = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithComma('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArray = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArray('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArrayWithComma = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArrayWithComma('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArrayWithCommaArray = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArrayWithCommaArrayWithComma('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArrayWithCommaArrayWithComma = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArray = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma('1,2,3')\n  [1, 2, 3]\n  */\nconst convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithComma = string => {\n  const numbers = string.split(',');\n  return numbers.map(Number);\n};\n\n/**\n * Given a string, convert it to a list of integers\n * >>> convertToIntArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWithCommaArrayWith", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> impudentCase('Hello')\n  'hELLO'\n  */\nconst impudentCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "impudentCase", "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> impudentCase('Hello')\n  'hELLO'\n  */\nconst impudentCase = (string) => {\n  return string.toLowerCase().replace(/[a-z]/g, c => c.toUpperCase())\n}\n\n/**\n * Given a string, return the first uppercase letter of the string.\n * If no uppercase letters are found, return an empty string.\n * If no uppercase letters are found and no lowercase letters are found, return an empty string.\n * If no uppercase letters are found and no lowercase letters are found and no numbers are found, return an empty string.\n * If no uppercase letters are found and no lowercase letters are found and no numbers are found and no special characters are found, return an empty string.\n * If no uppercase letters are found and no lowercase letters are found and no numbers are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no special characters are found and no ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, curr) => acc += curr, \"\");\n};\n\n/* Convert string to number\n  >>> convertToNumber(\"\")\n  0\n  >>> convertToNumber(\"abc\")\n  3\n  >>> convertToNumber(\"123\")\n  123\n  >>> convertToNumber(\"123abc\")\n  123\n  >>> convertToNumber(\"123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc\")\n  123\n  >>> convertToNumber(\"123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n  123\n  >>> convertToNumber(\"123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123\")\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for the ones that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given prefix and do not end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given prefix and do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that end with a given prefix and do not start with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that end with a given prefix and do not start with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that end with a given prefix and do not start with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that end with a given prefix and do not start with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that end with a given prefix and do not start with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = {\n  belowZero,\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 20, 30])\n  false\n  >>> belowZero([10, -20, -30])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\nmodule.exports = {\n  belowZero,\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 20, 30])\n  false\n  >>> belowZero([10, -20, -30])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = {\n  belowZero,\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 20, 30])\n  false\n  >>> belowZero([10, -20, -30])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\nmodule.exports = {\n  belowZero,\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 20, 30])\n  false\n  >>> belowZero([10, -20, -30])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = {\n  belowZero,\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 20, 30])\n  false\n  >>> belowZero([10, -20, -30])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\nmodule.exports = {\n  belowZero,\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 20, 30])\n  false\n  >>> belowZero([10, -20, -30])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = {\n  belowZero,\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 20, 30])\n  false\n  >>> belowZero([10, -20, -30])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\nmodule.exports = {\n  belowZero,\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 20, 30])\n  false\n  >>> belowZero([10, -20, -30])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = {\n  belowZero,\n};\n\n},{}],12:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 20, 30])\n  false\n  >>> belowZero([10, -20, -30])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\nmodule.exports = {\n  belowZero,\n};\n\n},{}],13:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 20, 30])\n  false\n  >>> belowZero([10, -20, -30])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> catchPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> catchPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst catchPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "catchPositive", "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> catchPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> catchPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst catchPositive = (l) => {\n  return l.filter(v => v > 0)\n}\n\n/**\n  Returns true if the list contains only positive numbers.\n  >>> catchPositive([-1, 2, -4, 5, 6])\n  true\n  >>> catchPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  false\n  */\nconst catchNegative = (l) => {\n  return l.filter(v => v < 0)\n}\n\n/**\n  Returns true if the list contains only negative numbers.\n  >>> catchNegative([-1, 2, -4, 5, 6])\n  false\n  >>> catchNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchZero = (l) => {\n  return l.filter(v => v === 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN.\n  >>> catchZero([-1, 2, -4, 5, 6])\n  false\n  >>> catchZero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchNaN = (l) => {\n  return l.filter(v => isNaN(v))\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are negative.\n  >>> catchNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchNegativeNaN = (l) => {\n  return l.filter(v => isNaN(v) && v < 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are positive.\n  >>> catchNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchPositiveNaN = (l) => {\n  return l.filter(v => isNaN(v) && v > 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are zero.\n  >>> catchNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchZeroNaN = (l) => {\n  return l.filter(v => isNaN(v) && v === 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN.\n  >>> catchNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchNaNNaN = (l) => {\n  return l.filter(v => isNaN(v) && isNaN(v))\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN but are negative.\n  >>> catchNaNNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaNNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchNegativeNaNNaN = (l) => {\n  return l.filter(v => isNaN(v) && isNaN(v) && v < 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN but are positive.\n  >>> catchNaNNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaNNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchPositiveNaNNaN = (l) => {\n  return l.filter(v => isNaN(v) && isNaN(v) && v > 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN but are zero.\n  >>> catchNaNNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaNNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchZeroNaNNaN = (l) => {\n  return l.filter(v => isNaN(v) && isNaN(v) && v === 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN but are NaN but are negative.\n  >>> catchNaNNaNNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaNNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchNegativeNaNNaNNaN = (l) => {\n  return l.filter(v => isNaN(v) && isNaN(v) && isNaN(v) && v < 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN but are NaN but are positive.\n  >>> catchNaNNaNNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaNNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchPositiveNaNNaNNaN = (l) => {\n  return l.filter(v => isNaN(v) && isNaN(v) && isNaN(v) && v > 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN but are NaN but are zero.\n  >>> catchNaNNaNNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaNNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchZeroNaNNaNNaN = (l) => {\n  return l.filter(v => isNaN(v) && isNaN(v) && isNaN(v) && v === 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN but are NaN but are negative.\n  >>> catchNaNNaNNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaNNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchNegativeNaNNaNNaNNaN = (l) => {\n  return l.filter(v => isNaN(v) && isNaN(v) && isNaN(v) && isNaN(v) && v < 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN but are NaN but are positive.\n  >>> catchNaNNaNNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaNNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchPositiveNaNNaNNaN = (l) => {\n  return l.filter(v => isNaN(v) && isNaN(v) && isNaN(v) && isNaN(v) && v > 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN but are NaN but are zero.\n  >>> catchNaNNaNNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaNNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchZeroNaNNaNNaN = (l) => {\n  return l.filter(v => isNaN(v) && isNaN(v) && isNaN(v) && isNaN(v) && v === 0)\n}\n\n/**\n  Returns true if the list contains only numbers that are not NaN but are NaN but are NaN but are negative.\n  >>> catchNaNNaNNaN([-1, 2, -4, 5, 6])\n  false\n  >>> catchNaNNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  true\n  */\nconst catchNegativeNaNNaNNaNNaN = (l) => {\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPremier(6)\n  false\n  >>> isPremier(101)\n  true\n  >>> isPremier(11)\n  true\n  >>> isPremier(13441)\n  true\n  >>> isPremier(61)\n  true\n  >>> isPremier(4)\n  false\n  >>> isPremier(1)\n  false\n  */\nconst isPremier = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPremier", "gc": "<|endoftext|>/*Return true if a given number is prime, and false otherwise.\n  >>> isPremier(6)\n  false\n  >>> isPremier(101)\n  true\n  >>> isPremier(11)\n  true\n  >>> isPremier(13441)\n  true\n  >>> isPremier(61)\n  true\n  >>> isPremier(4)\n  false\n  >>> isPremier(1)\n  false\n  */\nconst isPremier = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  false\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  false\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  false\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  false\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrimeOrZero = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrimeOrZero(6)\n  true\n  >>> isPrimeOrZero(101)\n  false\n  >>> isPrimeOrZero(11)\n  false\n  >>> isPrimeOrZero(13441)\n  true\n  >>> isPrimeOrZero(61)\n  false\n  >>> isPrimeOrZero(4)\n  false\n  >>> isPrimeOrZero(1)\n  false\n  */\nconst isPrimeOrZeroOrZero = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrimeOrZeroOrZero(6)\n  true\n  >>> isPrimeOrZeroOrZero(101)\n  false\n  >>> isPrimeOrZeroOrZero(11)\n  false\n  >>> isPrimeOrZeroOrZero(13441)\n  true\n  >>> isPrimeOrZeroOrZero(61)\n  false\n  >>> isPrimeOrZeroOrZero(4)\n  false\n  >>> isPrimeOrZeroOrZero(1)\n  false\n  */\nconst isPrimeOrZeroOrOne = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrimeOrZeroOrOne(6)\n  true\n  >>> isPrimeOrZeroOrOne(101)\n  false\n  >>> isPrimeOrZeroOrOne(11)\n  false\n  >>> isPrimeOrZeroOrOne(13441)\n  true\n  >>> isPrimeOrZeroOrOne(61)\n  false\n  >>> isPrimeOrZeroOrOne(4)\n  false\n  >>> isPrimeOrZeroOrOne(1)\n  false\n  */\nconst isPrimeOrZeroOrOneOrZero = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrimeOrZeroOrOneOrZero(6)\n  true\n  >>> isPrimeOrZeroOrOneOrZero(101)\n  false\n  >>> isPrimeOrZeroOrOneOrZero(11)\n  false\n  >>> isPrimeOrZeroOrOneOrZero(13441)\n  true\n  >>> isPrimeOrZeroOrOneOrZero(61)\n  false\n  >>> isPrimeOrZeroOrOneOrZero(4)\n  false\n  >>> isPrimeOrZeroOrOneOrZero(1)\n  false\n  */\nconst isPrimeOrZeroOrOneOrOne = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrimeOrZeroOrOneOrOne(6)\n  true\n  >>> isPrimeOrZeroOrOneOrOne(101)\n  false\n  >>> isPrimeOrZeroOrOneOrOne(11)\n  false\n  >>> isPrimeOrZeroOrOneOrOne(13441)\n  true\n  >>> isPrimeOrZeroOrOneOrOne(61)\n  false\n  >>> isPrimeOrZeroOrOneOrOne(4)\n  false\n  >>> isPrimeOrZeroOrOneOrOne(1)\n  false\n  */\nconst isPrimeOrZeroOrOneOrTwo = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrimeOrZeroOrOneOrTwo(6)\n  true\n  >>> isPrimeOrZeroOrOneOrTwo(101)\n  false\n  >>> isPrimeOrZeroOrOneOrTwo(11)\n  false\n  >>> isPrimeOrZeroOrOneOrTwo(13441)\n  true\n  >>> isPrimeOrZeroOrOneOrTwo(61)\n  false\n  >>> is", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let zero = 0;\n  let lastZero = 0;\n  let lastZeroIndex = 0;\n  let lastZeroIndex2 = 0;\n  let lastZeroIndex3 = 0;\n  let lastZeroIndex4 = 0;\n  let lastZeroIndex5 = 0;\n  let lastZeroIndex6 = 0;\n  let lastZeroIndex7 = 0;\n  let lastZeroIndex8 = 0;\n  let lastZeroIndex9 = 0;\n  let lastZeroIndex10 = 0;\n  let lastZeroIndex11 = 0;\n  let lastZeroIndex12 = 0;\n  let lastZeroIndex13 = 0;\n  let lastZeroIndex14 = 0;\n  let lastZeroIndex15 = 0;\n  let lastZeroIndex16 = 0;\n  let lastZeroIndex17 = 0;\n  let lastZeroIndex18 = 0;\n  let lastZeroIndex19 = 0;\n  let lastZeroIndex20 = 0;\n  let lastZeroIndex21 = 0;\n  let lastZeroIndex22 = 0;\n  let lastZeroIndex23 = 0;\n  let lastZeroIndex24 = 0;\n  let lastZeroIndex25 = 0;\n  let lastZeroIndex26 = 0;\n  let lastZeroIndex27 = 0;\n  let lastZeroIndex28 = 0;\n  let lastZeroIndex29 = 0;\n  let lastZeroIndex30 = 0;\n  let lastZeroIndex31 = 0;\n  let lastZeroIndex32 = 0;\n  let lastZeroIndex33 = 0;\n  let lastZeroIndex34 = 0;\n  let lastZeroIndex35 = 0;\n  let lastZeroIndex36 = 0;\n  let lastZeroIndex37 = 0;\n  let lastZeroIndex38 = 0;\n  let lastZeroIndex39 = 0;\n  let lastZeroIndex40 = 0;\n  let lastZeroIndex41 = 0;\n  let lastZeroIndex42 = 0;\n  let lastZeroIndex43 = 0;\n  let lastZeroIndex44 = 0;\n  let lastZeroIndex45 = 0;\n  let lastZeroIndex46 = 0;\n  let lastZeroIndex47 = 0;\n  let lastZeroIndex48 = 0;\n  let lastZeroIndex49 = 0;\n  let lastZeroIndex50 = 0;\n  let lastZeroIndex51 = 0;\n  let lastZeroIndex52 = 0;\n  let lastZeroIndex53 = 0;\n  let lastZeroIndex54 = 0;\n  let lastZeroIndex55 = 0;\n  let lastZeroIndex56 = 0;\n  let lastZeroIndex57 = 0;\n  let lastZeroIndex58 = 0;\n  let lastZeroIndex59 = 0;\n  let lastZeroIndex60 = 0;\n  let lastZeroIndex61 = 0;\n  let lastZeroIndex62 = 0;\n  let lastZeroIndex63 = 0;\n  let lastZeroIndex64 = 0;\n  let lastZeroIndex65 = 0;\n  let lastZeroIndex66 = 0;\n  let lastZeroIndex67 = 0;\n  let lastZeroIndex68 = 0;\n  let lastZeroIndex69 = 0;\n  let lastZeroIndex70 = 0;\n  let lastZeroIndex71 = 0;\n  let lastZeroIndex72 = 0;\n  let lastZeroIndex73 = 0;\n  let lastZeroIndex74 = 0;\n  let lastZeroIndex75 = 0;\n  let lastZeroIndex76 = 0;\n  let lastZeroIndex77 = 0;\n  let lastZeroIndex78 = 0;\n  let lastZeroIndex79 = 0;\n  let lastZeroIndex80 = 0;\n  let lastZeroIndex81 = 0;\n  let lastZeroIndex82 = 0;\n  let lastZeroIndex83 = 0;\n  let lastZeroIndex84 = 0;\n  let lastZeroIndex85 = 0;\n  let lastZeroIndex86 = 0;\n  let lastZeroIndex87 = 0;\n  let lastZeroIndex88 = 0;\n  let lastZeroIndex89 = 0;\n  let lastZeroIndex90 = 0;\n  let lastZeroIndex91 = 0;\n  let lastZeroIndex92 = 0;\n  let lastZeroIndex93 = 0;\n  let lastZeroIndex94 = 0;\n  let lastZeroIndex95 = 0;\n  let lastZeroIndex96 = 0;\n  let lastZeroIndex97 = 0;\n  let lastZeroIndex98 = 0;\n  let lastZeroIndex99 = 0;\n  let lastZeroIndex100 = 0;\n  let lastZeroIndex101 = 0;\n  let lastZeroIndex102 = 0;\n  let lastZeroIndex103 = 0;\n  let lastZeroIndex104 = 0;\n  let lastZeroIndex105 = 0;\n  let lastZeroIndex106 = 0;\n  let lastZeroIndex107 = 0;\n  let lastZeroIndex108 = 0;\n  let lastZeroIndex109 = 0;\n  let lastZeroIndex110 = 0;\n  let lastZeroIndex111 = 0;\n  let lastZeroIndex112 = 0;\n  let lastZeroIndex113 = 0;\n  let lastZeroIndex114 = 0;\n  let lastZeroIndex115 = 0;\n  let lastZeroIndex116 = 0;\n  let lastZeroIndex117 = 0;\n  let lastZeroIndex118 = 0;\n  let lastZeroIndex119 = 0;\n  let lastZeroIndex120 = 0;\n  let lastZeroIndex121 = 0;\n  let lastZeroIndex122 = 0;\n  let lastZeroIndex123 = 0;\n  let lastZeroIndex124 = 0;\n  let lastZeroIndex125 = 0;\n  let lastZeroIndex126 = 0;\n  let lastZeroIndex127 = 0;\n  let lastZeroIndex128 = 0;\n  let lastZeroIndex129 = 0;\n  let lastZeroIndex130 = 0;\n  let lastZeroIndex131 = 0;\n  let lastZeroIndex132 = 0;\n  let lastZeroIndex133 = 0;\n  let lastZeroIndex134 = 0;\n  let lastZeroIndex135 = 0;\n  let lastZeroIndex136 = 0;\n  let lastZeroIndex137 = 0;\n  let lastZeroIndex138 = 0;\n  let lastZeroIndex139 = 0;\n  let lastZeroIndex140 = 0;\n  let lastZeroIndex141 = 0;\n  let lastZeroIndex142 = 0;\n  let lastZeroIndex143 = 0;\n  let lastZeroIndex144 = 0;\n  let lastZeroIndex145 = 0;\n  let lastZeroIndex146 = 0;\n  let lastZeroIndex147 = 0;\n  let lastZeroIndex148 = 0;\n  let lastZeroIndex149 = 0;\n  let lastZeroIndex150 = 0;\n  let lastZeroIndex151 = 0;\n  let lastZeroIndex152 = 0;\n  let lastZeroIndex153 = 0;\n  let lastZeroIndex154 = 0;\n  let lastZeroIndex155 = 0;\n  let lastZeroIndex156 = 0;\n  let lastZeroIndex157 = 0;\n  let lastZeroIndex158 = 0;\n  let lastZeroIndex159 = 0;\n  let lastZeroIndex160 = 0;\n  let lastZeroIndex161 = 0;\n  let lastZeroIndex162 = 0;\n  let lastZeroIndex163 = 0;\n  let lastZeroIndex164 = 0;\n  let lastZeroIndex165 = 0;\n  let lastZeroIndex166 = 0;\n  let lastZeroIndex167 = 0;\n  let lastZeroIndex168 = 0;\n  let lastZeroIndex169 = 0;\n  let lastZeroIndex170 = 0;\n  let lastZeroIndex171 = 0;\n  let lastZeroIndex172 = 0;\n  let lastZeroIndex173 = 0;\n  let lastZeroIndex174 = 0;\n  let lastZeroIndex175 = 0;\n  let lastZeroIndex176 = 0;\n  let lastZeroIndex177 = 0;\n  let lastZeroIndex178 = 0;\n  let lastZeroIndex179 = 0;\n  let lastZeroIndex180 = 0;\n  let lastZeroIndex181 = 0;\n  let lastZeroIndex182 = 0;\n  let lastZeroIndex183 = 0;\n  let lastZeroIndex184 = 0;\n  let lastZeroIndex185 = 0;\n  let lastZeroIndex186 = 0;\n  let lastZeroIndex187 = 0;\n  let lastZeroIndex188 = 0;\n  let lastZeroIndex", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  let thirdIndex = 0;\n  let thirdLength = 0;\n  let thirdValue = 0;\n  let thirdValueIndex = 0;\n  let thirdValueLength = 0;\n  let thirdValueValue = 0;\n  let thirdValueValueIndex = 0;\n  let thirdValueValueLength = 0;\n  let thirdValueValueValue = 0;\n  let thirdValueValueValueIndex = 0;\n  let thirdValueValueValueLength = 0;\n  let thirdValueValueValueValue = 0;\n  let thirdValueValueValueIndex = 0;\n  let thirdValueValueValueLength = 0;\n  let thirdValueValueValueValue = 0;\n  let thirdValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let thirdValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let thirdValueValueValueValueValueValueValueValue", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted alone elements in a list\n  >>> alone([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst alone = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "alone", "gc": "<|endoftext|>/*Return sorted alone elements in a list\n  >>> alone([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst alone = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> alone([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSorted = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 0, 123]\n  */\nconst aloneSortedSortedSorted", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "soapElement", "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst soapElement = (l) => {\n  let min = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i];\n    }\n  }\n  return min;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst soapElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of elements in the list.\n  >>> soapElement([1, 2, 3])\n  6\n  >>> soap", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "gc": "<|endoftext|>/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 8 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 9 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 0 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 1 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 2 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 3 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 4 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 5 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 6 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 8 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 9 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 0 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0 || i % 11 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 1 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i > ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...even,...odd]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 2]\n  */\nconst sortEvenOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortEvenOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortEvenOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4]\n  >>> sortEvenOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1, 3]\n  */\nconst sortEvenOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2]\n  >>> sortEvenOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1, 3, 2]\n  */\nconst sortEvenOddOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2, 3]\n  >>> sortEvenOddOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1, 3, 2, 1]\n  */\nconst sortEvenOddOddOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2, 3, 3]\n  >>> sortEvenOddOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1, 3, 2, 1, 2, 1]\n  */\nconst sortEvenOddOddOddOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2, 3, 3, 3]\n  >>> sortEvenOddOddOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1, 3, 2, 1, 2, 1, 1]\n  */\nconst sortEvenOddOddOddOddOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddOddOddOddOddOddOdd([1, 2, ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroups", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  premierFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> premierFib(1)\n  2\n  >>> premierFib(2)\n  3\n  >>> premierFib(3)\n  5\n  >>> premierFib(4)\n  13\n  >>> premierFib(5)\n  89\n  */\nconst premierFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "premierFib", "gc": "<|endoftext|>/*\n  premierFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> premierFib(1)\n  2\n  >>> premierFib(2)\n  3\n  >>> premierFib(3)\n  5\n  >>> premierFib(4)\n  13\n  >>> premierFib(5)\n  89\n  */\nconst premierFib = (n) => {\n  if (n < 2) return 1;\n  if (n < 3) return 2;\n  if (n < 5) return 3;\n  if (n < 8) return 5;\n  if (n < 13) return 9;\n  if (n < 19) return 13;\n  if (n < 29) return 21;\n  if (n < 39) return 29;\n  if (n < 49) return 39;\n  if (n < 59) return 49;\n  if (n < 79) return 59;\n  if (n < 89) return 79;\n  if (n < 99) return 89;\n  if (n < 111) return 99;\n  if (n < 131) return 111;\n  if (n < 149) return 131;\n  if (n < 159) return 149;\n  if (n < 191) return 159;\n  if (n < 219) return 191;\n  if (n < 291) return 219;\n  if (n < 391) return 291;\n  if (n < 491) return 391;\n  if (n < 591) return 491;\n  if (n < 791) return 591;\n  if (n < 891) return 791;\n  if (n < 991) return 891;\n  if (n < 1199) return 991;\n  if (n < 13199) return 13199;\n  if (n < 14919) return 14919;\n  if (n < 15929) return 15929;\n  if (n < 19199) return 19199;\n  if (n < 21929) return 21929;\n  if (n < 29199) return 29199;\n  if (n < 39199) return 39199;\n  if (n < 49199) return 49199;\n  if (n < 59199) return 59199;\n  if (n < 79199) return 79199;\n  if (n < 89199) return 89199;\n  if (n < 99199) return 99199;\n  if (n < 111991) return 111991;\n  if (n < 131991) return 131991;\n  if (n < 149191) return 149191;\n  if (n < 159291) return 159291;\n  if (n < 191991) return 191991;\n  if (n < 219291) return 219291;\n  if (n < 291991) return 291991;\n  if (n < 391991) return 391991;\n  if (n < 491991) return 491991;\n  if (n < 591991) return 591991;\n  if (n < 791991) return 791991;\n  if (n < 891991) return 891991;\n  if (n < 991991) return 991991;\n  if (n < 1119999) return 1119999;\n  if (n < 1319999) return 1319999;\n  if (n < 1491999) return 1491999;\n  if (n < 1592999) return 1592999;\n  if (n < 1919999) return 1919999;\n  if (n < 2192999) return 2192999;\n  if (n < 2919999) return 2919999;\n  if (n < 3919999) return 3919999;\n  if (n < 4919999) return 4919999;\n  if (n < 5919999) return 5919999;\n  if (n < 7919999) return 7919999;\n  if (n < 8919999) return 8919999;\n  if (n < 9919999) return 9919999;\n  if (n < 11199999) return 11199999;\n  if (n < 13199999) return 13199999;\n  if (n < 14919999) return 14919999;\n  if (n < 15929999) return 15929999;\n  if (n < 19199999) return 19199999;\n  if (n < 21929999) return 21929999;\n  if (n < 29199999) return 29199999;\n  if (n < 39199999) return 39199999;\n  if (n < 49199999) return 49199999;\n  if (n < 59199999) return 59199999;\n  if (n < 79199999) return 79199999;\n  if (n < 89199999) return 89199999;\n  if (n < 99199999) return 99199999;\n  if (n < 111999999) return 11199999;\n  if (n < 131999999) return 13199999;\n  if (n < 149199999) return 14919999;\n  if (n < 159299999) return 15929999;\n  if (n < 191999999) return 19199999;\n  if (n < 219299999) return 21929999;\n  if (n < 291999999) return 29199999;\n  if (n < 391999999) return 39199999;\n  if (n < 491999999) return 49199999;\n  if (n < 591999999) return 59199999;\n  if (n < 791999999) return 79199999;\n  if (n < 891999999) return 89199999;\n  if (n < 991999999) return 99199999;\n  if (n < 111999999999) return 1119999999;\n  if (n < 131999999999) return 1319999999;\n  if (n < 149199999999) return 1491999999;\n  if (n < 159299999999) return 1592999999;\n  if (n < 191999999999) return 1919999999;\n  if (n < 219299999999) return 2192999999;\n  if (n < 291999999999) return 2919999999;\n  if (n < 391999999999) return 3919999999;\n  if (n < 491999999999) return 4919999999;\n  if (n < 591999999999) return 5919999999;\n  if (n < 791999999999) return 7919999999;\n  if (n < 891999999999) return 8919999999;\n  if (n < 991999999999) return 9919999999;\n  if (n < 1119999999999) return 1119999999;\n  if (n < 1319999999999) return 1319999999;\n  if (n < 1491999999999) return 1491999999;\n  if (n < 1592999999999) return 1592999999;\n  if (n < 1919999999999) return 1919999999;\n  if (n < 2192999999999) return 2192999999;\n  if (n < 2919999999999) return 2919999999;\n  if (n < 3919999999999) return 3919999999;\n  if (n < 4919999999999) return 4919999999;\n  if (n < 5919999999999) return 5919999999;\n  if (n < 7919999999999) return 7919999999;\n  if (n < 8919999999999) return 8919999999;\n  if (n < 9919999999999) return 9919999999;\n  if (n < 1119999999999999) return 11199999999999;\n  if (n < 1319999999999999) return 13199999999999;\n  if (n < 1491999999999999) return 14919999999999;\n  if (n < 1592999999999999) return 15929999999999;\n  if (n < 1919999999999999) return 19199999999999;\n  if (n < 2192999999999999) return 21929999999999;\n  if (n < 2919999999999999) return 29199999999999;\n  if (n < 3919999999999999) return 39199999999999;\n  if (n < 4919999999999999) return 49199999999999;\n  if (n < 5919999999999999) return 59199999999999;\n  if (n < 7919999999999999) return 79199999999999;\n  if (n < 8919999999999999) return 89199999999999;\n  if (n < 9919999999999999) return 99199999999999;\n  if (n < 11199999999999999) return 11199999999999;\n  if (n < 13199999999999999) return 13199999999999;\n  if (n < 14919999999999999) return 14919999999999;\n  if (n < 15929999999999999) return 15929999999999;\n  if (n < 19199999999999999) return 19199999999999;\n  if (n < 21929999999999999) return 21929999999999;\n  if (n < 29199999999999999) return 29199", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> entailAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "entailAbsoluteDeviation", "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> entailAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average squared difference between each\n  element and a centerpoint (mean in this case):\n  MSD = average ^ 2 - x_mean ^ 2\n  >>> entailMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanSquaredDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.pow(number - mean, 2));\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Root Mean Squared Deviation\n  around the mean of this dataset.\n  Root Mean Squared Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = sqrt(mean ^ 2 - x_mean ^ 2)\n  >>> entailRootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailRootMeanSquaredDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.pow(number - mean, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Standard Deviation\n  around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean ^ 2 - x_mean ^ 2)\n  >>> entailStandardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailStandardDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.pow(number - mean, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Variance Deviation\n  around the mean of this dataset.\n  Variance Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  V = sqrt(mean ^ 2 - x_mean ^ 2)\n  >>> entailVarianceDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailVarianceDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.pow(number - mean, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Standard Deviation and\n  Variance Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean ^ 2 - x_mean ^ 2)\n  Variance Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  V = sqrt(mean ^ 2 - x_mean ^ 2)\n  >>> entailStandardDeviationAndVarianceDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailStandardDeviationAndVarianceDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.pow(number - mean, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Percentage Deviation\n  around the mean of this dataset.\n  Mean Absolute Percentage Deviation is the percentage difference between each\n  element and a centerpoint (mean in this case):\n  MADP = average | x - x_mean | * 100\n  >>> entailMeanAbsolutePercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanAbsolutePercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean) * 100);\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Percentage Deviation\n  around the mean of this dataset.\n  Mean Squared Percentage Deviation is the percentage difference between each\n  element and a centerpoint (mean in this case):\n  MSDP = average ^ 2 - x_mean ^ 2 * 100\n  >>> entailMeanSquaredPercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanSquaredPercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.pow(number - mean, 2) * 100);\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Root Mean Squared Percentage Deviation\n  around the mean of this dataset.\n  Root Mean Squared Percentage Deviation is the percentage difference between each\n  element and a centerpoint (mean in this case):\n  RMSP = sqrt(mean ^ 2 - x_mean ^ 2 * 100)\n  >>> entailRootMeanSquaredPercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailRootMeanSquaredPercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.pow(number - mean, 2) * 100);\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Standard Deviation and\n  Mean Absolute Percentage Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean ^ 2 - x_mean ^ 2 * 100)\n  Mean Absolute Percentage Deviation is the percentage difference between each\n  element and a centerpoint (mean in this case):\n  MADP = average | x - x_mean | * 100\n  >>> entailStandardDeviationAndMeanAbsolutePercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailStandardDeviationAndMeanAbsolutePercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.pow(number - mean, 2) * 100);\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Standard Deviation and\n  Mean Squared Percentage Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean ^ 2 - x_mean ^ 2 * 100)\n  Mean Squared Percentage Deviation is the percentage difference between each\n  element and a centerpoint (mean in this case):\n  MSDP = average ^ 2 - x_mean ^ 2 * 100\n  >>> entailStandardDeviationAndMeanSquaredPercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  tripleTotalToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> tripleTotalToZero([1, 3, 5, 0])\n  false\n  >>> tripleTotalToZero([1, 3, -2, 1])\n  true\n  >>> tripleTotalToZero([1, 2, 3, 7])\n  false\n  >>> tripleTotalToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleTotalToZero([1])\n  false\n  */\nconst tripleTotalToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "tripleTotalToZero", "gc": "<|endoftext|>/*\n  tripleTotalToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> tripleTotalToZero([1, 3, 5, 0])\n  false\n  >>> tripleTotalToZero([1, 3, -2, 1])\n  true\n  >>> tripleTotalToZero([1, 2, 3, 7])\n  false\n  >>> tripleTotalToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleTotalToZero([1])\n  false\n  */\nconst tripleTotalToZero = (l) => {\n  let total = 0;\n  for (let i = 0; i < l.length; i++) {\n    total += l[i];\n    if (total === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = tripleTotalToZero;\n\n},{}],9:[function(require,module,exports){\n/**\n * A collection of functions to help with parsing and formatting dates\n * and times.\n *\n * @module date-utils\n */\n\nconst _ = require('lodash');\nconst moment = require('moment');\n\n/**\n * Parses a date string and returns a moment object.\n *\n * @param  {String} dateString The date string to parse.\n * @return {Moment}          A moment object representing the date.\n */\nconst parseDate = (dateString) => {\n  return moment(dateString, 'YYYY-MM-DD');\n};\n\n/**\n * Parses a time string and returns a moment object.\n *\n * @param  {String} timeString The time string to parse.\n * @return {Moment}          A moment object representing the time.\n */\nconst parseTime = (timeString) => {\n  return moment(timeString, 'HH:mm');\n};\n\n/**\n * Parses a date string and returns a moment object in UTC.\n *\n * @param  {String} dateString The date string to parse.\n * @return {Moment}          A moment object representing the date in UTC.\n */\nconst parseUTCDate = (dateString) => {\n  return moment(dateString, 'YYYY-MM-DDT00:00:00.000Z');\n};\n\n/**\n * Parses a time string and returns a moment object in UTC.\n *\n * @param  {String} timeString The time string to parse.\n * @return {Moment}          A moment object representing the time in UTC.\n */\nconst parseUTCTime = (timeString) => {\n  return moment(timeString, 'HH:mm:ss.SSSZ');\n};\n\n/**\n * Formats a moment object into a date string.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The date string representing the date.\n */\nconst formatDate = (date) => {\n  return date.format('YYYY-MM-DD');\n};\n\n/**\n * Formats a moment object into a time string.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The time string representing the time.\n */\nconst formatTime = (date) => {\n  return date.format('HH:mm');\n};\n\n/**\n * Formats a moment object into a UTC date string.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The date string representing the date in UTC.\n */\nconst formatUTCDate = (date) => {\n  return date.format('YYYY-MM-DDT00:00:00.000Z');\n};\n\n/**\n * Formats a moment object into a UTC time string.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The time string representing the time in UTC.\n */\nconst formatUTCTime = (date) => {\n  return date.format('HH:mm:ss.SSSZ');\n};\n\n/**\n * Formats a moment object into a date string in UTC.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The date string representing the date in UTC in UTC.\n */\nconst formatUTCDateUTC = (date) => {\n  return date.format('YYYY-MM-DDTHH:mm:ss.SSSZ');\n};\n\n/**\n * Formats a moment object into a time string in UTC.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The time string representing the time in UTC in UTC.\n */\nconst formatUTCTimeUTC = (date) => {\n  return date.format('HH:mm:ss.SSSZ');\n};\n\n/**\n * Formats a moment object into a date string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The date string representing the date in local time.\n */\nconst formatDateLocal = (date) => {\n  return date.format('YYYY-MM-DD');\n};\n\n/**\n * Formats a moment object into a time string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The time string representing the time in local time.\n */\nconst formatTimeLocal = (date) => {\n  return date.format('HH:mm');\n};\n\n/**\n * Formats a moment object into a date string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The date string representing the date in local time in local time.\n */\nconst formatDateLocalUTC = (date) => {\n  return date.format('YYYY-MM-DDTHH:mm:ss.SSSZ');\n};\n\n/**\n * Formats a moment object into a time string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The time string representing the time in local time in local time.\n */\nconst formatTimeLocalUTC = (date) => {\n  return date.format('HH:mm:ss.SSSZ');\n};\n\n/**\n * Formats a moment object into a date string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The date string representing the date in local time in local time in local time.\n */\nconst formatDateLocalLocal = (date) => {\n  return date.format('YYYY-MM-DD');\n};\n\n/**\n * Formats a moment object into a time string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The time string representing the time in local time in local time in local time.\n */\nconst formatTimeLocalLocal = (date) => {\n  return date.format('HH:mm:ss.SSSZ');\n};\n\n/**\n * Formats a moment object into a date string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The date string representing the date in local time in local time in local time in local time.\n */\nconst formatDateLocalLocalUTC = (date) => {\n  return date.format('YYYY-MM-DDTHH:mm:ss.SSSZ');\n};\n\n/**\n * Formats a moment object into a time string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The time string representing the time in local time in local time in local time in local time in local time.\n */\nconst formatTimeLocalLocalUTC = (date) => {\n  return date.format('HH:mm:ss.SSSZ');\n};\n\n/**\n * Formats a moment object into a date string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The date string representing the date in local time in local time in local time in local time in local time.\n */\nconst formatDateLocalLocalLocal = (date) => {\n  return date.format('YYYY-MM-DD');\n};\n\n/**\n * Formats a moment object into a time string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The time string representing the time in local time in local time in local time in local time in local time in local time.\n */\nconst formatTimeLocalLocalLocal = (date) => {\n  return date.format('HH:mm:ss.SSSZ');\n};\n\n/**\n * Formats a moment object into a date string in local time.\n *\n * @param  {Moment} date A moment object representing a date.\n * @return {String}       The date string representing the date in local time in local time in local time in local time in local time in local time.\n */\nconst format", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst cableCarRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "cableCarRaceCollision", "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst cableCarRaceCollision = (n) => {\n  const collisions = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed > car2.speed) {\n      collisions++;\n    }\n  }\n  return collisions;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is already occupied, return null.\n*/\nconst getCarAt = (cars, index) => {\n  const car = cars[index];\n  if (car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNull = (cars, index) => {\n  const car = cars[index];\n  if (car.occupied) {\n    return car;\n  }\n  return null;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupied = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNull = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupied = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupiedOrNull = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupied = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupied = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNull = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupied = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNull = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupied = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupied = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupied = (cars, index) => {\n  const car = cars[index];\n  if (!car.occupied) {\n    return null;\n  }\n  return car;\n};\n\n/*\n  Given a car array and a car index, return the car at the given index.\n  If the car at the given index is occupied, return null.\n*/\nconst getCarAtOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNullOrUnoccupiedOrNull", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (i > 0) {\n    j++;\n    i--;\n    l[j + 1] = l[j] + 1;\n  }\n  return l;\n};\n\n/**\n * Remove duplicates from an array.\n * If `isSorted` is true, then `isSorted` will be used to determine if duplicates are allowed.\n * If `isSorted` is false, then `isSorted` will be used to determine if duplicates are disallowed.\n * If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n *\n * Note: This modifies the array in place.\n *\n * @param {Array} array The array to modify.\n * @param {Boolean} [isSorted=true] If true, then `isSorted` will be used to determine if duplicates are allowed.\n * @param {Function} [isSorted=undefined] If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n * @returns {Array} The original array without duplicates.\n */\nconst removeDuplicates = (array, isSorted = true) => {\n  const result = [];\n  const isSorted = isSorted || defaultIsSorted;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    const found = false;\n    for (let j = 0; j < result.length; j++) {\n      if (result[j] === value) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      result.push(value);\n    }\n  }\n\n  if (isSorted) {\n    result.sort();\n  }\n\n  return result;\n};\n\n/**\n * Remove duplicates from an array.\n * If `isSorted` is true, then `isSorted` will be used to determine if duplicates are allowed.\n * If `isSorted` is false, then `isSorted` will be used to determine if duplicates are disallowed.\n * If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n *\n * Note: This modifies the array in place.\n *\n * @param {Array} array The array to modify.\n * @param {Boolean} [isSorted=true] If true, then `isSorted` will be used to determine if duplicates are allowed.\n * @param {Function} [isSorted=undefined] If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n * @returns {Array} The original array without duplicates.\n */\nconst removeDuplicatesStrict = (array, isSorted = true) => {\n  const result = [];\n  const isSorted = isSorted || defaultIsSorted;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    const found = false;\n    for (let j = 0; j < result.length; j++) {\n      if (result[j] === value) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      result.push(value);\n    }\n  }\n\n  if (isSorted) {\n    result.sort();\n  }\n\n  return result;\n};\n\n/**\n * Remove duplicates from an array.\n * If `isSorted` is true, then `isSorted` will be used to determine if duplicates are allowed.\n * If `isSorted` is false, then `isSorted` will be used to determine if duplicates are disallowed.\n * If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n *\n * Note: This modifies the array in place.\n *\n * @param {Array} array The array to modify.\n * @param {Boolean} [isSorted=true] If true, then `isSorted` will be used to determine if duplicates are allowed.\n * @param {Function} [isSorted=undefined] If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n * @returns {Array} The original array without duplicates.\n */\nconst removeDuplicatesStrictWeak = (array, isSorted = true) => {\n  const result = [];\n  const isSorted = isSorted || defaultIsSorted;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    const found = false;\n    for (let j = 0; j < result.length; j++) {\n      if (result[j] === value) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      result.push(value);\n    }\n  }\n\n  if (isSorted) {\n    result.sort();\n  }\n\n  return result;\n};\n\n/**\n * Remove duplicates from an array.\n * If `isSorted` is true, then `isSorted` will be used to determine if duplicates are allowed.\n * If `isSorted` is false, then `isSorted` will be used to determine if duplicates are disallowed.\n * If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n *\n * Note: This modifies the array in place.\n *\n * @param {Array} array The array to modify.\n * @param {Boolean} [isSorted=true] If true, then `isSorted` will be used to determine if duplicates are allowed.\n * @param {Function} [isSorted=undefined] If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n * @returns {Array} The original array without duplicates.\n */\nconst removeDuplicatesWeak = (array, isSorted = true) => {\n  const result = [];\n  const isSorted = isSorted || defaultIsSorted;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    const found = false;\n    for (let j = 0; j < result.length; j++) {\n      if (result[j] === value) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      result.push(value);\n    }\n  }\n\n  if (isSorted) {\n    result.sort();\n  }\n\n  return result;\n};\n\n/**\n * Remove duplicates from an array.\n * If `isSorted` is true, then `isSorted` will be used to determine if duplicates are allowed.\n * If `isSorted` is false, then `isSorted` will be used to determine if duplicates are disallowed.\n * If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n *\n * Note: This modifies the array in place.\n *\n * @param {Array} array The array to modify.\n * @param {Boolean} [isSorted=true] If true, then `isSorted` will be used to determine if duplicates are allowed.\n * @param {Function} [isSorted=undefined] If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n * @returns {Array} The original array without duplicates.\n */\nconst removeDuplicatesWeakWeakWeak = (array, isSorted = true) => {\n  const result = [];\n  const isSorted = isSorted || defaultIsSorted;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    const found = false;\n    for (let j = 0; j < result.length; j++) {\n      if (result[j] === value) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      result.push(value);\n    }\n  }\n\n  if (isSorted) {\n    result.sort();\n  }\n\n  return result;\n};\n\n/**\n * Remove duplicates from an array.\n * If `isSorted` is true, then `isSorted` will be used to determine if duplicates are allowed.\n * If `isSorted` is false, then `isSorted` will be used to determine if duplicates are disallowed.\n * If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n *\n * Note: This modifies the array in place.\n *\n * @param {Array} array The array to modify.\n * @param {Boolean} [isSorted=true] If true, then `isSorted` will be used to determine if duplicates are allowed.\n * @param {Function} [isSorted=undefined] If `isSorted` is undefined, then `isSorted` will be used as the default sort function.\n * @returns {Array} The original array without duplicates.\n */\nconst removeDuplicatesWeakWeakWeakWeak = (array, isSorted = true) => {\n  const result = [];\n  const isSorted = isSorted || defaultIsSorted;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    const found = false;\n    for (let ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  copulateUnionToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> copulateUnionToZero([1, 3, 5, 0])\n  false\n  >>> copulateUnionToZero([1, 3, -2, 1])\n  false\n  >>> copulateUnionToZero([1, 2, 3, 7])\n  false\n  >>> copulateUnionToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateUnionToZero([1])\n  false\n  */\nconst copulateUnionToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "copulateUnionToZero", "gc": "<|endoftext|>/*\n  copulateUnionToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> copulateUnionToZero([1, 3, 5, 0])\n  false\n  >>> copulateUnionToZero([1, 3, -2, 1])\n  false\n  >>> copulateUnionToZero([1, 2, 3, 7])\n  false\n  >>> copulateUnionToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateUnionToZero([1])\n  false\n  */\nconst copulateUnionToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (l[i] === 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateIntersectToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  intersect with zero, and false otherwise.\n  >>> copulateIntersectToZero([1, 3, 5, 0])\n  false\n  >>> copulateIntersectToZero([1, 3, -2, 1])\n  false\n  >>> copulateIntersectToZero([1, 2, 3, 7])\n  false\n  >>> copulateIntersectToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateIntersectToZero([1])\n  false\n  */\nconst copulateIntersectToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (l[i] === 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateDifferenceToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToZero([1, 3, 5, 0])\n  false\n  >>> copulateDifferenceToZero([1, 3, -2, 1])\n  false\n  >>> copulateDifferenceToZero([1, 2, 3, 7])\n  false\n  >>> copulateDifferenceToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateDifferenceToZero([1])\n  false\n  */\nconst copulateDifferenceToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (l[i] === 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateProductToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  product to zero, and false otherwise.\n  >>> copulateProductToZero([1, 3, 5, 0])\n  false\n  >>> copulateProductToZero([1, 3, -2, 1])\n  false\n  >>> copulateProductToZero([1, 2, 3, 7])\n  false\n  >>> copulateProductToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateProductToZero([1])\n  false\n  */\nconst copulateProductToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (l[i] === 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulatePowerToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  power to the zero, and false otherwise.\n  >>> copulatePowerToZero([1, 3, 5, 0])\n  false\n  >>> copulatePowerToZero([1, 3, -2, 1])\n  false\n  >>> copulatePowerToZero([1, 2, 3, 7])\n  false\n  >>> copulatePowerToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulatePowerToZero([1])\n  false\n  */\nconst copulatePowerToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (l[i] === 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> copulateSumToZero([1, 3, 5, 0])\n  false\n  >>> copulateSumToZero([1, 3, -2, 1])\n  false\n  >>> copulateSumToZero([1, 2, 3, 7])\n  false\n  >>> copulateSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateSumToZero([1])\n  false\n  */\nconst copulateSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (l[i] === 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateProductToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  product to zero, and false otherwise.\n  >>> copulateProductToZero([1, 3, 5, 0])\n  false\n  >>> copulateProductToZero([1, 3, -2, 1])\n  false\n  >>> copulateProductToZero([1, 2, 3, 7])\n  false\n  >>> copulateProductToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateProductToZero([1])\n  false\n  */\nconst copulateProductToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (l[i] === 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulatePowerToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  power to the zero, and false otherwise.\n  >>> copulatePowerToZero([1, 3, 5, 0])\n  false\n  >>> copulatePowerToZero([1, 3, -2, 1])\n  false\n  >>> copulatePowerToZero([1, 2, 3, 7])\n  false\n  >>> copulatePowerToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulatePowerToZero([1])\n  false\n  */\nconst copulatePowerToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (l[i] === 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulatePowerToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  power to the zero, and false otherwise.\n  >>> copulatePowerToZero([1, 3, 5, 0])\n  false\n  >>> copulatePowerToZero([1, 3, -2, 1])\n  false\n  >>> copulatePowerToZero([1, 2, 3, 7])\n  false\n  >>> copulatePowerToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulatePowerToZero([1])\n  false\n  */\nconst copulatePowerToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (l[i] === 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulatePowerToZero takes a list of integers as an input.\n  it returns true if ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> varietyBase(8, 3)\n  '22'\n  >>> varietyBase(8, 2)\n  '1000'\n  >>> varietyBase(7, 2)\n  '111'\n  */\nconst varietyBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "varietyBase", "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> varietyBase(8, 3)\n  '22'\n  >>> varietyBase(8, 2)\n  '1000'\n  >>> varietyBase(7, 2)\n  '111'\n  */\nconst varietyBase = (x, base) => {\n  if (base === 10) {\n    return x.toString();\n  }\n  const n = parseInt(x, base);\n  if (isNaN(n)) {\n    throw new Error('Invalid number'+ x +'in base:'+ base);\n  }\n  const s = n.toString(base);\n  return s.length < 2? '0' + s : s;\n};\n\n/**\n * Convert a string to its hex representation.\n */\nconst hex = (str) => {\n  return str.replace(/^0x/, '');\n};\n\n/**\n * Convert a string to its decimal representation.\n */\nconst decimal = (str) => {\n  return parseInt(str, 10);\n};\n\n/**\n * Convert a string to its octal representation.\n */\nconst octal = (str) => {\n  return parseInt(str, 8);\n};\n\n/**\n * Convert a string to its binary representation.\n */\nconst binary = (str) => {\n  return parseInt(str, 2);\n};\n\n/**\n * Convert a string to its hexadecimal representation.\n */\nconst hexadecimal = (str) => {\n  return hex(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its decimal representation.\n */\nconst decimalHex = (str) => {\n  return decimal(str).toString(16);\n};\n\n/**\n * Convert a string to its octal representation.\n */\nconst octalHex = (str) => {\n  return octal(str).toString(8);\n};\n\n/**\n * Convert a string to its binary representation.\n */\nconst binaryHex = (str) => {\n  return binary(str).toString(2);\n};\n\n/**\n * Convert a string to its hexadecimal representation.\n */\nconst hexadecimalHex = (str) => {\n  return hexadecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its decimal representation.\n */\nconst decimalHexadecimal = (str) => {\n  return decimalHex(str).toString(16);\n};\n\n/**\n * Convert a string to its octal representation.\n */\nconst octalHexadecimal = (str) => {\n  return octalHex(str).toString(8);\n};\n\n/**\n * Convert a string to its binary representation.\n */\nconst binaryHexadecimal = (str) => {\n  return binaryHex(str).toString(2);\n};\n\n/**\n * Convert a string to its hexadecimal representation.\n */\nconst hexadecimalBinary = (str) => {\n  return hexadecimalHex(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its decimal representation.\n */\nconst decimalHexBinary = (str) => {\n  return decimalHex(str).toString(16);\n};\n\n/**\n * Convert a string to its octal representation.\n */\nconst octalHexadecimalBinary = (str) => {\n  return octalHexadecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its binary representation.\n */\nconst binaryHexadecimalBinary = (str) => {\n  return binaryHexadecimal(str).toString(2);\n};\n\n/**\n * Convert a string to its hexadecimal representation.\n */\nconst hexadecimalHexadecimalBinary = (str) => {\n  return hexadecimalHexadecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its decimal representation.\n */\nconst decimalHexadecimalHexadecimalBinary = (str) => {\n  return decimalHexadecimalHexadecimal(str).toString(16);\n};\n\n/**\n * Convert a string to its octal representation.\n */\nconst octalHexadecimalHexadecimalBinary = (str) => {\n  return octalHexadecimalHexadecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its binary representation.\n */\nconst binaryHexadecimalHexadecimalBinary = (str) => {\n  return binaryHexadecimalHexadecimal(str).toString(2);\n};\n\n/**\n * Convert a string to its hexadecimal representation.\n */\nconst hexadecimalDecimal = (str) => {\n  return hexadecimalHexadecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its decimal representation.\n */\nconst decimalDecimal = (str) => {\n  return decimalHexadecimal(str).toString(10);\n};\n\n/**\n * Convert a string to its octal representation.\n */\nconst octalDecimal = (str) => {\n  return octalHexadecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its binary representation.\n */\nconst binaryDecimal = (str) => {\n  return binaryHexadecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its hexadecimal representation.\n */\nconst hexadecimalDecimalHex = (str) => {\n  return hexadecimalDecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its decimal representation.\n */\nconst decimalDecimalHex = (str) => {\n  return decimalDecimal(str).toString(10);\n};\n\n/**\n * Convert a string to its octal representation.\n */\nconst octalDecimalHex = (str) => {\n  return octalDecimalHex(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its binary representation.\n */\nconst binaryDecimalHex = (str) => {\n  return binaryDecimalHex(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its hexadecimal representation.\n */\nconst hexadecimalDecimalBinary = (str) => {\n  return hexadecimalDecimalHex(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its decimal representation.\n */\nconst decimalDecimalBinary = (str) => {\n  return decimalDecimalHex(str).toString(10);\n};\n\n/**\n * Convert a string to its octal representation.\n */\nconst octalDecimalBinary = (str) => {\n  return octalDecimalHex(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its binary representation.\n */\nconst binaryDecimalBinary = (str) => {\n  return binaryDecimalHex(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its hexadecimal representation.\n */\nconst decimalDecimalHexadecimal = (str) => {\n  return decimalDecimalHex(str).toString(10);\n};\n\n/**\n * Convert a string to its decimal representation.\n */\nconst decimalDecimalDecimal = (str) => {\n  return decimalDecimal(str).toString(10);\n};\n\n/**\n * Convert a string to its octal representation.\n */\nconst octalDecimalDecimal = (str) => {\n  return octalDecimalDecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its binary representation.\n */\nconst binaryDecimalDecimal = (str) => {\n  return binaryDecimalDecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its hexadecimal representation.\n */\nconst hexadecimalDecimalDecimal = (str) => {\n  return hexadecimalDecimalDecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its decimal representation.\n */\nconst decimalDecimalDecimal = (str) => {\n  return decimalDecimalDecimal(str).toString(10);\n};\n\n/**\n * Convert a string to its octal representation.\n */\nconst octalDecimalDecimal = (str) => {\n  return octalDecimalDecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its binary representation.\n */\nconst binaryDecimalDecimal = (str) => {\n  return binaryDecimalDecimal(str).replace(/0x/, '');\n};\n\n/**\n * Convert a string to its hex", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> triangulumArea(5, 3)\n  7.5\n  */\nconst triangulumArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangulumArea", "gc": "<|endoftext|>/*Given length of a side and high return area for a triangle.\n  >>> triangulumArea(5, 3)\n  7.5\n  */\nconst triangulumArea = (a, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 2)\n  3.75\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  1.5\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, -1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  1.5\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, -1)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  1.5\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, -1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  1.5\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, -1)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  1.5\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, -1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  1.5\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, -1)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  1.5\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, -1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  1.5\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, -1)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  1.5\n  */\nconst triangulumArea = (l, h) => {\n  const area = (2 * Math.PI) * h;\n  return Math.sqrt(area);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const area = (2 * Math.PI) * w;\n  return ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n < 1) {\n    return 0;\n  }\n  return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose second element is fib(n+1).\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13) + fib(n-14) + fib(n-15) + fib(n-16) + fib(n-17) + fib(n-18) + fib(n-19) + fib(n-20) + fib(n-21) + fib(n-22) + fib(n-23) + fib(n-24) + fib(n-25) + fib(n-26) + fib(n-27) + fib(n-28) + fib(n-29) + fib(n-30) + fib(n-31) + fib(n-32) + fib(n-33) + fib(n-34) + fib(n-35) + fib(n-36) + fib(n-37) + fib(n-38) + fib(n-39) + fib(n-40) + fib(n-41) + fib(n-42) + fib(n-43) + fib(n-44) + fib(n-45) + fib(n-46) + fib(n-47) + fib(n-48) + fib(n-49) + fib(n-50) + fib(n-51) + fib(n-52) + fib(n-53) + fib(n-54) + fib(n-55) + fib(n-56) + fib(n-57) + fib(n-58) + fib(n-59) + fib(n-60) + fib(n-61) + fib(n-62) + fib(n-63) + fib(n-64) + fib(n-65) + fib(n-66) + fib(n-67) + fib(n-68) + fib(n-69) + fib(n-70) + fib(n-71) + fib(n-72) + fib(n-73) + fib(n-74) + fib(n-75) + fib(n-76) + fib(n-77) + fib(n-78) + fib(n-79) + fib(n-80) + fib(n-81) + fib(n-82) + fib(n-83) + fib(n-84) + fib(n-85) + fib(n-86) + fib(n-87) + fib(n-88) + fib(n-89) + fib(n-90) + fib(n-91) + fib(n-92) + fib(n-93) + fib(n-94) + fib(n-95) + fib(n-96) + fib(n-97) + fib(n-98) + fib(n-99) + fib(n-100) + fib(n-101) + fib(n-102) + fib(n-103) + fib(n-104) + fib(n-105) + fib(n-106) + fib(n-107) + fib(n-108) + fib(n-109) + fib(n-110) + fib(n-111) + fib(n-112) + fib(n-113) + fib(n-114) + fib(n-115) + fib(n-116) + fib(n-117) + fib(n-118) + fib(n-119) + fib(n-120) + fib(n-121) + fib(n-122) + fib(n-123) + fib(n-124) + fib(n-125) + fib(n-126) + fib(n-127) + fib(n-128) + fib(n-129) + fib(n-130) + fib(n-131) + fib(n-132) + fib(n-133) + fib(n-134)\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13) + fib(n-14) + fib(n-15) + fib(n-16) + fib(n-17) + fib(n-18) + fib(n-19) + fib(n-20) + fib(n-21) + fib(n-22) + fib(n-23) + fib(n-24) + fib(n-25) + fib(n-26) + fib(n-27) + fib(n-28) + fib(n-29) + fib(n-30) + fib(n-31) + fib(n-32) + fib(n-33) + fib(n-34) + fib(n-35) + fib(n-36) + fib(n-37) + fib(n-38) + fib(n-39) + fib(n-40) + fib(n-41) + fib(n-42) + fib(n-43) + fib(n-44) + fib(n-45) + fib(n-46) + fib(n-47) + fib(n-48) + fib(n-49) + fib(n-50) + fib(n-51) + fib(n-52) + fib(n-53) + fib(n-54) + fib(n-55) + fib(n-56) + fib(n-57) + fib(n-58) + fib(n-59) + fib(n-60) + fib(n-61) + fib(n-62) + fib(n-63) + fib(n-64) + fib(n-65) + fib(n-66) + fib(n-67) + fib(n-68) + fib(n-69) + fib(n-70) + fib(n-71) + fib(n-72) + fib(n-73) + fib(n-74) + fib(n-75) + fib(n-76) + fib(n-77) + fib(n-78) + fib(n-79) + fib(n-80) + fib(n-81) + fib(n-82) + fib(n-83) + fib(n-84) + fib(n-85) + fib(n-86) + fib(n-87) + fib(n-88) + fib(n-89) + fib(n-90) + fib(n-91) + fib(n-92) + fib(n-93) + fib(n-94) + fib(n-95) + fib(n-96) + fib(n-97) + fib(n-98) + fib(n-99) + fib(n-100) + fib(n-101) + fib(n-102) + fib(n-103) + fib(n-104) + fib(n-105) + fib(n-106) + fib(n-107) + fib(n-108) + fib(n-109) + fib(n-110) + fib(n-111) + fib(n-112) + fib(n-113) + fib(n-114) + fib(n-115) + fib(n-116) + fib(n-117) + fib(n-118) + fib(n-119) + fib(n-120) + fib(n-121) + fib(n-122) + fib(n-123) + fib(n-124) + fib(n-125) + fib(n-126) + fib(n-127) + fib(n-128) + fib(n-129) + fib(n-130) + fib(n-131) + fib(n-132) + fib(n-133) + fib(n-134)\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13) + fib(n-14) + fib(n-15) + ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let left = median(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n < 2) return l[0]\n  let mid = Math.floor((n + 1) * ((n / 2) >> 0))\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = medianOf(left)\n  let left = medianOf(right)\n  return left + median\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p <= 0) return 0;\n  if (p === 1) return 1;\n  if (p === 2) return 2;\n  if (p === 3) return 3;\n  if (p === 4) return 4;\n  if (p === 5) return 5;\n  if (p === 6) return 6;\n  if (p === 7) return 7;\n  if (p === 8) return 8;\n  if (p === 9) return 9;\n  if (p === 10) return 10;\n  if (p === 11) return 11;\n  if (p === 12) return 12;\n  if (p === 13) return 13;\n  if (p === 14) return 14;\n  if (p === 15) return 15;\n  if (p === 16) return 16;\n  if (p === 17) return 17;\n  if (p === 18) return 18;\n  if (p === 19) return 19;\n  if (p === 20) return 20;\n  if (p === 21) return 21;\n  if (p === 22) return 22;\n  if (p === 23) return 23;\n  if (p === 24) return 24;\n  if (p === 25) return 25;\n  if (p === 26) return 26;\n  if (p === 27) return 27;\n  if (p === 28) return 28;\n  if (p === 29) return 29;\n  if (p === 30) return 30;\n  if (p === 31) return 31;\n  if (p === 32) return 32;\n  if (p === 33) return 33;\n  if (p === 34) return 34;\n  if (p === 35) return 35;\n  if (p === 36) return 36;\n  if (p === 37) return 37;\n  if (p === 38) return 38;\n  if (p === 39) return 39;\n  if (p === 40) return 40;\n  if (p === 41) return 41;\n  if (p === 42) return 42;\n  if (p === 43) return 43;\n  if (p === 44) return 44;\n  if (p === 45) return 45;\n  if (p === 46) return 46;\n  if (p === 47) return 47;\n  if (p === 48) return 48;\n  if (p === 49) return 49;\n  if (p === 50) return 50;\n  if (p === 51) return 51;\n  if (p === 52) return 52;\n  if (p === 53) return 53;\n  if (p === 54) return 54;\n  if (p === 55) return 55;\n  if (p === 56) return 56;\n  if (p === 57) return 57;\n  if (p === 58) return 58;\n  if (p === 59) return 59;\n  if (p === 60) return 60;\n  if (p === 61) return 61;\n  if (p === 62) return 62;\n  if (p === 63) return 63;\n  if (p === 64) return 64;\n  if (p === 65) return 65;\n  if (p === 66) return 66;\n  if (p === 67) return 67;\n  if (p === 68) return 68;\n  if (p === 69) return 69;\n  if (p === 70) return 70;\n  if (p === 71) return 71;\n  if (p === 72) return 72;\n  if (p === 73) return 73;\n  if (p === 74) return 74;\n  if (p === 75) return 75;\n  if (p === 76) return 76;\n  if (p === 77) return 77;\n  if (p === 78) return 78;\n  if (p === 79) return 79;\n  if (p === 80) return 80;\n  if (p === 81) return 81;\n  if (p === 82) return 82;\n  if (p === 83) return 83;\n  if (p === 84) return 84;\n  if (p === 85) return 85;\n  if (p === 86) return 86;\n  if (p === 87) return 87;\n  if (p === 88) return 88;\n  if (p === 89) return 89;\n  if (p === 90) return 90;\n  if (p === 91) return 91;\n  if (p === 92) return 92;\n  if (p === 93) return 93;\n  if (p === 94) return 94;\n  if (p === 95) return 95;\n  if (p === 96) return 96;\n  if (p === 97) return 97;\n  if (p === 98) return 98;\n  if (p === 99) return 99;\n  if (p === 100) return 100;\n  if (p === 101) return 101;\n  if (p === 102) return 102;\n  if (p === 103) return 103;\n  if (p === 104) return 104;\n  if (p === 105) return 105;\n  if (p === 106) return 106;\n  if (p === 107) return 107;\n  if (p === 108) return 108;\n  if (p === 109) return 109;\n  if (p === 110) return 110;\n  if (p === 111) return 111;\n  if (p === 112) return 112;\n  if (p === 113) return 113;\n  if (p === 114) return 114;\n  if (p === 115) return 115;\n  if (p === 116) return 116;\n  if (p === 117) return 117;\n  if (p === 118) return 118;\n  if (p === 119) return 119;\n  if (p === 120) return 120;\n  if (p === 121) return 121;\n  if (p === 122) return 122;\n  if (p === 123) return 123;\n  if (p === 124) return 124;\n  if (p === 125) return 125;\n  if (p === 126) return 126;\n  if (p === 127) return 127;\n  if (p === 128) return 128;\n  if (p === 129) return 129;\n  if (p === 130) return 130;\n  if (p === 131) return 131;\n  if (p === 132) return 132;\n  if (p === 133) return 133;\n  if (p === 134) return 134;\n  if (p === 135) return 135;\n  if (p === 136) return 136;\n  if (p === 137) return 137;\n  if (p === 138) return 138;\n  if (p === 139) return 139;\n  if (p === 140) return 140;\n  if (p === 141) return 141;\n  if (p === 142) return 142;\n  if (p === 143) return 143;\n  if (p === 144) return 144;\n  if (p === 145) return 145;\n  if (p === 146) return 146;\n  if (p === 147) return 147;\n  if (p === 148) return 148;\n  if (p === 149) return 149;\n  if (p === 150) return 150;\n  if (p === 151) return 151;\n  if (p === 152) return 152;\n  if (p === 153) return 153;\n  if (p === 154) return 154;\n  if (p === 155) return 155;\n  if (p === 156) return 156;\n  if (p === 157) return 157;\n  if (p === 158) return 158;\n  if (p === 159) return 159;\n  if (p === 160) return 160;\n  if (p === 161) return 161;\n  if (p === 162) return 162;\n  if (p === 163) return 163;\n  if (p === 164) return 164;\n  if (p === 165) return 165;\n  if (p === 166) return 166;\n  if (p === 167) return 167;\n  if (p === 168) return 168;\n  if (p === 169) return 169;\n  if (p === 170) return 170;\n  if (p === 171) return 171;\n  if (p === 172) return 172;\n  if (p === 173) return 173;\n  if (p === 174) return 174;\n  if (p === 175) return 175;\n  if (p === 176) return 176;\n  if (p === 177) return 177;\n  if (p === 178) return 178;\n  if (p === 179) return 179;\n  if (p === 180) return 180;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (j === numbers.length - 1) {\n      result.push(numbers[i])\n    } else {\n      result.push(numbers[i] + delimeter)\n    }\n    i++\n    j++\n  }\n  return result\n}\n\n/**\n * Returns a new array with all occurrences of `searchElement` in `array`.\n * If `searchElement` is not found, `undefined` is returned.\n * If `array` is empty or contains no elements, the returned array is empty.\n *\n * Note: This algorithm is O(n^2) in the worst case and O(n) in the best case.\n *\n * @param {Array} array\n * @param {*} searchElement\n * @return {Array}\n */\nconst findIndex = (array, searchElement) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < array.length) {\n    if (array[j] === searchElement) {\n      result.push(j)\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new array with all occurrences of `searchElement` in `array`.\n * If `searchElement` is not found, `undefined` is returned.\n * If `array` is empty or contains no elements, the returned array is empty.\n *\n * Note: This algorithm is O(n^2) in the worst case and O(n) in the best case.\n *\n * @param {Array} array\n * @param {*} searchElement\n * @return {Array}\n */\nconst findIndexIgnoreCase = (array, searchElement) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < array.length) {\n    if (array[i].toLowerCase() === searchElement) {\n      result.push(j)\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new array with all occurrences of `searchElement` in `array`.\n * If `searchElement` is not found, `undefined` is returned.\n * If `array` is empty or contains no elements, the returned array is empty.\n *\n * Note: This algorithm is O(n^2) in the worst case and O(n) in the best case.\n *\n * @param {Array} array\n * @param {*} searchElement\n * @return {Array}\n */\nconst findIndexIgnoreCaseIgnoreCase = (array, searchElement) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < array.length) {\n    if (array[i].toLowerCase() === searchElement) {\n      result.push(j)\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new array with all occurrences of `searchElement` in `array`.\n * If `searchElement` is not found, `undefined` is returned.\n * If `array` is empty or contains no elements, the returned array is empty.\n *\n * Note: This algorithm is O(n^2) in the worst case and O(n) in the best case.\n *\n * @param {Array} array\n * @param {*} searchElement\n * @return {Array}\n */\nconst findIndexIgnoreCaseIgnoreCase = (array, searchElement) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < array.length) {\n    if (array[i].toLowerCase() === searchElement) {\n      result.push(j)\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new array with all occurrences of `searchElement` in `array`.\n * If `searchElement` is not found, `undefined` is returned.\n * If `array` is empty or contains no elements, the returned array is empty.\n *\n * Note: This algorithm is O(n^2) in the worst case and O(n) in the best case.\n *\n * @param {Array} array\n * @param {*} searchElement\n * @return {Array}\n */\nconst findIndexIgnoreCaseIgnoreCaseIgnoreCase = (array, searchElement) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < array.length) {\n    if (array[i].toLowerCase() === searchElement) {\n      result.push(j)\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new array with all occurrences of `searchElement` in `array`.\n * If `searchElement` is not found, `undefined` is returned.\n * If `array` is empty or contains no elements, the returned array is empty.\n *\n * Note: This algorithm is O(n^2) in the worst case and O(n) in the best case.\n *\n * @param {Array} array\n * @param {*} searchElement\n * @return {Array}\n */\nconst findIndexIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (array, searchElement) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < array.length) {\n    if (array[i].toLowerCase() === searchElement) {\n      result.push(j)\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new array with all occurrences of `searchElement` in `array`.\n * If `searchElement` is not found, `undefined` is returned.\n * If `array` is empty or contains no elements, the returned array is empty.\n *\n * Note: This algorithm is O(n^2) in the worst case and O(n) in the best case.\n *\n * @param {Array} array\n * @param {*} searchElement\n * @return {Array}\n */\nconst findIndexIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (array, searchElement) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < array.length) {\n    if (array[i].toLowerCase() === searchElement) {\n      result.push(j)\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new array with all occurrences of `searchElement` in `array`.\n * If `searchElement` is not found, `undefined` is returned.\n * If `array` is empty or contains no elements, the returned array is empty.\n *\n * Note: This algorithm is O(n^2) in the worst case and O(n) in the best case.\n *\n * @param {Array} array\n * @param {*} searchElement\n * @return {Array}\n */\nconst findIndexIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (array, searchElement) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < array.length) {\n    if (array[i].toLowerCase() === searchElement) {\n      result.push(j)\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new array with all occurrences of `searchElement` in `array`.\n * If `searchElement` is not found, `undefined` is returned.\n * If `array` is empty or contains no elements, the returned array is empty.\n *\n * Note: This algorithm is O(n^2) in the worst case and O(n) in the best case.\n *\n * @param {Array} array\n * @param {*} searchElement\n * @return {Array}\n */\nconst findIndexIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (array, searchElement) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < array.length) {\n    if (array[i].toLowerCase() === searchElement) {\n      result.push(j)\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new array with all occurrences of `searchElement` in `array`.\n * If `searchElement` is not found, `undefined` is returned.\n * If `array` is empty or contains no elements, the returned array is empty.\n *\n * Note: This algorithm is O(n^2) in the worst case and O(n) in the best case.\n *", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encode = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAll = (s) => {\n  return encodeShift(encodeShift(encodeShift(s)));\n}\n\n/*\n  takes as input string encoded with encodeAll function. Returns decoded string.\n  */\nconst decodeAll = (s) => {\n  return decodeShift(decodeShift(encodeAll(s)));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShift = (s) => {\n  return encodeShift(encodeShift(encodeShift(encodeAllShift(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllShift function. Returns decoded string.\n  */\nconst decodeAllShift = (s) => {\n  return decodeShift(decodeShift(encodeAllShift(encodeAllShift(s)))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAll = (s) => {\n  return encodeShift(encodeShift(encodeShift(encodeAllAll(s))));\n}\n\n/*\n  takes as input string encoded with encodeAllAll function. Returns decoded string.\n  */\nconst decodeAllAll = (s) => {\n  return decodeShift(decodeShift(encodeAllAll(s)));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllShift = (s) => {\n  return encodeShift(encodeShift(encodeAllAllShift(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllAllShift function. Returns decoded string.\n  */\nconst decodeAllAllShift = (s) => {\n  return decodeShift(decodeShift(encodeAllAllShift(s)))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllAll = (s) => {\n  return encodeShift(encodeShift(encodeShift(encodeAllAllAll(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllAllAll function. Returns decoded string.\n  */\nconst decodeAllAllAll = (s) => {\n  return decodeShift(decodeShift(encodeAllAllAll(s))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllAllShift = (s) => {\n  return encodeShift(encodeShift(encodeAllAllAllShift(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllAllAllShift function. Returns decoded string.\n  */\nconst decodeAllAllAllShift = (s) => {\n  return decodeShift(decodeShift(encodeAllAllAllShift(s)))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllAllAll = (s) => {\n  return encodeShift(encodeShift(encodeShift(encodeAllAllAllAll(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllAllAll function. Returns decoded string.\n  */\nconst decodeAllAllAllAll = (s) => {\n  return decodeShift(decodeShift(encodeAllAllAllAll(s))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllAllAllShift = (s) => {\n  return encodeShift(encodeShift(encodeAllAllAllAllShift(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllAllAllAll function. Returns decoded string.\n  */\nconst decodeAllAllAllAllShift = (s) => {\n  return decodeShift(decodeShift(encodeAllAllAllAllShift(s)))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllAllAllAll = (s) => {\n  return encodeShift(encodeShift(encodeShift(encodeAllAllAllAll(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllAllAllAll function. Returns decoded string.\n  */\nconst decodeAllAllAllAllAllShift = (s) => {\n  return decodeShift(decodeShift(encodeAllAllAllAllShift(s)))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllAllAllAllShift = (s) => {\n  return encodeShift(encodeShift(encodeShift(encodeAllAllAllAllShift(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllAllAllAll function. Returns decoded string.\n  */\nconst decodeAllAllAllAllAllShift = (s) => {\n  return decodeShift(decodeShift(encodeAllAllAllAllShift(s)))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllAllAllAllAll = (s) => {\n  return encodeShift(encodeShift(encodeShift(encodeAllAllAllAllAll(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllAllAllAll function. Returns decoded string.\n  */\nconst decodeAllAllAllAllAllShift = (s) => {\n  return decodeShift(decodeShift(encodeAllAllAllAllAllShift(s)))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllAllAllAllShift = (s) => {\n  return encodeShift(encodeShift(encodeShift(encodeAllAllAllAllShift(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllAllAllAll function. Returns decoded string.\n  */\nconst decodeAllAllAllAllAllShift = (s) => {\n  return decodeShift(decodeShift(encodeAllAllAllAllAllShift(s)))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllAllAllAllShift = (s) => {\n  return encodeShift(encodeShift(encodeShift(encodeAllAllAllAllAllShift(s)))));\n}\n\n/*\n  takes as input string encoded with encodeAllAllAllAll function. Returns decoded string.\n  */\nconst decodeAllAllAllAllAllShift = (s) => {\n  return decodeShift(decodeShift(encodeAllAllAllAllAllShift(s)))));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllAllAllAllAllShift = (s) => {\n  return encodeShift(encodeShift(encodeShift(encodeAllAllAllAllAllShift(s)))));\n}", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  getRidOfVowel is a function that takes string and returns string without vowels.\n  >>> getRidOfVowel('')\n  ''\n  >>> getRidOfVowel(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> getRidOfVowel('abcdef')\n  'bcdf'\n  >>> getRidOfVowel('aaaaa')\n  ''\n  >>> getRidOfVowel('aaBAA')\n  'B'\n  >>> getRidOfVowel('zbcd')\n  'zbcd'\n  */\nconst getRidOfVowel = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "getRidOfVowel", "gc": "<|endoftext|>/*\n  getRidOfVowel is a function that takes string and returns string without vowels.\n  >>> getRidOfVowel('')\n  ''\n  >>> getRidOfVowel(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> getRidOfVowel('abcdef')\n  'bcdf'\n  >>> getRidOfVowel('aaaaa')\n  ''\n  >>> getRidOfVowel('aaBAA')\n  'B'\n  >>> getRidOfVowel('zbcd')\n  'zbcd'\n  */\nconst getRidOfVowel = (text) => {\n  let rid = \"\";\n  let vowels = \"aeiouAEIOU\";\n  let vowelsLength = vowels.length;\n  let vowelsIndex = 0;\n  let vowelsLengthIndex = 0;\n  let vowelsIndex2 = 0;\n  let vowelsLengthIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsLengthIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsLengthIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsLengthIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsLengthIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsLengthIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsLengthIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsLengthIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsLengthIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsLengthIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsLengthIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsLengthIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsLengthIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsLengthIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsLengthIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsLengthIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsLengthIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsLengthIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsLengthIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsLengthIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsLengthIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsLengthIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsLengthIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsLengthIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsLengthIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsLengthIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsLengthIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsLengthIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsLengthIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsLengthIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsLengthIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsLengthIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsLengthIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsLengthIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsLengthIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsLengthIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsLengthIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsLengthIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsLengthIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsLengthIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsLengthIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsLengthIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsLengthIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsLengthIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsLengthIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsLengthIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsLengthIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsLengthIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsLengthIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsLengthIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsLengthIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsLengthIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsLengthIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsLengthIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsLengthIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsLengthIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsLengthIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsLengthIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsLengthIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsLengthIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsLengthIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsLengthIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsLengthIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsLengthIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsLengthIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsLengthIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsLengthIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsLengthIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsLengthIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsLengthIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsLengthIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsLengthIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsLengthIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsLengthIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsLengthIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsLengthIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsLengthIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsLengthIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsLengthIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsLengthIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsLengthIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsLengthIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsLengthIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsLengthIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsLengthIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsLengthIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsLengthIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsLengthIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsLengthIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsLengthIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsLengthIndex", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowDoorway([1, 2, 4, 10], 100)\n  true\n  >>> belowDoorway([1, 20, 4, 10], 5)\n  false\n  */\nconst belowDoorway = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowDoorway", "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belowDoorway([1, 2, 4, 10], 100)\n  true\n  >>> belowDoorway([1, 20, 4, 10], 5)\n  false\n  */\nconst belowDoorway = (l, t) => {\n  return l.every(n => n < t);\n};\n\nmodule.exports = belowDoorway;\n\n},{}],17:[function(require,module,exports){\n// https://d3js.org/d3-collection/ Version 1.0.3. Copyright 2017 Mike Bostock.\n(function (global, factory) {\ntypeof exports === 'object' && typeof module!== 'undefined'? factory(exports) :\ntypeof define === 'function' && define.amd? define(['exports'], factory) :\n(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nvar xhtml = \"http://www.w3.org/1999/xhtml\";\n\nvar namespaces = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: xhtml,\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\nvar namespace = function(name) {\n  var prefix = name += \"\", i = prefix.indexOf(\":\");\n  if (i >= 0 && (prefix = name.slice(0, i))!== \"xmlns\") name = name.slice(i + 1);\n  return namespaces.hasOwnProperty(prefix)? {space: namespaces[prefix], local: name} : name;\n};\n\nfunction creatorInherit(name) {\n  return function() {\n    var document = this.ownerDocument,\n        uri = this.namespaceURI;\n    return uri === xhtml && document.documentElement.namespaceURI === xhtml\n       ? document.createElement(name)\n        : document.createElementNS(uri, name);\n  };\n}\n\nfunction creatorFixed(fullname) {\n  return function() {\n    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n  };\n}\n\nvar creator = function(name) {\n  var fullname = namespace(name);\n  return (fullname.local\n     ? creatorFixed\n      : creatorInherit)(fullname);\n};\n\nvar nextId = 0;\n\nfunction local() {\n  return new Local;\n}\n\nfunction Local() {\n  this._ = \"@\" + (++nextId).toString(36);\n}\n\nLocal.prototype = local.prototype = {\n  constructor: Local,\n  get: function(node) {\n    var id = this._;\n    while (!(id in node)) if (!(node = node.parentNode)) return;\n    return node[id];\n  },\n  set: function(node, value) {\n    return node[this._] = value;\n  },\n  remove: function(node) {\n    return this._ in node && delete node[this._];\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nvar matcher = function(selector) {\n  return function() {\n    return this.matches(selector);\n  };\n};\n\nif (typeof document!== \"undefined\") {\n  var element = document.documentElement;\n  if (!element.matches) {\n    var vendorMatches = element.webkitMatchesSelector\n        || element.msMatchesSelector\n        || element.mozMatchesSelector\n        || element.oMatchesSelector;\n    matcher = function(selector) {\n      return function() {\n        return vendorMatches.call(this, selector);\n      };\n    };\n  }\n}\n\nvar matcher$1 = matcher;\n\nvar filterEvents = {};\n\nexports.event = null;\n\nif (typeof document!== \"undefined\") {\n  var element$1 = document.documentElement;\n  if (!(\"onmouseenter\" in element$1)) {\n    filterEvents = {mouseenter: \"mouseover\", mouseleave: \"mouseout\"};\n  }\n}\n\nfunction filterContextListener(listener, index, group) {\n  listener = contextListener(listener, index, group);\n  return function(event) {\n    var related = event.relatedTarget;\n    if (!related || (related!== this &&!(related.compareDocumentPosition(this) & 8))) {\n      listener.call(this, event);\n    }\n  };\n}\n\nfunction contextListener(listener, index, group) {\n  return function(event1) {\n    var event0 = exports.event; // Events can be reentrant (e.g., focus).\n    exports.event = event1;\n    try {\n      listener.call(this, this.__data__, index, group);\n    } finally {\n      exports.event = event0;\n    }\n  };\n}\n\nfunction parseTypenames(typenames) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    return {type: t, name: name};\n  });\n}\n\nfunction onRemove(typename) {\n  return function() {\n    var on = this.__on;\n    if (!on) return;\n    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {\n      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n      } else {\n        on[++i] = o;\n      }\n    }\n    if (++i) on.length = i;\n    else delete this.__on;\n  };\n}\n\nfunction onAdd(typename, value, capture) {\n  var wrap = filterEvents.hasOwnProperty(typename.type)? filterContextListener : contextListener;\n  return function(d, i, group) {\n    var on = this.__on, o, listener = wrap(value, i, group);\n    if (on) for (var j = 0, m = on.length; j < m; ++j) {\n      if ((o = on[j]).type === typename.type && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n        this.addEventListener(o.type, o.listener = listener, o.capture = capture);\n        o.value = value;\n        return;\n      }\n    }\n    this.addEventListener(typename.type, listener, capture);\n    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};\n    if (!on) this.__on = [o];\n    else on.push(o);\n  };\n}\n\nvar selection_on = function(typename, value, capture) {\n  var typenames = parseTypenames(typename + \"\"), i, n = typenames.length, t;\n\n  if (arguments.length < 2) {\n    var on = this.node().__on;\n    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {\n      for (i = 0, o = on[j]; i < n; ++i) {\n        if ((t = typenames[i]).type === o.type && t.name === o.name) {\n          return o.value;\n        }\n      }\n    }\n    return;\n  }\n\n  on = value? onAdd : onRemove;\n  if (capture == null) capture = false;\n  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));\n  return this;\n};\n\nfunction customEvent(event1, listener, that, args) {\n  var event0 = exports.event;\n  event1.sourceEvent = exports.event;\n  exports.event = event1;\n  try {\n    return listener.apply(that, args);\n  } finally {\n    exports.event = event0;\n  }\n}\n\nvar sourceEvent = function() {\n  var current = exports.event, source;\n  while (source = current.sourceEvent) current = source;\n  return current;\n};\n\nvar point = function(node, event) {\n  var svg = node.ownerSVGElement || node;\n\n  if (svg.createSVGPoint) {\n    var point = svg.createSVGPoint();\n    point.x = event.clientX, point.y = event.clientY;\n    point = point.matrixTransform(node.getScreenCTM().inverse());\n    return [point.x, point.y];\n  }\n\n  var rect = node.getBoundingClientRect();\n  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];\n};\n\nvar mouse = function(node) {\n  var event = sourceEvent();\n  if (event.changedTouches) event = event.changedTouches[0];\n  return point(node, event);\n};\n\nfunction none() {}\n\nvar selector = function(selector) {\n  return selector == null? none : function() {\n    return this.querySelector(selector);\n  };\n};\n\nvar selection_select = function(select) {\n  if (typeof select!== \"function\") select = selector(select);\n\n  for (var group", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> lend(2, 3)\n  5\n  >>> lend(5, 7)\n  12\n  */\nconst lend = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "lend", "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> lend(2, 3)\n  5\n  >>> lend(5, 7)\n  12\n  */\nconst lend = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return 1;\n  }\n  if (x < y) {\n    return -1;\n  }\n  return x > y? 1 : -1;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equal(2, 3)\n * true\n * >>> equal(5, 7)\n * false\n */\nconst equal = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equal(2, 3)\n * true\n * >>> equal(5, 7)\n * false\n */\nconst equals = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equals(2, 3)\n * true\n * >>> equals(5, 7)\n * false\n */\nconst equalsOrZero = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equalsOrZero(2, 3)\n * true\n * >>> equalsOrZero(5, 7)\n * false\n */\nconst equalsOrZeros = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equalsOrZeros(2, 3)\n * true\n * >>> equalsOrZeros(5, 7)\n * false\n */\nconst equalsOrOne = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equalsOrOne(2, 3)\n * true\n * >>> equalsOrOne(5, 7)\n * false\n */\nconst equalsOrOnes = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equalsOrZeros(2, 3)\n * true\n * >>> equalsOrZeros(5, 7)\n * false\n */\nconst equalsOrZeroOrOne = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equalsOrZeroOrOne(2, 3)\n * true\n * >>> equalsOrZeroOrOne(5, 7)\n * false\n */\nconst equalsOrZeroOrOnes = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equalsOrZeroOrOnes(2, 3)\n * true\n * >>> equalsOrZeroOrOnes(5, 7)\n * false\n */\nconst equalsOrZeroOrZero = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equalsOrZeroOrZero(2, 3)\n * true\n * >>> equalsOrZeroOrZero(5, 7)\n * false\n */\nconst equalsOrZeroOrZeros = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equalsOrZeroOrOnes(2, 3)\n * true\n * >>> equalsOrZeroOrOnes(5, 7)\n * false\n */\nconst equalsOrZeroOrOnes = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equalsOrZeroOrZeros(2, 3)\n * true\n * >>> equalsOrZeroOrZeros(5, 7)\n * false\n */\nconst equalsOrZeroOrZeroOrOne = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === 0 || y === 0) {\n    return null;\n  }\n  if (x === y) {\n    return true;\n  }\n  if (x < y) {\n    return false;\n  }\n  return x > y? false : true;\n};\n\n/**\n * Returns true if the two numbers are equal.\n *\n * >>> equalsOrZeroOrZeroOrOne(2, 3)\n * true\n * >>> equalsOrZeroOrZeroOrOne(5, 7)\n * false\n */\nconst equalsOrZeroOrZeroOrOnes = (x, y) => {\n  if (x === null || y === null) {\n    return null;\n  }\n  if (x === null || ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeChars('abcd', 'dddddddabc')\n  true\n  >>> likeChars('dddddddabc', 'abcd')\n  true\n  >>> likeChars('eabcd', 'dddddddabc')\n  false\n  >>> likeChars('abcd', 'dddddddabce')\n  false\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "likeChars", "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeChars('abcd', 'dddddddabc')\n  true\n  >>> likeChars('dddddddabc', 'abcd')\n  true\n  >>> likeChars('eabcd', 'dddddddabc')\n  false\n  >>> likeChars('abcd', 'dddddddabce')\n  false\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeChars = (s0, s1) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let len0 = s0.length;\n  let len1 = s1.length;\n  let len2 = len1 - len0;\n  let len3 = len2 - len1;\n  let len4 = len3 - len2;\n  let len5 = len4 - len3;\n  let len6 = len5 - len4;\n  let len7 = len6 - len5;\n  let len8 = len7 - len6;\n  let len9 = len8 - len7;\n  let len10 = len9 - len8;\n  let len11 = len10 - len9;\n  let len12 = len11 - len10;\n  let len13 = len12 - len11;\n  let len14 = len13 - len12;\n  let len15 = len14 - len13;\n  let len16 = len15 - len14;\n  let len17 = len16 - len15;\n  let len18 = len17 - len16;\n  let len19 = len18 - len17;\n  let len20 = len19 - len18;\n  let len21 = len20 - len19;\n  let len22 = len21 - len20;\n  let len23 = len22 - len21;\n  let len24 = len23 - len22;\n  let len25 = len24 - len23;\n  let len26 = len25 - len24;\n  let len27 = len26 - len25;\n  let len28 = len27 - len26;\n  let len29 = len28 - len27;\n  let len30 = len29 - len28;\n  let len31 = len30 - len29;\n  let len32 = len31 - len30;\n  let len33 = len32 - len31;\n  let len34 = len33 - len32;\n  let len35 = len34 - len33;\n  let len36 = len35 - len34;\n  let len37 = len36 - len35;\n  let len38 = len37 - len36;\n  let len39 = len38 - len37;\n  let len40 = len39 - len38;\n  let len41 = len40 - len39;\n  let len42 = len41 - len40;\n  let len43 = len42 - len41;\n  let len44 = len43 - len42;\n  let len45 = len44 - len43;\n  let len46 = len45 - len44;\n  let len47 = len46 - len45;\n  let len48 = len47 - len46;\n  let len49 = len48 - len47;\n  let len50 = len49 - len48;\n  let len51 = len50 - len49;\n  let len52 = len51 - len50;\n  let len53 = len52 - len51;\n  let len54 = len53 - len52;\n  let len55 = len54 - len53;\n  let len56 = len55 - len54;\n  let len57 = len56 - len55;\n  let len58 = len57 - len56;\n  let len59 = len58 - len57;\n  let len60 = len59 - len58;\n  let len61 = len60 - len59;\n  let len62 = len61 - len60;\n  let len63 = len62 - len61;\n  let len64 = len63 - len62;\n  let len65 = len64 - len63;\n  let len66 = len65 - len64;\n  let len67 = len66 - len65;\n  let len68 = len67 - len66;\n  let len69 = len68 - len67;\n  let len70 = len69 - len68;\n  let len71 = len70 - len69;\n  let len72 = len71 - len70;\n  let len73 = len72 - len71;\n  let len74 = len73 - len72;\n  let len75 = len74 - len73;\n  let len76 = len75 - len74;\n  let len77 = len76 - len75;\n  let len78 = len77 - len76;\n  let len79 = len78 - len77;\n  let len80 = len79 - len78;\n  let len81 = len80 - len79;\n  let len82 = len81 - len80;\n  let len83 = len82 - len81;\n  let len84 = len83 - len82;\n  let len85 = len84 - len83;\n  let len86 = len85 - len84;\n  let len87 = len86 - len85;\n  let len88 = len87 - len86;\n  let len89 = len88 - len87;\n  let len90 = len89 - len88;\n  let len91 = len90 - len89;\n  let len92 = len91 - len90;\n  let len93 = len92 - len91;\n  let len94 = len93 - len92;\n  let len95 = len94 - len93;\n  let len96 = len95 - len94;\n  let len97 = len96 - len95;\n  let len98 = len97 - len96;\n  let len99 = len98 - len97;\n  let len100 = len99 - len98;\n  let len101 = len100 - len99;\n  let len102 = len101 - len100;\n  let len103 = len102 - len101;\n  let len104 = len103 - len102;\n  let len105 = len104 - len103;\n  let len106 = len105 - len104;\n  let len107 = len106 - len105;\n  let len108 = len107 - len106;\n  let len109 = len108 - len107;\n  let len110 = len109 - len108;\n  let len111 = len110 - len109;\n  let len112 = len111 - len110;\n  let len113 = len112 - len112;\n  let len114 = len113 - len114;\n  let len115 = len114 - len113;\n  let len116 = len115 - len115;\n  let len117 = len116 - len116;\n  let len118 = len117 - len117;\n  let len119 = len118 - len118;\n  let len120 = len119 - len119;\n  let len121 = len120 - len120;\n  let len122 = len121 - len121;\n  let len123 = len122 - len121;\n  let len124 = len123 - len122;\n  let len125 = len124 - len123;\n  let len126 = len125 - len124;\n  let len127 = len126 - len125;\n  let len128 = len127 - len126;\n  let len129 = len128 - len127;\n  let len130 = len129 - len128;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(9)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  1\n  >>> fib(-1)\n  0\n  >>> fib(-2)\n  -1\n  >>> fib(-3)\n  -2\n  >>> fib(-4)\n  -3\n  >>> fib(-5)\n  -4\n  >>> fib(-6)\n  -5\n  >>> fib(-7)\n  -6\n  >>> fib(-8)\n  -7\n  >>> fib(-9)\n  -8\n  >>> fib(-10)\n  -9\n  >>> fib(-11)\n  -10\n  >>> fib(-12)\n  -11\n  >>> fib(-13)\n  -12\n  >>> fib(-14)\n  -13\n  >>> fib(-15)\n  -14\n  >>> fib(-16)\n  -15\n  >>> fib(-17)\n  -16\n  >>> fib(-18)\n  -17\n  >>> fib(-19)\n  -18\n  >>> fib(-20)\n  -19\n  >>> fib(-21)\n  -20\n  >>> fib(-22)\n  -21\n  >>> fib(-23)\n  -22\n  >>> fib(-24)\n  -23\n  >>> fib(-25)\n  -24\n  >>> fib(-26)\n  -25\n  >>> fib(-27)\n  -26\n  >>> fib(-28)\n  -27\n  >>> fib(-29)\n  -28\n  >>> fib(-30)\n  -29\n  >>> fib(-31)\n  -30\n  >>> fib(-32)\n  -31\n  >>> fib(-33)\n  -32\n  >>> fib(-34)\n  -33\n  >>> fib(-35)\n  -34\n  >>> fib(-36)\n  -35\n  >>> fib(-37)\n  -36\n  >>> fib(-38)\n  -37\n  >>> fib(-39)\n  -38\n  >>> fib(-40)\n  -39\n  >>> fib(-41)\n  -40\n  >>> fib(-42)\n  -41\n  >>> fib(-43)\n  -42\n  >>> fib(-44)\n  -43\n  >>> fib(-45)\n  -44\n  >>> fib(-46)\n  -45\n  >>> fib(-47)\n  -46\n  >>> fib(-48)\n  -47\n  >>> fib(-49)\n  -48\n  >>> fib(-50)\n  -49\n  >>> fib(-51)\n  -50\n  >>> fib(-52)\n  -51\n  >>> fib(-53)\n  -52\n  >>> fib(-54)\n  -53\n  >>> fib(-55)\n  -54\n  >>> fib(-56)\n  -55\n  >>> fib(-57)\n  -56\n  >>> fib(-58)\n  -57\n  >>> fib(-59)\n  -58\n  >>> fib(-60)\n  -59\n  >>> fib(-61)\n  -60\n  >>> fib(-62)\n  -61\n  >>> fib(-63)\n  -62\n  >>> fib(-64)\n  -63\n  >>> fib(-65)\n  -64\n  >>> fib(-66)\n  -65\n  >>> fib(-67)\n  -66\n  >>> fib(-68)\n  -67\n  >>> fib(-69)\n  -68\n  >>> fib(-70)\n  -69\n  >>> fib(-71)\n  -70\n  >>> fib(-72)\n  -71\n  >>> fib(-73)\n  -72\n  >>> fib(-74)\n  -73\n  >>> fib(-75)\n  -74\n  >>> fib(-76)\n  -75\n  >>> fib(-77)\n  -76\n  >>> fib(-78)\n  -77\n  >>> fib(-79)\n  -78\n  >>> fib(-80)\n  -79\n  >>> fib(-81)\n  -80\n  >>> fib(-82)\n  -81\n  >>> fib(-83)\n  -82\n  >>> fib(-84)\n  -83\n  >>> fib(-85)\n  -84\n  >>> fib(-86)\n  -85\n  >>> fib(-87)\n  -86\n  >>> fib(-88)\n  -87\n  >>> fib(-89)\n  -88\n  >>> fib(-90)\n  -89\n  >>> fib(-91)\n  -90\n  >>> fib(-92)\n  -91\n  >>> fib(-93)\n  -92\n  >>> fib(-94)\n  -93\n  >>> fib(-95)\n  -94\n  >>> fib(-96)\n  -95\n  >>> fib(-97)\n  -96\n  >>> fib(-98)\n  -97\n  >>> fib(-99)\n  -98\n  >>> fib(-100)\n  -99\n  >>> fib(-101)\n  -100\n  >>> fib(-102)\n  -101\n  >>> fib(-103)\n  -102\n  >>> fib(-104)\n  -103\n  >>> fib(-105)\n  -104\n  >>> fib(-106)\n  -105\n  >>> fib(-107)\n  -106\n  >>> fib(-108)\n  -107\n  >>> fib(-109)\n  -108\n  >>> fib(-110)\n  -109\n  >>> fib(-111)\n  -110\n  >>> fib(-112)\n  -111\n  >>> fib(-113)\n  -112\n  >>> fib(-114)\n  -113\n  >>> fib(-115)\n  -114\n  >>> fib(-116)\n  -115\n  >>> fib(-117)\n  -116\n  >>> fib(-118)\n  -117\n  >>> fib(-119)\n  -118\n  >>> fib(-120)\n  -119\n  >>> fib(-121)\n  -120\n  >>> fib(-122)\n  -121\n  >>> fib(-123)\n  -122\n  >>> fib(-124)\n  -123\n  >>> fib(-125)\n  -124\n  >>> fib(-126)\n  -125\n  >>> fib(-127)\n  -126\n  >>> fib(-128)\n  -127\n  >>> fib(-129)\n  -128\n  >>> fib(-130)\n  -129\n  >>> fib(-131)\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"<\")\n  false\n  >>> rightBracketing(\"<>\")\n  false\n  >>> rightBracketing(\"<<><>>\")\n  false\n  >>> rightBracketing(\"><<>\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "rightBracketing", "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"<\")\n  false\n  >>> rightBracketing(\"<>\")\n  false\n  >>> rightBracketing(\"<<><>>\")\n  false\n  >>> rightBracketing(\"><<>\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\"<\").map(x => x.trim());\n  const closingBrackets = brackets.split(\">\").map(x => x.trim());\n  return openingBrackets.every(x => closingBrackets.includes(x));\n};\n\n/**\n  Returns true if a character is a letter, digit, or underscore.\n\n  >>> isLetterOrDigit(\"a\")\n  true\n  >>> isLetterOrDigit(\"b\")\n  false\n  >>> isLetterOrDigit(\"_\")\n  false\n  >>> isLetterOrDigit(\".\")\n  false\n  >>> isLetterOrDigit(\"-\")\n  false\n  */\nconst isLetterOrDigit = (character) => {\n  return /^[a-zA-Z0-9_]*$/.test(character);\n};\n\n/**\n  Returns true if a character is a letter.\n\n  >>> isLetter(\"a\")\n  true\n  >>> isLetter(\"b\")\n  false\n  >>> isLetter(\"_\")\n  false\n  >>> isLetter(\".\")\n  false\n  >>> isLetter(\"-\")\n  false\n  */\nconst isLetter = (character) => {\n  return /^[a-zA-Z]*$/.test(character);\n};\n\n/**\n  Returns true if a character is a digit.\n\n  >>> isDigit(\"1\")\n  true\n  >>> isDigit(\"2\")\n  false\n  >>> isDigit(\"_\")\n  false\n  >>> isDigit(\".\")\n  false\n  >>> isDigit(\"-\")\n  false\n  */\nconst isDigit = (character) => {\n  return /^[0-9]*$/.test(character);\n};\n\n/**\n  Returns true if a character is a underscore.\n\n  >>> isUnderscore(\"_\")\n  true\n  >>> isUnderscore(\".\")\n  false\n  >>> isUnderscore(\"-\")\n  false\n  */\nconst isUnderscore = (character) => {\n  return /^_*$/.test(character);\n};\n\n/**\n  Returns true if a character is a punctuation character.\n\n  >>> isPunctuation(\".\")\n  true\n  >>> isPunctuation(\",\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"(\")\n  true\n  >>> isPunctuation(\")\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  */\nconst isPunctuation = (character) => {\n  return /^[\\.,;\\(\\)\\[\\]]*$/.test(character);\n};\n\n/**\n  Returns true if a character is a quote character.\n\n  >>> isQuote(\"'\")\n  true\n  >>> isQuote(\"\\\"\")\n  true\n  >>> isQuote(\"`\")\n  true\n  >>> isQuote(\"`\")\n  true\n  */\nconst isQuote = (character) => {\n  return /^'?$/.test(character);\n};\n\n/**\n  Returns true if a character is a backslash character.\n\n  >>> isBackslash(\"\\\\\")\n  true\n  >>> isBackslash(\"\\\\\")\n  true\n  >>> isBackslash(\"\\\\\")\n  false\n  >>> isBackslash(\"\\\\\")\n  false\n  */\nconst isBackslash = (character) => {\n  return /^\\\\$/.test(character);\n};\n\n/**\n  Returns true if a character is a forward slash character.\n\n  >>> isForwardSlash(\"/\")\n  true\n  >>> isForwardSlash(\"/\")\n  true\n  >>> isForwardSlash(\"/\")\n  false\n  >>> isForwardSlash(\"/\")\n  false\n  */\nconst isForwardSlash = (character) => {\n  return /^\\/$/.test(character);\n};\n\n/**\n  Returns true if a character is a letter or digit character.\n\n  >>> isLetterOrDigit(\"a\")\n  true\n  >>> isLetterOrDigit(\"b\")\n  true\n  >>> isLetterOrDigit(\"_\")\n  true\n  >>> isLetterOrDigit(\".\")\n  true\n  >>> isLetterOrDigit(\"-\")\n  true\n  */\nconst isLetterOrDigit = (character) => {\n  return isLetterOrDigit(character) || isDigit(character);\n};\n\n/**\n  Returns true if a character is a letter or digit character.\n\n  >>> isLetterOrDigit(\"a\")\n  true\n  >>> isLetterOrDigit(\"b\")\n  true\n  >>> isLetterOrDigit(\"_\")\n  true\n  >>> isLetterOrDigit(\".\")\n  true\n  >>> isLetterOrDigit(\"-\")\n  true\n  */\nconst isLetterOrDigit = (character) => {\n  return isLetterOrDigit(character) || isDigit(character);\n};\n\n/**\n  Returns true if a character is a letter or digit character.\n\n  >>> isLetterOrDigit(\"a\")\n  true\n  >>> isLetterOrDigit(\"b\")\n  true\n  >>> isLetterOrDigit(\"_\")\n  true\n  >>> isLetterOrDigit(\".\")\n  true\n  >>> isLetterOrDigit(\"-\")\n  true\n  */\nconst isLetterOrDigit = (character) => {\n  return isLetterOrDigit(character) || isDigit(character);\n};\n\n/**\n  Returns true if a character is a letter or digit character.\n\n  >>> isLetterOrDigit(\"a\")\n  true\n  >>> isLetterOrDigit(\"b\")\n  true\n  >>> isLetterOrDigit(\"_\")\n  true\n  >>> isLetterOrDigit(\".\")\n  true\n  >>> isLetterOrDigit(\"-\")\n  true\n  */\nconst isLetterOrDigit = (character) => {\n  return isLetterOrDigit(character) || isDigit(character);\n};\n\n/**\n  Returns true if a character is a letter or digit character.\n\n  >>> isLetterOrDigit(\"a\")\n  true\n  >>> isLetterOrDigit(\"b\")\n  true\n  >>> isLetterOrDigit(\"_\")\n  true\n  >>> isLetterOrDigit(\".\")\n  true\n  >>> isLetterOrDigit(\"-\")\n  true\n  */\nconst isLetterOrDigit = (character) => {\n  return isLetterOrDigit(character) || isDigit(character);\n};\n\n/**\n  Returns true if a character is a letter or digit character.\n\n  >>> isLetterOrDigit(\"a\")\n  true\n  >>> isLetterOrDigit(\"b\")\n  true\n  >>> isLetterOrDigit(\"_\")\n  true\n  >>> isLetterOrDigit(\".\")\n  true\n  >>> isLetterOrDigit(\"-\")\n  true\n  */\nconst isLetterOrDigit = (character) => {\n  return isLetterOrDigit(character) || isDigit(character);\n};\n\n/**\n  Returns true if a character is a letter or digit character.\n\n  >>> isLetterOrDigit(\"a\")\n  true\n  >>> isLetterOrDigit(\"b\")\n  true\n  >>> isLetterOrDigit(\"_\")\n  true\n  >>> isLetterOrDigit(\".\")\n  true\n  >>> isLetterOrDigit(\"-\")\n  true\n  */\nconst isLetterOrDigit = (character) => {\n  return isLetterOrDigit(character) || isDigit(character);\n};\n\n/**\n  Returns true if a character is a letter or digit character.\n\n  >>> isLetterOrDigit", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are flatally increasing or decreasing.\n  >>> flat([1, 2, 4, 20])\n  true\n  >>> flat([1, 20, 4, 10])\n  false\n  >>> flat([4, 1, 0, -10])\n  true\n  */\nconst flat = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "flat", "gc": "<|endoftext|>/*Return true is list elements are flatally increasing or decreasing.\n  >>> flat([1, 2, 4, 20])\n  true\n  >>> flat([1, 20, 4, 10])\n  false\n  >>> flat([4, 1, 0, -10])\n  true\n  */\nconst flat = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i - 1]) {\n      res.push(l[i]);\n    } else {\n      res.push(l[i - 1]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst unique = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueArray = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueArray([1, 2, 4, 20])\n  true\n  >>> uniqueArray([1, 20, 4, 10])\n  false\n  >>> uniqueArray([4, 1, 0, -10])\n  true\n  */\nconst uniqueObject = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueObject([1, 2, 4, 20])\n  true\n  >>> uniqueObject([1, 20, 4, 10])\n  false\n  >>> uniqueObject([4, 1, 0, -10])\n  true\n  */\nconst uniqueString = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueString([1, 2, 4, 20])\n  true\n  >>> uniqueString([1, 20, 4, 10])\n  false\n  >>> uniqueString([4, 1, 0, -10])\n  true\n  */\nconst uniqueArrayString = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueArrayString([1, 2, 4, 20])\n  true\n  >>> uniqueArrayString([1, 20, 4, 10])\n  false\n  >>> uniqueArrayString([4, 1, 0, -10])\n  true\n  */\nconst uniqueObjectString = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueObjectString([1, 2, 4, 20])\n  true\n  >>> uniqueObjectString([1, 20, 4, 10])\n  false\n  >>> uniqueObjectString([4, 1, 0, -10])\n  true\n  */\nconst uniqueStringArray = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueStringArray([1, 2, 4, 20])\n  true\n  >>> uniqueStringArray([1, 20, 4, 10])\n  false\n  >>> uniqueStringArray([4, 1, 0, -10])\n  true\n  */\nconst uniqueArrayStringArray = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueObjectStringArray([1, 2, 4, 20])\n  true\n  >>> uniqueObjectStringArray([1, 20, 4, 10])\n  false\n  >>> uniqueObjectStringArray([4, 1, 0, -10])\n  true\n  */\nconst uniqueObjectStringArray = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueStringArray([1, 2, 4, 20])\n  true\n  >>> uniqueStringArray([1, 20, 4, 10])\n  false\n  >>> uniqueStringArray([4, 1, 0, -10])\n  true\n  */\nconst uniqueArrayStringObject = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueArrayStringObject([1, 2, 4, 20])\n  true\n  >>> uniqueArrayStringObject([1, 20, 4, 10])\n  false\n  >>> uniqueArrayStringObject([4, 1, 0, -10])\n  true\n  */\nconst uniqueObjectStringObject = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueArrayStringObject([1, 2, 4, 20])\n  true\n  >>> uniqueArrayStringObject([1, 20, 4, 10])\n  false\n  >>> uniqueArrayStringObject([4, 1, 0, -10])\n  true\n  */\nconst uniqueArrayStringString = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueArrayStringString([1, 2, 4, 20])\n  true\n  >>> uniqueArrayStringString([1, 20, 4, 10])\n  false\n  >>> uniqueArrayStringString([4, 1, 0, -10])\n  true\n  */\nconst uniqueObjectStringString = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueArrayStringString([1, 2, 4, 20])\n  true\n  >>> uniqueArrayStringString([1, 20, 4, 10])\n  false\n  >>> uniqueArrayStringString([4, 1, 0, -10])\n  true\n  */\nconst uniqueArrayStringObjectString = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  Return true is list elements are unique.\n  >>> uniqueArrayStringObjectString([1, 2, 4, 20])\n  true\n  >>> uniqueArrayStringObjectString([1, 20, 4, 10])\n  false\n  >>> uniqueArrayStringObjectString([4, 1, 0, -10])\n  true\n  */\nconst uniqueObjectStringObjectString = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n  }\n  return res;\n};\n\n/**\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique coarse elements for two lists.\n  >>> coarse([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> coarse([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst coarse = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "coarse", "gc": "<|endoftext|>/*Return sorted unique coarse elements for two lists.\n  >>> coarse([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> coarse([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst coarse = (l1, l2) => {\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort((a, b) => a - b);\n  const l2 = l2.sort((a, b) => a - b);\n  const l1 = l1.filter(x => x!== null);\n  const l2 = l2.filter(x => x!== null);\n  const l1 = l1.sort", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> bigChoiceFactor(13195)\n  29\n  >>> bigChoiceFactor(2048)\n  2\n  */\nconst bigChoiceFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "bigChoiceFactor", "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> bigChoiceFactor(13195)\n  29\n  >>> bigChoiceFactor(2048)\n  2\n  */\nconst bigChoiceFactor = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    n /= factor;\n    factor++;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return true if n is a prime number.\n  >>> isPrime(13195)\n  True\n  >>> isPrime(2048)\n  False\n  */\nconst isPrime = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 3) {\n    return n % 2 === 0;\n  }\n  if (n <= 5) {\n    return n % 3 === 0;\n  }\n  if (n <= 7) {\n    return n % 5 === 0;\n  }\n  if (n <= 9) {\n    return n % 7 === 0;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if n is a prime number greater than 1.\n  >>> isPrimeGreaterThanOne(13195)\n  True\n  >>> isPrimeGreaterThanOne(2048)\n  False\n  */\nconst isPrimeGreaterThanOne = (n) => {\n  return isPrime(n) && n > 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number greater than or equal to 1.\n  >>> isPrimeGreaterThanOrEqualTo(13195)\n  True\n  >>> isPrimeGreaterThanOrEqualTo(2048)\n  False\n  */\nconst isPrimeGreaterThanOrEqualTo = (n) => {\n  return isPrime(n) && n >= 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number less than 1.\n  >>> isPrimeLessThanOne(13195)\n  True\n  >>> isPrimeLessThanOne(2048)\n  False\n  */\nconst isPrimeLessThanOne = (n) => {\n  return isPrime(n) && n < 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number less than or equal to 1.\n  >>> isPrimeLessThanOrEqualTo(13195)\n  True\n  >>> isPrimeLessThanOrEqualTo(2048)\n  False\n  */\nconst isPrimeLessThanOrEqualTo = (n) => {\n  return isPrime(n) && n <= 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number greater than or equal to n.\n  >>> isPrimeGreaterThanOrEqualTo(13195)\n  True\n  >>> isPrimeGreaterThanOrEqualTo(2048)\n  False\n  */\nconst isPrimeGreaterThanOrEqualTo = (n) => {\n  return isPrime(n) && n >= n;\n};\n\n/*\n  Given a number n, return true if n is a prime number less than n.\n  >>> isPrimeLessThanOrEqualTo(13195)\n  True\n  >>> isPrimeLessThanOrEqualTo(2048)\n  False\n  */\nconst isPrimeLessThanOrEqualTo = (n) => {\n  return isPrime(n) && n <= n;\n};\n\n/*\n  Given a number n, return true if n is a prime number greater than n.\n  >>> isPrimeGreaterThan(13195)\n  True\n  >>> isPrimeGreaterThan(2048)\n  False\n  */\nconst isPrimeGreaterThan = (n) => {\n  return isPrime(n) && n > 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number less than n.\n  >>> isPrimeLessThan(13195)\n  True\n  >>> isPrimeLessThan(2048)\n  False\n  */\nconst isPrimeLessThan = (n) => {\n  return isPrime(n) && n < 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number greater than n.\n  >>> isPrimeGreaterThanOrEqualTo(13195)\n  True\n  >>> isPrimeGreaterThanOrEqualTo(2048)\n  False\n  */\nconst isPrimeGreaterThanOrEqualTo = (n) => {\n  return isPrime(n) && n >= 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number less than n.\n  >>> isPrimeLessThanOrEqualTo(13195)\n  True\n  >>> isPrimeLessThanOrEqualTo(2048)\n  False\n  */\nconst isPrimeLessThanOrEqualTo = (n) => {\n  return isPrime(n) && n <= 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number greater than n.\n  >>> isPrimeGreaterThan(13195)\n  True\n  >>> isPrimeGreaterThan(2048)\n  False\n  */\nconst isPrimeGreaterThan = (n) => {\n  return isPrime(n) && n > 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number less than n.\n  >>> isPrimeLessThan(13195)\n  True\n  >>> isPrimeLessThan(2048)\n  False\n  */\nconst isPrimeLessThan = (n) => {\n  return isPrime(n) && n < 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number greater than n.\n  >>> isPrimeGreaterThanOrEqualTo(13195)\n  True\n  >>> isPrimeGreaterThanOrEqualTo(2048)\n  False\n  */\nconst isPrimeGreaterThanOrEqualTo = (n) => {\n  return isPrime(n) && n >= 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number less than n.\n  >>> isPrimeLessThanOrEqualTo(13195)\n  True\n  >>> isPrimeLessThanOrEqualTo(2048)\n  False\n  */\nconst isPrimeLessThanOrEqualTo = (n) => {\n  return isPrime(n) && n <= 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number greater than n.\n  >>> isPrimeGreaterThan(13195)\n  True\n  >>> isPrimeGreaterThan(2048)\n  False\n  */\nconst isPrimeGreaterThan = (n) => {\n  return isPrime(n) && n > 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number less than n.\n  >>> isPrimeLessThan(13195)\n  True\n  >>> isPrimeLessThan(2048)\n  False\n  */\nconst isPrimeLessThan = (n) => {\n  return isPrime(n) && n < 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number greater than n.\n  >>> isPrimeGreaterThanOrEqualTo(13195)\n  True\n  >>> isPrimeGreaterThanOrEqualTo(2048)\n  False\n  */\nconst isPrimeGreaterThanOrEqualTo = (n) => {\n  return isPrime(n) && n >= 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number less than n.\n  >>> isPrimeLessThanOrEqualTo(13195)\n  True\n  >>> isPrimeLessThanOrEqualTo(2048)\n  False\n  */\nconst isPrimeLessThanOrEqualTo = (n) => {\n  return isPrime(n) && n <= 1;\n};\n\n/*\n  Given a number n, return true if n is a prime number greater than n.\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_stack = [];\n  const paren_level = 0;\n  const paren_nesting = 0;\n  const paren_nesting_level = 0;\n  const paren_nesting_nesting = 0;\n  const paren_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n  const paren_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*summarizeToN is a function that sums numbers from 1 to n.\n  >>> summarizeToN(30)\n  465\n  >>> summarizeToN(100)\n  5050\n  >>> summarizeToN(5)\n  15\n  >>> summarizeToN(10)\n  55\n  >>> summarizeToN(1)\n  1\n  */\nconst summarizeToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "summarizeToN", "gc": "<|endoftext|>/*summarizeToN is a function that sums numbers from 1 to n.\n  >>> summarizeToN(30)\n  465\n  >>> summarizeToN(100)\n  5050\n  >>> summarizeToN(5)\n  15\n  >>> summarizeToN(10)\n  55\n  >>> summarizeToN(1)\n  1\n  */\nconst summarizeToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatNumber = (numbers) => {\n  let roundedNumbers = numbers.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedNumbers.map(number => {\n    return number.toString();\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatCurrency = (numbers) => {\n  let roundedNumbers = numbers.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedNumbers.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatPercent = (numbers) => {\n  let roundedNumbers = numbers.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedNumbers.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatTime = (time) => {\n  let roundedTime = time.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedTime.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatDateTime = (date) => {\n  let roundedDate = date.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedDate.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatDate = (date) => {\n  let roundedDate = date.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedDate.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatDateTimeShort = (date) => {\n  let roundedDate = date.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedDate.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatTimeShort = (time) => {\n  let roundedTime = time.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedTime.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatDateTimeMedium = (date) => {\n  let roundedDate = date.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedDate.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatDateMedium = (date) => {\n  let roundedDate = date.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedDate.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatTimeMedium = (time) => {\n  let roundedTime = time.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedTime.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatDateTimeLong = (date) => {\n  let roundedDate = date.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedDate.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatDateLong = (date) => {\n  let roundedDate = date.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedDate.map(number => {\n    return number.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  }).join(', ');\n  return roundedString;\n};\n\n/**\n * A function that takes an array of numbers and returns a string of the form \"$#,##0.00\".\n * Note that this function will round to the nearest number when there are multiples of thousands.\n */\nconst formatTimeLong = (time) => {\n  let roundedTime = time.map(number => {\n    return Math.round(number * 100) / 100;\n  });\n  let roundedString = roundedTime.map(number => {", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"(\")\n  false\n  >>> rightBracketing(\"()\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\")(()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "rightBracketing", "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"(\")\n  false\n  >>> rightBracketing(\"()\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\")(()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/[^()]+/g);\n  const closingBrackets = brackets.match(/[^)]+/g);\n  return openingBrackets.every(opening => closingBrackets.every(closing => opening === closing));\n};\n\n/**\n * Returns true if a character is a valid unicode character (i.e. not a\n * control character).\n *\n * See http://unicode.org/reports/tr15/\n *\n * Note: This does not check for control characters, only non-control characters.\n */\nconst isValidUnicodeCharacter = character => {\n  return /[\\u0080-\\uFFFF]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequence = character => {\n  return /[\\u0000-\\u001f]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrWhitespace = character => {\n  return isValidUnicodeEscapeSequence(character) || /\\s/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewline = character => {\n  return isValidUnicodeEscapeSequence(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespace = character => {\n  return isValidUnicodeEscapeSequenceOrWhitespace(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewline = character => {\n  return isValidUnicodeEscapeSequenceOrWhitespaceOrNewline(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespace = character => {\n  return isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrWhitespace(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = character => {\n  return isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespace(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = character => {\n  return isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = character => {\n  return isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = character => {\n  return isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = character => {\n  return isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = character => {\n  return isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = character => {\n  return isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = character => {\n  return isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace(character) || /[\\u000a\\u000d\\u2028\\u2029]/.test(character);\n};\n\n/**\n * Returns true if a character is a valid unicode escape sequence.\n *\n * See http://unicode.org/reports/tr15/#escape-sequences\n */\nconst isValidUnicodeEscapeSequenceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = character => {\n  return isValid", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const n = xs.length\n  let d = 1\n  for (let i = 0; i < n - 1; i++) {\n    d *= xs[i]\n  }\n  return [d, xs[n]]\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the squared errors\n// between the point p and q.\nconst minimize = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += xs[i] * p[i]\n  }\n  return q - sum * sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsolute = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] * p[i])\n  }\n  return q - sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsoluteError = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] - p[i])\n  }\n  return q - sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsoluteErrorAbsolute = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i])\n  }\n  return q - sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsoluteErrorAbsoluteError = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i])\n  }\n  return q - sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsoluteErrorAbsoluteErrorAbsolute = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i])\n  }\n  return q - sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsoluteErrorAbsoluteErrorAbsoluteError = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i])\n  }\n  return q - sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsolute = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i])\n  }\n  return q - sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsoluteError = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i])\n  }\n  return q - sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsoluteError = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i])\n  }\n  return q - sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsoluteError = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i])\n  }\n  return q - sum / n\n}\n\n// Given a polynomial of degree n and coefficients xs and a point p, return the\n// point q of the polynomial that minimizes the sum of the absolute errors\n// between the point p and q.\nconst minimizeAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsoluteErrorAbsolute = (xs, p, q) => {\n  const n = xs.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q[i]) + Math.abs(xs[i] - p[i]) + Math.abs(xs[i] - q", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is less than or equal to n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibLessThan = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is greater than n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibGreaterThan = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is equal to n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is greater than or equal to n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibGreaterThanOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is equal to n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibEqualOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is less than n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibLessThanOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is greater than n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibGreaterThanOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is equal to n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibEqualOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is less than or equal to n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibLessThanOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is greater than n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibGreaterThanOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is equal to n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibEqualOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is less than or equal to n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibLessThanOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is greater than n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibGreaterThanOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci number in the Fibonacci sequence whose nth term is equal to n.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibEqualOrEqual = (n) => {\n  if (n <= 1) return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the nth Fibonacci ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelReckon which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelReckon(\"abcde\")\n  2\n  >>> vowelReckon(\"ACEDY\")\n  3\n  */\nconst vowelReckon = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelReckon", "gc": "<|endoftext|>/*Write a function vowelReckon which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelReckon(\"abcde\")\n  2\n  >>> vowelReckon(\"ACEDY\")\n  3\n  */\nconst vowelReckon = (s) => {\n  let vowels = 0;\n  let vowelsEnd = 0;\n  let vowelsStart = 0;\n  let vowelsEndStart = 0;\n  let vowelsEndEnd = 0;\n  let vowelsStartEnd = 0;\n  let vowelsEndStartEnd = 0;\n  let vowelsEndEndEnd = 0;\n  let vowelsStartEndEnd = 0;\n  let vowelsEndEndEnd = 0;\n  let vowelsStartEndEndEnd = 0;\n  let vowelsEndEndEndEnd = 0;\n  let vowelsStartEndEndEnd = 0;\n  let vowelsEndEndEndEnd = 0;\n  let vowelsStartEndEndEnd = 0;\n  let vowelsEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> roundShift(12, 1)\n  \"21\"\n  >>> roundShift(12, 2)\n  \"12\"\n  */\nconst roundShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "roundShift", "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> roundShift(12, 1)\n  \"21\"\n  >>> roundShift(12, 2)\n  \"12\"\n  */\nconst roundShift = (x, shift) => {\n  let digits = x.toString(2).split('');\n  let reversed = digits.reverse();\n  digits = reversed.slice(0).reverse().join('');\n  return digits.slice(0, shift) + digits.slice(shift, digits.length);\n};\n\n/*\n  Convert a number to a string in base 2.\n  >>> toBase(2)\n  \"2\"\n  >>> toBase(16)\n  \"1010\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"100\"\n  >>> toBase(16)\n  \"1000\"\n  >>> toBase(-16)\n  \"-1000\"\n  >>> toBase(8)\n  \"", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "fingerSum", "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSum = (s) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSumLower = (s) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumLower(\"\") => 0\n      fingerSumLower(\"abAB\") => 131\n      fingerSumLower(\"abcCd\") => 67\n      fingerSumLower(\"helloE\") => 69\n      fingerSumLower(\"woArBld\") => 131\n      fingerSumLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumLower = (s) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumUpper(\"\") => 0\n      fingerSumUpper(\"abAB\") => 131\n      fingerSumUpper(\"abcCd\") => 67\n      fingerSumUpper(\"helloE\") => 69\n      fingerSumUpper(\"woArBld\") => 131\n      fingerSumUpper(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpper = (s) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumLower(\"\") => 0\n      fingerSumLower(\"abAB\") => 131\n      fingerSumLower(\"abcCd\") => 67\n      fingerSumLower(\"helloE\") => 69\n      fingerSumLower(\"woArBld\") => 131\n      fingerSumLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperLower = (s) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumUpperLower(\"\") => 0\n      fingerSumUpperLower(\"abAB\") => 131\n      fingerSumUpperLower(\"abcCd\") => 67\n      fingerSumUpperLower(\"helloE\") => 69\n      fingerSumUpperLower(\"woArBld\") => 131\n      fingerSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperLower = (s) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumLower(\"\") => 0\n      fingerSumLower(\"abAB\") => 131\n      fingerSumLower(\"abcCd\") => 67\n      fingerSumLower(\"helloE\") => 69\n      fingerSumLower(\"woArBld\") => 131\n      fingerSumLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperUpperLower = (s) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumUpperUpperLower(\"\") => 0\n      fingerSumUpperUpperLower(\"abAB\") => 131\n      fingerSumUpperUpperLower(\"abcCd\") => 67\n      fingerSumUpperUpperLower(\"helloE\") => 69\n      fingerSumUpperUpperLower(\"woArBld\") => 131\n      fingerSumUpperUpperLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperUpperLower = (s) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumLower(\"\") => 0\n      fingerSumLower(\"abAB\") => 131\n      fingerSumLower(\"abcCd\") => 67\n      fingerSumLower(\"helloE\") => 69\n      fingerSumLower(\"woArBld\") => 131\n      fingerSumLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumLower = (s) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumUpperUpperLower(\"\") => 0\n      fingerSumUpperUpperLower(\"abAB\") => 131\n      fingerSumUpperUpperLower(\"abcCd\") => 67\n      fingerSumUpperUpperLower(\"helloE\") => 69\n      fingerSumUpperUpperLower(\"woArBld\") => 131\n      fingerSumUpperUpperLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperUpperLower = (s) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumUpperLower(\"\") => 0\n      fingerSumUpperLower(\"abAB\") => 131\n      fingerSumUpperLower(\"abcCd\") => 67\n      fingerSumUpperLower(\"helloE\") => 69\n      fingerSumUpperLower(\"woArBld\") => 131\n      fingerSumUpperLower(\"aAaaaXa\") => 153\n  */", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "yieldDistribution", "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(' ');\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes('apple')) {\n      apples++;\n    } else if (fruits[i].includes('orange')) {\n      oranges++;\n    } else if (fruits[i].includes('mango')) {\n      mango++;\n    }\n  }\n  total = apples\n    + oranges\n    + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(' ');\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes('apple')) {\n      apples++;\n    } else if (fruits[i].includes('orange')) {\n      oranges++;\n    } else if (fruits[i].includes('mango')) {\n      mango++;\n    }\n  }\n  total = apples\n    + oranges\n    + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(' ');\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes('apple')) {\n      apples++;\n    } else if (fruits[i].includes('orange')) {\n      oranges++;\n    } else if (fruits[i].includes('mango')) {\n      mango++;\n    }\n  }\n  total = apples\n    + oranges\n    + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(' ');\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes('apple')) {\n      apples++;\n    } else if (fruits[i].includes('orange')) {\n      oranges++;\n    } else if (fruits[i].includes('mango')) {\n      mango++;\n    }\n  }\n  total = apples\n    + oranges\n    + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(' ');\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes('apple')) {\n      apples++;\n    } else if (fruits[i].includes('orange')) {\n      oranges++;\n    } else if (fruits[i].includes('mango')) {\n      mango++;\n    }\n  }\n  total = apples\n    + oranges\n    + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(' ');\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes('apple')) {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to hustle one of the nodes and return it.\n  The hustleed node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The hustleed node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst hustle = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "hustle", "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to hustle one of the nodes and return it.\n  The hustleed node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The hustleed node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst hustle = (arr) => {\n  const len = arr.length;\n  const evens = arr.filter(n => n % 2 === 0);\n  let min = 0;\n  let max = 0;\n  let minIndex = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < len; i++) {\n    if (evens[i]!== 0) {\n      min = Math.min(min, arr[i]);\n      max = Math.max(max, arr[i]);\n      minIndex = i;\n      maxIndex = i;\n    }\n  }\n  return [min, minIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the minimum number of nodes that would make the\n// tree balanced.\n// The minimum number of nodes that would make the tree balanced is\n// the minimum number of nodes that would make the tree balanced if the\n// tree were balanced using an algorithm that balances the tree in\n// such a way that each node has exactly one child.\n// If there are multiple nodes with the same minimum number of children,\n// return the node that has smallest index.\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: 1\n//     Explanation: 2 has the smallest even value, and 1 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: 1\n//     Explanation: 2 has the smallest even value, and 1 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: -1\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: -1\n// Explanation: 5 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: 3 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: 4 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: 2 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: 1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n//              so we will choose the first zero, which has the smallest index.\n// Explanation: -1 is the smallest value, but there are two zeros,\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      research([4, 1, 2, 2, 3, 1])) == 2\n      research([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      research([5, 5, 4, 4, 4])) == -1\n  */\nconst research = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "research", "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      research([4, 1, 2, 2, 3, 1])) == 2\n      research([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      research([5, 5, 4, 4, 4])) == -1\n  */\nconst research = (lst) => {\n  let max = 0;\n  let freq = 0;\n  lst.forEach((num) => {\n    if (num > max) {\n      max = num;\n      freq = num;\n    }\n  });\n  return max;\n};\n\nmodule.exports = research;\n\n},{}],4:[function(require,module,exports){\n/*\n  You are given an integer array nums and an integer k. Return the number of ways to arrange the integers such that nums[i] + nums[j] + nums[k] <= k.\n  You may assume that each input would have exactly one solution.\n  Example:\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      k = 3\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, 6, 2, 5, 7, 4, 8]\n      nums = [1, 3, ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'e')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'f')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'g')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'h')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'i')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'j')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'k')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'l')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'],'m')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'n')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'o')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'p')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'q')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'r')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'],'s')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 't')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'u')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'v')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'w')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'x')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'y')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'z')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'A')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'B')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'C')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'D')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'E')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'F')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'G')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'H')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'I')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'J')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'K')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'L')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'M')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'N')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'O')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'P')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'Q')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'R')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'S')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'T')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'U')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'V')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'W')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'X')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'Y')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'Z')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'e')\n  ['array', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'f')\n  ['array', 'cde", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  foreignSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  foreignSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  foreignSortList([]) == []\n  */\nconst foreignSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "foreignSortList", "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  foreignSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  foreignSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  foreignSortList([]) == []\n  */\nconst foreignSortList = (lst) => {\n  let sorted = lst.sort((a, b) => a - b);\n  let res = [];\n  let min = sorted[0];\n  let max = sorted[0];\n  for (let i = 1; i < sorted.length; i++) {\n    if (sorted[i] < min) {\n      min = sorted[i];\n    }\n    if (sorted[i] > max) {\n      max = sorted[i];\n    }\n    res.push(sorted[i]);\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortList = (lst) => {\n  let sorted = lst.sort((a, b) => a - b);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverseReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverseReverseReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverseReverseReverseReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangulumArea(3, 4, 5) == 6.00\n  triangulumArea(1, 2, 10) == -1\n  */\nconst triangulumArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangulumArea", "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangulumArea(3, 4, 5) == 6.00\n  triangulumArea(1, 2, 10) == -1\n  */\nconst triangulumArea = (a, b, c) => {\n  let sum = 0;\n  let sum2 = 0;\n  let sum3 = 0;\n  let area = 0;\n  if (a > b) {\n    sum = a + b;\n    sum2 = a + b;\n    sum3 = a + b;\n    area = sum;\n  } else if (a > c) {\n    sum = a + c;\n    sum2 = a + c;\n    sum3 = a + c;\n    area = sum;\n  } else if (b > c) {\n    sum = a + c;\n    sum2 = a + c;\n    sum3 = a + c;\n    area = sum;\n  }\n  return area / Math.sqrt(sum2 * sum3 + sum2 * sum2 + sum3 * sum3);\n};\n\nconst getTriangleArea = (triangle) => {\n  let area = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    area = sideA * sideB * sideC;\n  } else if (sideB > sideA && sideB > sideC) {\n    area = sideB * sideA * sideC;\n  } else if (sideC > sideA && sideC > sideB) {\n    area = sideC * sideA * sideB;\n  }\n  return area;\n};\n\nconst getTrianglePerimeter = (triangle) => {\n  let perimeter = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    perimeter = sideA * sideB;\n  } else if (sideB > sideA && sideB > sideC) {\n    perimeter = sideB * sideA;\n  } else if (sideC > sideA && sideC > sideB) {\n    perimeter = sideC * sideA;\n  }\n  return perimeter;\n};\n\nconst getTrianglePerimeter2 = (triangle) => {\n  let perimeter = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    perimeter = sideA * sideB;\n  } else if (sideB > sideA && sideB > sideC) {\n    perimeter = sideB * sideA;\n  } else if (sideC > sideA && sideC > sideB) {\n    perimeter = sideC * sideA;\n  }\n  return perimeter;\n};\n\nconst getTrianglePerimeter3 = (triangle) => {\n  let perimeter = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    perimeter = sideA * sideB;\n  } else if (sideB > sideA && sideB > sideC) {\n    perimeter = sideB * sideA;\n  } else if (sideC > sideA && sideC > sideB) {\n    perimeter = sideC * sideA;\n  }\n  return perimeter;\n};\n\nconst getTrianglePerimeter4 = (triangle) => {\n  let perimeter = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    perimeter = sideA * sideB;\n  } else if (sideB > sideA && sideB > sideC) {\n    perimeter = sideB * sideA;\n  } else if (sideC > sideA && sideC > sideB) {\n    perimeter = sideC * sideA;\n  }\n  return perimeter;\n};\n\nconst getTrianglePerimeter5 = (triangle) => {\n  let perimeter = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    perimeter = sideA * sideB;\n  } else if (sideB > sideA && sideB > sideC) {\n    perimeter = sideB * sideA;\n  } else if (sideC > sideA && sideC > sideB) {\n    perimeter = sideC * sideA;\n  }\n  return perimeter;\n};\n\nconst getTrianglePerimeter6 = (triangle) => {\n  let perimeter = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    perimeter = sideA * sideB;\n  } else if (sideB > sideA && sideB > sideC) {\n    perimeter = sideB * sideA;\n  } else if (sideC > sideA && sideC > sideB) {\n    perimeter = sideC * sideA;\n  }\n  return perimeter;\n};\n\nconst getTrianglePerimeter7 = (triangle) => {\n  let perimeter = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    perimeter = sideA * sideB;\n  } else if (sideB > sideA && sideB > sideC) {\n    perimeter = sideB * sideA;\n  } else if (sideC > sideA && sideC > sideB) {\n    perimeter = sideC * sideA;\n  }\n  return perimeter;\n};\n\nconst getTrianglePerimeter8 = (triangle) => {\n  let perimeter = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    perimeter = sideA * sideB;\n  } else if (sideB > sideA && sideB > sideC) {\n    perimeter = sideB * sideA;\n  } else if (sideC > sideA && sideC > sideB) {\n    perimeter = sideC * sideA;\n  }\n  return perimeter;\n};\n\nconst getTrianglePerimeter9 = (triangle) => {\n  let perimeter = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    perimeter = sideA * sideB;\n  } else if (sideB > sideA && sideB > sideC) {\n    perimeter = sideB * sideA;\n  } else if (sideC > sideA && sideC > sideB) {\n    perimeter = sideC * sideA;\n  }\n  return perimeter;\n};\n\nconst getTrianglePerimeter10 = (triangle) => {\n  let perimeter = 0;\n  let sideA = triangle.sides[0];\n  let sideB = triangle.sides[1];\n  let sideC = triangle.sides[2];\n  if (sideA > sideB && sideA > sideC) {\n    perimeter = sideA * sideB;\n  } else if (sideB > sideA && sideB > sideC) {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFlee", "gc": "<|endoftext|>/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const sumWeight = q.map(v => v.reduce((a, b) => a + b, 0));\n  return sumWeight <= maxWeight && sumWeight <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ true\n  # 1+2 is greater than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ true\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ false\n  # 3+2+3 is greater than the maximum possible weight, and it's unbalanced.\n\n  willItFlee([3], 5) ➞ false\n  # 3 is greater than the maximum possible weight, and it's unbalanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const sumWeight = q.map(v => v.reduce((a, b) => a + b, 0));\n  return sumWeight > maxWeight && sumWeight > w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is greater than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is greater than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is greater than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const sumWeight = q.map(v => v.reduce((a, b) => a + b, 0));\n  return sumWeight >= maxWeight && sumWeight >= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ true\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ true\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ false\n  # 3+2+3 is less than the maximum possible weight, and it's unbalanced.\n\n  willItFlee([3], 5) ➞ false\n  # 3 is less than the maximum possible weight, and it's unbalanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const sumWeight = q.map(v => v.reduce((a, b) => a + b, 0));\n  return sumWeight <= maxWeight && sumWeight <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is greater than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is greater than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is greater than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const sumWeight = q.map(v => v.reduce((a, b) => a + b, 0));\n  return sumWeight >= maxWeight && sumWeight >= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const sumWeight = q.map(v => v.reduce((a, b) => a + b, 0));\n  return sumWeight <= maxWeight && sumWeight <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ true\n  # 1+2 is greater than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ true\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ false\n  # 3+2+3 is greater than the maximum possible weight, and it's unbalanced.\n\n  will", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallChange", "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let len = arr.length;\n  let min = len / 2;\n  let count = 0;\n  let i = min;\n  while (len > 0) {\n    if (arr[len - 1] === arr[len]) {\n      len--;\n      count++;\n    } else {\n      len--;\n      count--;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  bigChange([1,2,3,5,4,7,9,6]) == 6\n  bigChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  bigChange([1, 2, 3, 2, 1]) == 4\n  */\nconst bigChange = (arr) => {\n  let len = arr.length;\n  let max = len / 2;\n  let count = 0;\n  let i = max;\n  while (len > 0) {\n    if (arr[len - 1] === arr[len]) {\n      len--;\n      count++;\n    } else {\n      len--;\n      count--;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let len = arr.length;\n  let min = len / 2;\n  let count = 0;\n  let i = min;\n  while (len > 0) {\n    if (arr[len - 1] === arr[len]) {\n      len--;\n      count++;\n    } else {\n      len--;\n      count--;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  bigChange([1,2,3,5,4,7,9,6]) == 6\n  bigChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  bigChange([1, 2, 3, 2, 1]) == 4\n  */\nconst bigChange = (arr) => {\n  let len = arr.length;\n  let max = len / 2;\n  let count = 0;\n  let i = max;\n  while (len > 0) {\n    if (arr[len - 1] === arr[len]) {\n      len--;\n      count++;\n    } else {\n      len--;\n      count--;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let len = arr.length;\n  let min = len / 2;\n  let count = 0;\n  let i = min;\n  while (len > 0) {\n    if (arr[len - 1] === arr[len]) {\n      len--;\n      count++;\n    } else {\n      len--;\n      count--;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  bigChange([1,2,3,5,4,7,9,6]) == 6\n  bigChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  bigChange([1, 2, 3, 2, 1]) == 4\n  */\nconst bigChange = (arr) => {\n  let len = arr.length;\n  let max = len / 2;\n  let count = 0;\n  let i = max;\n  while (len > 0) {\n    if (arr[len - 1] === arr[len]) {\n      len--;\n      count++;\n    } else {\n      len--;\n      count--;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let len = arr.length;\n  let min = len / 2;\n  let count = 0;\n  let i = min;\n  while (len > 0) {\n    if (arr[len - 1] === arr[len]) {\n      len--;\n      count++;\n    } else {\n      len--;\n      count--;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  bigChange([1,2,3,5,4,7,9,6]) == 6\n  bigChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  bigChange([1, 2, 3, 2, 1]) == 4\n  */\nconst bigChange = (arr) => {\n  let len = arr.length;\n  let max = len / 2;\n  let count = 0;\n  let i = max;\n  while (len > 0) {\n    if (arr[len - 1] === arr[len]) {\n      len--;\n      count++;\n    } else {\n      len--;\n      count--;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let len = arr.length;\n  let min = len / 2;\n  let count = 0;\n  let i = min;\n  while (len > 0) {\n    if (arr[len - 1] === arr[len]) {\n      len--;\n      count++;\n    } else {\n      len--;\n      count--;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  bigChange([1,2,3,5,4,7,9,6]) == 6\n  bigChange([1, 2, 3, 4, 3, 2, 2]", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "entireCatch", "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const lst3 = [...set1,...set2];\n  return lst3.filter(item => item.length < lst2.length);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const lst3 = [...set1,...set2];\n  return lst3.filter(item => item.length > lst2.length);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const lst3 = [...set1,...set2];\n  return lst3.filter(item => item.length === lst2.length);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list greater than or equal the\n  other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const lst3 = [...set1,...set2];\n  return lst3.filter(item => item.length > lst2.length);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list equal or less than the\n  other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const lst3 = [...set1,...set2];\n  return lst3.filter(item => item.length === lst2.length);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list equal or greater than the\n  other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const lst3 = [...set1,...set2];\n  return lst3.filter(item => item.length > lst2.length);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const lst3 = [...set1,...set2];\n  return lst3.filter(item => item.length!== lst2.length);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all string", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "gc": "<|endoftext|>/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryWorldPower(1, 4) => true\n  isElementaryWorldPower(2, 2) => true\n  isElementaryWorldPower(8, 2) => true\n  isElementaryWorldPower(3, 2) => false\n  isElementaryWorldPower(3, 1) => false\n  isElementaryWorldPower(5, 3) => false\n  */\nconst isElementaryWorldPower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isElementaryWorldPower", "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryWorldPower(1, 4) => true\n  isElementaryWorldPower(2, 2) => true\n  isElementaryWorldPower(8, 2) => true\n  isElementaryWorldPower(3, 2) => false\n  isElementaryWorldPower(3, 1) => false\n  isElementaryWorldPower(5, 3) => false\n  */\nconst isElementaryWorldPower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return isElementaryWorldPower(x, n / 2);\n  return isElementaryWorldPower(x, n / 2 + 1);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryWorldPower(1, 4) => true\n  isElementaryWorldPower(2, 2) => true\n  isElementaryWorldPower(8, 2) => true\n  isElementaryWorldPower(3, 2) => false\n  isElementaryWorldPower(3, 1) => false\n  isElementaryWorldPower(5, 3) => false\n  */\nconst isElementarySquarePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return isElementarySquarePower(x, n / 2);\n  return isElementarySquarePower(x, n / 2 + 1);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementarySquarePower(1, 4) => true\n  isElementarySquarePower(2, 2) => true\n  isElementarySquarePower(8, 2) => true\n  isElementarySquarePower(3, 2) => false\n  isElementarySquarePower(3, 1) => false\n  isElementarySquarePower(5, 3) => false\n  */\nconst isElementaryCubePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return isElementaryCubePower(x, n / 2);\n  return isElementaryCubePower(x, n / 2 + 1);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryCubePower(1, 4) => true\n  isElementaryCubePower(2, 2) => true\n  isElementaryCubePower(8, 2) => true\n  isElementaryCubePower(3, 2) => false\n  isElementaryCubePower(3, 1) => false\n  isElementaryCubePower(5, 3) => false\n  */\nconst isElementaryHexaPower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return isElementaryHexaPower(x, n / 2);\n  return isElementaryHexaPower(x, n / 2 + 1);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryHexaPower(1, 4) => true\n  isElementaryHexaPower(2, 2) => true\n  isElementaryHexaPower(8, 2) => true\n  isElementaryHexaPower(3, 2) => false\n  isElementaryHexaPower(3, 1) => false\n  isElementaryHexaPower(5, 3) => false\n  */\nconst isElementaryOctaPower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return isElementaryOctaPower(x, n / 2);\n  return isElementaryOctaPower(x, n / 2 + 1);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryOctaPower(1, 4) => true\n  isElementaryOctaPower(2, 2) => true\n  isElementaryOctaPower(8, 2) => true\n  isElementaryOctaPower(3, 2) => false\n  isElementaryOctaPower(3, 1) => false\n  isElementaryOctaPower(5, 3) => false\n  */\nconst isElementaryPiPower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return isElementaryPiPower(x, n / 2);\n  return isElementaryPiPower(x, n / 2 + 1);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPiPower(1, 4) => true\n  isElementaryPiPower(2, 2) => true\n  isElementaryPiPower(8, 2) => true\n  isElementaryPiPower(3, 2) => false\n  isElementaryPiPower(3, 1) => false\n  isElementaryPiPower(5, 3) => false\n  */\nconst isElementaryEPower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return isElementaryEPower(x, n / 2);\n  return isElementaryEPower(x, n / 2 + 1);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryEPower(1, 4) => true\n  isElementaryEPower(2, 2) => true\n  isElementaryEPower(8, 2) => true\n  isElementaryEPower(3, 2) => false\n  isElementaryEPower(3, 1) => false\n  isElementaryEPower(5, 3) => false\n  */\nconst isElementaryCoPower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return isElementaryCoPower(x, n / 2);\n  return isElementaryCoPower(x, n / 2 + 1);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryCoPower(1, 4) => true\n  isElementaryCoPower(2, 2) => true\n  isElementaryCoPower(8, 2) => true\n  isElementaryCoPower(3, 2) => false\n  isElementaryCoPower(3, 1) => false\n  isElementaryCoPower(5, 3) => false\n  */\nconst isElementarySePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 1) return true;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 1 === 0) return false;\n  if (a % 2 === 0) return true;\n  if (a % 3 === 0) return false;\n  return iscube(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a prime number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isprime(1) ==> true\n  isprime(2) ==> false\n  isprime(3) ==> true\n  isprime(4) ==> false\n  isprime(5) ==> true\n  isprime(6) ==> false\n  isprime(7) ==> true\n  isprime(8) ==> false\n  isprime(9) ==> true\n  isprime(10) ==> false\n  isprime(11) ==> true\n  isprime(12) ==> false\n  isprime(13) ==> true\n  isprime(14) ==> false\n  isprime(15) ==> true\n  isprime(16) ==> false\n  isprime(17) ==> true\n  isprime(18) ==> false\n  isprime(19) ==> true\n  isprime(20) ==> false\n  isprime(21) ==> true\n  isprime(22) ==> false\n  isprime(23) ==> true\n  isprime(24) ==> false\n  isprime(25) ==> true\n  isprime(26) ==> false\n  isprime(27) ==> true\n  isprime(28) ==> false\n  isprime(29) ==> true\n  isprime(30) ==> false\n  isprime(31) ==> true\n  isprime(32) ==> false\n  isprime(33) ==> true\n  isprime(34) ==> false\n  isprime(35) ==> true\n  isprime(36) ==> false\n  isprime(37) ==> true\n  isprime(38) ==> false\n  isprime(39) ==> true\n  isprime(40) ==> false\n  isprime(41) ==> true\n  isprime(42) ==> false\n  isprime(43) ==> true\n  isprime(44) ==> false\n  isprime(45) ==> true\n  isprime(46) ==> false\n  isprime(47) ==> true\n  isprime(48) ==> false\n  isprime(49) ==> true\n  isprime(50) ==> false\n  isprime(51) ==> true\n  isprime(52) ==> false\n  isprime(53) ==> true\n  isprime(54) ==> false\n  isprime(55) ==> true\n  isprime(56) ==> false\n  isprime(57) ==> true\n  isprime(58) ==> false\n  isprime(59) ==> true\n  isprime(60) ==> false\n  isprime(61) ==> true\n  isprime(62) ==> false\n  isprime(63) ==> true\n  isprime(64) ==> false\n  isprime(65) ==> true\n  isprime(66) ==> false\n  isprime(67) ==> true\n  isprime(68) ==> false\n  isprime(69) ==> true\n  isprime(70) ==> false\n  isprime(71) ==> true\n  isprime(72) ==> false\n  isprime(73) ==> true\n  isprime(74) ==> false\n  isprime(75) ==> true\n  isprime(76) ==> false\n  isprime(77) ==> true\n  isprime(78) ==> false\n  isprime(79) ==> true\n  isprime(80) ==> false\n  isprime(81) ==> true\n  isprime(82) ==> false\n  isprime(83) ==> true\n  isprime(84) ==> false\n  isprime(85) ==> true\n  isprime(86) ==> false\n  isprime(87) ==> true\n  isprime(88) ==> false\n  isprime(89) ==> true\n  isprime(90) ==> false\n  isprime(91) ==> true\n  isprime(92) ==> false\n  isprime(93) ==> true\n  isprime(94) ==> false\n  isprime(95) ==> true\n  isprime(96) ==> false\n  isprime(97) ==> true\n  isprime(98) ==> false\n  isprime(99) ==> true\n  isprime(100) ==> false\n  isprime(101) ==> true\n  isprime(102) ==> false\n  isprime(103) ==> true\n  isprime(104) ==> false\n  isprime(105) ==> true\n  isprime(106) ==> false\n  isprime(107) ==> true\n  isprime(108) ==> false\n  isprime(109) ==> true\n  isprime(110) ==> false\n  isprime(111) ==> true\n  isprime(112) ==> false\n  isprime(113) ==> true\n  isprime(114) ==> false\n  isprime(115) ==> true\n  isprime(116) ==> false\n  isprime(117) ==> true\n  isprime(118) ==> false\n  isprime(119) ==> true\n  isprime(120) ==> false\n  isprime(121) ==> true\n  isprime(122) ==> false\n  isprime(123) ==> true\n  isprime(124) ==> false\n  isprime(125) ==> true\n  isprime(126) ==> false\n  isprime(127) ==> true\n  isprime(128) ==> false\n  isprime(129) ==> true\n  isprime(130) ==> false\n  isprime(131) ==> true\n  isprime(132) ==> false\n  isprime(133) ==> true\n  isprime(134) ==> false\n  isprime(135) ==> true\n  isprime(136) ==> false\n  isprime(137) ==> true\n  isprime(138) ==> false\n  isprime(139) ==> true\n  isprime(140) ==> false\n  isprime(141) ==> true\n  isprime(142) ==> false\n  isprime(143) ==> true\n  isprime(144) ==> false\n  isprime(145) ==> true\n  isprime(146) ==> false\n  isprime(147) ==> true\n  isprime(148) ==> false\n  isprime(149) ==> true\n  isprime(150) ==> false\n  isprime(151) ==> true\n  isprime(152) ==> ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  const numStr = new String(num);\n  const numArr = numStr.split('');\n  const numArrLength = numArr.length;\n  let count = 0;\n  for (let i = 0; i < numArrLength; i++) {\n    if (numArr[i] === '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts\n  the number of characters that are divisible by 3 or 5 or 7 or 9 or 11 or 13 or 15 or 17 or 19 or 21\n  or 23. Characters are A===B===C===D===E===F===G===H===I===J===K===L===M===N===O===P===Q===R===S===T===U===V===W===X===Y===Z.\n  Characters are uppercase.\n  Examples:\n  For num = \"ABCD\" the output should be 3.\n  For num = \"ABCD\" the output should be 4.\n  For num = \"ABCD\" the output should be 5.\n  For num = \"ABCD\" the output should be 6.\n  For num = \"ABCD\" the output should be 7.\n  For num = \"ABCD\" the output should be 8.\n  For num = \"ABCD\" the output should be 9.\n  For num = \"ABCD\" the output should be 10.\n  For num = \"ABCD\" the output should be 11.\n  For num = \"ABCD\" the output should be 12.\n  For num = \"ABCD\" the output should be 13.\n  For num = \"ABCD\" the output should be 14.\n  For num = \"ABCD\" the output should be 15.\n  For num = \"ABCD\" the output should be 16.\n  For num = \"ABCD\" the output should be 17.\n  For num = \"ABCD\" the output should be 18.\n  For num = \"ABCD\" the output should be 19.\n  For num = \"ABCD\" the output should be 20.\n  For num = \"ABCD\" the output should be 21.\n  For num = \"ABCD\" the output should be 22.\n  For num = \"ABCD\" the output should be 23.\n  For num = \"ABCD\" the output should be 24.\n  For num = \"ABCD\" the output should be 25.\n  For num = \"ABCD\" the output should be 26.\n  For num = \"ABCD\" the output should be 27.\n  For num = \"ABCD\" the output should be 28.\n  For num = \"ABCD\" the output should be 29.\n  For num = \"ABCD\" the output should be 30.\n  For num = \"ABCD\" the output should be 31.\n  For num = \"ABCD\" the output should be 32.\n  For num = \"ABCD\" the output should be 33.\n  For num = \"ABCD\" the output should be 34.\n  For num = \"ABCD\" the output should be 35.\n  For num = \"ABCD\" the output should be 36.\n  For num = \"ABCD\" the output should be 37.\n  For num = \"ABCD\" the output should be 38.\n  For num = \"ABCD\" the output should be 39.\n  For num = \"ABCD\" the output should be 40.\n  For num = \"ABCD\" the output should be 41.\n  For num = \"ABCD\" the output should be 42.\n  For num = \"ABCD\" the output should be 43.\n  For num = \"ABCD\" the output should be 44.\n  For num = \"ABCD\" the output should be 45.\n  For num = \"ABCD\" the output should be 46.\n  For num = \"ABCD\" the output should be 47.\n  For num = \"ABCD\" the output should be 48.\n  For num = \"ABCD\" the output should be 49.\n  For num = \"ABCD\" the output should be 50.\n  For num = \"ABCD\" the output should be 51.\n  For num = \"ABCD\" the output should be 52.\n  For num = \"ABCD\" the output should be 53.\n  For num = \"ABCD\" the output should be 54.\n  For num = \"ABCD\" the output should be 55.\n  For num = \"ABCD\" the output should be 56.\n  For num = \"ABCD\" the output should be 57.\n  For num = \"ABCD\" the output should be 58.\n  For num = \"ABCD\" the output should be 59.\n  For num = \"ABCD\" the output should be 60.\n  For num = \"ABCD\" the output should be 61.\n  For num = \"ABCD\" the output should be 62.\n  For num = \"ABCD\" the output should be 63.\n  For num = \"ABCD\" the output should be 64.\n  For num = \"ABCD\" the output should be 65.\n  For num = \"ABCD\" the output should be 66.\n  For num = \"ABCD\" the output should be 67.\n  For num = \"ABCD\" the output should be 68.\n  For num = \"ABCD\" the output should be 69.\n  For num = \"ABCD\" the output should be 70.\n  For num = \"ABCD\" the output should be 71.\n  For num = \"ABCD\" the output should be 72.\n  For num = \"ABCD\" the output should be 73.\n  For num = \"ABCD\" the output should be 74.\n  For num = \"ABCD\" the output should be 75.\n  For num = \"ABCD\" the output should be 76.\n  For num = \"ABCD\" the output should be 77.\n  For num = \"ABCD\" the output should be 78.\n  For num = \"ABCD\" the output should be 79.\n  For num = \"ABCD\" the output should be 80.\n  For num = \"ABCD\" the output should be 81.\n  For num = \"ABCD\" the output should be 82.\n  For num = \"ABCD\" the output should be 83.\n  For num = \"ABCD\" the output should be 84.\n  For num = \"ABCD\" the output should be 85.\n  For num = \"ABCD\" the output should be 86.\n  For num = \"ABCD\" the output should be 87.\n  For num = \"ABCD\" the output should be 88.\n  For num = \"ABCD\" the output should be 89.\n  For num = \"ABCD\" the output should be 90.\n  For num = \"ABCD\" the output should be 91.\n  For num = \"ABCD\" the output should be 92.\n  For num = \"ABCD\" the output should be 93.\n  For num = \"ABCD\" the output should be 94.\n  For num = \"ABCD\" the output should be 95.\n  For num = \"ABCD\" the output should be 96.\n  For num = \"ABCD\" the output should be 97.\n  For num = \"ABCD\" the output should be 98.\n  For num = \"ABCD\" the ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString().split('');\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal('1111')   # returns 15\n  binaryToDecimal('100000')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.split('');\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString[i] === '1') {\n      decimal += 1;\n    } else {\n      decimal += 0;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in binary form.\n\n  Examples:\n  binaryToBinary('1111')   # returns \"11110\"\n  binaryToBinary('100000')   # returns \"10011\"\n  */\nconst binaryToBinary = binary => {\n  let binary = '';\n  let binaryString = binary.split('');\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('1111')   # returns \"15\"\n  decimalToBinary('100000')   # returns \"32\"\n  */\nconst decimalToBinary = decimal => {\n  let binary = '';\n  let decimalString = decimal.toString().split('');\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in binary form.\n\n  Examples:\n  binaryToBinary('1111')   # returns \"11110\"\n  binaryToBinary('100000')   # returns \"10011\"\n  */\nconst binaryToBinary = binary => {\n  let binary = '';\n  let binaryString = binary.split('');\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('1111')   # returns \"15\"\n  decimalToBinary('100000')   # returns \"32\"\n  */\nconst decimalToBinary = decimal => {\n  let binary = '';\n  let decimalString = decimal.toString().split('');\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in binary form.\n\n  Examples:\n  binaryToBinary('1111')   # returns \"11110\"\n  binaryToBinary('100000')   # returns \"10011\"\n  */\nconst binaryToBinary = binary => {\n  let binary = '';\n  let binaryString = binary.split('');\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('1111')   # returns \"15\"\n  decimalToBinary('100000')   # returns \"32\"\n  */\nconst decimalToBinary = decimal => {\n  let binary = '';\n  let decimalString = decimal.toString().split('');\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in binary form.\n\n  Examples:\n  binaryToBinary('1111')   # returns \"11110\"\n  binaryToBinary('100000')   # returns \"10011\"\n  */\nconst binaryToBinary = binary => {\n  let binary = '';\n  let binaryString = binary.split('');\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('1111')   # returns \"15\"\n  decimalToBinary('100000')   # returns \"32\"\n  */\nconst decimalToBinary = decimal => {\n  let binary = '';\n  let decimalString = decimal.toString().split('');\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in binary form.\n\n  Examples:\n  binaryToBinary('1111')   # returns \"11110\"\n  binaryToBinary('100000')   # returns \"10011\"\n  */\nconst binaryToBinary = binary => {\n  let binary = '';\n  let binaryString = binary.split('');\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('1111')   # returns \"15\"\n  decimalToBinary('100000')   # returns \"32\"\n  */\nconst decimalToBinary = decimal => {\n  let binary = '';\n  let decimalString = decimal.toString().split('');\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in binary form.\n\n  Examples:\n  binaryToBinary('1111')   # returns \"11110\"\n  binaryToBinary('100000')   # returns \"10011\"\n  */\nconst binaryToBinary = binary => {\n  let binary = '';\n  let binaryString = binary.split('');\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('1111')   # returns \"15\"\n  decimalToBinary('100000')   # returns \"32\"\n  */\nconst decimalToBinary = decimal => {\n  let binary = '';\n  let decimalString = decimal.toString().split('');\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelIntersection([])\n  (0, 1)\n  >>> kernelIntersection([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelIntersection = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "kernelIntersection", "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelIntersection([])\n  (0, 1)\n  >>> kernelIntersection([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelIntersection = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of pairs consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelProduct([2])\n  (1, 2)\n  >>> kernelProduct([2, 3])\n  (2, 6)\n  >>> kernelProduct([2, 3, 4, 5])\n  (2, 24, 120, 720)\n  */\nconst kernelProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of pairs consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelProduct([2, 3])\n  (2, 6)\n  >>> kernelProduct([2, 3, 4, 5])\n  (2, 24, 120, 720)\n  */\nconst kernelProductWithZero = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= 0;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of pairs consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelProductWithZero([2, 3])\n  (2, 6)\n  >>> kernelProductWithZero([2, 3, 4, 5])\n  (2, 24, 120, 720)\n  */\nconst kernelProductWithZeroAndZero = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= 0;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of pairs consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelProductWithZeroAndZero([2, 3])\n  (2, 6)\n  >>> kernelProductWithZeroAndZero([2, 3, 4, 5])\n  (2, 24, 120, 720)\n  */\nconst kernelProductWithZeroAndZeroAndZero = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= 0;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of pairs consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelProductWithZeroAndZeroAndZero([2, 3])\n  (2, 6)\n  >>> kernelProductWithZeroAndZeroAndZero([2, 3, 4, 5])\n  (2, 24, 120, 720)\n  */\nconst kernelProductWithZeroAndZeroAndZeroAndZero = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= 0;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of pairs consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelProductWithZeroAndZeroAndZeroAndZero([2, 3])\n  (2, 6)\n  >>> kernelProductWithZeroAndZeroAndZeroAndZero([2, 3, 4, 5])\n  (2, 24, 120, 720)\n  */\nconst kernelProductWithZeroAndZeroAndZeroAndZeroAndZero = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= 0;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of pairs consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelProductWithZeroAndZeroAndZeroAndZeroAndZeroAndZero([2, 3])\n  (2, 6)\n  >>> kernelProductWithZeroAndZeroAndZeroAndZeroAndZeroAndZero([2, 3, 4, 5])\n  (2, 24, 120, 720)\n  */\nconst kernelProductWithZeroAndZeroAndZeroAndZeroAndZeroAndZero = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= 0;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of pairs consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelProductWithZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZero([2, 3])\n  (2, 6)\n  >>> kernelProductWithZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZero([2, 3, 4, 5])\n  (2, 24, 120, 720)\n  */\nconst kernelProductWithZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZero = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= 0;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of pairs consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelProductWithZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZero([2, 3])\n  (2, 6)\n  >>> kernelProductWithZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZero([2, 3, 4, 5])\n  (2, 24, 120, 720)\n  */\nconst kernelProductWithZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZero = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= 0;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of pairs consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelProductWithZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAndZeroAnd", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isFelicitous(a) => false\n  isFelicitous(aa) => false\n  isFelicitous(abcd) => true\n  isFelicitous(aabb) => false\n  isFelicitous(adb) => true\n  isFelicitous(xyy) => false\n  */\nconst isFelicitous = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isFelicitous", "gc": "<|endoftext|>/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isFelicitous(a) => false\n  isFelicitous(aa) => false\n  isFelicitous(abcd) => true\n  isFelicitous(aabb) => false\n  isFelicitous(adb) => true\n  isFelicitous(xyy) => false\n  */\nconst isFelicitous = (s) => {\n  let isFelicitous = false;\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericLetterGrade", "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericLetterGrade = (grades) => {\n  const gradesArray = grades.map((grade) => grade.trim());\n  const gradesArrayLength = gradesArray.length;\n  let letterGrades = [];\n  let letterGrade = '';\n  let letterGradeIndex = 0;\n  let letterGradeIndexMax = gradesArrayLength - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMaxIndex = gradesArrayLength - 1;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = gradesArrayLength - 1;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex = 0;\n  let letterGradeIndexMinIndex = 0;\n  let letterGradeIndexMaxIndexIndex", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  premierDistance('Hello') == true\n  premierDistance('abcdcba') == true\n  premierDistance('kittens') == true\n  premierDistance('orange') == false\n  */\nconst premierDistance = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "premierDistance", "gc": "<|endoftext|>/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  premierDistance('Hello') == true\n  premierDistance('abcdcba') == true\n  premierDistance('kittens') == true\n  premierDistance('orange') == false\n  */\nconst premierDistance = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 3 or false otherwise\n  Examples\n  divisibleByThree('Hello') == true\n  divisibleByThree('abcdcba') == true\n  divisibleByThree('kittens') == false\n  divisibleByThree('orange') == false\n  */\nconst divisibleByThree = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isDivisible = false;\n      break;\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 5 or false otherwise\n  Examples\n  divisibleByFive('Hello') == true\n  divisibleByFive('abcdcba') == true\n  divisibleByFive('kittens') == false\n  divisibleByFive('orange') == false\n  */\nconst divisibleByFive = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isDivisible = false;\n      break;\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 7 or false otherwise\n  Examples\n  divisibleBySeven('Hello') == true\n  divisibleBySeven('abcdcba') == true\n  divisibleBySeven('kittens') == false\n  divisibleBySeven('orange') == false\n  */\nconst divisibleBySeven = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isDivisible = false;\n      break;\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 9 or false otherwise\n  Examples\n  divisibleByNine('Hello') == true\n  divisibleByNine('abcdcba') == true\n  divisibleByNine('kittens') == false\n  divisibleByNine('orange') == false\n  */\nconst divisibleByNine = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isDivisible = false;\n      break;\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 11 or false otherwise\n  Examples\n  divisibleByTen('Hello') == true\n  divisibleByTen('abcdcba') == true\n  divisibleByTen('kittens') == false\n  divisibleByTen('orange') == false\n  */\nconst divisibleByTen = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isDivisible = false;\n      break;\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 13 or false otherwise\n  Examples\n  divisibleByEleven('Hello') == true\n  divisibleByEleven('abcdcba') == true\n  divisibleByEleven('kittens') == false\n  divisibleByEleven('orange') == false\n  */\nconst divisibleByEleven = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isDivisible = false;\n      break;\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 15 or false otherwise\n  Examples\n  divisibleByTwelve('Hello') == true\n  divisibleByTwelve('abcdcba') == true\n  divisibleByTwelve('kittens') == false\n  divisibleByTwelve('orange') == false\n  */\nconst divisibleByTwelve = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isDivisible = false;\n      break;\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 17 or false otherwise\n  Examples\n  divisibleByThirteen('Hello') == true\n  divisibleByThirteen('abcdcba') == true\n  divisibleByThirteen('kittens') == false\n  divisibleByThirteen('orange') == false\n  */\nconst divisibleByThirteen = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isDivisible = false;\n      break;\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 19 or false otherwise\n  Examples\n  divisibleByFourteen('Hello') == true\n  divisibleByFourteen('abcdcba') == true\n  divisibleByFourteen('kittens') == false\n  divisibleByFourteen('orange') == false\n  */\nconst divisibleByFourteen = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isDivisible = false;\n      break;\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 21 or false otherwise\n  Examples\n  divisibleBySixteen('Hello') == true\n  divisibleBySixteen('abcdcba') == true\n  divisibleBySixteen('kittens') == false\n  divisibleBySixteen('orange') == false\n  */\nconst divisibleBySixteen = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {\n      isDivisible = false;\n      break;\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 23 or false otherwise\n  Examples\n  divisibleBySeventeen('Hello') == true\n  divisibleBySeventeen('abcdcba') == true\n  divisibleBySeventeen('kittens') == false\n  divisibleBySeventeen('orange') == false\n  */\nconst divisibleBySeventeen = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  for (let i = 1; i < length; i++) {\n    if (string[i]!== string[i - 1]) {", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst beginOneEnd = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "beginOneEnd", "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst beginOneEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst beginZeroEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 2.\n  */\nconst beginTwoEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 3.\n  */\nconst beginThreeEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 4.\n  */\nconst beginFourEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 5.\n  */\nconst beginFiveEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 6.\n  */\nconst beginSixEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 7.\n  */\nconst beginSevenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 8.\n  */\nconst beginEightEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 9.\n  */\nconst beginNineEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 10.\n  */\nconst beginTenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 11.\n  */\nconst beginElevenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 12.\n  */\nconst beginTwelveEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 13.\n  */\nconst beginThirteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 14.\n  */\nconst beginFourteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 15.\n  */\nconst beginFifteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 16.\n  */\nconst beginSixteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 17.\n  */\nconst beginSeventeenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 18.\n  */\nconst beginEighteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 19.\n  */\nconst beginNineteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 20.\n  */\nconst beginTwentyEnd = (n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst resolve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "resolve", "gc": "<|endoftext|>/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let num = 0;\n  let i = 0;\n  let j = 0;\n  let carry = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n  let temp4 = 0;\n  let temp5 = 0;\n  let temp6 = 0;\n  let temp7 = 0;\n  let temp8 = 0;\n  let temp9 = 0;\n  let temp10 = 0;\n  let temp11 = 0;\n  let temp12 = 0;\n  let temp13 = 0;\n  let temp14 = 0;\n  let temp15 = 0;\n  let temp16 = 0;\n  let temp17 = 0;\n  let temp18 = 0;\n  let temp19 = 0;\n  let temp20 = 0;\n  let temp21 = 0;\n  let temp22 = 0;\n  let temp23 = 0;\n  let temp24 = 0;\n  let temp25 = 0;\n  let temp26 = 0;\n  let temp27 = 0;\n  let temp28 = 0;\n  let temp29 = 0;\n  let temp30 = 0;\n  let temp31 = 0;\n  let temp32 = 0;\n  let temp33 = 0;\n  let temp34 = 0;\n  let temp35 = 0;\n  let temp36 = 0;\n  let temp37 = 0;\n  let temp38 = 0;\n  let temp39 = 0;\n  let temp40 = 0;\n  let temp41 = 0;\n  let temp42 = 0;\n  let temp43 = 0;\n  let temp44 = 0;\n  let temp45 = 0;\n  let temp46 = 0;\n  let temp47 = 0;\n  let temp48 = 0;\n  let temp49 = 0;\n  let temp50 = 0;\n  let temp51 = 0;\n  let temp52 = 0;\n  let temp53 = 0;\n  let temp54 = 0;\n  let temp55 = 0;\n  let temp56 = 0;\n  let temp57 = 0;\n  let temp58 = 0;\n  let temp59 = 0;\n  let temp60 = 0;\n  let temp61 = 0;\n  let temp62 = 0;\n  let temp63 = 0;\n  let temp64 = 0;\n  let temp65 = 0;\n  let temp66 = 0;\n  let temp67 = 0;\n  let temp68 = 0;\n  let temp69 = 0;\n  let temp70 = 0;\n  let temp71 = 0;\n  let temp72 = 0;\n  let temp73 = 0;\n  let temp74 = 0;\n  let temp75 = 0;\n  let temp76 = 0;\n  let temp77 = 0;\n  let temp78 = 0;\n  let temp79 = 0;\n  let temp80 = 0;\n  let temp81 = 0;\n  let temp82 = 0;\n  let temp83 = 0;\n  let temp84 = 0;\n  let temp85 = 0;\n  let temp86 = 0;\n  let temp87 = 0;\n  let temp88 = 0;\n  let temp89 = 0;\n  let temp90 = 0;\n  let temp91 = 0;\n  let temp92 = 0;\n  let temp93 = 0;\n  let temp94 = 0;\n  let temp95 = 0;\n  let temp96 = 0;\n  let temp97 = 0;\n  let temp98 = 0;\n  let temp99 = 0;\n  let temp100 = 0;\n  let temp101 = 0;\n  let temp102 = 0;\n  let temp103 = 0;\n  let temp104 = 0;\n  let temp105 = 0;\n  let temp106 = 0;\n  let temp107 = 0;\n  let temp108 = 0;\n  let temp109 = 0;\n  let temp110 = 0;\n  let temp111 = 0;\n  let temp112 = 0;\n  let temp113 = 0;\n  let temp114 = 0;\n  let temp115 = 0;\n  let temp116 = 0;\n  let temp117 = 0;\n  let temp118 = 0;\n  let temp119 = 0;\n  let temp120 = 0;\n  let temp121 = 0;\n  let temp122 = 0;\n  let temp123 = 0;\n  let temp124 = 0;\n  let temp125 = 0;\n  let temp126 = 0;\n  let temp127 = 0;\n  let temp128 = 0;\n  let temp129 = 0;\n  let temp130 = 0;\n  let temp131 = 0;\n  let temp132 = 0;\n  let temp133 = 0;\n  let temp134 = 0;\n  let temp135 = 0;\n  let temp136 = 0;\n  let temp137 = 0;\n  let temp138 = 0;\n  let temp139 = 0;\n  let temp140 = 0;\n  let temp141 = 0;\n  let temp142 = 0;\n  let temp143 = 0;\n  let temp144 = 0;\n  let temp145 = 0;\n  let temp146 = 0;\n  let temp147 = 0;\n  let temp148 = 0;\n  let temp149 = 0;\n  let temp150 = 0;\n  let temp151 = 0;\n  let temp152 = 0;\n  let temp153 = 0;\n  let temp154 = 0;\n  let temp155 = 0;\n  let temp156 = 0;\n  let temp157 = 0;\n  let temp158 = 0;\n  let temp159 = 0;\n  let temp160 = 0;\n  let temp161 = 0;\n  let temp162 = 0;\n  let temp163 = 0;\n  let temp164 = 0;\n  let temp165 = 0;\n  let temp166 = 0;\n  let temp167 = 0;\n  let temp168 = 0;\n  let temp169 = 0;\n  let temp170 = 0;\n  let temp171 = 0;\n  let temp172 = 0;\n  let temp173 = 0;\n  let temp174 = 0;\n  let temp175 = 0;\n  let temp176 = 0;\n  let temp177 = 0;\n  let temp178 = 0;\n  let temp179 = 0;\n  let temp180 = 0;\n  let temp181 = 0;\n  let temp182 = 0;\n  let temp183 = 0;\n  let temp184 = 0;\n  let temp185 = 0;\n  let temp186 = 0;\n  let temp187 = 0;\n  let temp188 = 0;\n  let temp189 = 0;\n  let temp190 = 0;\n  let temp191 = 0;\n  let temp192 = 0;\n  let temp193 = 0;\n  let temp194 = 0;\n  let temp195 = 0;\n  let temp196 = 0;\n  let temp197 = 0;\n  let temp198 = 0;\n  let temp199 = 0;\n  let temp200 = 0;\n  let temp201 = 0;\n  let temp202 = 0;\n  let temp203 = 0;\n  let temp204 = 0;\n  let temp205 = 0;\n  let temp206 = 0;\n  let temp207 = 0;\n  let temp208 = 0;\n  let temp209 = 0;\n  let temp210 = 0;\n  let temp211 = 0;\n  let temp212 = 0;\n  let temp213 = 0;\n  let temp214 = 0;\n  let temp215 = 0;\n  let temp216 = 0;\n  let temp217 = 0;\n  let temp218 = 0;\n  let temp219 = 0;\n  let temp220 = 0;\n  let temp221 = 0;\n  let temp222 = 0;\n  let temp223 = 0;\n  let temp224 = 0;\n  let temp225 = 0;\n  let temp226 = 0;\n  let temp227 = 0;\n  let temp228 = 0;\n  let temp229 = 0;\n  let temp230 = 0;\n  let temp231 = 0;\n  let temp232 = 0;\n  let temp233 = 0;\n  let temp234 = 0;\n  let temp235 = 0;\n  let temp236 = 0;\n  let temp237 = 0;\n  let temp238 = 0;\n  let temp239 = 0;\n  let temp240 = 0;\n  let temp241 = 0;\n  let temp242 = 0;\n  let temp243 = 0;\n  let temp244 = 0;\n  let temp245 = 0;\n  let temp246 = 0;\n  let temp247 = 0;\n  let temp248 = 0;\n  let temp249 = 0;\n  let temp250 = 0;\n  let temp251 = 0;\n  let temp252 = 0;\n  let temp253 = 0;\n  let temp254 = 0;\n  let temp255 = 0;\n  let temp256 = 0;\n  let temp257 = 0;\n  let temp258 = 0;\n  let temp259 = 0;\n  let temp260 = 0;\n  let temp261 = 0;\n  let temp262 = 0;\n  let temp263 = 0;\n  let temp264 = 0;\n  let temp265 = 0;\n  let temp266 = 0;\n  let temp267 = 0;\n  let temp268 = 0;\n  let temp269 = 0;\n  let temp270 = 0;\n  let temp271 = 0;\n  let temp272 = 0;\n  let temp273 = 0;\n  let temp274 = 0;\n  let temp275 = 0;\n  let temp276 = 0;\n  let temp277 = 0;\n  let temp278 = 0;\n  let temp279 = 0;\n  let temp280 = 0;\n  let ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lend = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "lend", "gc": "<|endoftext|>/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 1 \n  */\nconst lendOdd = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices and odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lendEvenOdd = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      if (lst[i] % 2!== 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at even indices and even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 1 \n  */\nconst lendEvenEven = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      if (lst[i] % 2!== 0) {\n        if (lst[i] % 2 === 1) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at odd indices and odd indices and odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lendEvenOddEven = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      if (lst[i] % 2!== 0) {\n        if (lst[i] % 2 === 1) {\n          if (lst[i] % 2 === 1) {\n            count++;\n          }\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at even indices and even indices and odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 1 \n  */\nconst lendEvenEvenOddEven = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      if (lst[i] % 2!== 0) {\n        if (lst[i] % 2 === 1) {\n          if (lst[i] % 2 === 1) {\n            if (lst[i] % 2 === 1) {\n              count++;\n            }\n          }\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at odd indices and odd indices and even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lendEvenEvenOddEven = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      if (lst[i] % 2!== 0) {\n        if (lst[i] % 2 === 1) {\n          if (lst[i] % 2 === 1) {\n            if (lst[i] % 2 === 1) {\n              if (lst[i] % 2 === 1) {\n                count++;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at odd indices and even indices and odd indices and even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 1 \n  */\nconst lendEvenEvenOddEvenOdd = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      if (lst[i] % 2!== 0) {\n        if (lst[i] % 2 === 1) {\n          if (lst[i] % 2 === 1) {\n            if (lst[i] % 2 === 1) {\n              if (lst[i] % 2 === 1) {\n                if (lst[i] % 2 === 1) {\n                  count++;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at odd indices and even indices and odd indices and even indices and even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lendEvenEvenOddEvenOddEven = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      if (lst[i] % 2!== 0) {\n        if (lst[i] % 2 === 1) {\n          if (lst[i] % 2 === 1) {\n            if (lst[i] % 2 === 1) {\n              if (lst[i] % 2 === 1) {\n                if (lst[i] % 2 === 1) {\n                  count++;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at odd indices and even indices and odd indices and even indices and odd indices and even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 1 \n  */\nconst lendEvenEvenOddEvenOddEvenOdd = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      if (lst[i] % 2!== 0) {\n        if (lst[i] % 2 === 1) {\n          if (lst[i] % 2 === 1) {\n            if (lst[i] % 2 === 1) {\n              if (lst[i] % 2 === 1) {\n                if (lst[i] % 2 === 1) {\n                  count++;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at odd indices and even indices and odd indices and even indices and odd indices and even indices and even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lendEvenEvenOddEvenOddEvenOddEven = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      if (lst[i] % 2!== 0) {\n        if (lst[i] % 2 === 1) {\n          if (lst[i] % 2 === 1) {\n            if (lst[i] % 2 === 1) {\n              if (lst[i] % 2 === 1) {\n                if (lst[i] % 2 === 1) {\n                  count++;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at odd indices and even indices and odd indices and even indices and odd indices and even indices and odd indices and even indices and even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 1 \n  */\nconst lendEvenEvenOddEvenOddEvenOddEvenOdd = (lst) => {\n  let len = lst.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      if (lst[i] % 2!== 0) {\n        if (lst[i] % 2 === 1) {\n          if (lst[i] % 2 === 1) {\n            if (lst[i] % 2 === 1) {\n              if (lst[i] % 2 === 1) {\n                if (lst[i] % 2 === 1) {\n                  count++;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at odd indices and even indices and odd indices and ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newArr = []\n  let newStr = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let space = ''\n  let word = ''\n  let newWord = ''\n\n  while (i + 1 < s.length) {\n    word = s.substring(i + 1, j)\n    space = s.substring(j, i + 1)\n    j = i + 1\n    i = j\n    k = j + 1\n    newWord = word + space\n    newArr.push(newWord)\n  }\n\n  newStr = newArr.join(' ')\n  return newStr\n}\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newArr = []\n  let newStr = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let space = ''\n  let word = ''\n  let newWord = ''\n\n  while (i + 1 < s.length) {\n    word = s.substring(i + 1, j)\n    space = s.substring(j, i + 1)\n    j = i + 1\n    i = j\n    k = j + 1\n    newWord = word + space\n    newArr.push(newWord)\n  }\n\n  newStr = newArr.join(' ')\n  return newStr\n}\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newArr = []\n  let newStr = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let space = ''\n  let word = ''\n  let newWord = ''\n\n  while (i + 1 < s.length) {\n    word = s.substring(i + 1, j)\n    space = s.substring(j, i + 1)\n    j = i + 1\n    i = j\n    k = j + 1\n    newWord = word + space\n    newArr.push(newWord)\n  }\n\n  newStr = newArr.join(' ')\n  return newStr\n}\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newArr = []\n  let newStr = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let space = ''\n  let word = ''\n  let newWord = ''\n\n  while (i + 1 < s.length) {\n    word = s.substring(i + 1, j)\n    space = s.substring(j, i + 1)\n    j = i + 1\n    i = j\n    k = j + 1\n    newWord = word + space\n    newArr.push(newWord)\n  }\n\n  newStr = newArr.join(' ')\n  return newStr\n}\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newArr = []\n  let newStr = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let space = ''\n  let word = ''\n  let newWord = ''\n\n  while (i + 1 < s.length) {\n    word = s.substring(i + 1, j)\n    space = s.substring(j, i + 1)\n    j = i + 1\n    i = j\n    k = j + 1\n    newWord = word + space\n    newArr.push(newWord)\n  }\n\n  newStr = newArr.join(' ')\n  return newStr\n}\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newArr = []\n  let newStr = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let space = ''\n  let word = ''\n  let newWord = ''\n\n  while (i + 1 < s.length) {\n    word = s.substring(i + 1, j)\n    space = s.substring(j, i + 1)\n    j = i + 1\n    i = j\n    k = j + 1\n    newWord = word + space\n    newArr.push(newWord)\n  }\n\n  newStr = newArr.join(' ')\n  return newStr\n}\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newArr = []\n  let newStr = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let space = ''\n  let word = ''\n  let newWord = ''\n\n  while (i + 1 < s.length) {\n    word = s.substring(i + 1, j)\n    space = s.substring(j, i + 1)\n    j = i + 1\n    i = j\n    k = j + 1\n    newWord = word + space\n    newArr.push(newWord)\n  }\n\n  newStr = newArr.join(' ')\n  return ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  catchRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  catchRow([], 1) == []\n  catchRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst catchRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "catchRow", "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  catchRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  catchRow([], 1) == []\n  catchRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst catchRow = (lst, x) => {\n  let row = []\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  let rowIndexLength = 0\n  let columnIndexLength = 0\n  let rowIndex = 0\n  let columnIndex = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => a - b);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return the sum of the given array.\n\n  Example:\n  * sumArray([5, 1, 3, 2]) => 10\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]) => 15\n  * sumArray([5, 1, 3, 2]", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "gc": "<|endoftext|>/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  for (let j = 0; j < alphabet.length; j++) {\n    rotated += alphabet[j]\n    i++\n    if (i % 2 === 0) {\n      rotated += alphabet[j]\n    }\n  }\n  return rotated\n}\n\n/*Create a function decrypt that takes a string as an argument and\n  returns a string decrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  for (let j = 0; j < alphabet.length; j++) {\n    rotated += alphabet[j]\n    i++\n    if (i % 2 === 0) {\n      rotated += alphabet[j]\n    }\n  }\n  return rotated\n}\n\n/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'hi'\n  encrypt('asdfghjkl') returns 'asdfghjkl'\n  encrypt('gf') returns 'gfghjkl'\n  encrypt('et') returns 'et'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  for (let j = 0; j < alphabet.length; j++) {\n    rotated += alphabet[j]\n    i++\n    if (i % 2 === 0) {\n      rotated += alphabet[j]\n    }\n  }\n  return rotated\n}\n\n/*Create a function decrypt that takes a string as an argument and\n  returns a string decrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  decrypt('hi') returns 'hi'\n  decrypt('asdfghjkl') returns 'asdfghjkl'\n  decrypt('gf') returns 'gfghjkl'\n  decrypt('et') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  for (let j = 0; j < alphabet.length; j++) {\n    rotated += alphabet[j]\n    i++\n    if (i % 2 === 0) {\n      rotated += alphabet[j]\n    }\n  }\n  return rotated\n}\n\n/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'hi'\n  encrypt('asdfghjkl') returns 'asdfghjkl'\n  encrypt('gf') returns 'gfghjkl'\n  encrypt('et') returns 'et'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  for (let j = 0; j < alphabet.length; j++) {\n    rotated += alphabet[j]\n    i++\n    if (i % 2 === 0) {\n      rotated += alphabet[j]\n    }\n  }\n  return rotated\n}\n\n/*Create a function decrypt that takes a string as an argument and\n  returns a string decrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  decrypt('hi') returns 'hi'\n  decrypt('asdfghjkl') returns 'asdfghjkl'\n  decrypt('gf') returns 'gfghjkl'\n  decrypt('et') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  for (let j = 0; j < alphabet.length; j++) {\n    rotated += alphabet[j]\n    i++\n    if (i % 2 === 0) {\n      rotated += alphabet[j]\n    }\n  }\n  return rotated\n}\n\n/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'hi'\n  encrypt('asdfghjkl') returns 'asdfghjkl'\n  encrypt('gf') returns 'gfghjkl'\n  encrypt('et') returns 'et'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  for (let j = 0; j < alphabet.length; j++) {\n    rotated += alphabet[j]\n    i++\n    if (i % 2 === 0) {\n      rotated += alphabet[j]\n    }\n  }\n  return rotated\n}\n\n/*Create a function decrypt that takes a string as an argument and\n  returns a string decrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  decrypt('hi') returns 'hi'\n  decrypt('asdfghjkl') returns 'asdfghjkl'\n  decrypt('gf') returns 'gfghjkl'\n  decrypt('et') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  for (let j = 0; j < alphabet.length; j++) {\n    rotated += alphabet[j]\n    i++\n    if (i % 2 === 0) {\n      rotated += alphabet[j]\n    }\n  }\n  return rotated\n}\n\n/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'hi'\n  encrypt('asdfghjkl') returns 'asdfghjkl'\n  encrypt('gf') returns 'gfghjkl'\n  encrypt('et') returns 'et'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  for (let j = 0; j < alphabet.length; j++) {\n    rotated += alphabet[j]\n    i++\n    if (i % 2 === 0) {\n      rotated += alphabet[j]\n    }", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rolledMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rolledMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rolledMax", "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rolledMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rolledMax = (numbers) => {\n  let max = 0;\n  let maxIndex = 0;\n  let maxValue = 0;\n  let maxIndexValue = 0;\n  let maxValueIndex = 0;\n  let maxValueIndexValue = 0;\n  let maxValueIndexValue2 = 0;\n  let maxValueIndexValue2 = 0;\n  let maxValueIndexValue3 = 0;\n  let maxValueIndexValue3 = 0;\n  let maxValueIndexValue4 = 0;\n  let maxValueIndexValue4 = 0;\n  let maxValueIndexValue5 = 0;\n  let maxValueIndexValue5 = 0;\n  let maxValueIndexValue6 = 0;\n  let maxValueIndexValue6 = 0;\n  let maxValueIndexValue7 = 0;\n  let maxValueIndexValue7 = 0;\n  let maxValueIndexValue8 = 0;\n  let maxValueIndexValue8 = 0;\n  let maxValueIndexValue9 = 0;\n  let maxValueIndexValue9 = 0;\n  let maxValueIndexValue10 = 0;\n  let maxValueIndexValue10 = 0;\n  let maxValueIndexValue11 = 0;\n  let maxValueIndexValue11 = 0;\n  let maxValueIndexValue12 = 0;\n  let maxValueIndexValue12 = 0;\n  let maxValueIndexValue13 = 0;\n  let maxValueIndexValue13 = 0;\n  let maxValueIndexValue14 = 0;\n  let maxValueIndexValue14 = 0;\n  let maxValueIndexValue15 = 0;\n  let maxValueIndexValue15 = 0;\n  let maxValueIndexValue16 = 0;\n  let maxValueIndexValue16 = 0;\n  let maxValueIndexValue17 = 0;\n  let maxValueIndexValue17 = 0;\n  let maxValueIndexValue18 = 0;\n  let maxValueIndexValue18 = 0;\n  let maxValueIndexValue19 = 0;\n  let maxValueIndexValue19 = 0;\n  let maxValueIndexValue20 = 0;\n  let maxValueIndexValue20 = 0;\n  let maxValueIndexValue21 = 0;\n  let maxValueIndexValue21 = 0;\n  let maxValueIndexValue22 = 0;\n  let maxValueIndexValue22 = 0;\n  let maxValueIndexValue23 = 0;\n  let maxValueIndexValue23 = 0;\n  let maxValueIndexValue24 = 0;\n  let maxValueIndexValue24 = 0;\n  let maxValueIndexValue25 = 0;\n  let maxValueIndexValue25 = 0;\n  let maxValueIndexValue26 = 0;\n  let maxValueIndexValue26 = 0;\n  let maxValueIndexValue27 = 0;\n  let maxValueIndexValue27 = 0;\n  let maxValueIndexValue28 = 0;\n  let maxValueIndexValue28 = 0;\n  let maxValueIndexValue29 = 0;\n  let maxValueIndexValue29 = 0;\n  let maxValueIndexValue30 = 0;\n  let maxValueIndexValue30 = 0;\n  let maxValueIndexValue31 = 0;\n  let maxValueIndexValue31 = 0;\n  let maxValueIndexValue32 = 0;\n  let maxValueIndexValue32 = 0;\n  let maxValueIndexValue33 = 0;\n  let maxValueIndexValue33 = 0;\n  let maxValueIndexValue34 = 0;\n  let maxValueIndexValue34 = 0;\n  let maxValueIndexValue35 = 0;\n  let maxValueIndexValue35 = 0;\n  let maxValueIndexValue36 = 0;\n  let maxValueIndexValue36 = 0;\n  let maxValueIndexValue37 = 0;\n  let maxValueIndexValue37 = 0;\n  let maxValueIndexValue38 = 0;\n  let maxValueIndexValue38 = 0;\n  let maxValueIndexValue39 = 0;\n  let maxValueIndexValue39 = 0;\n  let maxValueIndexValue40 = 0;\n  let maxValueIndexValue40 = 0;\n  let maxValueIndexValue41 = 0;\n  let maxValueIndexValue41 = 0;\n  let maxValueIndexValue42 = 0;\n  let maxValueIndexValue42 = 0;\n  let maxValueIndexValue43 = 0;\n  let maxValueIndexValue43 = 0;\n  let maxValueIndexValue44 = 0;\n  let maxValueIndexValue44 = 0;\n  let maxValueIndexValue45 = 0;\n  let maxValueIndexValue45 = 0;\n  let maxValueIndexValue46 = 0;\n  let maxValueIndexValue46 = 0;\n  let maxValueIndexValue47 = 0;\n  let maxValueIndexValue47 = 0;\n  let maxValueIndexValue48 = 0;\n  let maxValueIndexValue48 = 0;\n  let maxValueIndexValue49 = 0;\n  let maxValueIndexValue49 = 0;\n  let maxValueIndexValue50 = 0;\n  let maxValueIndexValue50 = 0;\n  let maxValueIndexValue51 = 0;\n  let maxValueIndexValue51 = 0;\n  let maxValueIndexValue52 = 0;\n  let maxValueIndexValue52 = 0;\n  let maxValueIndexValue53 = 0;\n  let maxValueIndexValue53 = 0;\n  let maxValueIndexValue54 = 0;\n  let maxValueIndexValue54 = 0;\n  let maxValueIndexValue55 = 0;\n  let maxValueIndexValue55 = 0;\n  let maxValueIndexValue56 = 0;\n  let maxValueIndexValue56 = 0;\n  let maxValueIndexValue57 = 0;\n  let maxValueIndexValue57 = 0;\n  let maxValueIndexValue58 = 0;\n  let maxValueIndexValue58 = 0;\n  let maxValueIndexValue59 = 0;\n  let maxValueIndexValue59 = 0;\n  let maxValueIndexValue60 = 0;\n  let maxValueIndexValue60 = 0;\n  let maxValueIndexValue61 = 0;\n  let maxValueIndexValue61 = 0;\n  let maxValueIndexValue62 = 0;\n  let maxValueIndexValue62 = 0;\n  let maxValueIndexValue63 = 0;\n  let maxValueIndexValue63 = 0;\n  let maxValueIndexValue64 = 0;\n  let maxValueIndexValue64 = 0;\n  let maxValueIndexValue65 = 0;\n  let maxValueIndexValue65 = 0;\n  let maxValueIndexValue66 = 0;\n  let maxValueIndexValue66 = 0;\n  let maxValueIndexValue67 = 0;\n  let maxValueIndexValue67 = 0;\n  let maxValueIndexValue68 = 0;\n  let maxValueIndexValue68 = 0;\n  let maxValueIndexValue69 = 0;\n  let maxValueIndexValue69 = 0;\n  let maxValueIndexValue70 = 0;\n  let maxValueIndexValue70 = 0;\n  let maxValueIndexValue71 = 0;\n  let maxValueIndexValue71 = 0;\n  let maxValueIndexValue72 = 0;\n  let maxValueIndexValue72 = 0;\n  let maxValueIndexValue73 = 0;\n  let maxValueIndexValue73 = 0;\n  let maxValueIndexValue74 = 0;\n  let maxValueIndexValue74 = 0;\n  let maxValueIndexValue75 = 0;\n  let maxValueIndexValue75 = 0;\n  let maxValueIndexValue76 = 0;\n  let maxValueIndexValue76 = 0;\n  let maxValueIndexValue77 = 0;\n  let maxValueIndexValue77 = 0;\n  let maxValueIndexValue78 = 0;\n  let maxValueIndexValue78 = 0;\n  let maxValueIndexValue79 = 0;\n  let maxValueIndexValue79 = 0;\n  let maxValueIndexValue80 = 0;\n  let maxValueIndexValue80 = 0;\n  let maxValueIndexValue81 = 0;\n  let maxValueIndexValue81 = 0;\n  let maxValueIndexValue82 = 0;\n  let maxValueIndexValue82 = 0;\n  let maxValueIndexValue83 = 0;\n  let maxValueIndexValue83 = 0;\n  let maxValueIndexValue84 = 0;\n  let maxValueIndexValue84 = 0;\n  let maxValueIndexValue85 = 0;\n  let maxValueIndexValue85 = 0;\n  let maxValueIndexValue86 = 0;\n  let maxValueIndexValue86 = 0;\n  let maxValueIndexValue87 = 0;\n  let maxValueIndexValue87 = 0;\n  let maxValueIndexValue88 = 0;\n  let maxValueIndexValue88 = 0;\n  let maxValueIndexValue89 = 0;\n  let maxValueIndexValue89 = 0;\n  let maxValueIndexValue90 = 0;\n  let maxValueIndexValue90 = 0;\n  let maxValueIndexValue91 = 0;\n  let maxValueIndexValue91 = 0;\n  let maxValueIndexValue92 = 0;\n  let maxValueIndexValue92 = 0;\n  let maxValueIndexValue93", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let minVal = lst[0];\n  let minIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function findSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  findSmallest([1, 2, 3, 4, 5]) == 1\n  findSmallest([5, 1, 4, 3, 2]) == 1\n  findSmallest([]) == null\n  findSmallest([1, 1]) == null\n  */\nconst findSmallest = (lst) => {\n  let minVal = lst[0];\n  let minIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function findLargest() that returns the largest element of the list.\n  Return null if there is no such element.\n  \n  findLargest([1, 2, 3, 4, 5]) == 4\n  findLargest([5, 1, 4, 3, 2]) == 4\n  findLargest([]) == null\n  findLargest([1, 1]) == null\n  */\nconst findLargest = (lst) => {\n  let maxVal = lst[0];\n  let maxIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function findSmallestLargest() that returns the smallest element of the list that is the largest element of the list.\n  Return null if there is no such element.\n  \n  findSmallestLargest([1, 2, 3, 4, 5]) == 3\n  findSmallestLargest([5, 1, 4, 3, 2]) == 3\n  findSmallestLargest([]) == null\n  findSmallestLargest([1, 1]) == null\n  */\nconst findSmallestLargest = (lst) => {\n  let maxVal = lst[0];\n  let maxIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function findLargestLargest() that returns the largest element of the list that is the smallest element of the list.\n  Return null if there is no such element.\n  \n  findLargestLargest([1, 2, 3, 4, 5]) == 5\n  findLargestLargest([5, 1, 4, 3, 2]) == 5\n  findLargestLargest([]) == null\n  findLargestLargest([1, 1]) == null\n  */\nconst findLargestLargest = (lst) => {\n  let minVal = lst[0];\n  let minIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function findSmallestLargest() that returns the smallest element of the list that is the smallest element of the list.\n  Return null if there is no such element.\n  \n  findSmallestLargest([1, 2, 3, 4, 5]) == 1\n  findSmallestLargest([5, 1, 4, 3, 2]) == 1\n  findSmallestLargest([]) == null\n  findSmallestLargest([1, 1]) == null\n  */\nconst findSmallestLargest = (lst) => {\n  let minVal = lst[0];\n  let minIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function findLargestLargest() that returns the largest element of the list that is the largest element of the list.\n  Return null if there is no such element.\n  \n  findLargestLargest([1, 2, 3, 4, 5]) == 4\n  findLargestLargest([5, 1, 4, 3, 2]) == 4\n  findLargestLargest([]) == null\n  findLargestLargest([1, 1]) == null\n  */\nconst findLargestLargest = (lst) => {\n  let maxVal = lst[0];\n  let maxIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function findSmallestLargest() that returns the smallest element of the list that is the smallest element of the list.\n  Return null if there is no such element.\n  \n  findSmallestLargest([1, 2, 3, 4, 5]) == 3\n  findSmallestLargest([5, 1, 4, 3, 2]) == 3\n  findSmallestLargest([]) == null\n  findSmallestLargest([1, 1]) == null\n  */\nconst findSmallestLargest = (lst) => {\n  let minVal = lst[0];\n  let minIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function findLargestLargest() that returns the largest element of the list that is the largest element of the list.\n  Return null if there is no such element.\n  \n  findLargestLargest([1, 2, 3, 4, 5]) == 5\n  findLargestLargest([5, 1, 4, 3, 2]) == 5\n  findLargestLargest([]) == null\n  findLargestLargest([1, 1]) == null\n  */\nconst findLargestLargest = (lst) => {\n  let maxVal = lst[0];\n  let maxIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function findSmallestLargest() that returns the smallest element of the list that is the smallest element of the list.\n  Return null if there is no such element.\n  \n  findSmallestLargest([1, 2, 3, 4, 5]) == 1\n  findSmallestLargest([5, 1, 4, 3, 2]) == 1\n  findSmallestLargest([]) == null\n  findSmallestLargest([1, 1]) == null\n  */\nconst findSmallestLargest = (lst) => {\n  let minVal = lst[0];\n  let minIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBlase(\"Hello world\")\n  0\n  >>> isBlase(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBlase = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBlase", "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBlase(\"Hello world\")\n  0\n  >>> isBlase(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBlase = (S) => {\n  let boredom = 0;\n  let sentences = S.split('.');\n  for (let sentence of sentences) {\n    if (sentence.startsWith('I')) {\n      boredom++;\n    }\n  }\n  return boredom;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants. A consonant is a word that starts with the letter \"c\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isConsonant(\"Hello world\")\n  0\n  >>> isConsonant(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isConsonant = (S) => {\n  let consonants = 0;\n  let sentences = S.split('.');\n  for (let sentence of sentences) {\n    if (sentence.startsWith('c')) {\n      consonants++;\n    }\n  }\n  return consonants;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of vowels. A vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isVowel(\"Hello world\")\n  0\n  >>> isVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isVowel = (S) => {\n  let vowels = 0;\n  let sentences = S.split('.');\n  for (let sentence of sentences) {\n    if (sentence.startsWith('a')) {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A consonant is a word that starts with the letter \"c\"\n  and a vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isConsonantVowel(\"Hello world\")\n  0\n  >>> isConsonantVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isConsonantVowel = (S) => {\n  let consonants = 0;\n  let vowels = 0;\n  let sentences = S.split('.');\n  for (let sentence of sentences) {\n    if (sentence.startsWith('c') && sentence.startsWith('a')) {\n      consonants++;\n    }\n    if (sentence.startsWith('a') && sentence.startsWith('c')) {\n      vowels++;\n    }\n  }\n  return consonants + vowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A consonant is a word that starts with the letter \"c\"\n  and a vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isVowelVowel(\"Hello world\")\n  0\n  >>> isVowelVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isVowelVowel = (S) => {\n  let consonants = 0;\n  let vowels = 0;\n  let sentences = S.split('.');\n  for (let sentence of sentences) {\n    if (sentence.startsWith('c') && sentence.startsWith('a')) {\n      consonants++;\n    }\n    if (sentence.startsWith('a') && sentence.startsWith('c') && sentence.startsWith('a')) {\n      vowels++;\n    }\n  }\n  return consonants + vowels + consonants + vowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A consonant is a word that starts with the letter \"c\"\n  and a vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isConsonantVowelVowel(\"Hello world\")\n  0\n  >>> isConsonantVowelVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isConsonantVowelVowel = (S) => {\n  let consonants = 0;\n  let vowels = 0;\n  let sentences = S.split('.');\n  for (let sentence of sentences) {\n    if (sentence.startsWith('c') && sentence.startsWith('a') && sentence.startsWith('c') && sentence.startsWith('a')) {\n      consonants++;\n    }\n    if (sentence.startsWith('a') && sentence.startsWith('c') && sentence.startsWith('a') && sentence.startsWith('c')) {\n      vowels++;\n    }\n  }\n  return consonants + vowels + consonants + vowels + consonants + vowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A consonant is a word that starts with the letter \"c\"\n  and a vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isVowelVowelVowel(\"Hello world\")\n  0\n  >>> isVowelVowelVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isVowelVowelVowel = (S) => {\n  let consonants = 0;\n  let vowels = 0;\n  let sentences = S.split('.');\n  for (let sentence of sentences) {\n    if (sentence.startsWith('c') && sentence.startsWith('a') && sentence.startsWith('c') && sentence.startsWith('a') && sentence.startsWith('c')) {\n      consonants++;\n    }\n    if (sentence.startsWith('a') && sentence.startsWith('c') && sentence.startsWith('a') && sentence.startsWith('c') && sentence.startsWith('a')) {\n      vowels++;\n    }\n  }\n  return consonants + vowels + consonants + vowels + consonants + vowels + consonants + vowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A consonant is a word that starts with the letter \"c\"\n  and a vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isVowelVowelVowelVowel(\"Hello world\")\n  0\n  >>> isVowelVowelVowelVowel(\"The sk", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "gc": "<|endoftext|>/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return isInteger(x + y + z);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ false\n  allInt(3.6, -2.2, 2) ➞ true\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return isInteger(x + y + z);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenInt(5, 2, 7) ➞ true\n  evenInt(3, 2, 2) ➞ false\n  evenInt(3, -2, 1) ➞ false\n  evenInt(3.6, -2.2, 2) ➞ false\n  */\nconst evenInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return isInteger(x + y + z);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddInt(5, 2, 7) ➞ false\n  oddInt(3, 2, 2) ➞ true\n  oddInt(3, -2, 1) ➞ false\n  oddInt(3.6, -2.2, 2) ➞ true\n  */\nconst oddInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return isInteger(x + y + z);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7) ➞ false\n  evenOdd(3, 2, 2) ➞ true\n  evenOdd(3, -2, 1) ➞ false\n  evenOdd(3.6, -2.2, 2) ➞ true\n  */\nconst evenOddInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return isInteger(x + y + z);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddEvenOdd(5, 2, 7) ➞ false\n  oddEvenOdd(3, 2, 2) ➞ true\n  oddEvenOdd(3, -2, 1) ➞ false\n  oddEvenOdd(3.6, -2.2, 2) ➞ true\n  */\nconst oddEvenOddInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return isInteger(x + y + z);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7) ➞ false\n  evenOdd(3, 2, 2) ➞ true\n  evenOdd(3, -2, 1) ➞ false\n  evenOdd(3.6, -2.2, 2) ➞ true\n  */\nconst evenOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return false;\n  }\n  return isInteger(x + y);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddEvenOdd(5, 2, 7) ➞ false\n  oddEvenOdd(3, 2, 2) ➞ true\n  oddEvenOdd(3, -2, 1) ➞ false\n  oddEvenOdd(3.6, -2.2, 2) ➞ true\n  */\nconst oddEvenOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return false;\n  }\n  return isInteger(x + y);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7) ➞ false\n  evenOdd(3, 2, 2) ➞ true\n  evenOdd(3, -2, 1) ➞ false\n  evenOdd(3.6, -2.2, 2) ➞ true\n  */\nconst evenOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return false;\n  }\n  return isInteger(x + y);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddEvenOdd(5, 2, 7) ➞ false\n  oddEvenOdd(3, 2, 2) ➞ true\n  oddEvenOdd(3, -2, 1) ➞ false\n  oddEvenOdd(3.6, -2.2, 2) ➞ true\n  */\nconst oddEvenOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return false;\n  }\n  return isInteger(x + y);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7) ➞ false\n  evenOdd(3, 2, 2) ➞ true\n  evenOdd(3, -2, 1) ➞ false\n  evenOdd(3.6, -2.2, 2) ➞ true\n  */\nconst evenOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return false;\n  }\n  return isInteger(x + y);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddEvenOdd(5, 2, 7) ➞ false\n  oddEvenOdd(3, 2, 2) ➞ true\n  oddEvenOdd(3, -2, 1) ➞ false\n  oddEvenOdd(3.6, -2.2, 2) ➞ true\n  */\nconst oddEvenOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return false;\n  }\n  return isInteger(x + y);\n};\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  even", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsIndex = 0;\n  let vowelsCount = 0;\n  let vowelsIndex2 = 0;\n  let vowelsCount2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsCount3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsCount4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsCount5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsCount6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsCount7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsCount8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsCount9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsCount10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsCount11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsCount12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsCount13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsCount14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsCount15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsCount16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsCount17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsCount18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsCount19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsCount20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsCount21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsCount22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsCount23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsCount24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsCount25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsCount26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsCount27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsCount28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsCount29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsCount30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsCount31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsCount32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsCount33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsCount34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsCount35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsCount36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsCount37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsCount38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsCount39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsCount40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsCount41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsCount42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsCount43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsCount44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsCount45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsCount46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsCount47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsCount48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsCount49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsCount50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsCount51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsCount52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsCount53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsCount54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsCount55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsCount56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsCount57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsCount58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsCount59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsCount60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsCount61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsCount62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsCount63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsCount64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsCount65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsCount66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsCount67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsCount68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsCount69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsCount70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsCount71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsCount72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsCount73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsCount74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsCount75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsCount76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsCount77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsCount78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsCount79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsCount80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsCount81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsCount82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsCount83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsCount84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsCount85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsCount86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsCount87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsCount88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsCount89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsCount90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsCount91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsCount92 = 0;\n  let vowelsIndex93 = 0;\n  let vowelsCount93 = 0;\n  let vowelsIndex94 = 0;\n  let vowelsCount94 = 0;\n  let vowelsIndex95 = 0;\n  let vowelsCount95 = 0;\n  let vowelsIndex96 = 0;\n  let vowelsCount96 = 0;\n  let vowelsIndex97 = 0;\n  let vowelsCount97 = 0;\n  let vowelsIndex98 = 0;\n  let vowelsCount98 = 0;\n  let vowelsIndex99 = 0;\n  let vowelsCount99 = 0;\n  let vowelsIndex100 = 0;\n  let vowelsCount100 = 0;\n  let vowelsIndex101 = 0;\n  let vowelsCount101 = 0;\n  let vowelsIndex102 = 0;\n  let vowelsCount102 = 0;\n  let vowelsIndex", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  let count = 0;\n  let primes = [];\n  let prime;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let sum2;\n  let sum3;\n  let sum4;\n  let sum5;\n  let sum6;\n  let sum7;\n  let sum8;\n  let sum9;\n  let sum10;\n  let sum11;\n  let sum12;\n  let sum13;\n  let sum14;\n  let sum15;\n  let sum16;\n  let sum17;\n  let sum18;\n  let sum19;\n  let sum20;\n  let sum21;\n  let sum22;\n  let sum23;\n  let sum24;\n  let sum25;\n  let sum26;\n  let sum27;\n  let sum28;\n  let sum29;\n  let sum30;\n  let sum31;\n  let sum32;\n  let sum33;\n  let sum34;\n  let sum35;\n  let sum36;\n  let sum37;\n  let sum38;\n  let sum39;\n  let sum40;\n  let sum41;\n  let sum42;\n  let sum43;\n  let sum44;\n  let sum45;\n  let sum46;\n  let sum47;\n  let sum48;\n  let sum49;\n  let sum50;\n  let sum51;\n  let sum52;\n  let sum53;\n  let sum54;\n  let sum55;\n  let sum56;\n  let sum57;\n  let sum58;\n  let sum59;\n  let sum60;\n  let sum61;\n  let sum62;\n  let sum63;\n  let sum64;\n  let sum65;\n  let sum66;\n  let sum67;\n  let sum68;\n  let sum69;\n  let sum70;\n  let sum71;\n  let sum72;\n  let sum73;\n  let sum74;\n  let sum75;\n  let sum76;\n  let sum77;\n  let sum78;\n  let sum79;\n  let sum80;\n  let sum81;\n  let sum82;\n  let sum83;\n  let sum84;\n  let sum85;\n  let sum86;\n  let sum87;\n  let sum88;\n  let sum89;\n  let sum90;\n  let sum91;\n  let sum92;\n  let sum93;\n  let sum94;\n  let sum95;\n  let sum96;\n  let sum97;\n  let sum98;\n  let sum99;\n  let sum100;\n  let sum101;\n  let sum102;\n  let sum103;\n  let sum104;\n  let sum105;\n  let sum106;\n  let sum107;\n  let sum108;\n  let sum109;\n  let sum110;\n  let sum111;\n  let sum112;\n  let sum113;\n  let sum114;\n  let sum115;\n  let sum116;\n  let sum117;\n  let sum118;\n  let sum119;\n  let sum120;\n  let sum121;\n  let sum122;\n  let sum123;\n  let sum124;\n  let sum125;\n  let sum126;\n  let sum127;\n  let sum128;\n  let sum129;\n  let sum130;\n  let sum131;\n  let sum132;\n  let sum133;\n  let sum134;\n  let sum135;\n  let sum136;\n  let sum137;\n  let sum138;\n  let sum139;\n  let sum140;\n  let sum141;\n  let sum142;\n  let sum143;\n  let sum144;\n  let sum145;\n  let sum146;\n  let sum147;\n  let sum148;\n  let sum149;\n  let sum150;\n  let sum151;\n  let sum152;\n  let sum153;\n  let sum154;\n  let sum155;\n  let sum156;\n  let sum157;\n  let sum158;\n  let sum159;\n  let sum160;\n  let sum161;\n  let sum162;\n  let sum163;\n  let sum164;\n  let sum165;\n  let sum166;\n  let sum167;\n  let sum168;\n  let sum169;\n  let sum170;\n  let sum171;\n  let sum172;\n  let sum173;\n  let sum174;\n  let sum175;\n  let sum176;\n  let sum177;\n  let sum178;\n  let sum179;\n  let sum180;\n  let sum181;\n  let sum182;\n  let sum183;\n  let sum184;\n  let sum185;\n  let sum186;\n  let sum187;\n  let sum188;\n  let sum189;\n  let sum190;\n  let sum191;\n  let sum192;\n  let sum193;\n  let sum194;\n  let sum195;\n  let sum196;\n  let sum197;\n  let sum198;\n  let sum199;\n  let sum200;\n  let sum201;\n  let sum202;\n  let sum203;\n  let sum204;\n  let sum205;\n  let sum206;\n  let sum207;\n  let sum208;\n  let sum209;\n  let sum210;\n  let sum211;\n  let sum212;\n  let sum213;\n  let sum214;\n  let sum215;\n  let sum216;\n  let sum217;\n  let sum218;\n  let sum219;\n  let sum220;\n  let sum221;\n  let sum222;\n  let sum223;\n  let sum224;\n  let sum225;\n  let sum226;\n  let sum227;\n  let sum228;\n  let sum229;\n  let sum230;\n  let sum231;\n  let sum232;\n  let sum233;\n  let sum234;\n  let sum235;\n  let sum236;\n  let sum237;\n  let sum238;\n  let sum239;\n  let sum240;\n  let sum241;\n  let sum242;\n  let sum243;\n  let sum244;\n  let sum245;\n  let sum246;\n  let sum247;\n  let sum248;\n  let sum249;\n  let sum250;\n  let sum251;\n  let sum252;\n  let sum253;\n  let sum254;\n  let sum255;\n  let sum256;\n  let sum257;\n  let sum258;\n  let sum259;\n  let sum260;\n  let sum261;\n  let sum262;\n  let sum263;\n  let sum264;\n  let sum265;\n  let sum266;\n  let sum267;\n  let sum268;\n  let sum269;\n  let sum270;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  determineDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  determineDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  determineDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  determineDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  determineDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst determineDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "determineDictCase", "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  determineDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  determineDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  determineDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  determineDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  determineDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst determineDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let allKeysAreStrings = keys.every(key => typeof dict[key] ==='string');\n  return allKeysAreStrings;\n};\n\n/*\n  Given a string, return true if all characters are digits, else return false.\n  The function should return false is the given string contains only digits, \n  or if the string contains only letters.\n  Examples:\n  determineStringCase(\"12\") should return true.\n  determineStringCase(\"12a\") should return false.\n  determineStringCase(\"12A\") should return false.\n  determineStringCase(\"12aA\") should return false.\n  determineStringCase(\"12aAa\") should return false.\n  determineStringCase(\"12aAaA\") should return false.\n  determineStringCase(\"12aAaAa\") should return false.\n  determineStringCase(\"12aAaAaA\") should return false.\n  determineStringCase(\"12aAaAaAa\") should return false.\n  determineStringCase(\"12aAaAaAaAa\") should return false.\n  determineStringCase(\"12aAaAaAaAaAaA\") should return false.\n  determineStringCase(\"12aAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaA", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "considerUpTo", "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  breed(148, 412) should return 16.\n  breed(19, 28) should return 72.\n  breed(2020, 1851) should return 0.\n  breed(14,-15) should return 20.\n  */\nconst breed = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "breed", "gc": "<|endoftext|>/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  breed(148, 412) should return 16.\n  breed(19, 28) should return 72.\n  breed(2020, 1851) should return 0.\n  breed(14,-15) should return 20.\n  */\nconst breed = (a, b) => {\n  let product = 1;\n  let digit;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let sum;\n  let sum2;\n  let sum3;\n  let sum4;\n  let sum5;\n  let sum6;\n  let sum7;\n  let sum8;\n  let sum9;\n  let sum10;\n  let sum11;\n  let sum12;\n  let sum13;\n  let sum14;\n  let sum15;\n  let sum16;\n  let sum17;\n  let sum18;\n  let sum19;\n  let sum20;\n  let sum21;\n  let sum22;\n  let sum23;\n  let sum24;\n  let sum25;\n  let sum26;\n  let sum27;\n  let sum28;\n  let sum29;\n  let sum30;\n  let sum31;\n  let sum32;\n  let sum33;\n  let sum34;\n  let sum35;\n  let sum36;\n  let sum37;\n  let sum38;\n  let sum39;\n  let sum40;\n  let sum41;\n  let sum42;\n  let sum43;\n  let sum44;\n  let sum45;\n  let sum46;\n  let sum47;\n  let sum48;\n  let sum49;\n  let sum50;\n  let sum51;\n  let sum52;\n  let sum53;\n  let sum54;\n  let sum55;\n  let sum56;\n  let sum57;\n  let sum58;\n  let sum59;\n  let sum60;\n  let sum61;\n  let sum62;\n  let sum63;\n  let sum64;\n  let sum65;\n  let sum66;\n  let sum67;\n  let sum68;\n  let sum69;\n  let sum70;\n  let sum71;\n  let sum72;\n  let sum73;\n  let sum74;\n  let sum75;\n  let sum76;\n  let sum77;\n  let sum78;\n  let sum79;\n  let sum80;\n  let sum81;\n  let sum82;\n  let sum83;\n  let sum84;\n  let sum85;\n  let sum86;\n  let sum87;\n  let sum88;\n  let sum89;\n  let sum90;\n  let sum91;\n  let sum92;\n  let sum93;\n  let sum94;\n  let sum95;\n  let sum96;\n  let sum97;\n  let sum98;\n  let sum99;\n  let sum100;\n  let sum101;\n  let sum102;\n  let sum103;\n  let sum104;\n  let sum105;\n  let sum106;\n  let sum107;\n  let sum108;\n  let sum109;\n  let sum110;\n  let sum111;\n  let sum112;\n  let sum113;\n  let sum114;\n  let sum115;\n  let sum116;\n  let sum117;\n  let sum118;\n  let sum119;\n  let sum120;\n  let sum121;\n  let sum122;\n  let sum123;\n  let sum124;\n  let sum125;\n  let sum126;\n  let sum127;\n  let sum128;\n  let sum129;\n  let sum130;\n  let sum131;\n  let sum132;\n  let sum133;\n  let sum134;\n  let sum135;\n  let sum136;\n  let sum137;\n  let sum138;\n  let sum139;\n  let sum140;\n  let sum141;\n  let sum142;\n  let sum143;\n  let sum144;\n  let sum145;\n  let sum146;\n  let sum147;\n  let sum148;\n  let sum149;\n  let sum150;\n  let sum151;\n  let sum152;\n  let sum153;\n  let sum154;\n  let sum155;\n  let sum156;\n  let sum157;\n  let sum158;\n  let sum159;\n  let sum160;\n  let sum161;\n  let sum162;\n  let sum163;\n  let sum164;\n  let sum165;\n  let sum166;\n  let sum167;\n  let sum168;\n  let sum169;\n  let sum170;\n  let sum171;\n  let sum172;\n  let sum173;\n  let sum174;\n  let sum175;\n  let sum176;\n  let sum177;\n  let sum178;\n  let sum179;\n  let sum180;\n  let sum181;\n  let sum182;\n  let sum183;\n  let sum184;\n  let sum185;\n  let sum186;\n  let sum187;\n  let sum188;\n  let sum189;\n  let sum190;\n  let sum191;\n  let sum192;\n  let sum193;\n  let sum194;\n  let sum195;\n  let sum196;\n  let sum197;\n  let sum198;\n  let sum199;\n  let sum200;\n  let sum201;\n  let sum202;\n  let sum203;\n  let sum204;\n  let sum205;\n  let sum206;\n  let sum207;\n  let sum208;\n  let sum209;\n  let sum210;\n  let sum211;\n  let sum212;\n  let sum213;\n  let sum214;\n  let sum215;\n  let sum216;\n  let sum217;\n  let sum218;\n  let sum219;\n  let sum220;\n  let sum221;\n  let sum222;\n  let sum223;\n  let sum224;\n  let sum225;\n  let sum226;\n  let sum227;\n  let sum228;\n  let sum229;\n  let sum230;\n  let sum231;\n  let sum232;\n  let sum233;\n  let sum234;\n  let sum235;\n  let sum236;\n  let sum237;\n  let sum238;\n  let sum239;\n  let sum240;\n  let sum241;\n  let sum242;\n  let sum243;\n  let sum244;\n  let sum245;\n  let sum246;\n  let sum247;\n  let sum248;\n  let sum249;\n  let sum250;\n  let sum251;\n  let sum252;\n  let sum253;\n  let sum254;\n  let sum255;\n  let sum256;\n  let sum257;\n  let sum258;\n  let sum259;\n  let sum260;\n  let sum261;\n  let sum262;\n  let sum263;\n  let sum264;\n  let sum265;\n  let sum266;\n  let sum267;\n  let sum268;\n  let sum269;\n  let sum270;\n  let sum271;\n  let sum272;\n  let sum273;\n  let sum274;\n  let sum275;\n  let sum276;\n  let sum277;\n  let sum278;\n  let sum279;\n  let sum280;\n  let sum281;\n  let sum282;\n  let sum283;\n  let sum284;\n  let sum285;\n  let sum286;\n  let sum287;\n  let sum288;\n  let sum289;\n  let sum29", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  considerUpper('aBCdEf') returns 1\n  considerUpper('abcdefg') returns 0\n  considerUpper('dBBE') returns 0\n  */\nconst considerUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "considerUpper", "gc": "<|endoftext|>/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  considerUpper('aBCdEf') returns 1\n  considerUpper('abcdefg') returns 0\n  considerUpper('dBBE') returns 0\n  */\nconst considerUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let upper = false;\n  let vowel = false;\n  \n  for(let i = 0; i < l; i++) {\n    if(s[i] >= 'a' && s[i] <= 'z') {\n      upper = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n    else if(s[i] >= 'A' && s[i] <= 'Z') {\n      upper = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n    else if(s[i] >= '0' && s[i] <= '9') {\n      vowel = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n  }\n  \n  if(upper) {\n    for(let j = 0; j < l; j++) {\n      if(s[j] >= 'a' && s[j] <= 'z') {\n        count += 1;\n      }\n      else if(s[j] >= 'A' && s[j] <= 'Z') {\n        count += 1;\n      }\n      else if(s[j] >= '0' && s[j] <= '9') {\n        count += 1;\n      }\n    }\n  }\n  \n  if(vowel) {\n    for(let k = 0; k < l; k++) {\n      if(s[k] >= 'a' && s[k] <= 'z') {\n        count += 1;\n      }\n      else if(s[k] >= 'A' && s[k] <= 'Z') {\n        count += 1;\n      }\n      else if(s[k] >= '0' && s[k] <= '9') {\n        count += 1;\n      }\n    }\n  }\n  \n  return count;\n}\n\n/*\n  Given a string s, count the number of lowercase vowels in even indices.\n  \n  For example:\n  considerLower('aBCdEf') returns 1\n  considerLower('abcdefg') returns 0\n  considerLower('dBBE') returns 0\n  */\nconst considerLower = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let lower = false;\n  let vowel = false;\n  \n  for(let i = 0; i < l; i++) {\n    if(s[i] >= 'a' && s[i] <= 'z') {\n      lower = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n    else if(s[i] >= 'A' && s[i] <= 'Z') {\n      lower = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n    else if(s[i] >= '0' && s[i] <= '9') {\n      vowel = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n  }\n  \n  if(lower) {\n    for(let j = 0; j < l; j++) {\n      if(s[j] >= 'a' && s[j] <= 'z') {\n        count += 1;\n      }\n      else if(s[j] >= 'A' && s[j] <= 'Z') {\n        count += 1;\n      }\n      else if(s[j] >= '0' && s[j] <= '9') {\n        count += 1;\n      }\n    }\n  }\n  \n  if(vowel) {\n    for(let k = 0; k < l; k++) {\n      if(s[k] >= 'a' && s[k] <= 'z') {\n        count += 1;\n      }\n      else if(s[k] >= 'A' && s[k] <= 'Z') {\n        count += 1;\n      }\n      else if(s[k] >= '0' && s[k] <= '9') {\n        count += 1;\n      }\n    }\n  }\n  \n  return count;\n}\n\n/*\n  Given a string s, count the number of digits in even indices.\n  \n  For example:\n  considerDigits('aBCdEf') returns 1\n  considerDigits('abcdefg') returns 0\n  considerDigits('dBBE') returns 0\n  */\nconst considerDigits = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let digit = false;\n  let vowel = false;\n  \n  for(let i = 0; i < l; i++) {\n    if(s[i] >= '0' && s[i] <= '9') {\n      digit = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n    else if(s[i] >= 'A' && s[i] <= 'Z') {\n      digit = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n    else if(s[i] >= 'a' && s[i] <= 'z') {\n      vowel = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n  }\n  \n  if(digit) {\n    for(let j = 0; j < l; j++) {\n      if(s[j] >= '0' && s[j] <= '9') {\n        count += 1;\n      }\n      else if(s[j] >= 'A' && s[j] <= 'Z') {\n        count += 1;\n      }\n      else if(s[j] >= 'a' && s[j] <= 'z') {\n        vowel = true;\n        if(s[j] === s[i+1]) {\n          i++;\n        }\n      }\n    }\n  }\n  \n  if(vowel) {\n    for(let k = 0; k < l; k++) {\n      if(s[k] >= '0' && s[k] <= '9') {\n        count += 1;\n      }\n      else if(s[k] >= 'A' && s[k] <= 'Z') {\n        count += 1;\n      }\n      else if(s[k] >= 'a' && s[k] <= 'z') {\n        vowel = true;\n        if(s[k] === s[i+1]) {\n          i++;\n        }\n      }\n    }\n  }\n  \n  return count;\n}\n\n/*\n  Given a string s, count the number of spaces in even indices.\n  \n  For example:\n  considerSpace('aBCdEf') returns 1\n  considerSpace('abcdefg') returns 0\n  considerSpace('dBBE') returns 0\n  */\nconst considerSpace = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let space = false;\n  let vowel = false;\n  \n  for(let i = 0; i < l; i++) {\n    if(s[i] >='' && s[i] <= '~') {\n      space = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n    else if(s[i] >= 'A' && s[i] <= 'Z') {\n      space = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n    else if(s[i] >= 'a' && s[i] <= 'z') {\n      vowel = true;\n      if(s[i] === s[i+1]) {\n        i++;\n      }\n    }\n  }\n  \n  if(space) {\n    for(let j = 0; j < l; j++) {\n      if(s[j] >='' && s[j] <= '~') {\n        count += 1;\n      }\n      else if(s[j] >= 'A' && s[j] <= 'Z') {\n        count += 1;\n      }\n      else if(s[j] >= 'a' && s[j] <= 'z') {\n        vowel = true;\n        if(s[j] === s[i+1]) {\n          i++;\n        }\n      }\n    }\n  }\n  \n  if(vowel) {\n    for(let k = 0; k < l; k++) {\n      if(s[k] >='' && s[k] <= '~') {\n        count += 1;\n      }\n      else if(s[k] >= 'A' && s[k] <= 'Z') {\n        count += 1;\n      }\n      else if(s[k] >= 'a' && s[k] <= 'z') {\n        vowel = true;\n        if(s[k] === s[i+1]) {\n          i++;\n        }", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closeInteger(\"10\")\n  10\n  >>> closeInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closeInteger(\"14.5\") should\n  return 15 and closeInteger(\"-14.5\") should return -15.\n  */\nconst closeInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closeInteger", "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closeInteger(\"10\")\n  10\n  >>> closeInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closeInteger(\"14.5\") should\n  return 15 and closeInteger(\"-14.5\") should return -15.\n  */\nconst closeInteger = (value) => {\n  const [integer, fraction] = value.split(\".\");\n  const [integer1, integer2] = integer.split(\"-\");\n  const [integer3, integer4] = fraction.split(\".\");\n  const [integer5] = integer4.split(\"-\");\n  const [integer6, integer7] = integer5.split(\".\");\n  const [integer8] = integer7.split(\"-\");\n  const [integer9, integer10] = integer8.split(\".\");\n  const [integer11, integer12] = integer9.split(\"-\");\n  const [integer13, integer14] = integer10.split(\".\");\n  const [integer15, integer16] = integer11.split(\"-\");\n  const [integer17, integer18] = integer12.split(\".\");\n  const [integer19, integer20] = integer13.split(\"-\");\n  const [integer21, integer22] = integer14.split(\".\");\n  const [integer23, integer24] = integer15.split(\"-\");\n  const [integer25, integer26] = integer16.split(\".\");\n  const [integer27, integer28] = integer17.split(\"-\");\n  const [integer29, integer30] = integer18.split(\".\");\n  const [integer31, integer32] = integer19.split(\"-\");\n  const [integer33, integer34] = integer20.split(\".\");\n  const [integer35, integer36] = integer21.split(\"-\");\n  const [integer37, integer38] = integer22.split(\".\");\n  const [integer39, integer40] = integer23.split(\"-\");\n  const [integer41, integer42] = integer24.split(\".\");\n  const [integer43, integer44] = integer25.split(\"-\");\n  const [integer45, integer46] = integer26.split(\".\");\n  const [integer47, integer48] = integer27.split(\"-\");\n  const [integer49, integer50] = integer28.split(\".\");\n  const [integer51, integer52] = integer29.split(\"-\");\n  const [integer53, integer54] = integer30.split(\".\");\n  const [integer55, integer56] = integer31.split(\"-\");\n  const [integer57, integer58] = integer32.split(\".\");\n  const [integer59, integer60] = integer33.split(\"-\");\n  const [integer61, integer62] = integer34.split(\".\");\n  const [integer63, integer64] = integer35.split(\"-\");\n  const [integer65, integer66] = integer36.split(\".\");\n  const [integer67, integer68] = integer37.split(\"-\");\n  const [integer69, integer70] = integer38.split(\".\");\n  const [integer71, integer72] = integer39.split(\"-\");\n  const [integer73, integer74] = integer40.split(\".\");\n  const [integer75, integer76] = integer41.split(\"-\");\n  const [integer77, integer78] = integer42.split(\".\");\n  const [integer79, integer80] = integer43.split(\"-\");\n  const [integer81, integer82] = integer44.split(\".\");\n  const [integer83, integer84] = integer45.split(\"-\");\n  const [integer85, integer86] = integer46.split(\".\");\n  const [integer87, integer88] = integer47.split(\"-\");\n  const [integer89, integer90] = integer48.split(\".\");\n  const [integer91, integer92] = integer49.split(\"-\");\n  const [integer93, integer94] = integer50.split(\".\");\n  const [integer95, integer96] = integer51.split(\"-\");\n  const [integer97, integer98] = integer52.split(\".\");\n  const [integer99, integer100] = integer53.split(\"-\");\n  const [integer101, integer102] = integer54.split(\".\");\n  const [integer103, integer104] = integer55.split(\"-\");\n  const [integer105, integer106] = integer56.split(\".\");\n  const [integer107, integer108] = integer57.split(\"-\");\n  const [integer109, integer110] = integer58.split(\".\");\n  const [integer111, integer112] = integer59.split(\"-\");\n  const [integer113, integer114] = integer60.split(\".\");\n  const [integer115, integer116] = integer61.split(\"-\");\n  const [integer117, integer118] = integer62.split(\".\");\n  const [integer119, integer120] = integer63.split(\"-\");\n  const [integer121, integer122] = integer64.split(\".\");\n  const [integer123, integer124] = integer65.split(\"-\");\n  const [integer125, integer126] = integer66.split(\".\");\n  const [integer127, integer128] = integer67.split(\"-\");\n  const [integer129, integer130] = integer68.split(\".\");\n  const [integer131, integer132] = integer69.split(\"-\");\n  const [integer133, integer134] = integer70.split(\".\");\n  const [integer135, integer136] = integer71.split(\"-\");\n  const [integer137, integer138] = integer72.split(\".\");\n  const [integer139, integer140] = integer73.split(\"-\");\n  const [integer141, integer142] = integer74.split(\".\");\n  const [integer143, integer144] = integer75.split(\"-\");\n  const [integer145, integer146] = integer76.split(\".\");\n  const [integer147, integer148] = integer77.split(\"-\");\n  const [integer149, integer150] = integer78.split(\".\");\n  const [integer151, integer152] = integer79.split(\"-\");\n  const [integer153, integer154] = integer80.split(\".\");\n  const [integer155, integer156] = integer81.split(\"-\");\n  const [integer157, integer158] = integer82.split(\".\");\n  const [integer159, integer160] = integer83.split(\"-\");\n  const [integer161, integer162] = integer84.split(\".\");\n  const [integer163, integer164] = integer85.split(\"-\");\n  const [integer165, integer166] = integer86.split(\".\");\n  const [integer167, integer168] = integer87.split(\"-\");\n  const [integer169, integer170] = integer88.split(\".\");\n  const [integer171, integer172] = integer89.split(\"-\");\n  const [integer173, integer174] = integer90.split(\".\");\n  const [integer175, integer176] = integer91.split(\"-\");\n  const [integer177, integer178] = integer92.split(\".\");\n  const [integer179, integer180] = integer93.split(\"-\");\n  const [integer181, integer182] = integer94.split(\".\");\n  const [integer183, integer184] = integer95.split(\"-\");\n  const [integer185, integer186] = integer96.split(\".\");\n  const [integer187, integer188] = integer97.split(\"-\");\n  const [integer189, integer190] = integer98.split(\".\");\n  const [integer191, integer192] = integer99.split(\"-\");\n  const [integer193, integer194] = integer100.split(\".\");\n  const [integer195, integer196] = integer101.", "passed": 0, "run_status": 2}
