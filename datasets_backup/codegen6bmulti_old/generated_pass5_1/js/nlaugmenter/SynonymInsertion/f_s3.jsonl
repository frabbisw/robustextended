{"task_id": "JavaScript/0", "prompt": "/* Check match if in given contribute list of numbers, are any two numbers closer near to each other than \n   given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 3, "perturbed": true, "gc": "/* Check match if in given contribute list of numbers, are any two numbers closer near to each other than \n   given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sorted = numbers.sort();\n  const len = sorted.length;\n  let i = 0;\n  let j = len - 1;\n  while (i < j) {\n    const diff = sorted[i] - sorted[j];\n    if (Math.abs(diff) < threshold) {\n      return true;\n    }\n    i++;\n    j--;\n  }\n  return false;\n};\n\nexport default hasCloseElements;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/1", "prompt": "/* Input stimulation to this function routine is a string containing contain multiple groups of nested cuddle parentheses parenthesis. Your goal is to \n   separate those group into separate freestanding strings string and return the list of those. \n   Separate groups are balanced (each open brace is properly by rights closed shut) and not nested within each other \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 3, "perturbed": true, "gc": "/* Input stimulation to this function routine is a string containing contain multiple groups of nested cuddle parentheses parenthesis. Your goal is to \n   separate those group into separate freestanding strings string and return the list of those. \n   Separate groups are balanced (each open brace is properly by rights closed shut) and not nested within each other \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_list = paren_string.split(')')\n  const paren_list_length = paren_list.length\n  const paren_list_length_minus_1 = paren_list_length - 1\n  const paren_list_length_minus_2 = paren_list_length - 2\n  const paren_list_length_minus_3 = paren_list_length - 3\n  const paren_list_length_minus_4 = paren_list_length - 4\n  const paren_list_length_minus_5 = paren_list_length - 5\n  const paren_list_length_minus_6 = paren_list_length - 6\n  const paren_list_length_minus_7 = paren_list_length - 7\n  const paren_list_length_minus_8 = paren_list_length - 8\n  const paren_list_length_minus_9 = paren_list_length - 9\n  const paren_list_length_minus_10 = paren_list_length - 10\n  const paren_list_length_minus_11 = paren_list_length - 11\n  const paren_list_length_minus_12 = paren_list_length - 12\n  const paren_list_length_minus_13 = paren_list_length - 13\n  const paren_list_length_minus_14 = paren_list_length - 14\n  const paren_list_length_minus_15 = paren_list_length - 15\n  const paren_list_length_minus_16 = paren_list_length - 16\n  const paren_list_length_minus_17 = paren_list_length - 17\n  const paren_list_length_minus_18 = paren_list_length - 18\n  const paren_list_length_minus_19 = paren_list_length - 19\n  const paren_list_length_minus_20 = paren_list_length - 20\n  const paren_list_length_minus_21 = paren_list_length - 21\n  const paren_list_length_minus_22 = paren_list_length - 22\n  const paren_list_length_minus_23 = paren_list_length - 23\n  const paren_list_length_minus_24 = paren_list_length - 24\n  const paren_list_length_minus_25 = paren_list_length - 25\n  const paren_list_length_minus_26 = paren_list_length - 26\n  const paren_list_length_minus_27 = paren_list_length - 27\n  const paren_list_length_minus_28 = paren_list_length - 28\n  const paren_list_length_minus_29 = paren_list_length - 29\n  const paren_list_length_minus_30 = paren_list_length - 30\n  const paren_list_length_minus_31 = paren_list_length - 31\n  const paren_list_length_minus_32 = paren_list_length - 32\n  const paren_list_length_minus_33 = paren_list_length - 33\n  const paren_list_length_minus_34 = paren_list_length - 34\n  const paren_list_length_minus_35 = paren_list_length - 35\n  const paren_list_length_minus_36 = paren_list_length - 36\n  const paren_list_length_minus_37 = paren_list_length - 37\n  const paren_list_length_minus_38 = paren_list_length - 38\n  const paren_list_length_minus_39 = paren_list_length - 39\n  const paren_list_length_minus_40 = paren_list_length - 40\n  const paren_list_length_minus_41 = paren_list_length - 41\n  const paren_list_length_minus_42 = paren_list_length - 42\n  const paren_list_length_minus_43 = paren_list_length - 43\n  const paren_list_length_minus_44 = paren_list_length - 44\n  const paren_list_length_minus_45 = paren_list_length - 45\n  const paren_list_length_minus_46 = paren_list_length - 46\n  const paren_list_length_minus_47 = paren_list_length - 47\n  const paren_list_length_minus_48 = paren_list_length - 48\n  const paren_list_length_minus_49 = paren_list_length - 49\n  const paren_list_length_minus_50 = paren_list_length - 50\n  const paren_list_length_minus_51 = paren_list_length - 51\n  const paren_list_length_minus_52 = paren_list_length - 52\n  const paren_list_length_minus_53 = paren_list_length - 53\n  const paren_list_length_minus_54 = paren_list_length - 54\n  const paren_list_length_minus_55 = paren_list_length - 55\n  const paren_list_length_minus_56 = paren_list_length - 56\n  const paren_list_length_minus_57 = paren_list_length - 57\n  const paren_list_length_minus_58 = paren_list_length - 58\n  const paren_list_length_minus_59 = paren_list_length - 59\n  const paren_list_length_minus_60 = paren_list_length - 60\n  const paren_list_length_minus_61 = paren_list_length - 61\n  const paren_list_length_minus_62 = paren_list_length - 62\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let i = 0;\n  let j = string.length - 1;\n  while (i < j) {\n    if (string[i] === string[j]) {\n      prefix += string[i];\n      suffix = string.slice(i + 1, j);\n      break;\n    }\n    i++;\n    j--;\n  }\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that begins with the supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> longestPalindrome('cata')\n  'catac'\n  >>> longestPalindrome('cata')\n  'catac'\n  >>> longestPalindrome('cata')\n  'catac'\n  */\nconst longestPalindrome = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let i = 0;\n  let j = string.length - 1;\n  while (i < j) {\n    if (string[i] === string[j]) {\n      prefix += string[i];\n      suffix = string.slice(i + 1, j);\n      break;\n    }\n    i++;\n    j--;\n  }\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that ends with the supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> longestPalindrome('cat')\n  'catac'\n  >>> longestPalindrome('cat')\n  'catac'\n  >>> longestPalindrome('cat')\n  'catac'\n  */\nconst longestPalindromeEnding = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let i = 0;\n  let j = string.length - 1;\n  while (i < j) {\n    if (string[i] === string[j]) {\n      prefix = string.slice(0, i + 1);\n      suffix = string.slice(j + 1, string.length);\n      break;\n    }\n    i++;\n    j--;\n  }\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that begins with the supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> longestPalindrome('cata')\n  'catac'\n  >>> longestPalindrome('cata')\n  'catac'\n  >>> longestPalindrome('cata')\n  'catac'\n  */\nconst longestPalindromeStarting = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let i = 0;\n  let j = string.length - 1;\n  while (i < j) {\n    if (string[i] === string[j]) {\n      prefix = string.slice(i, string.length - i);\n      suffix = string.slice(0, j + 1);\n      break;\n    }\n    i++;\n    j--;\n  }\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that contains the supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> longestPalindrome('cat')\n  'catac'\n  >>> longestPalindrome('cat')\n  'catac'\n  >>> longestPalindrome('cat')\n  'catac'\n  */\nconst longestPalindromeContaining = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let i = 0;\n  let j = string.length - 1;\n  while (i < j) {\n    if (string[i] === string[j]) {\n      prefix = string.slice(0, i + 1);\n      suffix = string.slice(i + 1, string.length - i);\n      break;\n    }\n    i++;\n    j--;\n  }\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that contains the supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> longestPalindrome('cata')\n  'catac'\n  >>> longestPalindrome('cata')\n  'catac'\n  >>> longestPalindrome('cata')\n  'catac'\n  */\nconst longestPalindromeIncluding = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let i = 0;\n  let j = string.length - 1;\n  while (i < j) {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const num = i;\n    if (num % 2 === 0) {\n      result.push(num);\n    } else {\n      result.push(num + 1);\n    }\n  }\n  return result;\n};\n\nconsole.log(makeAPile(3));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 3, "perturbed": true, "gc": "/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string password and a dictionary of words. Your task is to return a boolean value indicating whether the password is a valid password.\n  \n  For example:\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == true\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == false\n  */\nconst isValidPassword = (password, dictionary) => {\n  let words = wordsString(password);\n  let valid = true;\n  for (let i = 0; i < words.length; i++) {\n    if (dictionary.indexOf(words[i]) === -1) {\n      valid = false;\n    }\n  }\n  return valid;\n};\n\n/*\n  You will be given a string password and a dictionary of words. Your task is to return a boolean value indicating whether the password is a valid password.\n  \n  For example:\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == true\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == false\n  */\nconst isValidPassword2 = (password, dictionary) => {\n  let words = wordsString(password);\n  let valid = true;\n  for (let i = 0; i < words.length; i++) {\n    if (dictionary.indexOf(words[i]) === -1) {\n      valid = false;\n    }\n  }\n  return valid;\n};\n\n/*\n  You will be given a string password and a dictionary of words. Your task is to return a boolean value indicating whether the password is a valid password.\n  \n  For example:\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == true\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == false\n  */\nconst isValidPassword3 = (password, dictionary) => {\n  let words = wordsString(password);\n  let valid = true;\n  for (let i = 0; i < words.length; i++) {\n    if (dictionary.indexOf(words[i]) === -1) {\n      valid = false;\n    }\n  }\n  return valid;\n};\n\n/*\n  You will be given a string password and a dictionary of words. Your task is to return a boolean value indicating whether the password is a valid password.\n  \n  For example:\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == true\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == false\n  */\nconst isValidPassword4 = (password, dictionary) => {\n  let words = wordsString(password);\n  let valid = true;\n  for (let i = 0; i < words.length; i++) {\n    if (dictionary.indexOf(words[i]) === -1) {\n      valid = false;\n    }\n  }\n  return valid;\n};\n\n/*\n  You will be given a string password and a dictionary of words. Your task is to return a boolean value indicating whether the password is a valid password.\n  \n  For example:\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == true\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == false\n  */\nconst isValidPassword5 = (password, dictionary) => {\n  let words = wordsString(password);\n  let valid = true;\n  for (let i = 0; i < words.length; i++) {\n    if (dictionary.indexOf(words[i]) === -1) {\n      valid = false;\n    }\n  }\n  return valid;\n};\n\n/*\n  You will be given a string password and a dictionary of words. Your task is to return a boolean value indicating whether the password is a valid password.\n  \n  For example:\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == true\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == false\n  */\nconst isValidPassword6 = (password, dictionary) => {\n  let words = wordsString(password);\n  let valid = true;\n  for (let i = 0; i < words.length; i++) {\n    if (dictionary.indexOf(words[i]) === -1) {\n      valid = false;\n    }\n  }\n  return valid;\n};\n\n/*\n  You will be given a string password and a dictionary of words. Your task is to return a boolean value indicating whether the password is a valid password.\n  \n  For example:\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == true\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == false\n  */\nconst isValidPassword7 = (password, dictionary) => {\n  let words = wordsString(password);\n  let valid = true;\n  for (let i = 0; i < words.length; i++) {\n    if (dictionary.indexOf(words[i]) === -1) {\n      valid = false;\n    }\n  }\n  return valid;\n};\n\n/*\n  You will be given a string password and a dictionary of words. Your task is to return a boolean value indicating whether the password is a valid password.\n  \n  For example:\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) == true\n  isValidPassword(\"password\", [\"password\", \"password\", \"password\", \"password\", \"password\"]) ==", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest large even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 3, "perturbed": true, "gc": "/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest large even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = Math.floor((x + y) / 2);\n  while (max - min > 1) {\n    if (mid % 2 === 0) {\n      max = mid;\n    } else {\n      min = mid;\n    }\n    mid = Math.floor((max + min) / 2);\n  }\n  return mid;\n};\n\nconst chooseNum2 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum2(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = Math.floor((x + y) / 2);\n  while (max - min > 1) {\n    if (mid % 2 === 0) {\n      max = mid;\n    } else {\n      min = mid;\n    }\n    mid = Math.floor((max + min) / 2);\n  }\n  return mid;\n};\n\nconst chooseNum3 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum3(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = Math.floor((x + y) / 2);\n  while (max - min > 1) {\n    if (mid % 2 === 0) {\n      max = mid;\n    } else {\n      min = mid;\n    }\n    mid = Math.floor((max + min) / 2);\n  }\n  return mid;\n};\n\nconst chooseNum4 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum4(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = Math.floor((x + y) / 2);\n  while (max - min > 1) {\n    if (mid % 2 === 0) {\n      max = mid;\n    } else {\n      min = mid;\n    }\n    mid = Math.floor((max + min) / 2);\n  }\n  return mid;\n};\n\nconst chooseNum5 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum5(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = Math.floor((x + y) / 2);\n  while (max - min > 1) {\n    if (mid % 2 === 0) {\n      max = mid;\n    } else {\n      min = mid;\n    }\n    mid = Math.floor((max + min) / 2);\n  }\n  return mid;\n};\n\nconst chooseNum6 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum6(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = Math.floor((x + y) / 2);\n  while (max - min > 1) {\n    if (mid % 2 === 0) {\n      max = mid;\n    } else {\n      min = mid;\n    }\n    mid = Math.floor((max + min) / 2);\n  }\n  return mid;\n};\n\nconst chooseNum7 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum7(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = Math.floor((x + y) / 2);\n  while (max - min > 1) {\n    if (mid % 2 === 0) {\n      max = mid;\n    } else {\n      min = mid;\n    }\n    mid = Math.floor((max + min) / 2);\n  }\n  return mid;\n};\n\nconst chooseNum8 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum8(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = Math.floor((x + y) / 2);\n  while (max - min > 1) {\n    if (mid % 2 === 0) {\n      max = mid;\n    } else {\n      min = mid;\n    }\n    mid = Math.floor((max + min) / 2);\n  }\n  return mid;\n};\n\nconst chooseNum9 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum9(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = Math.floor((x + y) / 2);\n  while (max - min > 1) {\n    if (mid % 2 === 0) {\n      max = mid;\n    } else {\n      min = mid;\n    }\n    mid = Math.floor((max + min) / 2);\n  }\n  return mid;\n};\n\nconst chooseNum10 = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum10(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = Math.floor((x + y) / 2);\n  while (max", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given impart two positive convinced integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 3, "perturbed": true, "gc": "/*You are given impart two positive convinced integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  const sign = binary[0] === '1'? '-' : ''\n  return sign + roundedAvg\n}\n\nconsole.log(roundedAvg(1, 5))\nconsole.log(roundedAvg(7, 5))\nconsole.log(roundedAvg(10, 20))\nconsole.log(roundedAvg(20, 33))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 3, "perturbed": true, "gc": "/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x; i++) {\n    let digits = x.toString().split('').filter(digit => digit.length === 1);\n    let sorted = digits.sort((a, b) => a - b);\n    if (sorted.length === 0) {\n      result.push(x);\n    }\n  }\n  return result;\n};\n\nmodule.exports = uniqueDigits;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given impart an array of integers integer, sort the integers that are between 1 and 9 inclusive, \n   reverse invert the resulting array, and then replace supplant each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart an array of integers integer, sort the integers that are between 1 and 9 inclusive, \n   reverse invert the resulting array, and then replace supplant each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let result = [];\n  let length = arr.length;\n  let i = 0;\n  while (i < length) {\n    let current = arr[i];\n    let lengthOfDigits = current.toString().length;\n    let j = 0;\n    while (j < lengthOfDigits) {\n      let digit = current.toString().charAt(j);\n      let name = \"\";\n      if (digit === \"1\") {\n        name = \"One\";\n      } else if (digit === \"2\") {\n        name = \"Two\";\n      } else if (digit === \"3\") {\n        name = \"Three\";\n      } else if (digit === \"4\") {\n        name = \"Four\";\n      } else if (digit === \"5\") {\n        name = \"Five\";\n      } else if (digit === \"6\") {\n        name = \"Six\";\n      } else if (digit === \"7\") {\n        name = \"Seven\";\n      } else if (digit === \"8\") {\n        name = \"Eight\";\n      } else if (digit === \"9\") {\n        name = \"Nine\";\n      }\n      result.push(name);\n      j++;\n    }\n    i++;\n  }\n  return result;\n};\n\nconst byLengthReverse = (arr) => {\n  let result = [];\n  let length = arr.length;\n  let i = 0;\n  while (i < length) {\n    let current = arr[i];\n    let lengthOfDigits = current.toString().length;\n    let j = lengthOfDigits - 1;\n    while (j >= 0) {\n      let digit = current.toString().charAt(j);\n      let name = \"\";\n      if (digit === \"1\") {\n        name = \"One\";\n      } else if (digit === \"2\") {\n        name = \"Two\";\n      } else if (digit === \"3\") {\n        name = \"Three\";\n      } else if (digit === \"4\") {\n        name = \"Four\";\n      } else if (digit === \"5\") {\n        name = \"Five\";\n      } else if (digit === \"6\") {\n        name = \"Six\";\n      } else if (digit === \"7\") {\n        name = \"Seven\";\n      } else if (digit === \"8\") {\n        name = \"Eight\";\n      } else if (digit === \"9\") {\n        name = \"Nine\";\n      }\n      result.push(name);\n      j--;\n    }\n    i++;\n  }\n  return result;\n};\n\nconst byLengthReverse2 = (arr) => {\n  let result = [];\n  let length = arr.length;\n  let i = length - 1;\n  while (i >= 0) {\n    let current = arr[i];\n    let lengthOfDigits = current.toString().length;\n    let j = lengthOfDigits - 1;\n    while (j >= 0) {\n      let digit = current.toString().charAt(j);\n      let name = \"\";\n      if (digit === \"1\") {\n        name = \"One\";\n      } else if (digit === \"2\") {\n        name = \"Two\";\n      } else if (digit === \"3\") {\n        name = \"Three\";\n      } else if (digit === \"4\") {\n        name = \"Four\";\n      } else if (digit === \"5\") {\n        name = \"Five\";\n      } else if (digit === \"6\") {\n        name = \"Six\";\n      } else if (digit === \"7\") {\n        name = \"Seven\";\n      } else if (digit === \"8\") {\n        name = \"Eight\";\n      } else if (digit === \"9\") {\n        name = \"Nine\";\n      }\n      result.push(name);\n      j--;\n    }\n    i--;\n  }\n  return result;\n};\n\nconst byLengthReverse3 = (arr) => {\n  let result = [];\n  let length = arr.length;\n  let i = length - 1;\n  while (i >= 0) {\n    let current = arr[i];\n    let lengthOfDigits = current.toString().length;\n    let j = lengthOfDigits - 1;\n    while (j >= 0) {\n      let digit = current.toString().charAt(j);\n      let name = \"\";\n      if (digit === \"1\") {\n        name = \"One\";\n      } else if (digit === \"2\") {\n        name = \"Two\";\n      } else if (digit === \"3\") {\n        name = \"Three\";\n      } else if (digit === \"4\") {\n        name = \"Four\";\n      } else if (digit === \"5\") {\n        name = \"Five\";\n      } else if (digit === \"6\") {\n        name = \"Six\";\n      } else if (digit === \"7\") {\n        name = \"Seven\";\n      } else if (digit === \"8\") {\n        name = \"Eight\";\n      } else if (digit === \"9\") {\n        name = \"Nine\";\n      }\n      result.push(name);\n      j--;\n    }\n    i--;\n  }\n  return result;\n};\n\nconst byLengthReverse4 = (arr) => {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 3, "perturbed": true, "gc": "/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(Math.pow(i, n));\n    } else {\n      result.push(i * f(n - i));\n    }\n  }\n  return result;\n};\n\nconst f2 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f(i));\n  }\n  return result;\n};\n\nconst f3 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f2(i));\n  }\n  return result;\n};\n\nconst f4 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f3(i));\n  }\n  return result;\n};\n\nconst f5 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f4(i));\n  }\n  return result;\n};\n\nconst f6 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f5(i));\n  }\n  return result;\n};\n\nconst f7 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f6(i));\n  }\n  return result;\n};\n\nconst f8 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f7(i));\n  }\n  return result;\n};\n\nconst f9 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f8(i));\n  }\n  return result;\n};\n\nconst f10 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f9(i));\n  }\n  return result;\n};\n\nconst f11 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f10(i));\n  }\n  return result;\n};\n\nconst f12 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f11(i));\n  }\n  return result;\n};\n\nconst f13 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f12(i));\n  }\n  return result;\n};\n\nconst f14 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f13(i));\n  }\n  return result;\n};\n\nconst f15 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f14(i));\n  }\n  return result;\n};\n\nconst f16 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f15(i));\n  }\n  return result;\n};\n\nconst f17 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f16(i));\n  }\n  return result;\n};\n\nconst f18 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f17(i));\n  }\n  return result;\n};\n\nconst f19 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f18(i));\n  }\n  return result;\n};\n\nconst f20 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f19(i));\n  }\n  return result;\n};\n\nconst f21 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f20(i));\n  }\n  return result;\n};\n\nconst f22 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f21(i));\n  }\n  return result;\n};\n\nconst f23 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f22(i));\n  }\n  return result;\n};\n\nconst f24 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f23(i));\n  }\n  return result;\n};\n\nconst f25 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(f24(i));\n  }\n  return result;\n};\n\nconst f26 = (n) => {\n  const result = [];\n  for (let i = 1;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given impart a positive convinced integer n, return a tuple that has the number act of even and odd \n   integer palindromes that fall hang within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a positive convinced integer n, return a tuple that has the number act of even and odd \n   integer palindromes that fall hang within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const even = []\n  const odd = []\n  for (let i = 1; i <= n; i++) {\n    const palindrome = i.toString()\n    if (palindrome.length % 2 === 0) {\n      even.push(palindrome)\n    } else {\n      odd.push(palindrome)\n    }\n  }\n  return [...even,...odd]\n}\n\nexport default evenOddPalindrome\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (sum > 0) {\n      num++;\n      sum -= arr[i];\n    }\n  }\n  return num;\n};\n\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers integer arr[1], arr[2],... , arr[N].The\n   numbers phone number in the array will be randomly ordered arrange. Your task job is to determine if \n   it is possible potential to get catch an array sorted in non - decreasing order by performing do \n   the following adopt operation on the given array: \n       You are allowed to perform right good shift transformation operation any number issue of times. \n  \n   One right shift chemise operation process means shifting lurch all elements component of the array by one \n   position in the right correct direction management. The last element of the array will be moved move to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain the sorted array by performing perform the above operation \n   then return true else return false. \n   If the given array is empty then return true. \n\n   Note: The given move over list is guaranteed to have unique alone elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 3, "perturbed": true, "gc": "/*We have an array 'arr' of N integers integer arr[1], arr[2],..., arr[N].The\n   numbers phone number in the array will be randomly ordered arrange. Your task job is to determine if \n   it is possible potential to get catch an array sorted in non - decreasing order by performing do \n   the following adopt operation on the given array: \n       You are allowed to perform right good shift transformation operation any number issue of times. \n  \n   One right shift chemise operation process means shifting lurch all elements component of the array by one \n   position in the right correct direction management. The last element of the array will be moved move to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain the sorted array by performing perform the above operation \n   then return true else return false. \n   If the given array is empty then return true. \n\n   Note: The given move over list is guaranteed to have unique alone elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every((x, i) => x <= arr[i]);\n};\n\nconst moveOneBall2 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every((x, i) => x <= arr[i]);\n};\n\nconst moveOneBall3 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every((x, i) => x <= arr[i]);\n};\n\nconst moveOneBall4 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every((x, i) => x <= arr[i]);\n};\n\nconst moveOneBall5 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every((x, i) => x <= arr[i]);\n};\n\nconst moveOneBall6 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every((x, i) => x <= arr[i]);\n};\n\nconst moveOneBall7 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every((x, i) => x <= arr[i]);\n};\n\nconst moveOneBall8 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every((x, i) => x <= arr[i]);\n};\n\nconst moveOneBall9 = (arr) => {\n  if (arr.length === 0) {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 3, "perturbed": true, "gc": "/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringAnd('010', '110')\n  '00'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary NOT on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringNot('010')\n  '101'\n  */\nconst stringNot = (a) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === '1')? '0' : '1';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor2 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringAnd('010', '110')\n  '00'\n  */\nconst stringAnd2 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr2 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary NOT on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringNot('010')\n  '101'\n  */\nconst stringNot2 = (a) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === '1')? '0' : '1';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor3 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringAnd('010', '110')\n  '00'\n  */\nconst stringAnd3 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr3 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem trouble, you will implement follow through a function that takes consume two lists of numbers phone number, \n   and determines determine whether it is possible to perform an exchange of elements chemical element \n   between them to make reach lst1 a list of only even numbers. \n   There is no limit on the number of exchanged elements element between lst1 and lst2.\n   If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 3, "perturbed": true, "gc": "/*In this problem trouble, you will implement follow through a function that takes consume two lists of numbers phone number, \n   and determines determine whether it is possible to perform an exchange of elements chemical element \n   between them to make reach lst1 a list of only even numbers. \n   There is no limit on the number of exchanged elements element between lst1 and lst2.\n   If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let lst1_len = lst1.length;\n  let lst2_len = lst2.length;\n  let lst1_even = [];\n  let lst2_even = [];\n  let lst1_odd = [];\n  let lst2_odd = [];\n  let i = 0;\n  let j = 0;\n  while (i < lst1_len && j < lst2_len) {\n    if (lst1[i] % 2 === 0) {\n      lst1_even.push(lst1[i]);\n    } else {\n      lst1_odd.push(lst1[i]);\n    }\n    if (lst2[j] % 2 === 0) {\n      lst2_even.push(lst2[j]);\n    } else {\n      lst2_odd.push(lst2[j]);\n    }\n    i++;\n    j++;\n  }\n  if (lst1_len === lst2_len) {\n    if (lst1_len === lst1_even.length && lst2_len === lst2_even.length) {\n      return \"YES\";\n    }\n  }\n  if (lst1_len === lst1_odd.length && lst2_len === lst2_odd.length) {\n    return \"YES\";\n  }\n  if (lst1_len === lst1_even.length && lst2_len === lst2_odd.length) {\n    return \"YES\";\n  }\n  if (lst1_len === lst1_odd.length && lst2_len === lst2_even.length) {\n    return \"YES\";\n  }\n  return \"NO\";\n};\n\nexports.exchange = exchange;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 3, "perturbed": true, "gc": "/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split('')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition repeat and containing the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  */\nconst histogram = (test) => {\n  const letters = test.split('')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition repeat and containing the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  */\nconst histogram = (test) => {\n  const letters = test.split('')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition repeat and containing the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  */\nconst histogram = (test) => {\n  const letters = test.split('')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition repeat and containing the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  */\nconst histogram = (test) => {\n  const letters = test.split('')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition repeat and containing the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  */\nconst histogram = (test) => {\n  const letters = test.split('')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition repeat and containing the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  */\nconst histogram", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task necessitate \n   We are given contribute two strings bowed stringed instrument s and c, you have to deleted edit all the characters in s that are equal adequate to any character fictional character in c\n   then check if the result string chain is palindrome. \n   A string chain is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing the result resultant role string chain and true / false assumed for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 3, "perturbed": true, "gc": "/*Task necessitate \n   We are given contribute two strings bowed stringed instrument s and c, you have to deleted edit all the characters in s that are equal adequate to any character fictional character in c\n   then check if the result string chain is palindrome. \n   A string chain is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing the result resultant role string chain and true / false assumed for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  const len = s.length;\n  let i = 0;\n  let j = len - 1;\n  let result = '';\n  while (i < j) {\n    if (s[i] === c[j]) {\n      i++;\n      j--;\n    } else {\n      result += s[i];\n      i++;\n    }\n  }\n  return [result, j === 0];\n};\n\nconst checkPalindrome = (s, c) => {\n  const [result, isPalindrome] = reverseDelete(s, c);\n  return [result, isPalindrome];\n};\n\nconst test = [\n  ['abcde', 'ae'],\n  ['abcdef', 'b'],\n  ['abcdedcba', 'ab'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuvwxyz', 'z'],\n  ['abcdefghijklmnopqrstuvwxyz', 'a'],\n  ['abcdefghijklmnopqrstuv", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 3, "perturbed": true, "gc": "/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const output = [];\n  const count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i];\n    const strLength = str.length;\n    const strOdd = [];\n    for (let j = 0; j < strLength; j++) {\n      if (isOdd(str[j])) {\n        strOdd.push(str[j]);\n      }\n    }\n    const strOddLength = strOdd.length;\n    if (strOddLength > 0) {\n      output.push(`the number of odd elements ${strOddLength} of the ${strOddLength}`);\n      count += strOddLength;\n    }\n  }\n  return output;\n};\n\nexport default oddCount;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const sum = nums.reduce((a, b) => a + b, 0)\n  const minSum = Math.min(sum, 0)\n  const minSubArray = []\n  const minSubArraySum = (nums) => {\n    const sum = nums.reduce((a, b) => a + b, 0)\n    const minSum = Math.min(sum, 0)\n    const minSubArray = []\n    const minSubArraySum = (nums) => {\n      const sum = nums.reduce((a, b) => a + b, 0)\n      const minSum = Math.min(sum, 0)\n      const minSubArray = []\n      const minSubArraySum = (nums) => {\n        const sum = nums.reduce((a, b) => a + b, 0)\n        const minSum = Math.min(sum, 0)\n        const minSubArray = []\n        const minSubArraySum = (nums) => {\n          const sum = nums.reduce((a, b) => a + b, 0)\n          const minSum = Math.min(sum, 0)\n          const minSubArray = []\n          const minSubArraySum = (nums) => {\n            const sum = nums.reduce((a, b) => a + b, 0)\n            const minSum = Math.min(sum, 0)\n            const minSubArray = []\n            const minSubArraySum = (nums) => {\n              const sum = nums.reduce((a, b) => a + b, 0)\n              const minSum = Math.min(sum, 0)\n              const minSubArray = []\n              const minSubArraySum = (nums) => {\n                const sum = nums.reduce((a, b) => a + b, 0)\n                const minSum = Math.min(sum, 0)\n                const minSubArray = []\n                const minSubArraySum = (nums) => {\n                  const sum = nums.reduce((a, b) => a + b, 0)\n                  const minSum = Math.min(sum, 0)\n                  const minSubArray = []\n                  const minSubArraySum = (nums) => {\n                    const sum = nums.reduce((a, b) => a + b, 0)\n                    const minSum = Math.min(sum, 0)\n                    const minSubArray = []\n                    const minSubArraySum = (nums) => {\n                      const sum = nums.reduce((a, b) => a + b, 0)\n                      const minSum = Math.min(sum, 0)\n                      const minSubArray = []\n                      const minSubArraySum = (nums) => {\n                        const sum = nums.reduce((a, b) => a + b, 0)\n                        const minSum = Math.min(sum, 0)\n                        const minSubArray = []\n                        const minSubArraySum = (nums) => {\n                          const sum = nums.reduce((a, b) => a + b, 0)\n                          const minSum = Math.min(sum, 0)\n                          const minSubArray = []\n                          const minSubArraySum = (nums) => {\n                            const sum = nums.reduce((a, b) => a + b, 0)\n                            const minSum = Math.min(sum, 0)\n                            const minSubArray = []\n                            const minSubArraySum = (nums) => {\n                              const sum = nums.reduce((a, b) => a + b, 0)\n                              const minSum = Math.min(sum, 0)\n                              const minSubArray = []\n                              const minSubArraySum = (nums) => {\n                                const sum = nums.reduce((a, b) => a + b, 0)\n                                const minSum = Math.min(sum, 0)\n                                const minSubArray = []\n                                const minSubArraySum = (nums) => {\n                                  const sum = nums.reduce((a, b) => a + b, 0)\n                                  const minSum = Math.min(sum, 0)\n                                  const minSubArray = []\n                                  const minSubArraySum = (nums) => {\n                                    const sum = nums.reduce((a, b) => a + b, 0)\n                                    const minSum = Math.min(sum, 0)\n                                    const minSubArray = []\n                                    const minSubArraySum = (nums) => {\n                                      const sum = nums.reduce((a, b) => a + b, 0)\n                                      const minSum = Math.min(sum, 0)\n                                      const minSubArray = []\n                                      const minSubArraySum = (nums) => {\n                                        const sum = nums.reduce((a, b) => a + b, 0)\n                                        const minSum = Math.min(sum, 0)\n                                        const minSubArray = []\n                                        const minSubArraySum = (nums) => {\n                                          const sum = nums.reduce((a, b) => a + b, 0)\n                                          const minSum = Math.min(sum, 0)\n                                          const minSubArray = []\n                                          const minSubArraySum = (nums) => {\n                                            const sum = nums.reduce((a, b) => a + b, 0)\n                                            const minSum = Math.min(sum, 0)\n                                            const minSubArray = []\n                                            const minSubArraySum = (nums) => {\n                                              const sum = nums.reduce((a, b) => a + b, 0)\n                                              const minSum = Math.min(sum, 0)\n                                              const minSubArray = []\n                                              const minSubArraySum = (nums) => {\n                                                const sum = nums.reduce((a, b) => a + b, 0)\n                                                const minSum = Math", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given impart a rectangular orthogonal grid of wells. Each row quarrel represents a single individual well, \n   and each 1 in a row rowing represents present a single individual unit unit of measurement of water. \n   Each well has a corresponding bucket that can be used to extract water water system from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use practice the buckets to empty the wells well. \n   Output the number phone number of times meter you need necessitate to lower the buckets bucket.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a rectangular orthogonal grid of wells. Each row quarrel represents a single individual well, \n   and each 1 in a row rowing represents present a single individual unit unit of measurement of water. \n   Each well has a corresponding bucket that can be used to extract water water system from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use practice the buckets to empty the wells well. \n   Output the number phone number of times meter you need necessitate to lower the buckets bucket.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n);\n  for (let i = 0; i < n; i++) {\n    buckets[i] = new Array(m);\n    for (let j = 0; j < m; j++) {\n      buckets[i][j] = 0;\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i][j] = capacity;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[i][j] > 0) {\n        count += buckets[i][j];\n      }\n    }\n  }\n  return count;\n};\n\nconst test = [\n  [\n    [0, 0, 1, 0],\n    [0, 1, 0, 0],\n    [1, 1, 1, 1]\n  ],\n  [\n    [0, 0, 1, 1],\n    [0, 0, 0, 0],\n    [1, 1, 1, 1],\n    [0, 1, 1, 1]\n  ],\n  [\n    [0, 0, 0],\n    [0, 0, 0]\n  ],\n  [\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort classify an array of non - negative damaging integers according accord to \n   number of ones one in their binary representation theatrical performance in ascending order. \n   For similar exchangeable number numeral of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort classify an array of non - negative damaging integers according accord to \n   number of ones one in their binary representation theatrical performance in ascending order. \n   For similar exchangeable number numeral of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sortedArray = [];\n  let sortedArrayLength = 0;\n  let sortedArrayLengthLength = 0;\n  let sortedArrayLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let sortedArrayLengthLength", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked task to implement \n   a function affair that returns fall a list of all words from string s that contain check exactly precisely \n   n consonants, in order these words appear in the string bowed stringed instrument s.\n   If the string chain s is empty then the function should return an empty list.\n   Note eminence: you may assume the input string bowed stringed instrument contains hold only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 3, "perturbed": true, "gc": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked task to implement \n   a function affair that returns fall a list of all words from string s that contain check exactly precisely \n   n consonants, in order these words appear in the string bowed stringed instrument s.\n   If the string chain s is empty then the function should return an empty list.\n   Note eminence: you may assume the input string bowed stringed instrument contains hold only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.slice(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\n/*\nGiven a string s, you have been tasked to implement a function that returns a list of all the words that are \ncontained in the string s.\n  Note eminence: you may assume the input string contains only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]\n  selectWords(\"simple white space\", 2) ==> [\"simple\", \"white\", \"space\"]\n  selectWords(\"Hello world\", 4) ==> [\"Hello\", \"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\", \"sam\"]\n  */\nconst selectWords = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.slice(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\n/*\nGiven a string s, you have been tasked to implement a function that returns a list of all the words that are \ncontained in the string s.\n  Note eminence: you may assume the input string contains only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]\n  selectWords(\"simple white space\", 2) ==> [\"simple\", \"white\", \"space\"]\n  selectWords(\"Hello world\", 4) ==> [\"Hello\", \"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\", \"sam\"]\n  */\nconst selectWords = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.slice(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\n/*\nGiven a string s, you have been tasked to implement a function that returns a list of all the words that are \ncontained in the string s.\n  Note eminence: you may assume the input string contains only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]\n  selectWords(\"simple white space\", 2) ==> [\"simple\", \"white\", \"space\"]\n  selectWords(\"Hello world\", 4) ==> [\"Hello\", \"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\", \"sam\"]\n  */\nconst selectWords = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.slice(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\n/*\nGiven a string s, you have been tasked to implement a function that returns a list of all the words that are \ncontained in the string s.\n  Note eminence: you may assume the input string contains only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]\n  selectWords(\"simple white space\", 2) ==> [\"simple\", \"white\", \"space\"]\n  selectWords(\"Hello world\", 4) ==> [\"Hello\", \"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\", \"sam\"]\n  */\nconst selectWords = (s, n) => {\n  const words = [];\n  const length = s.length;\n  let i = 0;\n  while (i < length) {\n    const word = s.slice(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n    }\n    i += n;\n  }\n  return words;\n};\n\n/*\nGiven a string s, you have been tasked to implement a function that returns a list of all the words that are \ncontained in the string s.\n  Note eminence: you may assume the input string contains only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"had\", \"a\", \"little\", \"lamb", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/118", "prompt": "/*You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 3, "perturbed": true, "gc": "/*You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const consonantIndex = consonants.indexOf(word[word.length - 1])\n  const vowelIndex = vowels.indexOf(word[0])\n  let closestVowel = ''\n  let distance = 0\n  for (let i = 0; i < word.length - 1; i++) {\n    if (vowels.indexOf(word[i])!== -1 && consonants.indexOf(word[i + 1])!== -1) {\n      const distance = Math.abs(vowels.indexOf(word[i]) - consonantIndex)\n      if (distance < distance) {\n        closestVowel = word[i]\n        break\n      }\n    }\n  }\n  return closestVowel\n}\n\nmodule.exports = getClosestVowel\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/119", "prompt": "/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 3, "perturbed": true, "gc": "/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr === '(') {\n      stack.push(curr);\n    } else if (curr === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No';\n};\n\nconst matchParens2 = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr === '(') {\n      stack.push(curr);\n    } else if (curr === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No';\n};\n\nconst matchParens3 = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr === '(') {\n      stack.push(curr);\n    } else if (curr === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No';\n};\n\nconst matchParens4 = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr === '(') {\n      stack.push(curr);\n    } else if (curr === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No';\n};\n\nconst matchParens5 = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr === '(') {\n      stack.push(curr);\n    } else if (curr === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No';\n};\n\nconst matchParens6 = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr === '(') {\n      stack.push(curr);\n    } else if (curr === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No';\n};\n\nconst matchParens7 = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr === '(') {\n      stack.push(curr);\n    } else if (curr === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No';\n};\n\nconst matchParens8 = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr === '(') {\n      stack.push(curr);\n    } else if (curr === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No';\n};\n\nconst matchParens9 = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr === '(') {\n      stack.push(curr);\n    } else if (curr === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No';\n};\n\nconst matchParens10 = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr === '(') {\n      stack.push(curr);\n    } else if (curr === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return reelect the first beginning one in case of multiple \n   strings of the same length duration. Return null in case font the input stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 3, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return reelect the first beginning one in case of multiple \n   strings of the same length duration. Return null in case font the input stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null\n  }\n  let longest = strings[0]\n  strings.forEach((string) => {\n    if (string.length > longest.length) {\n      longest = string\n    }\n  })\n  return longest\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'bb', 'ccc', 'ddd'])\n  'ccc'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee'])\n  'eee'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff'])\n  'eee'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg'])\n  'eee'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh'])\n  'hhh'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii'])\n  'iii'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj'])\n  'jjj'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk'])\n  'kkk'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll'])\n  'kkk'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm'])\n 'mmm'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn'])\n  'nnn'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn', 'ooo'])\n  'ooo'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn', 'ooo', 'ppp'])\n  'ppp'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn', 'ooo', 'ppp', 'qqq'])\n  'qqq'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn', 'ooo', 'ppp', 'qqq', 'rrr'])\n  'qqq'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn', 'ooo', 'ppp', 'qqq', 'rrr','sss'])\n  'rrr'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn', 'ooo', 'ppp', 'qqq', 'rrr','sss', 'ttt'])\n  'ttt'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn', 'ooo', 'ppp', 'qqq', 'rrr','sss', 'ttt', 'uuu'])\n  'uuu'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn', 'ooo', 'ppp', 'qqq', 'rrr','sss', 'ttt', 'uuu', 'vvv'])\n  'vvv'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn', 'ooo', 'ppp', 'qqq', 'rrr','sss', 'ttt', 'uuu', 'vvv', 'www'])\n  'www'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh', 'iii', 'jjj', 'kkk', 'lll','mmm', 'nnn', 'ooo', 'ppp', 'qqq', 'rrr','sss', 'ttt', 'uuu', 'vvv', 'www', 'xxx'])\n  'xxx'\n  >>> longest(['a', 'bb', 'ccc', 'ddd', 'eee', 'fff', 'ggg', 'hhh", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given impart an array arr of integers integer and a positive integer k, return a sorted classify list \n   of length k with the maximum k numbers phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart an array arr of integers integer and a positive integer k, return a sorted classify list \n   of length k with the maximum k numbers phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const sorted = arr.slice().sort();\n  const result = [];\n  for (let i = 0; i < k; i++) {\n    result.push(sorted[i]);\n  }\n  return result;\n};\n\nconst test = [\n  [ [-3, -4, 5], 3 ],\n  [ [4, -4, 4], 2 ],\n  [ [-3, 2, 1, 2, -1, -2, 1], 1 ]\n];\n\ntest.forEach(t => {\n  console.log(maximum(t[0], t[1]));\n});\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 3, "perturbed": true, "gc": "/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const odd = lst.filter(x => x % 2 === 1);\n  const even = lst.filter(x => x % 2 === 0);\n  const sum = odd.reduce((acc, x) => acc + x, 0);\n  return even.reduce((acc, x) => acc + x, sum);\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements_2 = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements_3 = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements_4 = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements_5 = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements_6 = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements_7 = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements_8 = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements_9 = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements_10 = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements_11 = (arr, k) => {\n  const arrLen = arr.length\n  const sum = 0\n  let i = 0\n  let j = 0\n  while (i < arrLen) {\n    const element = arr[i]\n    const elementLen = element.toString().length\n    if (elementLen <= 2) {\n      sum += element\n      i++\n    } else {\n      j++\n      if (j >= k) {\n        break\n      }\n    }\n  }\n  return sum\n}", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given impart a positive convinced integer n, return a sorted classify list that has the odd numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a positive convinced integer n, return a sorted classify list that has the odd numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = [];\n    const even = [];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        even.push(n);\n        n = n / 2;\n      } else {\n        odd.push(n);\n        n = 3 * n + 1;\n      }\n    }\n    return odd.concat(even);\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz2 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = [];\n    const even = [];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        even.push(n);\n        n = n / 2;\n      } else {\n        odd.push(n);\n        n = 3 * n + 1;\n      }\n    }\n    return odd.concat(even);\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz3 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = [];\n    const even = [];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        even.push(n);\n        n = n / 2;\n      } else {\n        odd.push(n);\n        n = 3 * n + 1;\n      }\n    }\n    return odd.concat(even);\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz4 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = [];\n    const even = [];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        even.push(n);\n        n = n / 2;\n      } else {\n        odd.push(n);\n        n = 3 * n + 1;\n      }\n    }\n    return odd.concat(even);\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz5 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = [];\n    const even = [];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        even.push(n);\n        n = n / 2;\n      } else {\n        odd.push(n);\n        n = 3 * n + 1;\n      }\n    }\n    return odd.concat(even);\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz6 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = [];\n    const even = [];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        even.push(n);\n        n = n / 2;\n      } else {\n        odd.push(n);\n        n = 3 * n + 1;\n      }\n    }\n    return odd.concat(even);\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz7 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = [];\n    const even = [];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        even.push(n);\n        n = n / 2;\n      } else {\n        odd.push(n);\n        n = 3 * n + 1;\n      }\n    }\n    return odd.concat(even);\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz8 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = [];\n    const even = [];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        even.push(n);\n        n = n / 2;\n      } else {\n        odd.push(n);\n        n = 3 * n + 1;\n      }\n    }\n    return odd.concat(even);\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz9 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = [];\n    const even = [];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        even.push(n);\n        n = n / 2;\n      } else {\n        odd.push(n);\n        n = 3 * n + 1;\n      }\n    }\n    return odd.concat(even);\n  };\n  return coll", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 3, "perturbed": true, "gc": "/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (date === '') return false\n  const dateArray = date.split('-')\n  const month = parseInt(dateArray[1])\n  const day = parseInt(dateArray[2])\n  const year = parseInt(dateArray[0])\n  const days = month * 31 + day\n  const daysOfMonth = month * 30 + day\n  const daysOfYear = year * 365 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const daysOfYearLeap = year * 366 + daysOfMonth\n  const days", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 3, "perturbed": true, "gc": "/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords2 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords3 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords4 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords5 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords6 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords7 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords8 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords9 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords10 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords11 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords12 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords13 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords14 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords15 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords16 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords17 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords18 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords19 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords20 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords21 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords22 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords23 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords24 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords25 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords26 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords27 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords28 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords29 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords30 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords31 = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\nconst splitWords32 = (txt) => {\n  const words =", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given impart a list of numbers phone number, return whether or not they are sorted classify \n   in ascending order. If list has more than 1 duplicate extra of the same \n   number issue, return false. Assume no negative numbers number and only integers integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 3, "perturbed": true, "gc": "/* Given impart a list of numbers phone number, return whether or not they are sorted classify \n   in ascending order. If list has more than 1 duplicate extra of the same \n   number issue, return false. Assume no negative numbers number and only integers integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const duplicates = lst.filter((x, i, arr) => i < arr.length - 1 && x === arr[i + 1]);\n  return!duplicates.length || sorted.length === lst.length;\n};\n\nexport default isSorted;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/127", "prompt": "/*You are given impart two intervals time interval, \n   where each interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 3, "perturbed": true, "gc": "/*You are given impart two intervals time interval, \n   where each interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1.start, interval2.start);\n  const end = Math.min(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given impart an array arr of integers integer and you need to return\n   sum union of magnitudes of integers integer multiplied multiply by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart an array arr of integers integer and you need to return\n   sum union of magnitudes of integers integer multiplied multiply by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const signboard = []\n  const product = 1\n  const sum = 0\n  const productSign = 1\n  const sumSign = -1\n  const numeral = 0\n  const sign = 0\n  const numeralSign = 0\n  const signSign = 0\n  const numeralSignSign = 0\n  const signSignSign = 0\n  const numeralSignSignSign = 0\n  const signSignSignSign = 0\n  const numeralSignSignSignSign = 0\n  const signSignSignSignSign = 0\n  const numeralSignSignSignSignSign = 0\n  const signSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign = 0\n  const numeralSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign sign signSignSignSignSignSign signSignSignSignSignSign signSignSignSignSignSignSign signSignSignSign signSignSign sign\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign signSignSignSignSignSign signSignSignSignSign signSignSign sign sign\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign signSignSignSignSignSign signSignSignSign sign sign\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign signSignSignSignSignSignSign signSignSignSignSignSign signSignSignSign sign sign\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign signSignSignSignSignSignSign signSignSignSign signSignSignSign sign sign\n  const signSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSignSign signSignSignSignSign signSignSignSignSignSign signSignSign sign sign\n  const signSignSignSignSignSignSignSignSign", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given impart a grid with N rows course and N columns (N > = 2) and a positive plus integer k, \n   each cell of the grid contains control a value. Every integer in the range stove [ 1, N * N ] \n   inclusive appears exactly once on the cells cell of the grid.\n\n   You have to find determine the minimum path of length k in the grid. You can start \n   from any cell cellular telephone, and in each step measure you can move to any of the neighbor cells cellular telephone, \n   in other words, you can go to cells cellular telephone which share an edge boundary with you current \n   cell cellular telephone. \n   Please note notice that a path of length distance k means intend visiting exactly k cells cell (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length k) is considered less than a path way B (of length k) if \n   after making the ordered lists tilt of the values value on the cells cellular telephone that A ampere and B bel go start \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words news, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed guarantee that the answer is unique. \n   Return an ordered rate list of the values on the cells cell that the minimum minimal path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a grid with N rows course and N columns (N > = 2) and a positive plus integer k, \n   each cell of the grid contains control a value. Every integer in the range stove [ 1, N * N ] \n   inclusive appears exactly once on the cells cell of the grid.\n\n   You have to find determine the minimum path of length k in the grid. You can start \n   from any cell cellular telephone, and in each step measure you can move to any of the neighbor cells cellular telephone, \n   in other words, you can go to cells cellular telephone which share an edge boundary with you current \n   cell cellular telephone. \n   Please note notice that a path of length distance k means intend visiting exactly k cells cell (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length k) is considered less than a path way B (of length k) if \n   after making the ordered lists tilt of the values value on the cells cellular telephone that A ampere and B bel go start \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words news, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed guarantee that the answer is unique. \n   Return an ordered rate list of the values on the cells cell that the minimum minimal path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [N, M] = grid.length;\n  const [n, m] = grid[0].length;\n  const [lst_A, lst_B] = new Array(N * N).fill(0);\n  const [lst_A_index, lst_B_index] = new Array(N * N).fill(0);\n  const [lst_A_index_temp, lst_B_index_temp] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_2, lst_B_index_temp_2] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_3, lst_B_index_temp_3] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_4, lst_B_index_temp_4] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_5, lst_B_index_temp_5] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_6, lst_B_index_temp_6] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_7, lst_B_index_temp_7] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_8, lst_B_index_temp_8] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_9, lst_B_index_temp_9] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_10, lst_B_index_temp_10] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_11, lst_B_index_temp_11] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_12, lst_B_index_temp_12] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_13, lst_B_index_temp_13] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_14, lst_B_index_temp_14] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_15, lst_B_index_temp_15] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_16, lst_B_index_temp_16] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_17, lst_B_index_temp_17] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_18, lst_B_index_temp_18] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_19, lst_B_index_temp_19] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_20, lst_B_index_temp_20] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_21, lst_B_index_temp_21] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_22, lst_B_index_temp_22] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_23, lst_B_index_temp_23] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_24, lst_B_index_temp_24] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_25, lst_B_index_temp_25] = new Array(N * N).fill(0);\n  const [lst_A_index_temp_26, lst_B_index_temp_26", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return restitution a greatest big common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 3, "perturbed": true, "gc": "/* Return restitution a greatest big common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  let i = 0;\n  while (a!== b) {\n    if (a > b) {\n      a = a - b;\n    } else {\n      b = b - a;\n    }\n    i++;\n  }\n  return a;\n};\n\n/**\n  * Return the smallest integer that is a power of two\n  * @param {number} n\n  * @returns {number}\n  */\nconst nextPowerOfTwo = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst previousPowerOfTwo = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) - 1);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst nextPowerOfTwoInclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 1);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst previousPowerOfTwoInclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst nextPowerOfTwoExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 1);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst previousPowerOfTwoExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst nextPowerOfTwoInclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 2);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst previousPowerOfTwoInclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 1);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst nextPowerOfTwoInclusiveExclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 3);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst previousPowerOfTwoInclusiveExclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 2);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst nextPowerOfTwoExclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 3);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst previousPowerOfTwoExclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 1);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst nextPowerOfTwoExclusiveExclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 4);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst previousPowerOfTwoExclusiveExclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 2);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst nextPowerOfTwoExclusiveExclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 4);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst previousPowerOfTwoExclusiveExclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)) + 3);\n};\n\n/**\n * Return the smallest integer that is a power of two\n * @param {number} n\n * @returns {number}\n */\nconst nextPowerOfTwoExclusiveExclusiveExclusive = (n) => {\n  return Math.pow(2, Math.ceil", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries hundred. However, what people don't know is Tribonacci sequence succession. \n   Tribonacci sequence succession is defined by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 3, "perturbed": true, "gc": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries hundred. However, what people don't know is Tribonacci sequence succession. \n   Tribonacci sequence succession is defined by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let a = 1\n  let b = 1\n  let c = 1\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(a)\n    a = b\n    b = c\n    c = a + b\n  }\n  return result\n}\n\nconsole.log(tri(3))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive convinced integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 3, "perturbed": true, "gc": "/*Given a positive convinced integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\nconsole.log(digits(1));\nconsole.log(digits(4));\nconsole.log(digits(235));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create make a function routine that takes a string as input remark which contains only square straight brackets bracket. \n   The function should return true if and only if there is a valid subsequence posteriority of brackets bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]')  true \n   isNested('[]]]]]]][[[[[]')  false \n   isNested('[][]')  false assumed \n   isNested('[]')  false fake \n   isNested('[[][]]')  true \n   isNested('[[]][[')  true on-key \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 3, "perturbed": true, "gc": "/*\n  Create make a function routine that takes a string as input remark which contains only square straight brackets bracket. \n   The function should return true if and only if there is a valid subsequence posteriority of brackets bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]')  true \n   isNested('[]]]]]]][[[[[]')  false \n   isNested('[][]')  false assumed \n   isNested('[]')  false fake \n   isNested('[[][]]')  true \n   isNested('[[]][[')  true on-key \n   * / \n const isNested = (string) = > {\n  const isNested = (string) = > {\n    const isNested = (string) = > {\n      const isNested = (string) = > {\n        const isNested = (string) = > {\n          const isNested = (string) = > {\n            const isNested = (string) = > {\n              const isNested = (string) = > {\n                const isNested = (string) = > {\n                  const isNested = (string) = > {\n                    const isNested = (string) = > {\n                      const isNested = (string) = > {\n                        const isNested = (string) = > {\n                          const isNested = (string) = > {\n                            const isNested = (string) = > {\n                              const isNested = (string) = > {\n                                const isNested = (string) = > {\n                                  const isNested = (string) = > {\n                                    const isNested = (string) = > {\n                                      const isNested = (string) = > {\n                                        const isNested = (string) = > {\n                                          const isNested = (string) = > {\n                                            const isNested = (string) = > {\n                                              const isNested = (string) = > {\n                                                const isNested = (string) = > {\n                                                  const isNested = (string) = > {\n                                                    const isNested = (string) = > {\n                                                     const isNested = (string) = > {\n                                                      const isNested = (string) = > {\n                                                        const isNested = (string) = > {\n                                                         const isNested = (string) = > {\n                                                           const isNested = (string) = > {\n                                                            const isNested = (string) = > {\n                                                              const isNested = (string) = > {\n                                                              }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given impart a list of numbers phone number. \n   You need want to return the sum of squared numbers in the given impart list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "/*You are given impart a list of numbers phone number. \n   You need want to return the sum of squared numbers in the given impart list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1,2,3]));\nconsole.log(sumSquares([1,4,9]));\nconsole.log(sumSquares([1,3,5,7]));\nconsole.log(sumSquares([1.4,4.2,0]));\nconsole.log(sumSquares([-2.4,1,1]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is an alphabetical alphabetic character quality and is not \n   a part of a word, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 3, "perturbed": true, "gc": "/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is an alphabetical alphabetic character quality and is not \n   a part of a word, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter =!isALetter;\n  return isALetter && isNotALetter;\n};\n\n/* Create a function that returns true if the last character of a given string is a letter and is not a part of a word, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter =!isALetter;\n  return isALetter && isNotALetter;\n};\n\n/* Create a function that returns true if the last character of a given string is a letter and is not a part of a word, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter =!isALetter;\n  return isALetter && isNotALetter;\n};\n\n/* Create a function that returns true if the last character of a given string is a letter and is not a part of a word, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter =!isALetter;\n  return isALetter && isNotALetter;\n};\n\n/* Create a function that returns true if the last character of a given string is a letter and is not a part of a word, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter =!isALetter;\n  return isALetter && isNotALetter;\n};\n\n/* Create a function that returns true if the last character of a given string is a letter and is not a part of a word, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter =!isALetter;\n  return isALetter && isNotALetter;\n};\n\n/* Create a function that returns true if the last character of a given string is a letter and is not a part of a word, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter =!isALetter;\n  return isALetter && isNotALetter;\n};\n\n/* Create a function that returns true if the last character of a given string is a letter and is not a part of a word, and false otherwise.\n   Note bill:", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 3, "perturbed": true, "gc": "/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  const arrLength = arr.length;\n  let max = -1;\n  let maxIndex = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arrLength) {\n    if (arr[i] >= arr[i + 1]) {\n      if (arr[i] > max) {\n        max = arr[i];\n        maxIndex = i;\n      }\n    } else {\n      break;\n    }\n    i++;\n  }\n  if (maxIndex === -1) {\n    return -1;\n  }\n  while (j < arrLength) {\n    if (arr[j] >= arr[j + 1]) {\n      if (arr[j] > max) {\n        max = arr[j];\n        maxIndex = j;\n      }\n    } else {\n      break;\n    }\n    j++;\n  }\n  return maxIndex;\n};\n\nmodule.exports = canArrange;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 3, "perturbed": true, "gc": "/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largest = lst.reduce((a, b) => {\n    if (a === null) {\n      return b;\n    }\n    if (b < a) {\n      return b;\n    }\n    return a;\n  }, null);\n  const smallest = lst.reduce((a, b) => {\n    if (a === null) {\n      return b;\n    }\n    if (b > a) {\n      return b;\n    }\n    return a;\n  }, null);\n  return largest === null? null : [largest, smallest];\n};\n\n/*\n  Create a function that returns the largest of two numbers.\n  If the two numbers are equal, return the largest number.\n  If the first number is larger, return the second number.\n  If the second number is larger, return the first number.\n  If the first number is null, return the second number.\n  If the second number is null, return the first number.\n  Examples:\n  largestNumber([2, 4, 1, 3, 5, 7]) == 7\n  largestNumber([2, 4, 1, 3, 5, 7, 9]) == 9\n  largestNumber([2, 4, 1, 3, 5, 7]) == 7\n  largestNumber([2, 4, 1, 3, 5, 7, 9]) == 9\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11]) == 11\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13]) == 11\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15]) == 15\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17]) == 15\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]) == 19\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]) == 19\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23]) == 23\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]) == 23\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27]) == 27\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29]) == 29\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31]) == 29\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33]) == 33\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35]) == 35\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37]) == 37\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]) == 39\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41]) == 41\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43]) == 43\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45]) == 45\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47]) == 47\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49]) == 49\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51]) == 51\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53]) == 53\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55]) == 55\n  largestNumber([2, 4, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create make a function routine that takes integers integer, floats, or strings bowed stringed instrument representing defend \n   real numbers, and returns refund the larger bigger variable in its given variable type. \n   Return null nothing if the values value are equal. \n   Note eminence: If a real number is represented defend as a string, the floating float point period might be. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  null nothing \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 3, "perturbed": true, "gc": "/*\n  Create make a function routine that takes integers integer, floats, or strings bowed stringed instrument representing defend \n   real numbers, and returns refund the larger bigger variable in its given variable type. \n   Return null nothing if the values value are equal. \n   Note eminence: If a real number is represented defend as a string, the floating float point period might be. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  null nothing \n   * / \n const compareOne = (a, b) = > {\n   if (a === b) return null;\n   if (typeof a === 'number' && typeof b === 'number') {\n     if (a > b) return a;\n     if (a < b) return b;\n     return null;\n   }\n   if (typeof a ==='string' && typeof b ==='string') {\n     if (a > b) return a;\n     if (a < b) return b;\n     return null;\n   }\n   if (typeof a === 'object' && typeof b === 'object') {\n     if (a.length > b.length) return a;\n     if (a.length < b.length) return b;\n     return null;\n   }\n   return null;\n }\n*/\n\nconst compareOne = (a, b) => {\n  if (a === b) return null;\n  if (typeof a === 'number' && typeof b === 'number') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    if (a.length > b.length) return a;\n    if (a.length < b.length) return b;\n    return null;\n  }\n  return null;\n}\n\nconst compareTwo = (a, b) => {\n  if (a === b) return null;\n  if (typeof a === 'number' && typeof b === 'number') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    if (a.length > b.length) return a;\n    if (a.length < b.length) return b;\n    return null;\n  }\n  return null;\n}\n\nconst compareThree = (a, b) => {\n  if (a === b) return null;\n  if (typeof a === 'number' && typeof b === 'number') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    if (a.length > b.length) return a;\n    if (a.length < b.length) return b;\n    return null;\n  }\n  return null;\n}\n\nconst compareFour = (a, b) => {\n  if (a === b) return null;\n  if (typeof a === 'number' && typeof b === 'number') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    if (a.length > b.length) return a;\n    if (a.length < b.length) return b;\n    return null;\n  }\n  return null;\n}\n\nconst compareFive = (a, b) => {\n  if (a === b) return null;\n  if (typeof a === 'number' && typeof b === 'number') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    if (a.length > b.length) return a;\n    if (a.length < b.length) return b;\n    return null;\n  }\n  return null;\n}\n\nconst compareSix = (a, b) => {\n  if (a === b) return null;\n  if (typeof a === 'number' && typeof b === 'number') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    if (a > b) return a;\n    if (a < b) return b;\n    return null;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    if (a.length > b.length) return a;\n    if (a.length < b.length) return b;\n    return null;\n  }\n  return null;\n}\n\nconst compareSeven = (a, b) => {\n  if (a === b) return null;\n  if (typeof a === 'number' && typeof b === 'number')", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 3, "perturbed": true, "gc": "/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n === 0) return true\n  if (n === 1) return false\n  if (n % 2 === 0) return isEqualToSumEven(n - 1)\n  return isEqualToSumEven(n - 1) && isEqualToSumEven(n + 1)\n}\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  if (n === 0) return true\n  if (n === 1) return false\n  if (n % 2 === 1) return isEqualToSumOdd(n - 1)\n  return isEqualToSumOdd(n - 1) && isEqualToSumOdd(n + 1)\n}\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 negative positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumNegativeEven = (n) => {\n  if (n === 0) return true\n  if (n === 1) return false\n  if (n % 2 === 0) return isEqualToSumNegativeEven(n - 1)\n  return isEqualToSumNegativeEven(n - 1) && isEqualToSumNegativeEven(n + 1)\n}\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 negative positivist odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumNegativeOdd = (n) => {\n  if (n === 0) return true\n  if (n === 1) return false\n  if (n % 2 === 1) return isEqualToSumNegativeOdd(n - 1)\n  return isEqualToSumNegativeOdd(n - 1) && isEqualToSumNegativeOdd(n + 1)\n}\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive or negative positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumPositiveOrNegativeEven = (n) => {\n  if (n === 0) return true\n  if (n === 1) return false\n  if (n % 2 === 0) return isEqualToSumPositiveOrNegativeEven(n - 1)\n  return isEqualToSumPositiveOrNegativeEven(n - 1) && isEqualToSumPositiveOrNegativeEven(n + 1)\n}\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive or negative positivist odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumPositiveOrNegativeOdd = (n) => {\n  if (n === 0) return true\n  if (n === 1) return false\n  if (n % 2 === 1) return isEqualToSumPositiveOrNegativeOdd(n - 1)\n  return isEqualToSumPositiveOrNegativeOdd(n - 1) && isEqualToSumPositiveOrNegativeOdd(n + 1)\n}\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive or negative positivist odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumPositiveOrNegativeOdd = (n) => {\n  if (n === 0) return true\n  if (n === 1) return false\n  if (n % 2 === 1) return isEqualToSumPositiveOrNegativeOdd(n - 1)\n  return isEqualToSumPositiveOrNegativeOdd(n - 1) && isEqualToSumPositiveOrNegativeOdd(n + 1)\n}\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive or negative positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumPositiveOrNegativeEven = (n) => {\n  if (n === 0) return true\n  if (n === 1) return false\n  if (n % 2 === 0) return isEqualToSumPositiveOrNegativeEven(n - 1)\n  return isEqualToSumPositiveOrNegativeEven(n - 1) && isEqualToSumPositiveOrNegativeEven(n + 1)\n}\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive or negative positivist odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumPositiveOrNegativeOdd = (n) => {\n  if (n === 0) return true\n  if (n === 1) return false\n  if (n % 2 === 1) return isEqualToSumPositiveOrNegativeOdd", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 3, "perturbed": true, "gc": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n}\n\nconst factorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}\n\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nconst sumOfFactorial = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial2 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += factorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial3 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial4 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial5 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial6 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial7 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial8 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial9 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial10 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial11 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial12 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial13 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial14 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial15 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial16 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial17 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial18 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial19 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial20 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial21 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial22 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\nconst sumOfFactorial23 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/14", "prompt": "/* Return restitution list of all prefixes prefix from shortest to longest of the input remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 3, "perturbed": true, "gc": "/* Return restitution list of all prefixes prefix from shortest to longest of the input remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = []\n  const prefix = ''\n  let i = 0\n  while (i < string.length) {\n    prefixes.push(prefix)\n    prefix = string[i] + prefix\n    i++\n  }\n  return prefixes\n}\n\n/* Return the longest prefix of the input remark string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given impart a string bowed stringed instrument text, replace supplant all spaces in it with underscores, \n   and if a string bowed stringed instrument has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a string bowed stringed instrument text, replace supplant all spaces in it with underscores, \n   and if a string bowed stringed instrument has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces2 = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces3 = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces4 = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces5 = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces6 = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces7 = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces8 = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces9 = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces10 = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a function affair which takes lease a string bowed stringed instrument representing act a file's name, and returns \n  ' Yes' if the the file's name is valid, and returns tax return' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following conditions weather \n   are met meet: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot'.' \n   - The substring before the dot acid should not be empty, and it starts depart with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot acid should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 3, "perturbed": true, "gc": "/*Create a function affair which takes lease a string bowed stringed instrument representing act a file's name, and returns \n 'Yes' if the the file's name is valid, and returns tax return' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following conditions weather \n   are met meet: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot'.' \n   - The substring before the dot acid should not be empty, and it starts depart with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot acid should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  let file_name_check = file_name.split('.');\n  let file_name_check_length = file_name_check.length;\n  let file_name_check_length_two = file_name_check_length - 1;\n  let file_name_check_length_three = file_name_check_length - 2;\n  let file_name_check_length_four = file_name_check_length - 3;\n  let file_name_check_length_five = file_name_check_length - 4;\n  let file_name_check_length_six = file_name_check_length - 5;\n  let file_name_check_length_seven = file_name_check_length - 6;\n  let file_name_check_length_eight = file_name_check_length - 7;\n  let file_name_check_length_nine = file_name_check_length - 8;\n  let file_name_check_length_ten = file_name_check_length - 9;\n  let file_name_check_length_eleven = file_name_check_length - 10;\n  let file_name_check_length_twelve = file_name_check_length - 11;\n  let file_name_check_length_thirteen = file_name_check_length - 12;\n  let file_name_check_length_fourteen = file_name_check_length - 13;\n  let file_name_check_length_fifteen = file_name_check_length - 14;\n  let file_name_check_length_sixteen = file_name_check_length - 15;\n  let file_name_check_length_seventeen = file_name_check_length - 16;\n  let file_name_check_length_eighteen = file_name_check_length - 17;\n  let file_name_check_length_nineteen = file_name_check_length - 18;\n  let file_name_check_length_twenty = file_name_check_length - 19;\n  let file_name_check_length_twenty_one = file_name_check_length - 20;\n  let file_name_check_length_twenty_two = file_name_check_length - 21;\n  let file_name_check_length_twenty_three = file_name_check_length - 22;\n  let file_name_check_length_twenty_four = file_name_check_length - 23;\n  let file_name_check_length_twenty_five = file_name_check_length - 24;\n  let file_name_check_length_twenty_six = file_name_check_length - 25;\n  let file_name_check_length_twenty_seven = file_name_check_length - 26;\n  let file_name_check_length_twenty_eight = file_name_check_length - 27;\n  let file_name_check_length_twenty_nine = file_name_check_length - 28;\n  let file_name_check_length_thirty = file_name_check_length - 29;\n  let file_name_check_length_thirty_one = file_name_check_length - 30;\n  let file_name_check_length_thirty_two = file_name_check_length - 31;\n  let file_name_check_length_thirty_three = file_name_check_length - 32;\n  let file_name_check_length_thirty_four = file_name_check_length - 33;\n  let file_name_check_length_thirty_five = file_name_check_length - 34;\n  let file_name_check_length_thirty_six = file_name_check_length - 35;\n  let file_name_check_length_thirty_seven = file_name_check_length - 36;\n  let file_name_check_length_thirty_eight = file_name_check_length - 37;\n  let file_name_check_length_thirty_nine = file_name_check_length - 38;\n  let file_name_check_length_thirty_ten = file_name_check_length - 39;\n  let file_name_check_length_thirty_eleven = file_name_check_length - 40;\n  let file_name_check_length_thirty_twelve = file_name_check_length - 41;\n  let file_name_check_length_thirty_thirteen = file_name_check_length - 42;\n  let file_name_check_length_thirty_fourteen = file_name_check_length - 43;\n  let file_name_check_length_thirty_fifteen = file_name_check_length - 44;\n  let file_name_check_length_thirty_sixteen = file_name_check_length - 45;\n  let file_name_check_length_thirty_seventeen = file_name_check_length - 46;\n  let file_name_check_length_thirty_eighteen = file_name_check_length - 47;\n  let file_name_check_length_thirty_nineteen = file_name_check_length - 48;\n  let file_name_check_length_thirty_twenty = file_name_check_length - 49;\n  let file_name_check", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresCubesSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given impart a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = new Array(word.length)\n    for (let j = 0; j < word.length; j++) {\n      newWord[j] = word[j]\n    }\n    newWords.push(newWord)\n  }\n  return newWords\n}\n\nconst getPrimeNumbers = (number) => {\n  const primeNumbers = []\n  for (let i = 2; i <= number; i++) {\n    if (number % i === 0) {\n      primeNumbers.push(i)\n    }\n  }\n  return primeNumbers\n}\n\nconst getPrimeNumbersInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const primeNumbers = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const primeNumbersInWord = getPrimeNumbers(word.length)\n    for (let j = 0; j < primeNumbersInWord.length; j++) {\n      primeNumbers.push(primeNumbersInWord[j])\n    }\n  }\n  return primeNumbers\n}\n\nconst getBowedString = (primeNumbers, words) => {\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = new Array(word.length)\n    for (let j = 0; j < word.length; j++) {\n      newWord[j] = word[j]\n    }\n    newWords.push(newWord)\n  }\n  for (let i = 0; i < primeNumbers.length; i++) {\n    const primeNumber = primeNumbers[i]\n    const newWord = new Array(primeNumber)\n    for (let j = 0; j < primeNumber; j++) {\n      newWord[j] = '*'\n    }\n    newWords.push(newWord)\n  }\n  return newWords\n}\n\nconst getBowedStringInSentence = (primeNumbers, words) => {\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = new Array(word.length)\n    for (let j = 0; j < word.length; j++) {\n      newWord[j] = word[j]\n    }\n    newWords.push(newWord)\n  }\n  for (let i = 0; i < primeNumbers.length; i++) {\n    const primeNumber = primeNumbers[i]\n    const newWord = new Array(primeNumber)\n    for (let j = 0; j < primeNumber; j++) {\n      newWord[j] = '*'\n    }\n    newWords.push(newWord)\n  }\n  return newWords\n}\n\nconst getBowedStringInSentence2 = (primeNumbers, words) => {\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = new Array(word.length)\n    for (let j = 0; j < word.length; j++) {\n      newWord[j] = word[j]\n    }\n    newWords.push(newWord)\n  }\n  for (let i = 0; i < primeNumbers.length; i++) {\n    const primeNumber = primeNumbers[i]\n    const newWord = new Array(primeNumber)\n    for (let j = 0; j < primeNumber; j++) {\n      newWord[j] = '*'\n    }\n    newWords.push(newWord)\n  }\n  return newWords\n}\n\nconst getBowedStringInSentence3 = (primeNumbers, words) => {\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = new Array(word.length)\n    for (let j = 0; j < word.length; j++) {\n      newWord[j] = word[j]\n    }\n    newWords.push(newWord)\n  }\n  for (let i = 0; i < primeNumbers.length; i++) {\n    const primeNumber = primeNumbers[i]\n    const newWord = new Array(primeNumber)\n    for (let j = 0; j < primeNumber; j++) {\n      newWord[j] = '*'\n    }\n    newWords.push(newWord)\n  }\n  return newWords\n}\n\nconst getBowedStringInSentence4 = (primeNumbers, words) => {\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = new Array(word.length)\n    for (let j = 0; j < word.length; j++) {\n      newWord[j] = word[j]\n    }\n    newWords.push(newWord)\n  }\n  for (let i = 0; i < primeNumbers.length; i++) {\n    const primeNumber = primeNumbers[i]\n    const newWord = new Array(primeNumber)\n    for (let j = 0; j < primeNumber; j++) {\n      newWord[j] = '*'\n    }\n    newWords.push(newWord)\n  }\n  return newWords\n}\n\nconst getBowedStringInSentence5 = (primeNumbers, words) => {\n  const newWords = []\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task job is to implement follow through a function that will simplify the expression saying \n   x * n. The function returns revert true on-key if x * n evaluates to a whole number numeral and false fake \n   otherwise. Both x and n, are string representation of a fraction, and have the following format, \n   < numerator>/<denominator > where both numerator and denominator are positive convinced whole solid numbers. \n\n   You can assume simulate that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 3, "perturbed": true, "gc": "/*Your task job is to implement follow through a function that will simplify the expression saying \n   x * n. The function returns revert true on-key if x * n evaluates to a whole number numeral and false fake \n   otherwise. Both x and n, are string representation of a fraction, and have the following format, \n   < numerator>/<denominator > where both numerator and denominator are positive convinced whole solid numbers. \n\n   You can assume simulate that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n   let x = x.toString();\n   let n = n.toString();\n   let xn = x + n;\n   let xn_int = parseInt(xn);\n   if (xn_int === 0) {\n     return false;\n   }\n   return xn_int === parseInt(xn);\n }\n*/\n\nfunction simplify(x, n) {\n  let xn = x + n;\n  let xn_int = parseInt(xn);\n  if (xn_int === 0) {\n    return false;\n  }\n  return xn_int === parseInt(xn);\n}\n\nconsole.log(simplify(\"1/5\", \" 5/1 \"));\nconsole.log(simplify(\"1/6\", \" 2/1 \"));\nconsole.log(simplify(\"7/10\", \" 10/2 \"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits2 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits3 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits4 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits5 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits6 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits7 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits8 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits9 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits10 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits11 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits12 = (num) => {\n  return num.toString().split('').reduce((a, b) => a + b, 0);\n};\n\n/*\n  Write a function which returns the sum of the digits of a given number.\n  For example:\n  >>> sumDigits(123) == 3\n  >>> sumDigits(1234) == 4\n  >>> sumDigits(0) == 0\n  */\nconst sumDigits13 = (num) => {\n  return num.toString().split('').reduce((", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 3, "perturbed": true, "gc": "/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i].toString().substr(0, 1) % 2!== 0 && nums[i].toString().substr(-1, 1) % 2!== 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconsole.log(specialFilter([15, -73, 14, -15]));\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let result = 0\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          result++\n        }\n      }\n    }\n  }\n  return result\n}\n\nconsole.log(getMaxTriples(5))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 3, "perturbed": true, "gc": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planet1_name = planet1.toLowerCase();\n  let planet2_name = planet2.toLowerCase();\n  let planet1_orbit = getOrbit(planet1_name);\n  let planet2_orbit = getOrbit(planet2_name);\n  let planet1_satellite = getSatellite(planet1_name);\n  let planet2_satellite = getSatellite(planet2_name);\n  let planet1_satellite_names = planet1_satellite.map(satellite => satellite.toLowerCase());\n  let planet2_satellite_names = planet2_satellite.map(satellite => satellite.toLowerCase());\n  let planet1_satellites = planet1_satellite_names.filter(satellite => planet1_orbit.indexOf(satellite) > -1);\n  let planet2_satellites = planet2_satellite_names.filter(satellite => planet2_orbit.indexOf(satellite) > -1);\n  let planet1_satellites_names = planet1_satellites.map(satellite => satellite.toLowerCase());\n  let planet2_satellites_names = planet2_satellites.map(satellite => satellite.toLowerCase());\n  let planet1_satellites_names_set = new Set(planet1_satellites_names);\n  let planet2_satellites_names_set = new Set(planet2_satellites_names);\n  let planet1_satellites_names_set_intersection = planet1_satellites_names_set.intersection(planet2_satellites_names_set);\n  let planet1_satellites_names_set_union = planet1_satellites_names_set.union(planet2_satellites_names_set);\n  let planet1_satellites_names_set_difference = planet1_satellites_names_set.difference(planet2_satellites_names_set);\n  let planet1_satellites_names_set_symmetric_difference = planet1_satellites_names_set.symmetricDifference(planet2_satellites_names_set);\n  let planet1_satellites_names_set_intersection_union = planet1_satellites_names_set_intersection.union(planet2_satellites_names_set_union);\n  let planet1_satellites_names_set_intersection_difference = planet1_satellites_names_set_intersection.difference(planet2_satellites_names_set_difference);\n  let planet1_satellites_names_set_intersection_symmetric_difference = planet1_satellites_names_set_intersection.symmetricDifference(planet2_satellites_names_set_symmetric_difference);\n  let planet1_satellites_names_set_intersection_union_difference = planet1_satellites_names_set_intersection_union.difference(planet2_satellites_names_set_difference);\n  let planet1_satellites_names_set_intersection_union_symmetric_difference = planet1_satellites_names_set_intersection_union.symmetricDifference(planet2_satellites_names_set_symmetric_difference);\n  let planet1_satellites_names_set_intersection_union_difference_symmetric_difference = planet1_satellites_names_set_intersection_union_difference.symmetricDifference(planet2_satellites_names_set_symmetric_difference);\n  let planet1_satellites_names_set_intersection_union_difference_symmetric_difference_symmetric_difference = planet1_satellites_names_set_intersection_union_difference_symmetric_difference.symmetricDifference(planet2_satellites_names_set_symmetric_difference_symmetric_difference);\n  let planet1_satellites_names_set_intersection_union_difference_symmetric_difference_symmetric_difference_symmetric_difference = planet1_satellites_names_set_intersection_union_difference_symmetric_difference_symmetric_difference.symmetricDifference(planet2_satellites_names_set_symmetric_difference_symmetric_difference_symmetric_difference);\n  let planet1_satellites_names_set_intersection_union_difference_symmetric_difference_symmetric_difference_symmetric_difference_symmetric_difference = planet1_satellites_names_set_intersection_union_difference_symmetric_difference_symmetric_difference_symmetric_difference.symmetricDifference(planet2_satellites_names_set_symmetric_difference_symmetric_difference_symmetric_difference_symmetric_difference);\n  let planet1_satellites_names_set_intersection_union_difference_symmetric_difference_symmetric_difference_symmetric_difference_symmetric_difference_symmetric_difference = planet1_satellites_names_set_intersection_union_difference_symmetric_difference_symmetric_diff", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 3, "perturbed": true, "gc": "/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n    let sortedList = [];\n    for (let i = 0; i < lst.length; i++) {\n        let l = lst[i];\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            sum += l[j];\n        }\n        if (sum % 2 === 1) {\n            sortedList.push(l);\n        }\n    }\n    return sortedList;\n};\n\nconst list_sort = (lst) => {\n    let sortedList = [];\n    for (let i = 0; i < lst.length; i++) {\n        let l = lst[i];\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            sum += l[j];\n        }\n        if (sum % 2 === 1) {\n            sortedList.push(l);\n        }\n    }\n    return sortedList;\n};\n\nconst list_sort_by_length = (lst) => {\n    let sortedList = [];\n    for (let i = 0; i < lst.length; i++) {\n        let l = lst[i];\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            sum += l[j];\n        }\n        if (sum % 2 === 1) {\n            sortedList.push(l);\n        }\n    }\n    return sortedList;\n};\n\nconst list_sort_by_length_desc = (lst) => {\n    let sortedList = [];\n    for (let i = 0; i < lst.length; i++) {\n        let l = lst[i];\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            sum += l[j];\n        }\n        if (sum % 2 === 1) {\n            sortedList.push(l);\n        }\n    }\n    return sortedList.reverse();\n};\n\nconst list_sort_by_length_asc = (lst) => {\n    let sortedList = [];\n    for (let i = 0; i < lst.length; i++) {\n        let l = lst[i];\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            sum += l[j];\n        }\n        if (sum % 2 === 1) {\n            sortedList.push(l);\n        }\n    }\n    return sortedList;\n};\n\nconst list_sort_by_length_desc_asc = (lst) => {\n    let sortedList = [];\n    for (let i = 0; i < lst.length; i++) {\n        let l = lst[i];\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            sum += l[j];\n        }\n        if (sum % 2 === 1) {\n            sortedList.push(l);\n        }\n    }\n    return sortedList.reverse();\n};\n\nconst list_sort_by_length_desc_asc_by_length = (lst) => {\n    let sortedList = [];\n    for (let i = 0; i < lst.length; i++) {\n        let l = lst[i];\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            sum += l[j];\n        }\n        if (sum % 2 === 1) {\n            sortedList.push(l);\n        }\n    }\n    return sortedList.reverse();\n};\n\nconst list_sort_by_length_desc_asc_by_length_desc = (lst) => {\n    let sortedList = [];\n    for (let i = 0; i < lst.length; i++) {\n        let l = lst[i];\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            sum += l[j];\n        }\n        if (sum % 2 === 1) {\n            sortedList.push(l);\n        }\n    }\n    return sortedList.reverse();\n};\n\nconst list_sort_by_length_desc_asc_by_length_desc_by_length = (lst) => {\n    let sortedList = [];\n    for (let i = 0; i < lst.length; i++) {\n        let l = lst[i];\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            sum += l[j];\n        }\n        if (sum % 2 === 1) {\n            sortedList.push(l);\n        }\n    }\n    return sortedList.reverse();\n};\n\nconst list_sort_by_length_desc_asc_by_length_desc_by_length_desc = (lst) => {\n    let sortedList = [];\n    for (let i = 0; i < lst.length; i++) {\n        let l = lst[i];\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            sum += l[j];\n        }\n        if (sum % 2 === 1) {\n            sortedList.push(l);\n        }\n    }\n    return sortedList.reverse();\n};\n\nconst list_sort_by_length", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 3, "perturbed": true, "gc": "/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence2 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence3 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence4 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence5 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence6 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence7 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence8 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence9 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence10 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence11 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence12 = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 3, "perturbed": true, "gc": "/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n  if (n === 2) {\n    return true\n  }\n  if (n % 2 === 0) {\n    return false\n  }\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\nconst xOrYPrime = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime2 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime3 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime4 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime5 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime6 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime7 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime8 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime9 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime10 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime11 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime12 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime13 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime14 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime15 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime16 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime17 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime18 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime19 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime20 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime21 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime22 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime23 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime24 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime25 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime26 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime27 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime28 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime29 = (n, x, y) => {\n  if (isPrime(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given impart a list of numbers phone number, return the sum union of squares of the numbers \n   in the list that are odd leftover. Ignore numbers numeral that are negative damaging or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 3, "perturbed": true, "gc": "/* Given impart a list of numbers phone number, return the sum union of squares of the numbers \n   in the list that are odd leftover. Ignore numbers numeral that are negative damaging or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] % 2 === 1) {\n            sum += lst[i] * lst[i];\n        }\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n}\n\n// Given a list of numbers, return the sum of the numbers. \n// If the list is empty, return 0. \n// * / \nconst sum = (lst) = > {\n    let sum = 0;\n    for", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/152", "prompt": "/*I think remember we all remember commend that feeling when the result solution of some long - awaited \n   event consequence is finally ultimately known. The feelings and thoughts thinking you have at that moment here and now are \n   definitely worth noting down and comparing. \n   Your task job is to determine settle if a person correctly guessed the results resultant role of a number of matches. \n   You are given establish two arrays of scores and guesses guess of equal adequate length distance, where each index shows express a match catch. \n   Return an array of the same length denoting how far off each guess was. If they have guessed guess correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 3, "perturbed": true, "gc": "/*I think remember we all remember commend that feeling when the result solution of some long - awaited \n   event consequence is finally ultimately known. The feelings and thoughts thinking you have at that moment here and now are \n   definitely worth noting down and comparing. \n   Your task job is to determine settle if a person correctly guessed the results resultant role of a number of matches. \n   You are given establish two arrays of scores and guesses guess of equal adequate length distance, where each index shows express a match catch. \n   Return an array of the same length denoting how far off each guess was. If they have guessed guess correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let result = []\n  for (let i = 0; i < game.length; i++) {\n    let score = game[i]\n    let guess = guess[i]\n    if (score === guess) {\n      result.push(0)\n    } else {\n      result.push(Math.abs(score - guess))\n    }\n  }\n  return result\n}\n\n/*\n  Given a number, return the number of digits in the number.\n  \n  example:\n\n  digit(1234) -> 4\n  digit(123) -> 3\n  digit(12) -> 2\n  digit(1) -> 1\n  digit(0) -> 0\n  digit(-1) -> 1\n  digit(-12) -> 2\n  digit(-123) -> 3\n  digit(-1234) -> 4\n  digit(-12345) -> 5\n  digit(-123456) -> 6\n  digit(-1234567) -> 7\n  digit(-12345678) -> 8\n  digit(-123456789) -> 9\n  digit(-1234567890) -> 10\n  digit(-12345678901) -> 11\n  digit(-123456789012) -> 12\n  digit(-1234567890123) -> 13\n  digit(-12345678901234) -> 14\n  digit(-123456789012345) -> 15\n  digit(-1234567890123456) -> 16\n  digit(-12345678901234567) -> 17\n  digit(-123456789012345678) -> 18\n  digit(-1234567890123456789) -> 19\n  digit(-12345678901234567890) -> 20\n  digit(-123456789012345678901) -> 21\n  digit(-1234567890123456789012) -> 22\n  digit(-12345678901234567890123) -> 23\n  digit(-123456789012345678901234) -> 24\n  digit(-1234567890123456789012345) -> 25\n  digit(-12345678901234567890123456) -> 26\n  digit(-123456789012345678901234567) -> 27\n  digit(-1234567890123456789012345678) -> 28\n  digit(-12345678901234567890123456789) -> 29\n  digit(-123456789012345678901234567890) -> 30\n  digit(-1234567890123456789012345678901) -> 31\n  digit(-12345678901234567890123456789012) -> 32\n  digit(-123456789012345678901234567890123) -> 33\n  digit(-1234567890123456789012345678901234) -> 34\n  digit(-12345678901234567890123456789012345) -> 35\n  digit(-123456789012345678901234567890123456) -> 36\n  digit(-1234567890123456789012345678901234567) -> 37\n  digit(-12345678901234567890123456789012345678) -> 38\n  digit(-123456789012345678901234567890123456789) -> 39\n  digit(-1234567890123456789012345678901234567890) -> 40\n  digit(-12345678901234567890123456789012345678901) -> 41\n  digit(-123456789012345678901234567890123456789012) -> 42\n  digit(-1234567890123456789012345678901234567890123) -> 43\n  digit(-12345678901234567890123456789012345678901234) -> 44\n  digit(-123456789012345678901234567890123456789012345) -> 45\n  digit(-1234567890123456789012345678901234567890123456) -> 46\n  digit(-12345678901234567890123456789012345678901234567) -> 47\n  digit(-123456789012345678901234567890123456789012345678) -> 48\n  digit(-1234567890123456789012345678901234567890123456789) -> 49\n  digit(-12345678901234567890123456789012345678901234567890) -> 50\n  digit(-123456789012345678901234567890123456789012345678901) -> 51\n  digit(-1234567890123456789012345678901234567890123456789012) -> 52\n  digit(-12345678901234567890123456789012345678901234567890123) -> 53\n  digit(-123456789012345678901234567890123456789012345678901234) -> 54\n  digit(-1234567890123456789012345678901234567890123456789012345", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given impart the name of a class course (a string) and a list of extensions.\n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 3, "perturbed": true, "gc": "/*You will be given impart the name of a class course (a string) and a list of extensions.\n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach((extension) => {\n    const extension_name = extension.split('.').pop();\n    const extension_strength = extension.split('.').reduce((acc, char) => {\n      if (char.toUpperCase() === char) {\n        acc++;\n      }\n      return acc;\n    }, 0);\n    if (strength[extension_name] === undefined) {\n      strength[extension_name] = extension_strength;\n    } else {\n      strength[extension_name] = Math.min(strength[extension_name], extension_strength);\n    }\n  });\n  const strongest_extension = Object.keys(strength).reduce((acc, key) => {\n    if (strength[key] === strength[key]) {\n      return key;\n    }\n    return strength[key];\n  }, 0);\n  return `${class_name}.${strongest_extension}`;\n};\n\nmodule.exports = strongestExtension;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 3, "perturbed": true, "gc": "/*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   let a = a.toLowerCase();\n   let b = b.toLowerCase();\n   let a_len = a.length;\n   let b_len = b.length;\n   let a_start = 0;\n   let b_start = 0;\n   let a_end = a_len - 1;\n   let b_end = b_len - 1;\n   while (a_start <= a_end && b_start <= b_end) {\n     if (a[a_start] == b[b_start]) {\n       a_start++;\n       b_start++;\n     } else if (a[a_start] == b[b_start + 1]) {\n       a_start++;\n       b_start++;\n       b_start++;\n     } else if (a[a_start] == b[b_start - 1]) {\n       a_start++;\n       b_start--;\n     } else if (a[a_start] == b[b_start - 2]) {\n       a_start++;\n       b_start--;\n       b_start--;\n     } else if (a[a_start] == b[b_start + 2]) {\n       a_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n     } else if (a[a_start] == b[b_start - 3]) {\n       a_start++;\n       b_start--;\n       b_start--;\n       b_start--;\n     } else if (a[a_start] == b[b_start + 3]) {\n       a_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n     } else if (a[a_start] == b[b_start - 4]) {\n       a_start++;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n     } else if (a[a_start] == b[b_start + 4]) {\n       a_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n     } else if (a[a_start] == b[b_start - 5]) {\n       a_start++;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n     } else if (a[a_start] == b[b_start + 5]) {\n       a_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n     } else if (a[a_start] == b[b_start - 6]) {\n       a_start++;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n     } else if (a[a_start] == b[b_start + 6]) {\n       a_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n     } else if (a[a_start] == b[b_start - 7]) {\n       a_start++;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n     } else if (a[a_start] == b[b_start + 7]) {\n       a_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n     } else if (a[a_start] == b[b_start - 8]) {\n       a_start++;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n     } else if (a[a_start] == b[b_start + 8]) {\n       a_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n     } else if (a[a_start] == b[b_start - 9]) {\n       a_start++;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n     } else if (a[a_start] == b[b_start + 9]) {\n       a_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n       b_start++;\n     } else if (a[a_start] == b[b_start - 10]) {\n       a_start++;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n       b_start--;\n     } else if (a[a_start] == b[b_start + 10]) {\n       a_start++;\n       b_start++;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number numeral of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 3, "perturbed": true, "gc": "/*Given an integer. return a tuple that has the number numeral of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = Math.floor(num / 2);\n  }\n  return [even, odd];\n};\n\nmodule.exports = evenOddCount;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given impart a positive convinced integer, obtain receive its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a positive convinced integer, obtain receive its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const roman = {\n    'I': 1,\n    'V': 5,\n    'X': 10,\n    'L': 50,\n    'C': 100,\n    'D': 500,\n    'M': 1000\n  };\n  const result = [];\n  let current = number;\n  while (current > 0) {\n    const remainder = current % roman[current];\n    current = Math.floor(current / roman[current]);\n    result.unshift(remainder);\n  }\n  return result.join('');\n};\n\n/*\n  Given a roman numeral, return the number. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToRoman(19) == 19\n  >>> intToRoman(152) == 152\n  >>> intToRoman(426) == 426\n  */\nconst intToRoman = (number) => {\n  const roman = {\n    'I': 1,\n    'V': 5,\n    'X': 10,\n    'L': 50,\n    'C': 100,\n    'D': 500,\n    'M': 1000\n  };\n  const result = [];\n  let current = number;\n  while (current > 0) {\n    const remainder = current % roman[current];\n    current = Math.floor(current / roman[current]);\n    result.unshift(remainder);\n  }\n  return result.join('');\n};\n\n/*\n  Given a positive number, return the number in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  const roman = {\n    'I': 1,\n    'V': 5,\n    'X': 10,\n    'L': 50,\n    'C': 100,\n    'D': 500,\n    'M': 1000\n  };\n  const result = [];\n  let current = number;\n  while (current > 0) {\n    const remainder = current % roman[current];\n    current = Math.floor(current / roman[current]);\n    result.unshift(remainder);\n  }\n  return result.join('');\n};\n\n/*\n  Given a positive number, return the number in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  const roman = {\n    'I': 1,\n    'V': 5,\n    'X': 10,\n    'L': 50,\n    'C': 100,\n    'D': 500,\n    'M': 1000\n  };\n  const result = [];\n  let current = number;\n  while (current > 0) {\n    const remainder = current % roman[current];\n    current = Math.floor(current / roman[current]);\n    result.unshift(remainder);\n  }\n  return result.join('');\n};\n\n/*\n  Given a positive number, return the number in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  const roman = {\n    'I': 1,\n    'V': 5,\n    'X': 10,\n    'L': 50,\n    'C': 100,\n    'D': 500,\n    'M': 1000\n  };\n  const result = [];\n  let current = number;\n  while (current > 0) {\n    const remainder = current % roman[current];\n    current = Math.floor(current / roman[current]);\n    result.unshift(remainder);\n  }\n  return result.join('');\n};\n\n/*\n  Given a positive number, return the number in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  const roman = {\n    'I': 1,\n    'V': 5,\n    'X': 10,\n    'L': 50,\n    'C': 100,\n    'D': 500,\n    'M': 1000\n  };\n  const result = [];\n  let current = number;\n  while (current > 0) {\n    const remainder = current % roman[current];\n    current = Math.floor(current / roman[current]);\n    result.unshift(remainder);\n  }\n  return result.join('');\n};\n\n/*\n  Given a positive number, return the number in roman numeral. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  const roman = {\n    'I': 1,\n    'V': 5,\n    'X': 10,\n    'L': 50,\n    'C': 100,\n    'D': 500,\n    'M': 1000\n  };\n  const", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/157", "prompt": "/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 3, "perturbed": true, "gc": "/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const s1 = Math.sqrt(a * a + b * b);\n  const s2 = Math.sqrt(c * c + b * b);\n  const s3 = Math.sqrt(a * a + c * c);\n  const s4 = Math.sqrt(a * a + c * c + b * b);\n  const s5 = Math.sqrt(c * c + a * a + b * b);\n  const s6 = Math.sqrt(a * a + b * b + c * c);\n  const s7 = Math.sqrt(a * a + c * c + b * b + c * c);\n  const s8 = Math.sqrt(c * c + a * a + b * b + c * c);\n  const s9 = Math.sqrt(a * a + b * b + c * c + a * a + b * b);\n  const s10 = Math.sqrt(a * a + c * c + b * b + c * c + a * a + b * b);\n  const s11 = Math.sqrt(c * c + a * a + b * b + c * c + a * a + b * b);\n  const s12 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c);\n  const s13 = Math.sqrt(a * a + c * c + b * b + a * a + c * c + b * b);\n  const s14 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s15 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s16 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s17 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s18 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s19 = Math.sqrt(a * a + c * c + b * b + a * a + c * c + b * b + c * c);\n  const s20 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s21 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s22 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s23 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s24 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s25 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s26 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s27 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s28 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s29 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s30 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s31 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s32 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s33 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s34 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s35 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s36 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s37 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s38 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c * c);\n  const s39 = Math.sqrt(a * a + b * b + c * c + a * a + b * b + c * c + b * b);\n  const s40 = Math.sqrt(c * c + a * a + b * b + a * a + c * c + b * b + c", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function affair that accepts take a list of strings bowed stringed instrument. \n   The list contains contain different words. Return the word son with maximum maximal number \n   of unique characters quality. If multiple strings string have maximum number of unique \n   characters, return the one which comes come first foremost in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 3, "perturbed": true, "gc": "/*Write a function affair that accepts take a list of strings bowed stringed instrument. \n   The list contains contain different words. Return the word son with maximum maximal number \n   of unique characters quality. If multiple strings string have maximum number of unique \n   characters, return the one which comes come first foremost in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   const max = words[0];\n   for (let i = 1; i < words.length; i++) {\n     const [word, count] = words[i];\n     if (count > max.count) {\n       max = word;\n     }\n   }\n   return max;\n }\n*/\n\nconst findMax = (words) => {\n  const max = words[0];\n  for (let i = 1; i < words.length; i++) {\n    const [word, count] = words[i];\n    if (count > max.count) {\n      max = word;\n    }\n  }\n  return max;\n};\n\nconsole.log(findMax([\"name\", \" of \", \" string \"]));\nconsole.log(findMax([\"name\", \" enam \", \" game \"]));\nconsole.log(findMax([\"aaaaaaa\", \" bb \", \" cc \"]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 3, "perturbed": true, "gc": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining]\n  } else {\n    return [number, need - number]\n  }\n}\n\nconst main = () => {\n  const [number, remaining] = eat(5, 6, 10)\n  console.log(`${number} carrots eaten, ${remaining} left`)\n  const [number, remaining] = eat(4, 8, 9)\n  console.log(`${number} carrots eaten, ${remaining} left`)\n  const [number, remaining] = eat(1, 10, 10)\n  console.log(`${number} carrots eaten, ${remaining} left`)\n  const [number, remaining] = eat(2, 11, 5)\n  console.log(`${number} carrots eaten, ${remaining} left`)\n}\n\nmain()\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/16", "prompt": "/* Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 3, "perturbed": true, "gc": "/* Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const chars = string.split('')\n  const counts = {}\n  chars.forEach((char) => {\n    if (counts[char] === undefined) {\n      counts[char] = 1\n    } else {\n      counts[char]++\n    }\n  })\n  return Object.keys(counts).length\n}\n\n/* Given a string, find the longest substring that contains all the same characters\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRST", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let sum = 0\n  let product = 1\n  let operation = 0\n\n  while (i < operatorLength && j < operandLength) {\n    operation = operator[i]\n    sum = operand[j]\n    if (operation === '+') {\n      sum += operand[j + 1]\n    } else if (operation === '-') {\n      sum -= operand[j + 1]\n    } else if (operation === '*') {\n      product *= operand[j + 1]\n    } else if (operation === '/') {\n      product /= operand[j + 1]\n    } else if (operation === '**') {\n      product *= operand[j + 1]\n      product *= operand[j + 2]\n    }\n    result.push(sum)\n    i += 1\n    j += 2\n  }\n  return result\n}\n\nconst doAlgebra2 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let sum = 0\n  let product = 1\n  let operation = 0\n\n  while (i < operatorLength && j < operandLength) {\n    operation = operator[i]\n    sum = operand[j]\n    if (operation === '+') {\n      sum += operand[j + 1]\n    } else if (operation === '-') {\n      sum -= operand[j + 1]\n    } else if (operation === '*') {\n      product *= operand[j + 1]\n    } else if (operation === '/') {\n      product /= operand[j + 1]\n    } else if (operation === '**') {\n      product *= operand[j + 1]\n      product *= operand[j + 2]\n    }\n    result.push(sum)\n    i += 1\n    j += 2\n  }\n  return result\n}\n\nconst doAlgebra3 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let sum = 0\n  let product = 1\n  let operation = 0\n\n  while (i < operatorLength && j < operandLength) {\n    operation = operator[i]\n    sum = operand[j]\n    if (operation === '+') {\n      sum += operand[j + 1]\n    } else if (operation === '-') {\n      sum -= operand[j + 1]\n    } else if (operation === '*') {\n      product *= operand[j + 1]\n    } else if (operation === '/') {\n      product /= operand[j + 1]\n    } else if (operation === '**') {\n      product *= operand[j + 1]\n      product *= operand[j + 2]\n    }\n    result.push(sum)\n    i += 1\n    j += 2\n  }\n  return result\n}\n\nconst doAlgebra4 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let sum = 0\n  let product = 1\n  let operation = 0\n\n  while (i < operatorLength && j < operandLength) {\n    operation = operator[i]\n    sum = operand[j]\n    if (operation === '+') {\n      sum += operand[j + 1]\n    } else if (operation === '-') {\n      sum -= operand[j + 1]\n    } else if (operation === '*') {\n      product *= operand[j + 1]\n    } else if (operation === '/') {\n      product /= operand[j + 1]\n    } else if (operation === '**') {\n      product *= operand[j + 1]\n      product *= operand[j + 2]\n    }\n    result.push(sum)\n    i += 1\n    j += 2\n  }\n  return result\n}\n\nconst doAlgebra5 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let sum = 0\n  let product = 1\n  let operation = 0\n\n  while (i < operatorLength && j < operandLength) {\n    operation = operator[i]\n    sum = operand[j]\n    if (operation === '+') {\n      sum += operand[j + 1]\n    } else if (operation === '-') {\n      sum -= operand[j + 1]\n    } else if (operation === '*') {\n      product *= operand[j + 1]\n    } else if (operation === '/') {\n      product /= operand[j + 1]\n    } else if (operation === '**') {\n      product *= operand[j + 1]\n      product *= operand[j + 2]\n    }\n    result.push(sum)\n    i += 1\n    j += 2\n  }\n  return", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given impart a string bowed stringed instrument s.\n   if s[i] is a letter, reverse overrule its case casing from lower to upper or vise versa, \n   otherwise differently keep observe it as it is. \n   If the string contains no letters letter, reverse change by reversal the string. \n   The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*You are given impart a string bowed stringed instrument s.\n   if s[i] is a letter, reverse overrule its case casing from lower to upper or vise versa, \n   otherwise differently keep observe it as it is. \n   If the string contains no letters letter, reverse change by reversal the string. \n   The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toLowerCase() === s[i].toUpperCase()) {\n      result += s[i].toUpperCase();\n    } else {\n      result += s[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\nmodule.exports = stringToMd5;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given impart two positive convinced integers integer a and b, return the even digits between a\n   and b, in ascending rise order decree.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart two positive convinced integers integer a and b, return the even digits between a\n   and b, in ascending rise order decree.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers2 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers3 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers4 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers5 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers6 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers7 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers8 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers9 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers10 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers11 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers12 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers13 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers14 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers15 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers16 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers17 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers18 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers19 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers20 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers21 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers22 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers23 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers24 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input stimulation to this function routine is a string representing act musical notes note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   not last. \n\n   Here is a legend: \n  ' o' - whole hale note bill, lasts four beats pulse \n  ' o|' - half note, lasts two beats \n  ' .|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 3, "perturbed": true, "gc": "/* Input stimulation to this function routine is a string representing act musical notes note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   not last. \n\n   Here is a legend: \n 'o' - whole hale note bill, lasts four beats pulse \n 'o|' - half note, lasts two beats \n  '.|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split(' ')\n  const beat_length = 4\n  const beat_length_half = 2\n  const beat_length_quarter = 1\n  const beat_length_whole = 4\n  const beat_length_half_quarter = 2\n  const beat_length_quarter_half = 2\n  const beat_length_whole_half = 4\n  const beat_length_whole_quarter = 2\n  const beat_length_half_whole = 2\n  const beat_length_quarter_whole = 2\n  const beat_length_whole_half_quarter = 2\n  const beat_length_quarter_half_whole = 2\n  const beat_length_half_quarter_whole = 2\n  const beat_length_whole_quarter_half = 2\n  const beat_length_quarter_half_whole = 2\n  const beat_length_half_quarter_whole = 2\n  const beat_length_whole_quarter_half_quarter = 2\n  const beat_length_quarter_half_whole_quarter = 2\n  const beat_length_half_quarter_whole_quarter = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_half_quarter_whole_quarter_half = 2\n  const beat_length_quarter_half_whole_quarter_half = 2\n  const beat_length_whole_quarter_half_quarter_half = 2\n  const beat_length_quarter_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find witness how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 3, "perturbed": true, "gc": "/* Find witness how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const stringLength = string.length\n  const substringLength = substring.length\n  const overlap = Math.min(stringLength, substringLength)\n  const overlapCount = overlap\n  const stringIndex = 0\n  const substringIndex = 0\n  const overlapIndex = 0\n  const overlapCount = overlap\n  const result = []\n  while (stringIndex < stringLength && substringIndex < substringLength) {\n    if (string[stringIndex] === substring[substringIndex]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n      substringIndex += 1\n    } else if (string[stringIndex] === substring[substringIndex - 1]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n    } else if (string[stringIndex] === substring[substringIndex + 1]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n      substringIndex += 1\n    } else if (string[stringIndex - 1] === substring[substringIndex]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n    } else if (string[stringIndex + 1] === substring[substringIndex]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n      substringIndex += 1\n    } else {\n      stringIndex += 1\n      substringIndex += 1\n    }\n  }\n  return result.length\n}\n\n/*\n  Find the longest substring that can be found in the original string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'aa')\n  'aaa'\n  >>> longestSubstring('aaaa', 'aa')\n  'aaaa'\n  >>> longestSubstring('aaaa', 'aaa')\n  'aaaa'\n  */\nconst longestSubstring = (string, substring) => {\n  const stringLength = string.length\n  const substringLength = substring.length\n  const overlap = Math.min(stringLength, substringLength)\n  const overlapCount = overlap\n  const stringIndex = 0\n  const substringIndex = 0\n  const overlapIndex = 0\n  const result = []\n  while (stringIndex < stringLength && substringIndex < substringLength) {\n    if (string[stringIndex] === substring[substringIndex]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n      substringIndex += 1\n    } else if (string[stringIndex] === substring[substringIndex - 1]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n    } else if (string[stringIndex] === substring[substringIndex + 1]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n      substringIndex += 1\n    } else if (string[stringIndex - 1] === substring[substringIndex]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n    } else if (string[stringIndex + 1] === substring[substringIndex]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n      substringIndex += 1\n    } else {\n      stringIndex += 1\n      substringIndex += 1\n    }\n  }\n  return result.length > 0? result[0] : ''\n}\n\n/*\n  Find the longest substring that can be found in the original string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'aa')\n  'aaa'\n  >>> longestSubstring('aaaa', 'aa')\n  'aaaa'\n  >>> longestSubstring('aaaa', 'aaa')\n  'aaaa'\n  */\nconst longestSubstring = (string, substring) => {\n  const stringLength = string.length\n  const substringLength = substring.length\n  const overlap = Math.min(stringLength, substringLength)\n  const overlapCount = overlap\n  const stringIndex = 0\n  const substringIndex = 0\n  const overlapIndex = 0\n  const result = []\n  while (stringIndex < stringLength && substringIndex < substringLength) {\n    if (string[stringIndex] === substring[substringIndex]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n      substringIndex += 1\n    } else if (string[stringIndex] === substring[substringIndex - 1]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n    } else if (string[stringIndex] === substring[substringIndex + 1]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n      substringIndex += 1\n    } else if (string[stringIndex - 1] === substring[substringIndex]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n    } else if (string[stringIndex + 1] === substring[substringIndex]) {\n      result.push(overlapIndex)\n      overlapIndex += 1\n      stringIndex += 1\n      substringIndex += 1\n    } else {\n      stringIndex += 1\n      substringIndex += 1\n    }\n  }\n  return result.length > 0? result[0] : ''\n}\n\n/*\n  Find the longest substring that can be found in the original string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'aa')\n  'aaa'\n  >>> longestSubstring('aaaa', 'aa')\n  'aaaa'\n  >>> longestSubstring('aaaa', 'aaa')\n  'aaaa'\n  */\nconst longestSubstring = (string, substring) => {\n  const stringLength = string.length\n  const substringLength = substring.length\n  const overlap = Math.min(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/19", "prompt": "/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 3, "perturbed": true, "gc": "/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const sortedNumbers = numbers.split(' ').sort((a, b) => {\n    const aNumber = parseInt(a, 10);\n    const bNumber = parseInt(b, 10);\n    return aNumber - bNumber;\n  });\n  return sortedNumbers.join(' ');\n};\n\n/*\n  Input:\n   'one two three'\n   \n   Output:\n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n   \n   'one two three'\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 3, "perturbed": true, "gc": "/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  const intPartShare = Math.floor(decPart * Math.pow(10, Math.floor(Math.log10(number))));\n  return intPartShare + (decPart - intPartShare) / Math.pow(10, Math.floor(Math.log10(number)));\n};\n\n/* Given a positive number, it can be divided into two parts, the first part is the largest integer smaller than \n   the given number, the second part is the leftover part. \n\n   Return the two parts of the number.\n  >>> divideNumber(3.5)\n  [0.5, 0.5]\n  */\nconst divideNumber = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  const intPartShare = Math.floor(decPart * Math.pow(10, Math.floor(Math.log10(number))));\n  return [intPartShare, (decPart - intPartShare) / Math.pow(10, Math.floor(Math.log10(number)))];\n};\n\n/* Given a positive number, it can be divided into three parts, the first part is the largest integer smaller than \n   the given number, the second part is the leftover part, the third part is the decimal part. \n\n   Return the three parts of the number.\n  >>> divideNumber(3.5)\n  [0.5, 0.5, 0.5]\n  */\nconst divideNumber2 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  const intPartShare = Math.floor(decPart * Math.pow(10, Math.floor(Math.log10(number))));\n  return [intPartShare, (decPart - intPartShare) / Math.pow(10, Math.floor(Math.log10(number))), decPart];\n};\n\n/* Given a positive number, it can be divided into four parts, the first part is the largest integer smaller than \n   the given number, the second part is the leftover part, the third part is the decimal part, the fourth part is the \n   decimal part. \n\n   Return the four parts of the number.\n  >>> divideNumber2(3.5)\n  [0.5, 0.5, 0.5, 0.5]\n  */\nconst divideNumber3 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  const intPartShare = Math.floor(decPart * Math.pow(10, Math.floor(Math.log10(number))));\n  return [intPartShare, (decPart - intPartShare) / Math.pow(10, Math.floor(Math.log10(number))), decPart, decPart];\n};\n\n/* Given a positive number, it can be divided into five parts, the first part is the largest integer smaller than \n   the given number, the second part is the leftover part, the third part is the decimal part, the fourth part is the \n   decimal part, the fifth part is the decimal part. \n\n   Return the five parts of the number.\n  >>> divideNumber3(3.5)\n  [0.5, 0.5, 0.5, 0.5, 0.5]\n  */\nconst divideNumber4 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  const intPartShare = Math.floor(decPart * Math.pow(10, Math.floor(Math.log10(number))));\n  return [intPartShare, (decPart - intPartShare) / Math.pow(10, Math.floor(Math.log10(number))), decPart, decPart, decPart];\n};\n\n/* Given a positive number, it can be divided into six parts, the first part is the largest integer smaller than \n   the given number, the second part is the leftover part, the third part is the decimal part, the fourth part is the \n   decimal part, the fifth part is the decimal part, the sixth part is the decimal part. \n\n   Return the six parts of the number.\n  >>> divideNumber4(3.5)\n  [0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\n  */\nconst divideNumber5 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  const intPartShare = Math.floor(decPart * Math.pow(10, Math.floor(Math.log10(number))));\n  return [intPartShare, (decPart - intPartShare) / Math.pow(10, Math.floor(Math.log10(number))), decPart, decPart, decPart, decPart];\n};\n\n/* Given a positive number, it can be divided into seven parts, the first part is the largest integer smaller than \n   the given number, the second part is the leftover part, the third part is the decimal part, the fourth part is the \n   decimal part, the fifth part is the decimal part, the sixth part is the decimal part, the seventh part is the \n   decimal part. \n\n   Return the seven parts of the number.\n  >>> divideNumber5(3.5)\n  [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\n  */\nconst divideNumber6 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  const intPartShare = Math.floor(decPart * Math.pow(10, Math.floor(Math.log10(number))));\n  return [intPartShare, (decPart - intPartShare) / Math.pow(10, Math.floor(Math.log10(number))), decPart, decPart, decPart, decPart, decPart];\n};\n\n/* Given a positive number, it can be divided into eight parts, the first part", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied provide list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 3, "perturbed": true, "gc": "/* From a supplied provide list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const distance = (a, b) => Math.abs(a - b);\n  const min = (a, b) => Math.min(a, b);\n  const max = (a, b) => Math.max(a, b);\n  const minDistance = (a, b) => min(distance(a, b), distance(b, a));\n  const minDistanceIndex = (a, b) => minDistance(a, b) === distance(a, b)? a : b;\n  const minDistanceIndex2 = (a, b) => minDistance(a, b) === distance(a, b)? b : a;\n  const minDistance2 = (a, b) => minDistance(a, b);\n  const minDistance3 = (a, b) => minDistance(a, b);\n  const minDistance4 = (a, b) => minDistance(a, b);\n  const minDistance5 = (a, b) => minDistance(a, b);\n  const minDistance6 = (a, b) => minDistance(a, b);\n  const minDistance7 = (a, b) => minDistance(a, b);\n  const minDistance8 = (a, b) => minDistance(a, b);\n  const minDistance9 = (a, b) => minDistance(a, b);\n  const minDistance10 = (a, b) => minDistance(a, b);\n  const minDistance11 = (a, b) => minDistance(a, b);\n  const minDistance12 = (a, b) => minDistance(a, b);\n  const minDistance13 = (a, b) => minDistance(a, b);\n  const minDistance14 = (a, b) => minDistance(a, b);\n  const minDistance15 = (a, b) => minDistance(a, b);\n  const minDistance16 = (a, b) => minDistance(a, b);\n  const minDistance17 = (a, b) => minDistance(a, b);\n  const minDistance18 = (a, b) => minDistance(a, b);\n  const minDistance19 = (a, b) => minDistance(a, b);\n  const minDistance20 = (a, b) => minDistance(a, b);\n  const minDistance21 = (a, b) => minDistance(a, b);\n  const minDistance22 = (a, b) => minDistance(a, b);\n  const minDistance23 = (a, b) => minDistance(a, b);\n  const minDistance24 = (a, b) => minDistance(a, b);\n  const minDistance25 = (a, b) => minDistance(a, b);\n  const minDistance26 = (a, b) => minDistance(a, b);\n  const minDistance27 = (a, b) => minDistance(a, b);\n  const minDistance28 = (a, b) => minDistance(a, b);\n  const minDistance29 = (a, b) => minDistance(a, b);\n  const minDistance30 = (a, b) => minDistance(a, b);\n  const minDistance31 = (a, b) => minDistance(a, b);\n  const minDistance32 = (a, b) => minDistance(a, b);\n  const minDistance33 = (a, b) => minDistance(a, b);\n  const minDistance34 = (a, b) => minDistance(a, b);\n  const minDistance35 = (a, b) => minDistance(a, b);\n  const minDistance36 = (a, b) => minDistance(a, b);\n  const minDistance37 = (a, b) => minDistance(a, b);\n  const minDistance38 = (a, b) => minDistance(a, b);\n  const minDistance39 = (a, b) => minDistance(a, b);\n  const minDistance40 = (a, b) => minDistance(a, b);\n  const minDistance41 = (a, b) => minDistance(a, b);\n  const minDistance42 = (a, b) => minDistance(a, b);\n  const minDistance43 = (a, b) => minDistance(a, b);\n  const minDistance44 = (a, b) => minDistance(a, b);\n  const minDistance45 = (a, b) => minDistance(a, b);\n  const minDistance46 = (a, b) => minDistance(a, b);\n  const minDistance47 = (a, b) => minDistance(a, b);\n  const minDistance48 = (a, b) => minDistance(a, b);\n  const minDistance49 = (a, b) => minDistance(a, b);\n  const minDistance50 = (a, b) => minDistance(a, b);\n  const minDistance51 = (a, b) => minDistance(a, b);\n  const minDistance52 = (a, b) => minDistance(a, b);\n  const minDistance53 = (a, b) => minDistance(a, b);\n  const minDistance54 = (a, b) => minDistance(a, b);\n  const minDistance55 = (a, b) => minDistance(a, b);\n  const minDistance56 = (a, b) => minDistance(a, b);\n  const minDistance57 = (a, b) => minDistance(a, b);\n  const minDistance58 = (a, b) => minDistance(a, b);\n  const minDistance59 = (a, b) => minDistance(a, b);\n  const minDistance60 = (a, b) => minDistance(a, b);\n  const minDistance61 = (a, b) => minDistance(a, b);\n  const minDistance62 = (a, b) => minDistance(a, b);\n  const minDistance63 = (a, b)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given impart list of numbers (of at least two elements element), apply lend oneself a linear analogue transform to that list,\n   such that the smallest number numeral will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 3, "perturbed": true, "gc": "/* Given impart list of numbers (of at least two elements element), apply lend oneself a linear analogue transform to that list,\n   such that the smallest number numeral will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const scale = (x) => (x - min) / (max - min);\n  return numbers.map(scale);\n};\n\n/* Given a list of numbers, return a list of their sum\n  >>> sum([1, 2, 3, 4])\n  10\n  */\nconst sum = (numbers) => {\n  return numbers.reduce((a, b) => a + b);\n};\n\n/* Given a list of numbers, return a list of their product\n  >>> product([1, 2, 3, 4])\n  24\n  */\nconst product = (numbers) => {\n  return numbers.reduce((a, b) => a * b);\n};\n\n/* Given a list of numbers, return a list of their average\n  >>> average([1, 2, 3, 4])\n  2.5\n  */\nconst average = (numbers) => {\n  return sum(numbers) / numbers.length;\n};\n\n/* Given a list of numbers, return a list of their median\n  >>> median([1, 2, 3, 4])\n  2.5\n  */\nconst median = (numbers) => {\n  const sorted = sorted(numbers);\n  const half = Math.floor(numbers.length / 2);\n  return sorted[half];\n};\n\n/* Given a list of numbers, return a list of their mode\n  >>> mode([1, 2, 3, 4])\n  2\n  */\nconst mode = (numbers) => {\n  const sorted = sorted(numbers);\n  const half = Math.floor(numbers.length / 2);\n  const count = 0;\n  const mode = 0;\n  for (let i = 0; i < half; i++) {\n    if (numbers[i] === sorted[i]) {\n      count++;\n    }\n  }\n  if (count === 1) {\n    return sorted[half];\n  }\n  for (let i = half + 1; i < numbers.length; i++) {\n    if (numbers[i] === sorted[i]) {\n      count++;\n    }\n  }\n  if (count === 1) {\n    return sorted[half];\n  }\n  for (let i = half - 1; i >= 0; i--) {\n    if (numbers[i] === sorted[i]) {\n      count++;\n    }\n  }\n  if (count === 1) {\n    return sorted[half];\n  }\n  return sorted[half];\n};\n\n/* Given a list of numbers, return a list of their standard deviation\n  >>> standardDeviation([1, 2, 3, 4])\n  1.118033988749895\n  */\nconst standardDeviation = (numbers) => {\n  const avg = average(numbers);\n  const sum = sum(numbers);\n  const squared = numbers.map((x) => (x - avg) * (x - avg));\n  return Math.sqrt(sum / numbers.length) / avg;\n};\n\n/* Given a list of numbers, return a list of their standard deviation\n  >>> standardDeviation([1, 2, 3, 4])\n  1.118033988749895\n  */\nconst standardDeviation = (numbers) => {\n  const avg = average(numbers);\n  const sum = sum(numbers);\n  const squared = numbers.map((x) => (x - avg) * (x - avg));\n  return Math.sqrt(sum / numbers.length) / avg;\n};\n\n/* Given a list of numbers, return a list of their standard deviation\n  >>> standardDeviation([1, 2, 3, 4])\n  1.118033988749895\n  */\nconst standardDeviation = (numbers) => {\n  const avg = average(numbers);\n  const sum = sum(numbers);\n  const squared = numbers.map((x) => (x - avg) * (x - avg));\n  return Math.sqrt(sum / numbers.length) / avg;\n};\n\n/* Given a list of numbers, return a list of their standard deviation\n  >>> standardDeviation([1, 2, 3, 4])\n  1.118033988749895\n  */\nconst standardDeviation = (numbers) => {\n  const avg = average(numbers);\n  const sum = sum(numbers);\n  const squared = numbers.map((x) => (x - avg) * (x - avg));\n  return Math.sqrt(sum / numbers.length) / avg;\n};\n\n/* Given a list of numbers, return a list of their standard deviation\n  >>> standardDeviation([1, 2, 3, 4])\n  1.118033988749895\n  */\nconst standardDeviation = (numbers) => {\n  const avg = average(numbers);\n  const sum = sum(numbers);\n  const squared = numbers.map((x) => (x - avg) * (x - avg));\n  return Math.sqrt(sum / numbers.length) / avg;\n};\n\n/* Given a list of numbers, return a list of their standard deviation\n  >>> standardDeviation([1, 2, 3, 4])\n  1.118033988749895\n  */\nconst standardDeviation = (numbers) => {\n  const avg = average(numbers);\n  const sum = sum(numbers);\n  const squared = numbers.map((x) => (x - avg) * (x - avg));\n  return Math.sqrt(sum / numbers.length) / avg;\n};\n\n/* Given a list of numbers, return a list of their standard deviation\n  >>> standardDeviation([1, 2, 3, 4])\n  1.118033988749895\n  */\nconst standardDeviation = (numbers) => {\n  const avg = average(numbers);\n  const sum = sum(numbers);\n  const squared = numbers.map((x) => (x - avg) * (x - avg));\n  return Math.sqrt(sum / numbers.length", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter given impart list of any python values only for integers integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 3, "perturbed": true, "gc": "/* Filter given impart list of any python values only for integers integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given impart list of any python values only for strings string\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given impart list of any python values only for booleans boolean\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given impart list of any python values only for objects object\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given impart list of any python values only for arrays array\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter given impart list of any python values only for dictionaries dictionary\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(v => typeof v === 'object' &&!Array.isArray(v));\n};\n\n/**\n  * Filter given impart list of any python values only for numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given impart list of any python values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given impart list of any python values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given impart list of any python values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given impart list of any python values only for arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter given impart list of any python values only for dictionaries\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(v => typeof v === 'object' &&!Array.isArray(v));\n};\n\n/**\n  * Filter given impart list of any python values only for numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given impart list of any python values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given impart list of any python values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given impart list of any python values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given impart list of any python values only for arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter given impart list of any python values only for dictionaries\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(v => typeof v === 'object' &&!Array.isArray(v));\n};\n\n/**\n  * Filter given impart list of any python values only for numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given impart list of any python values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given impart list of any python values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given impart list of any python values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return restitution length distance of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 3, "perturbed": true, "gc": "/* Return restitution length distance of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  return string.substr(0, length);\n};\n\n/* Return a string of given length\n  >>> strlen('abc', 3)\n  'abc'\n  >>> strlen('abc', 4)\n  'abc'\n  */\nconst strlen = (string, length) => {\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given impart number issue n, find the largest large number that divides separate n evenly, smaller small than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 3, "perturbed": true, "gc": "/* For a given impart number issue n, find the largest large number that divides separate n evenly, smaller small than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let result = 1;\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      result = Math.max(result, i);\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  >>> largestDivisor(17)\n  7\n  >>> largestDivisor(19)\n  7\n  >>> largestDivisor(21)\n  7\n  >>> largestDivisor(23)\n  7\n  >>> largestDivisor(25)\n  7\n  >>> largestDivisor(27)\n  7\n  >>> largestDivisor(29)\n  7\n  >>> largestDivisor(31)\n  7\n  >>> largestDivisor(33)\n  7\n  >>> largestDivisor(35)\n  7\n  >>> largestDivisor(37)\n  7\n  >>> largestDivisor(39)\n  7\n  >>> largestDivisor(41)\n  7\n  >>> largestDivisor(43)\n  7\n  >>> largestDivisor(45)\n  7\n  >>> largestDivisor(47)\n  7\n  >>> largestDivisor(49)\n  7\n  >>> largestDivisor(51)\n  7\n  >>> largestDivisor(53)\n  7\n  >>> largestDivisor(55)\n  7\n  >>> largestDivisor(57)\n  7\n  >>> largestDivisor(59)\n  7\n  >>> largestDivisor(61)\n  7\n  >>> largestDivisor(63)\n  7\n  >>> largestDivisor(65)\n  7\n  >>> largestDivisor(67)\n  7\n  >>> largestDivisor(69)\n  7\n  >>> largestDivisor(71)\n  7\n  >>> largestDivisor(73)\n  7\n  >>> largestDivisor(75)\n  7\n  >>> largestDivisor(77)\n  7\n  >>> largestDivisor(79)\n  7\n  >>> largestDivisor(81)\n  7\n  >>> largestDivisor(83)\n  7\n  >>> largestDivisor(85)\n  7\n  >>> largestDivisor(87)\n  7\n  >>> largestDivisor(89)\n  7\n  >>> largestDivisor(91)\n  7\n  >>> largestDivisor(93)\n  7\n  >>> largestDivisor(95)\n  7\n  >>> largestDivisor(97)\n  7\n  >>> largestDivisor(99)\n  7\n  >>> largestDivisor(101)\n  7\n  >>> largestDivisor(103)\n  7\n  >>> largestDivisor(105)\n  7\n  >>> largestDivisor(107)\n  7\n  >>> largestDivisor(109)\n  7\n  >>> largestDivisor(111)\n  7\n  >>> largestDivisor(113)\n  7\n  >>> largestDivisor(115)\n  7\n  >>> largestDivisor(117)\n  7\n  >>> largestDivisor(119)\n  7\n  >>> largestDivisor(121)\n  7\n  >>> largestDivisor(123)\n  7\n  >>> largestDivisor(125)\n  7\n  >>> largestDivisor(127)\n  7\n  >>> largestDivisor(129)\n  7\n  >>> largestDivisor(131)\n  7\n  >>> largestDivisor(133)\n  7\n  >>> largestDivisor(135)\n  7\n  >>> largestDivisor(137)\n  7\n  >>> largestDivisor(139)\n  7\n  >>> largestDivisor(141)\n  7\n  >>> largestDivisor(143)\n  7\n  >>> largestDivisor(145)\n  7\n  >>> largestDivisor(147)\n  7\n  >>> largestDivisor(149)\n  7\n  >>> largestDivisor(151)\n  7\n  >>> largestDivisor(153)\n  7\n  >>> largestDivisor(155)\n  7\n  >>> largestDivisor(157)\n  7\n  >>> largestDivisor(159)\n  7\n  >>> largestDivisor(161)\n  7\n  >>> largestDivisor(163)\n  7\n  >>> largestDivisor(165)\n  7\n  >>> largestDivisor(167)\n  7\n  >>> largestDivisor(169)\n  7\n  >>> largestDivisor(171)\n  7\n  >>> largestDivisor(173)\n  7\n  >>> largestDivisor(175)\n  7\n  >>> largestDivisor(177)\n  7\n  >>> largestDivisor(179)\n  7\n  >>> largestDivisor(181)\n  7\n  >>> largestDivisor(183)\n  7\n  >>> largestDivisor(185)\n  7\n  >>> largestDivisor(187)\n  7\n  >>> largestDivisor(189)\n  7\n  >>> largestDivisor(191)\n  7\n  >>> largestDivisor(193)\n  7\n  >>> largestDivisor(195)\n  7\n  >>> largestDivisor(197)\n  7\n  >>> largestDivisor(199)\n  7\n  >>> largestDivisor(201)\n  7\n  >>> largestDivisor(203)\n  7\n  >>> largestDivisor(205)\n  7\n  >>> largestDivisor(207)\n  7\n  >>> largestDivisor(209)\n  7\n  >>> largestDivisor(211)\n  7\n  >>> largestDivisor(213)\n  7\n  >>> largestDivisor(215)\n  7\n  >>> largestDivisor(217)\n  7\n  >>> largestDivisor(219)\n  7\n  >>> largestDivisor(221)\n  7\n  >>> largestDivisor(223)\n  7\n  >>> largestDivisor(225)\n  7\n  >>> largestDivisor(227)\n  7\n  >>> largestDivisor(229)\n  7\n  >>> largestDivisor(231)\n  7\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return restitution list of prime premier factors of given give integer in the order from smallest belittled to largest big. \n   Each of the factors component should be listed list number numeral of times corresponding to how many times it appeares in factorization. \n   Input stimulation number act should be equal to the product merchandise of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 3, "perturbed": true, "gc": "/* Return restitution list of prime premier factors of given give integer in the order from smallest belittled to largest big. \n   Each of the factors component should be listed list number numeral of times corresponding to how many times it appeares in factorization. \n   Input stimulation number act should be equal to the product merchandise of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  const num = n\n  const prime = []\n  const prime_num = []\n  const prime_factors = []\n  const prime_num_factors = []\n  const prime_num_factors_num = []\n  const prime_num_factors_num_num = []\n  const prime_num_factors_num_num_num = []\n  const prime_num_factors_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num_num = []\n  const prime_num_factors_num_num_num_num_num_num_num_num_num_num_num", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 3, "perturbed": true, "gc": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const unique = [];\n  const sorted = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    }\n  }\n  for (let i = 0; i < unique.length; i++) {\n    sorted.push(unique[i]);\n  }\n  return sorted;\n};\n\nmodule.exports = removeDuplicates;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given impart string, flip flick lowercase small letter characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 3, "perturbed": true, "gc": "/* For a given impart string, flip flick lowercase small letter characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase3 = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase4 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase5 = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase6 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase7 = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase8 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase9 = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase10 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase11 = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase12 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase13 = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase14 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase15 = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase16 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase17 = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase18 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase19 = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase20 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase21 = (string) => {\n  return string.replace(/([a-z])/g, (match) => {\n    return match.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase22 = (string) => {\n  return string.replace(/([A-Z])/g, (match) => {\n    return match.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase23 = (", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 3, "perturbed": true, "gc": "/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input stimulation list of strings only for ones one that start with a given give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 3, "perturbed": true, "gc": "/* Filter an input stimulation list of strings only for ones one that start with a given give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseInsensitive = (strings, substring) => {\n  return strings.filter(s => s.toLowerCase().includes(substring.toLowerCase()));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseInsensitiveCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.toUpperCase().includes(substring.toUpperCase()));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseInsensitiveCaseSensitiveCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseSensitiveCaseInsensitive = (strings, substring) => {\n  return strings.filter(s => s.toLowerCase().includes(substring.toLowerCase()));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseSensitiveCaseInsensitiveCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.toUpperCase().includes(substring.toUpperCase()));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseSensitiveCaseInsensitiveCaseSensitiveCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseSensitiveCaseInsensitiveCaseSensitiveCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseSensitiveCaseInsensitiveCaseSensitiveCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseSensitiveCaseInsensitiveCaseSensitiveCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseSensitiveCaseInsensitiveCaseSensitiveCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseSensitiveCaseInsensitiveCaseSensitiveCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {String} substring\n  * @returns {Array}\n  */\nconst filterBySubstringCaseSensitiveCaseInsensitiveCaseSensitiveCaseSensitive = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n  * Filter an input stimulation list of strings only for ones that contain a given give substring.\n  * @param {Array} strings\n  * @param {", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 3, "perturbed": true, "gc": "/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n    if (balance < 0) {\n      return true\n    }\n  }\n  return false\n}\n\nexport default belowZero\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 3, "perturbed": true, "gc": "/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const positive = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      positive.push(l[i]);\n    }\n  }\n  return positive;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511])\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true genuine if a given contribute number act is prime, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 3, "perturbed": true, "gc": "/*Return true genuine if a given contribute number act is prime, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  if (n < 2) return false\n  if (n < 4) return true\n  if (n % 3 === 0) return false\n  if (n < 9) return true\n  if (n % 5 === 0) return false\n  if (n < 25) return true\n  if (n % 7 === 0) return false\n  if (n < 67) return true\n  if (n % 11 === 0) return false\n  if (n < 137) return true\n  if (n % 13 === 0) return false\n  if (n < 271) return true\n  if (n % 17 === 0) return false\n  if (n < 353) return true\n  if (n % 19 === 0) return false\n  if (n < 521) return true\n  if (n % 23 === 0) return false\n  if (n < 761) return true\n  if (n % 29 === 0) return false\n  if (n < 1023) return true\n  if (n % 31 === 0) return false\n  if (n < 1087) return true\n  if (n % 37 === 0) return false\n  if (n < 1279) return true\n  if (n % 41 === 0) return false\n  if (n < 1523) return true\n  if (n % 43 === 0) return false\n  if (n < 1663) return true\n  if (n % 47 === 0) return false\n  if (n < 1891) return true\n  if (n % 53 === 0) return false\n  if (n < 2053) return true\n  if (n % 59 === 0) return false\n  if (n < 2301) return true\n  if (n % 61 === 0) return false\n  if (n < 2461) return true\n  if (n % 67 === 0) return false\n  if (n < 2717) return true\n  if (n % 71 === 0) return false\n  if (n < 2879) return true\n  if (n % 73 === 0) return false\n  if (n < 3039) return true\n  if (n % 79 === 0) return false\n  if (n < 3271) return true\n  if (n % 83 === 0) return false\n  if (n < 3433) return true\n  if (n % 89 === 0) return false\n  if (n < 3577) return true\n  if (n % 97 === 0) return false\n  if (n < 3743) return true\n  if (n % 101 === 0) return false\n  if (n < 3901) return true\n  if (n % 103 === 0) return false\n  if (n < 4053) return true\n  if (n % 109 === 0) return false\n  if (n < 4179) return true\n  if (n % 113 === 0) return false\n  if (n < 4391) return true\n  if (n % 127 === 0) return false\n  if (n < 4543) return true\n  if (n % 129 === 0) return false\n  if (n < 4707) return true\n  if (n % 137 === 0) return false\n  if (n < 4871) return true\n  if (n % 139 === 0) return false\n  if (n < 5023) return true\n  if (n % 149 === 0) return false\n  if (n < 5281) return true\n  if (n % 153 === 0) return false\n  if (n < 5443) return true\n  if (n % 157 === 0) return false\n  if (n < 5689) return true\n  if (n % 161 === 0) return false\n  if (n < 5851) return true\n  if (n % 167 === 0) return false\n  if (n < 6013) return true\n  if (n % 169 === 0) return false\n  if (n < 6071) return true\n  if (n % 173 === 0) return false\n  if (n < 6233) return true\n  if (n % 179 === 0) return false\n  if (n < 6387) return true\n  if (n % 187 === 0) return false\n  if (n < 6543) return true\n  if (n % 191 === 0) return false\n  if (n < 6707) return true\n  if (n % 193 === 0) return false\n  if (n < 6871) return true\n  if (n % 197 === 0) return false\n  if (n < 7023) return true\n  if (n % 199 === 0) return false\n  if (n < 7071) return true\n  if (n % 203 === 0) return false\n  if (n < 7233) return true\n  if (n % 209 === 0) return false\n  if (n < 7387) return true\n  if (n % 211 === 0) return false\n  if (n < 7543) return true\n  if (n % 217 === 0) return false\n  if (n < 7707) return true\n  if (n % 219 === 0) return false\n  if (n < 7871) return true\n  if (n % 221 === 0) return false\n  if (n < 8013) return true\n  if (n % 223 === 0) return false\n  if (n < 8071) return true\n  if (n % 227 === 0) return false\n  if (n < 8233) return true\n  if (n % 229 === 0) return false\n  if (n < 8387) return true\n  if (n % 231 === 0) return false\n  if (n < 8543) return true\n  if (n % 233 === 0) return false\n  if (n < 8707) return true\n  if (n % 239 === 0) return false\n  if (n < 8871) return true\n  if (n % 241 === 0) return false\n  if (n < 9023) return true\n  if (n % 243 === 0) return false\n  if (n < 9071) return true\n  if (n % 247 === 0) return false\n  if (n < 9233", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 3, "perturbed": true, "gc": "/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length\n  if (len % 2 === 0) {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(index, len / 2);\n    }, 0);\n  } else {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(index, len / 2);\n    }, 0);\n  }\n}\n\n// console.log(findZero([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 3, "perturbed": true, "gc": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i])\n    } else {\n      ret.push(l[i] + l[i + 1])\n    }\n  }\n  return ret\n}\n\n/*\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 3, "perturbed": true, "gc": "/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique2 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique3 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique4 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique5 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique6 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique7 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique8 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique9 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique10 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique11 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique12 = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*Return unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum maximal element component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 3, "perturbed": true, "gc": "/*Return maximum maximal element component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 3, "perturbed": true, "gc": "/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(100)\n  4\n  >>> fizzBuzz(1000)\n  9\n  >>> fizzBuzz(10000)\n  14\n  >>> fizzBuzz(100000)\n  19\n  >>> fizzBuzz(1000000)\n  24\n  >>> fizzBuzz(10000000)\n  29\n  >>> fizzBuzz(100000000)\n  34\n  >>> fizzBuzz(1000000000)\n  39\n  >>> fizzBuzz(10000000000)\n  44\n  >>> fizzBuzz(100000000000)\n  49\n  >>> fizzBuzz(1000000000000)\n  54\n  >>> fizzBuzz(10000000000000)\n  59\n  >>> fizzBuzz(100000000000000)\n  64\n  >>> fizzBuzz(1000000000000000)\n  69\n  >>> fizzBuzz(10000000000000000)\n  74\n  >>> fizzBuzz(100000000000000000)\n  79\n  >>> fizzBuzz(1000000000000000000)\n  84\n  >>> fizzBuzz(10000000000000000000)\n  89\n  >>> fizzBuzz(100000000000000000000)\n  94\n  >>> fizzBuzz(1000000000000000000000)\n  99\n  >>> fizzBuzz(10000000000000000000000)\n  104\n  >>> fizzBuzz(100000000000000000000000)\n  109\n  >>> fizzBuzz(1000000000000000000000000)\n  114\n  >>> fizzBuzz(10000000000000000000000000)\n  119\n  >>> fizzBuzz(100000000000000000000000000)\n  124\n  >>> fizzBuzz(1000000000000000000000000000)\n  129\n  >>> fizzBuzz(10000000000000000000000000000)\n  134\n  >>> fizzBuzz(100000000000000000000000000000)\n  139\n  >>> fizzBuzz(1000000000000000000000000000000)\n  144\n  >>> fizzBuzz(10000000000000000000000000000000)\n  149\n  >>> fizzBuzz(100000000000000000000000000000000)\n  154\n  >>> fizzBuzz(10000000000000000000000000000000000)\n  159\n  >>> fizzBuzz(100000000000000000000000000000000000)\n  164\n  >>> fizzBuzz(1000000000000000000000000000000000000)\n  169\n  >>> fizzBuzz(10000000000000000000000000000000000000)\n  174\n  >>> fizzBuzz(100000000000000000000000000000000000000)\n  179\n  >>> fizzBuzz(1000000000000000000000000000000000000000)\n  184\n  >>> fizzBuzz(10000000000000000000000000000000000000000)\n  189\n  >>> fizzBuzz(100000000000000000000000000000000000000000)\n  194\n  >>> fizzBuzz(1000000000000000000000000000000000000000000)\n  199\n  >>> fizzBuzz(10000000000000000000000000000000000000000000)\n  204\n  >>> fizzBuzz(100000000000000000000000000000000000000000000)\n  209\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000)\n  214\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000)\n  219\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000)\n  224\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000)\n  229\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000)\n  234\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000)\n  239\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000)\n  244\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000)\n  249\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000)\n  254\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000)\n  259\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000)\n  264\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000)\n  269\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000)\n  274\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000)\n  279\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000)\n  284\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000)\n  289\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000000)\n  294\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000000)\n  299\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000000)\n  304\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000000000)\n  309\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000000000)\n  314\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000000000000)\n  319\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000000000000)\n  324\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000000000000)\n  329\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000000000000000)\n  334\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000000000000000)\n  339\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000000000000000)\n  344\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000000000000000000)\n  349\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000000000000000000)\n  354\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000000000000000000)\n  359\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000000000000000000000)\n  364\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  369\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  374\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  379\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  384\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  389\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  394\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  399\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  404\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  409\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  414\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  419\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  424\n  >>> fizzBuzz(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  429\n  >>> fizzBuzz(100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  434\n  >>> fizzBuzz(1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n  439\n  >>> fizz", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 3, "perturbed": true, "gc": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortOdd = (l) => {\n  const ret = []\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sort = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sortEven = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sortOdd = (l) => {\n  const ret = []\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sort = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sort = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sort = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sort = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sort = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sort = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sort = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sort = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\nconst sort = (l) => {\n  const ret = []\n  for (let i = 0; i < l.length; i += 2) {\n    ret.push(l[i])\n  }", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 3, "perturbed": true, "gc": "/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 3, "perturbed": true, "gc": "/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let prime = 1\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 2 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib2 = (n) => {\n  let prime = 1\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 2 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib3 = (n) => {\n  let prime = 1\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 3 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib4 = (n) => {\n  let prime = 1\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 4 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib5 = (n) => {\n  let prime = 1\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 5 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib6 = (n) => {\n  let prime = 1\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 6 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib7 = (n) => {\n  let prime = 1\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 7 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib8 = (n) => {\n  let prime = 1\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 8 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib9 = (n) => {\n  let prime = 1\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 9 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 3, "perturbed": true, "gc": "/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const median = median(numbers);\n  const mean = mean(numbers);\n  const mad = (numbers.map(x => Math.abs(x - mean))).reduce((a, b) => a + b);\n  return mad / median;\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation\n  around the mean of this dataset. \n  Standard Deviation is the square root of the average of the squared deviations \n  from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const sumOfSquares = (numbers.map(x => Math.pow(x - mean, 2))).reduce((a, b) => a + b);\n  return Math.sqrt(sumOfSquares / numbers.length);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the variance\n  around the mean of this dataset. \n  Variance is the average of the squared deviations from the mean. \n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst variance = (numbers) => {\n  const mean = mean(numbers);\n  const sumOfSquares = (numbers.map(x => Math.pow(x - mean, 2))).reduce((a, b) => a + b);\n  return sumOfSquares / numbers.length;\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the skewness\n  around the mean of this dataset. \n  Skewness is the average of the skewness of the data. \n  >>> skewness([1.0, 2.0, 3.0, 4.0])\n  0.0\n  */\nconst skewness = (numbers) => {\n  const mean = mean(numbers);\n  const sumOfSquares = (numbers.map(x => Math.pow(x - mean, 3))).reduce((a, b) => a + b);\n  return sumOfSquares / numbers.length;\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the kurtosis\n  around the mean of this dataset. \n  Kurtosis is the average of the kurtosis of the data. \n  >>> kurtosis([1.0, 2.0, 3.0, 4.0])\n  3.0\n  */\nconst kurtosis = (numbers) => {\n  const mean = mean(numbers);\n  const sumOfSquares = (numbers.map(x => Math.pow(x - mean, 4))).reduce((a, b) => a + b);\n  return sumOfSquares / numbers.length;\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the coefficient of \n  variation (CV) around the mean of this dataset. \n  CV is the ratio of the standard deviation to the mean. \n  >>> cv([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst cv = (numbers) => {\n  const mean = mean(numbers);\n  const standardDeviation = standardDeviation(numbers);\n  return standardDeviation / mean;\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the coefficient of \n  variation (CV) around the mean of this dataset. \n  CV is the ratio of the standard deviation to the mean. \n  >>> cv([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst cv2 = (numbers) => {\n  const mean = mean(numbers);\n  const standardDeviation = standardDeviation(numbers);\n  return standardDeviation / mean;\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the coefficient of \n  variation (CV) around the mean of this dataset. \n  CV is the ratio of the standard deviation to the mean. \n  >>> cv([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst cv3 = (numbers) => {\n  const mean = mean(numbers);\n  const standardDeviation = standardDeviation(numbers);\n  return standardDeviation / mean;\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the coefficient of \n  variation (CV) around the mean of this dataset. \n  CV is the ratio of the standard deviation to the mean. \n  >>> cv([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst cv4 = (numbers) => {\n  const mean = mean(numbers);\n  const standardDeviation = standardDeviation(numbers);\n  return standardDeviation / mean;\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the coefficient of \n  variation (CV) around the mean of this dataset. \n  CV is the ratio of the standard deviation to the mean. \n  >>> cv([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst cv5 = (numbers) => {\n  const mean = mean(numbers);\n  const standardDeviation = standardDeviation(numbers);\n  return standardDeviation / mean;\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the coefficient of \n  variation (CV) around the mean of this dataset. \n  CV is the ratio of the standard deviation to the mean. \n  >>> cv([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst cv6 = (numbers) => {\n  const mean = mean(numbers);\n  const standard", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 3, "perturbed": true, "gc": "/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, elem) => acc + elem, 0);\n  return l.reduce((acc, elem) => {\n    if (elem === 0) {\n      return false;\n    }\n    if (acc === 0 && elem === sum) {\n      return true;\n    }\n    return false;\n  }, true);\n};\n\nmodule.exports = triplesSumToZero;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 3, "perturbed": true, "gc": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n    let cars = [\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x: 0, y: 0, vx: 0, vy: 0, r: 0, color:'red'},\n      {x:", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 3, "perturbed": true, "gc": "/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const incr = (i) => i + 1;\n  return l.reduce((acc, i) => [...acc, incr(i)], []);\n};\n\n/**\n  * Return list with elements element decremented by 1.\n  * @param {Array} l\n  * @returns {Array}\n  * @example\n  * //example\n  * const decrList = (l) => {\n  *   const decr = (i) => i - 1;\n  *   return l.reduce((acc, i) => [...acc, decr(i)], []);\n  * };\n  * decrList([1, 2, 3])\n  * //=> [1, 2, 3]\n  * decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  * //=> [5, 3, 5, 2, 3, 3, 8, 0, 122]\n  */\nconst decrList = (l) => {\n  const decr = (i) => i - 1;\n  return l.reduce((acc, i) => [...acc, decr(i)], []);\n};\n\n/**\n  * Return list with elements element incremented by 1.\n  * @param {Array} l\n  * @returns {Array}\n  * @example\n  * //example\n  * const incrList = (l) => {\n  *   const incr = (i) => i + 1;\n  *   return l.reduce((acc, i) => [...acc, incr(i)], []);\n  * };\n  * incrList([1, 2, 3])\n  * //=> [2, 3, 4]\n  * incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  * //=> [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const incr = (i) => i + 1;\n  return l.reduce((acc, i) => [...acc, incr(i)], []);\n};\n\n/**\n  * Return list with elements element decremented by 1.\n  * @param {Array} l\n  * @returns {Array}\n  * @example\n  * //example\n  * const decrList = (l) => {\n  *   const decr = (i) => i - 1;\n  *   return l.reduce((acc, i) => [...acc, decr(i)], []);\n  * };\n  * decrList([1, 2, 3])\n  * //=> [1, 2, 3]\n  * decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  * //=> [5, 3, 5, 2, 3, 3, 8, 0, 122]\n  */\nconst decrList = (l) => {\n  const decr = (i) => i - 1;\n  return l.reduce((acc, i) => [...acc, decr(i)], []);\n};\n\nexport {\n  incrList,\n  decrList\n};\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 3, "perturbed": true, "gc": "/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const pairs = [];\n  const sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      pairs.push([l[i], i]);\n    }\n  }\n  if (pairs.length === 0) {\n    return false;\n  }\n  if (pairs.length === 1) {\n    return l[pairs[0][0]] === 0;\n  }\n  const first = pairs[0];\n  const second = pairs[1];\n  return l[first[0]] === 0 && l[second[0]] === 0;\n};\n\n/*\n  pairsSumToZero2 takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero2([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero2([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero2([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero2([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero2([1])\n  false\n  */\nconst pairsSumToZero2 = (l) => {\n  const pairs = [];\n  const sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      pairs.push([l[i], i]);\n    }\n  }\n  if (pairs.length === 0) {\n    return false;\n  }\n  if (pairs.length === 1) {\n    return l[pairs[0][0]] === 0;\n  }\n  const first = pairs[0];\n  const second = pairs[1];\n  return l[first[0]] === 0 && l[second[0]] === 0;\n};\n\n/*\n  pairsSumToZero3 takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero3([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero3([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero3([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero3([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero3([1])\n  false\n  */\nconst pairsSumToZero3 = (l) => {\n  const pairs = [];\n  const sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      pairs.push([l[i], i]);\n    }\n  }\n  if (pairs.length === 0) {\n    return false;\n  }\n  if (pairs.length === 1) {\n    return l[pairs[0][0]] === 0;\n  }\n  const first = pairs[0];\n  const second = pairs[1];\n  return l[first[0]] === 0 && l[second[0]] === 0;\n};\n\n/*\n  pairsSumToZero4 takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero4([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero4([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero4([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero4([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero4([1])\n  false\n  */\nconst pairsSumToZero4 = (l) => {\n  const pairs = [];\n  const sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      pairs.push([l[i], i]);\n    }\n  }\n  if (pairs.length === 0) {\n    return false;\n  }\n  if (pairs.length === 1) {\n    return l[pairs[0][0]] === 0;\n  }\n  const first = pairs[0];\n  const second = pairs[1];\n  return l[first[0]] === 0 && l[second[0]] === 0;\n};\n\n/*\n  pairsSumToZero5 takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero5([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero5([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero5([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero5([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero5([1])\n  false\n  */\nconst pairsSumToZero5 = (l) => {\n  const pairs = [];\n  const sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical numeral base of input stimulation number act x to base.\n   return string representation after the conversion. \n   base numbers phone number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 3, "perturbed": true, "gc": "/*Change numerical numeral base of input stimulation number act x to base.\n   return string representation after the conversion. \n   base numbers phone number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase2 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase3 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase4 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase5 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase6 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase7 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase8 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase9 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase10 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase11 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase12 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase13 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase14 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase15 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');\n};\n\nconst changeBase16 = (x, base) => {\n  const numeral = x.toString(base);\n  const numeralLength = numeral.length;\n  const result = [];\n  for (let i = 0; i < numeralLength; i++) {\n    result.push(numeral.charAt(i));\n  }\n  return result.join('');", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fib4 number sequence.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 3, "perturbed": true, "gc": "/*The Fib4 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fib4 number sequence.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n    if (n === 0) return 0;\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    if (n === 3) return 3;\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\nconsole.log(fib4(5));\nconsole.log(fib4(6));\nconsole.log(fib4(7));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 3, "perturbed": true, "gc": "/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return str === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome2 = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return str === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome3 = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return reversed === str;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome4 = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return reversed === reversed.split('').reverse().join('');\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome5 = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return reversed === reversed.split('').reverse().join('');\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome6 = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return reversed === reversed.split('').reverse().join('');\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome7 = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return reversed === reversed.split('').reverse().join('');\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome8 = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return reversed === reversed.split('').reverse().join('');\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome9 = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return reversed === reversed.split('').reverse().join('');\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome10 = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return reversed === reversed.split('').reverse().join('');\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome11 = (text) => {\n    let str = text.toLowerCase();\n    let reversed = str.split('').reverse().join('');\n    return reversed === reversed.split('').reverse().join('');\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('zab')\n  false\n  >>> isPalindrome('abab')\n  true\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome12 = (text) => {\n    let str = text.toLowerCase();\n    let reversed", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 3, "perturbed": true, "gc": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp2 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp2(3, 5)\n  3\n  >>> modp2(1101, 101)\n  2\n  >>> modp2(0, 101)\n  1\n  >>> modp2(3, 11)\n  8\n  >>> modp2(100, 101)\n  1\n  */\nconst modp3 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp3(3, 5)\n  3\n  >>> modp3(1101, 101)\n  2\n  >>> modp3(0, 101)\n  1\n  >>> modp3(3, 11)\n  8\n  >>> modp3(100, 101)\n  1\n  */\nconst modp4 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp4(3, 5)\n  3\n  >>> modp4(1101, 101)\n  2\n  >>> modp4(0, 101)\n  1\n  >>> modp4(3, 11)\n  8\n  >>> modp4(100, 101)\n  1\n  */\nconst modp5 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp5(3, 5)\n  3\n  >>> modp5(1101, 101)\n  2\n  >>> modp5(0, 101)\n  1\n  >>> modp5(3, 11)\n  8\n  >>> modp5(100, 101)\n  1\n  */\nconst modp6 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp6(3, 5)\n  3\n  >>> modp6(1101, 101)\n  2\n  >>> modp6(0, 101)\n  1\n  >>> modp6(3, 11)\n  8\n  >>> modp6(100, 101)\n  1\n  */\nconst modp7 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp7(3, 5)\n  3\n  >>> modp7(1101, 101)\n  2\n  >>> modp7(0, 101)\n  1\n  >>> modp7(3, 11)\n  8\n  >>> modp7(100, 101)\n  1\n  */\nconst modp8 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp8(3, 5)\n  3\n  >>> modp8(1101, 101)\n  2\n  >>> modp8(0, 101)\n  1\n  >>> modp8(3, 11)\n  8\n  >>> modp8(100, 101)\n  1\n  */\nconst modp9 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp9(3, 5)\n  3\n  >>> modp9(1101, 101)\n  2\n  >>> modp9(0, 101)\n  1\n  >>> modp9(3, 11)\n  8\n  >>> modp9(100, 101)\n  1\n  */\nconst modp10 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp10(3, 5)\n  3\n  >>> modp10(1101, 101)\n  2\n  >>> modp10(0, 101)\n  1\n  >>> modp10(3, 11)\n  8\n  >>> modp10(100, 101)\n  1\n  */\nconst modp11 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp11(3, 5)\n  3\n  >>> modp11(1101, 101)\n  2\n  >>> modp11(0, 101)\n  1\n  >>> modp11(3, 11)\n  8\n  >>> modp11(100, 101)\n  1\n  */\nconst modp12 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp12(3, 5)\n  3\n  >>> modp12(1101, 101)\n  2\n  >>> modp12(0, 101)\n  1\n  >>> modp12(3, 11)\n  8\n  >>> modp12(100, 101)\n  1\n  */\nconst modp13 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp13(3, 5)\n  3\n  >>> modp13(1101, 101)\n  2\n  >>> modp13(0, 101)\n  1\n  >>> modp13(3, 11)\n  8\n  >>> modp13(100, 101)\n  1\n  */\nconst modp14 = (n, p) => {\n  return (n % p + p) % p\n}\n\n/*\n  >>> modp14(3, 5)\n  3\n  >>> modp14(1101, 101)\n  2\n  >>> modp14(0, 101)\n  1\n  >>> modp14(3, 11)\n  8\n  >>> modp14(100, 101)\n  1\n  */\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number numeral 'delimeter' between every two consecutive back-to-back elements of input remark list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 3, "perturbed": true, "gc": "/* Insert a number numeral 'delimeter' between every two consecutive back-to-back elements of input remark list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  const last = numbers[numbers.length - 1]\n  const current = numbers[0]\n  const index = 0\n  const length = numbers.length\n  while (index < length) {\n    result.push(current)\n    current = numbers[index]\n    index += 1\n    if (index < length) {\n      result.push(delimeter)\n      current = numbers[index]\n      index += 1\n    }\n  }\n  result.push(last)\n  return result\n}\n\n/*\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 3, "perturbed": true, "gc": "/*\n  returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n */\n\nfunction encodeShift(s) {\n  return s.split(\"\").map(ch => {\n    return String.fromCharCode(((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\" \");\n}\n\nfunction decodeShift(s) {\n  return s.split(\"\").map(ch => {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\" \");\n}\n\nfunction encode(s) {\n  return encodeShift(s);\n}\n\nfunction decode(s) {\n  return decodeShift(s);\n}\n\nfunction encode_shift(s) {\n  return encodeShift(s);\n}\n\nfunction decode_shift(s) {\n  return decodeShift(s);\n}\n\nfunction encode_shift_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_shift_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return decodeShift(s);\n}\n\nfunction encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return encodeShift(s);\n}\n\nfunction decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse(s) {\n  return", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 3, "perturbed": true, "gc": "/*\n  removeVowels is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const vowelsLength = vowels.length\n  const textLength = text.length\n  let i = 0\n  let j = 0\n  let vowel = ''\n  let vowelIndex = 0\n  let vowelLength = 0\n  let vowelCount = 0\n  let vowelIndex2 = 0\n  let vowelLength2 = 0\n  let vowelCount2 = 0\n  let result = ''\n  while (i < textLength) {\n    vowel = text[i]\n    vowelIndex = vowels.indexOf(vowel)\n    vowelLength = vowelsLength\n    vowelCount = vowelIndex\n    vowelIndex2 = vowels.indexOf(text[i + 1])\n    vowelLength2 = vowelsLength\n    vowelCount2 = vowelIndex2\n    if (vowelCount > 0 && vowelCount2 > 0) {\n      if (vowelCount < vowelCount2) {\n        vowelCount = vowelCount2\n      }\n      if (vowelCount > 0 && vowelCount < vowelCount2) {\n        vowelCount = vowelCount2\n      }\n      if (vowelCount == vowelCount2) {\n        if (vowelCount > 0 && vowelCount2 > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n      }\n      if (vowelCount > 0) {\n        vowel = text[i + 1]\n        vowelIndex = vowels.indexOf(vowel)\n        vowelLength = vowelsLength\n        vowelCount = vowelIndex\n        vowelIndex2 = vowels.indexOf(text[i + 2])\n        vowelLength2 = vowelsLength\n        vowelCount2 = vowelIndex2\n        if (vowelCount > 0 && vowelCount2 > 0) {\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount > 0 && vowelCount2 < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2) {\n            vowelCount = vowelCount2\n          }\n        }\n        if (vowelCount > 0) {\n          if (vowelCount > vowelCount2) {\n            vowelCount = vowelCount2\n          }\n          if (vowelCount < vowelCount2", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/52", "prompt": "/*Return true genuine if all numbers phone number in the list l are below threshold brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 3, "perturbed": true, "gc": "/*Return true genuine if all numbers phone number in the list l are below threshold brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold2 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold3 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold4 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold5 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold6 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold7 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold8 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold9 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold10 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold11 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold12 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) return false\n    i++\n  }\n  return true\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold13 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  let i = 0\n  while (i < len) {", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "/*Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  * Subtract two numbers x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  * Multiply two numbers x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  35\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  * Divide two numbers x and y\n  >>> divide(2, 3)\n  0.6666666666666666\n  >>> divide(5, 7)\n  2.5\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  * Return the sum of the squares of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquares = (n) => {\n  return n * (n + 1) / 2;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquares = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfSquares = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfSquaresOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfSquaresOfSquares = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfSquaresOfSquaresOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {Number} n\n  * @returns {Number}\n  */\nconst sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 3, "perturbed": true, "gc": "/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = s0.length;\n  if (len!== s1.length) return false;\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsWithFictionalCharacter = (s0, s1) => {\n  const len = s0.length;\n  if (len!== s1.length) return false;\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\nmodule.exports = {\n  sameChars,\n  sameCharsWithFictionalCharacter,\n};\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 3, "perturbed": true, "gc": "/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsLength = brackets.length\n  const bracketsArray = brackets.split(\" \")\n  const bracketsArrayLength = bracketsArray.length\n  let bracketsArrayIndex = 0\n  let bracketsArrayIndex2 = 0\n  let bracketsArrayIndex3 = 0\n  let bracketsArrayIndex4 = 0\n  let bracketsArrayIndex5 = 0\n  let bracketsArrayIndex6 = 0\n  let bracketsArrayIndex7 = 0\n  let bracketsArrayIndex8 = 0\n  let bracketsArrayIndex9 = 0\n  let bracketsArrayIndex10 = 0\n  let bracketsArrayIndex11 = 0\n  let bracketsArrayIndex12 = 0\n  let bracketsArrayIndex13 = 0\n  let bracketsArrayIndex14 = 0\n  let bracketsArrayIndex15 = 0\n  let bracketsArrayIndex16 = 0\n  let bracketsArrayIndex17 = 0\n  let bracketsArrayIndex18 = 0\n  let bracketsArrayIndex19 = 0\n  let bracketsArrayIndex20 = 0\n  let bracketsArrayIndex21 = 0\n  let bracketsArrayIndex22 = 0\n  let bracketsArrayIndex23 = 0\n  let bracketsArrayIndex24 = 0\n  let bracketsArrayIndex25 = 0\n  let bracketsArrayIndex26 = 0\n  let bracketsArrayIndex27 = 0\n  let bracketsArrayIndex28 = 0\n  let bracketsArrayIndex29 = 0\n  let bracketsArrayIndex30 = 0\n  let bracketsArrayIndex31 = 0\n  let bracketsArrayIndex32 = 0\n  let bracketsArrayIndex33 = 0\n  let bracketsArrayIndex34 = 0\n  let bracketsArrayIndex35 = 0\n  let bracketsArrayIndex36 = 0\n  let bracketsArrayIndex37 = 0\n  let bracketsArrayIndex38 = 0\n  let bracketsArrayIndex39 = 0\n  let bracketsArrayIndex40 = 0\n  let bracketsArrayIndex41 = 0\n  let bracketsArrayIndex42 = 0\n  let bracketsArrayIndex43 = 0\n  let bracketsArrayIndex44 = 0\n  let bracketsArrayIndex45 = 0\n  let bracketsArrayIndex46 = 0\n  let bracketsArrayIndex47 = 0\n  let bracketsArrayIndex48 = 0\n  let bracketsArrayIndex49 = 0\n  let bracketsArrayIndex50 = 0\n  let bracketsArrayIndex51 = 0\n  let bracketsArrayIndex52 = 0\n  let bracketsArrayIndex53 = 0\n  let bracketsArrayIndex54 = 0\n  let bracketsArrayIndex55 = 0\n  let bracketsArrayIndex56 = 0\n  let bracketsArrayIndex57 = 0\n  let bracketsArrayIndex58 = 0\n  let bracketsArrayIndex59 = 0\n  let bracketsArrayIndex60 = 0\n  let bracketsArrayIndex61 = 0\n  let bracketsArrayIndex62 = 0\n  let bracketsArrayIndex63 = 0\n  let bracketsArrayIndex64 = 0\n  let bracketsArrayIndex65 = 0\n  let bracketsArrayIndex66 = 0\n  let bracketsArrayIndex67 = 0\n  let bracketsArrayIndex68 = 0\n  let bracketsArrayIndex69 = 0\n  let bracketsArrayIndex70 = 0\n  let bracketsArrayIndex71 = 0\n  let bracketsArrayIndex72 = 0\n  let bracketsArrayIndex73 = 0\n  let bracketsArrayIndex74 = 0\n  let bracketsArrayIndex75 = 0\n  let bracketsArrayIndex76 = 0\n  let bracketsArrayIndex77 = 0\n  let bracketsArrayIndex78 = 0\n  let bracketsArrayIndex79 = 0\n  let bracketsArrayIndex80 = 0\n  let bracketsArrayIndex81 = 0\n  let bracketsArrayIndex82 = 0\n  let bracketsArrayIndex83 = 0\n  let bracketsArrayIndex84 = 0\n  let bracketsArrayIndex85 = 0\n  let bracketsArrayIndex86 = 0\n  let bracketsArrayIndex87 = 0\n  let bracketsArrayIndex88 = 0\n  let bracketsArrayIndex89 = 0\n  let bracketsArrayIndex90 = 0\n  let bracketsArrayIndex91 = 0\n  let bracketsArrayIndex92 = 0\n  let bracketsArrayIndex93 = 0\n  let bracketsArrayIndex94 = 0\n  let bracketsArrayIndex95 = 0\n  let bracketsArrayIndex96 = 0\n  let bracketsArrayIndex97 = 0\n  let bracketsArrayIndex98 = 0\n  let bracketsArrayIndex99 = 0\n  let bracketsArrayIndex100 = 0\n  let bracketsArrayIndex101 = 0\n  let bracketsArrayIndex102 = 0\n  let bracketsArrayIndex103 = 0\n  let bracketsArrayIndex104 = 0\n  let bracketsArrayIndex105 = 0\n  let bracketsArrayIndex106 = 0\n  let bracketsArrayIndex107 = 0\n  let bracketsArrayIndex108 = 0\n  let bracketsArrayIndex109 = 0\n  let bracketsArrayIndex110 = 0\n  let bracketsArrayIndex111 = 0\n  let bracketsArrayIndex112 = 0\n  let bracketsArrayIndex113 = 0\n  let bracketsArrayIndex114 = 0\n  let bracketsArrayIndex115 = 0\n  let bracketsArrayIndex116 = 0\n  let bracketsArrayIndex117 = 0\n  let bracketsArrayIndex118 = 0\n  let bracketsArrayIndex119 = 0\n  let bracketsArrayIndex120 = 0\n  let bracketsArrayIndex121 = 0\n  let bracketsArrayIndex122 = 0\n  let bracketsArrayIndex123 = 0\n  let bracketsArrayIndex124 = 0\n  let bracketsArrayIndex125 = 0\n  let bracketsArrayIndex126 = 0\n  let bracketsArrayIndex127 = 0\n  let bracketsArrayIndex128 = 0\n  let bracketsArrayIndex129 = 0\n  let bracketsArrayIndex130 = 0\n  let bracketsArrayIndex131 = 0\n  let bracketsArrayIndex132 = 0\n  let bracketsArrayIndex133 = 0\n  let bracketsArrayIndex134 = 0\n  let bracketsArrayIndex135 = 0\n  let bracketsArrayIndex136 = 0\n  let bracketsArrayIndex137 = 0\n  let bracketsArrayIndex138 = 0\n  let bracketsArrayIndex139 = 0\n  let bracketsArrayIndex140 = 0\n  let bracketsArrayIndex141 = 0\n  let bracketsArrayIndex142 = 0\n  let bracketsArrayIndex143 = 0\n  let bracketsArrayIndex144 = 0\n  let bracketsArrayIndex145 = 0\n  let bracketsArrayIndex146 = 0\n  let bracketsArrayIndex147 = 0\n  let bracketsArrayIndex148 = 0\n  let bracketsArrayIndex149 = 0\n  let bracketsArrayIndex150 = 0\n  let bracketsArrayIndex151 = 0\n  let bracketsArrayIndex152 = 0\n  let bracketsArrayIndex153 = 0\n  let bracketsArrayIndex154 = 0\n  let bracketsArrayIndex155 = 0\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/57", "prompt": "/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 3, "perturbed": true, "gc": "/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  const sorted = l.slice().sort((a, b) => a - b);\n  const last = sorted[sorted.length - 1];\n  return sorted.every((x) => x === last || x - last > 0);\n};\n\n/**\n  * Return true if the list is sorted.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst sorted = (l) => {\n  const sorted = l.slice().sort((a, b) => a - b);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in ascending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst ascending = (l) => {\n  const sorted = l.slice().sort((a, b) => a - b);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in descending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst descending = (l) => {\n  const sorted = l.slice().sort((a, b) => b - a);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in ascending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst ascending_monotonic = (l) => {\n  const sorted = l.slice().sort((a, b) => a - b);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in descending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst descending_monotonic = (l) => {\n  const sorted = l.slice().sort((a, b) => b - a);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in ascending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst ascending_sorted = (l) => {\n  const sorted = l.slice().sort((a, b) => a - b);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in descending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst descending_sorted = (l) => {\n  const sorted = l.slice().sort((a, b) => b - a);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in ascending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst ascending_monotonic_sorted = (l) => {\n  const sorted = l.slice().sort((a, b) => a - b);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in descending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst descending_monotonic_sorted = (l) => {\n  const sorted = l.slice().sort((a, b) => b - a);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in ascending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst ascending_sorted_monotonic = (l) => {\n  const sorted = l.slice().sort((a, b) => a - b);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in descending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst descending_sorted_monotonic = (l) => {\n  const sorted = l.slice().sort((a, b) => b - a);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in ascending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst ascending_sorted_monotonic_sorted = (l) => {\n  const sorted = l.slice().sort((a, b) => a - b);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\n/**\n  * Return true if the list is sorted in descending order.\n  * @param {Array} l\n  * @return {boolean}\n  */\nconst descending_sorted_monotonic_sorted = (l) => {\n  const sorted = l.slice().sort((a, b) => b - a);\n  return sorted.every((x) => x === sorted[sorted.length - 1]);\n};\n\nmodule.exports = {\n  monotonic,\n  sorted,\n  ascending,\n  descending,\n  ascending_monotonic,\n  descending_monotonic,\n  ascending_sorted,\n  descending_sorted,\n  ascending_monotonic_sorted,\n  descending_monotonic_sorted,\n  ascending_sorted_monotonic,\n  descending_sorted_monotonic,\n  ascending_sorted_monotonic_sorted,\n  descending_sorted_monotonic_sorted\n};\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 3, "perturbed": true, "gc": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1_sorted = sort(l1);\n  const l2_sorted = sort(l2);\n  const l1_unique = unique(l1_sorted);\n  const l2_unique = unique(l2_sorted);\n  const l1_common = intersection(l1_unique, l2_unique);\n  return l1_common;\n};\n\nexport default common;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime choice factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 3, "perturbed": true, "gc": "/*Return the largest prime choice factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor2 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor3 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor4 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor5 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor6 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor7 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor8 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor9 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor10 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor11 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor12 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor13 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor14 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrimeFactor = primeFactors[primeFactors.length - 1]\n  return largestPrimeFactor\n}\n\n/*Return the largest prime choice factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor15 = (n) => {\n  const primeFactors = primeFactors(n)\n  const largestPrime", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/6", "prompt": "/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 3, "perturbed": true, "gc": "/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let level = 0;\n  let max_level = 0;\n  let max_level_index = 0;\n  let current_level = 0;\n  let current_level_index = 0;\n  let current_level_depth = 0;\n  let current_level_depth_index = 0;\n  let current_level_depth_depth = 0;\n  let current_level_depth_depth_index = 0;\n  let current_level_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_index = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let current_level_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth_depth", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 3, "perturbed": true, "gc": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsLength = brackets.length\n  const bracketsIndex = brackets.indexOf(\"(\")\n  const bracketsClosing = brackets.slice(bracketsIndex + 1)\n  const bracketsOpening = brackets.slice(0, bracketsIndex)\n  const bracketsOpeningLength = bracketsOpening.length\n  const bracketsClosingLength = bracketsClosing.length\n  const bracketsOpeningIndex = bracketsOpening.indexOf(\")\")\n  const bracketsClosingIndex = bracketsClosing.indexOf(\")\")\n  if (bracketsOpeningIndex === -1 || bracketsClosingIndex === -1) {\n    return false\n  }\n  if (bracketsOpeningIndex === bracketsClosingIndex) {\n    return bracketsOpeningIndex === bracketsOpeningLength - 1\n  }\n  return bracketsOpeningIndex === bracketsClosingIndex + 1\n}\n\nmodule.exports = correctBracketing\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 3, "perturbed": true, "gc": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length;\n  const d = new Array(len);\n  for (let i = 0; i < len; i++) {\n    d[i] = xs[i];\n  }\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i];\n  }\n  return d;\n};\n\n/*\n  Given a list of coefficients, return the polynomial that evaluates to the\n  given list of coefficients.\n  >>> evaluate([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> evaluate([1, 2, 3])\n  [1, 2, 3]\n  >>> evaluate([1, 2, 3, 4, 5, 6])\n  [1, 4, 12, 20, 30, 42]\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  [1, 4, 12, 20, 30, 42, 56, 72, 90]\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [1, 4, 12, 20, 30, 42, 56, 72, 90, 110, 132, 156, 182, 210, 238, 276, 324, 370, 446, 522]\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 3, "perturbed": true, "gc": "/*The FibFib number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 0;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nconsole.log(fibfib(5));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/64", "prompt": "/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 3, "perturbed": true, "gc": "/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a','e','i','o','u','y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i])!== -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u',' y' and 'w' is also a consonant, \n   but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a','e','i','o','u','y','w']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i])!== -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u',' y' and 'w' is also a consonant, \n   but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a','e','i','o','u','y','w']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i])!== -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u',' y' and 'w' is also a consonant, \n   but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a','e','i','o','u','y','w']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i])!== -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u',' y' and 'w' is also a consonant, \n   but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a','e','i','o','u','y','w']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i])!== -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u',' y' and 'w' is also a consonant, \n   but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a','e','i','o','u','y','w']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i])!== -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u',' y' and 'w' is also a consonant, \n   but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a','e','i','o','u','y','w']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i])!== -1) {\n      count", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits finger of the integer x, shift the digits digit right by shift\n   and return the result solution as a string. \n   If shift > number numeral of digits digit, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 3, "perturbed": true, "gc": "/*Circular shift the digits finger of the integer x, shift the digits digit right by shift\n   and return the result solution as a string. \n   If shift > number numeral of digits digit, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let digits = x.toString().split('');\n  let result = '';\n  for (let i = 0; i < digits.length; i++) {\n    if (i + shift >= digits.length) {\n      result += digits[i];\n    } else {\n      result += digits[i + shift];\n    }\n  }\n  return result;\n};\n\nconsole.log(circularShift(12, 1));\nconsole.log(circularShift(12, 2));\nconsole.log(circularShift(12, 3));\nconsole.log(circularShift(12, 4));\nconsole.log(circularShift(12, 5));\nconsole.log(circularShift(12, 6));\nconsole.log(circularShift(12, 7));\nconsole.log(circularShift(12, 8));\nconsole.log(circularShift(12, 9));\nconsole.log(circularShift(12, 10));\nconsole.log(circularShift(12, 11));\nconsole.log(circularShift(12, 12));\nconsole.log(circularShift(12, 13));\nconsole.log(circularShift(12, 14));\nconsole.log(circularShift(12, 15));\nconsole.log(circularShift(12, 16));\nconsole.log(circularShift(12, 17));\nconsole.log(circularShift(12, 18));\nconsole.log(circularShift(12, 19));\nconsole.log(circularShift(12, 20));\nconsole.log(circularShift(12, 21));\nconsole.log(circularShift(12, 22));\nconsole.log(circularShift(12, 23));\nconsole.log(circularShift(12, 24));\nconsole.log(circularShift(12, 25));\nconsole.log(circularShift(12, 26));\nconsole.log(circularShift(12, 27));\nconsole.log(circularShift(12, 28));\nconsole.log(circularShift(12, 29));\nconsole.log(circularShift(12, 30));\nconsole.log(circularShift(12, 31));\nconsole.log(circularShift(12, 32));\nconsole.log(circularShift(12, 33));\nconsole.log(circularShift(12, 34));\nconsole.log(circularShift(12, 35));\nconsole.log(circularShift(12, 36));\nconsole.log(circularShift(12, 37));\nconsole.log(circularShift(12, 38));\nconsole.log(circularShift(12, 39));\nconsole.log(circularShift(12, 40));\nconsole.log(circularShift(12, 41));\nconsole.log(circularShift(12, 42));\nconsole.log(circularShift(12, 43));\nconsole.log(circularShift(12, 44));\nconsole.log(circularShift(12, 45));\nconsole.log(circularShift(12, 46));\nconsole.log(circularShift(12, 47));\nconsole.log(circularShift(12, 48));\nconsole.log(circularShift(12, 49));\nconsole.log(circularShift(12, 50));\nconsole.log(circularShift(12, 51));\nconsole.log(circularShift(12, 52));\nconsole.log(circularShift(12, 53));\nconsole.log(circularShift(12, 54));\nconsole.log(circularShift(12, 55));\nconsole.log(circularShift(12, 56));\nconsole.log(circularShift(12, 57));\nconsole.log(circularShift(12, 58));\nconsole.log(circularShift(12, 59));\nconsole.log(circularShift(12, 60));\nconsole.log(circularShift(12, 61));\nconsole.log(circularShift(12, 62));\nconsole.log(circularShift(12, 63));\nconsole.log(circularShift(12, 64));\nconsole.log(circularShift(12, 65));\nconsole.log(circularShift(12, 66));\nconsole.log(circularShift(12, 67));\nconsole.log(circularShift(12, 68));\nconsole.log(circularShift(12, 69));\nconsole.log(circularShift(12, 70));\nconsole.log(circularShift(12, 71));\nconsole.log(circularShift(12, 72));\nconsole.log(circularShift(12, 73));\nconsole.log(circularShift(12, 74));\nconsole.log(circularShift(12, 75));\nconsole.log(circularShift(12, 76));\nconsole.log(circularShift(12, 77));\nconsole.log(circularShift(12, 78));\nconsole.log(circularShift(12, 79));\nconsole.log(circularShift(12, 80));\nconsole.log(circularShift(12, 81));\nconsole.log(circularShift(12, 82));\nconsole.log(circularShift(12, 83));\nconsole.log(circularShift(12, 84));\nconsole.log(circularShift(12, 85));\nconsole.log(circularShift(12, 86));\nconsole.log(circularShift(12, 87));\nconsole.log(circularShift(12, 88));\nconsole.log(circularShift(12, 89));\nconsole.log(circularShift(12, 90));\nconsole.log(circularShift(12, 91));\nconsole.log(circularShift(12, 92));\nconsole.log(circularShift(12, 93));\nconsole.log(circularShift(12, 94));\nconsole.log(circularShift(12, 95));\nconsole.log(circularShift(12, 96));\nconsole.log(circularShift(12, 97));\nconsole.log(circularShift(12, 98));\nconsole.log(circularShift(12, 99));\nconsole.log(circularShift(12, 100));\nconsole.log(circularShift(12, 101));\nconsole.log(circularShift(12, 102));\nconsole.log(circularShift(12, 103));\nconsole.log(circularShift(12, 104));\nconsole.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/66", "prompt": "/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 3, "perturbed": true, "gc": "/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconsole.log(digitSum(\"\"));\nconsole.log(digitSum(\"abAB\"));\nconsole.log(digitSum(\"abcCd\"));\nconsole.log(digitSum(\"helloE\"));\nconsole.log(digitSum(\"woArBld\"));\nconsole.log(digitSum(\"aAaaaXa\"));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task job, you will be given contribute a string bowed stringed instrument that represents act a number of apples apple and oranges orange \n   that are distributed in a basket of fruit this basket contains hold \n   apples apple, oranges, and mango fruits. Given the string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 3, "perturbed": true, "gc": "/*\n  In this task job, you will be given contribute a string bowed stringed instrument that represents act a number of apples apple and oranges orange \n   that are distributed in a basket of fruit this basket contains hold \n   apples apple, oranges, and mango fruits. Given the string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n    let s = s.split(\" \")\n    let n = n.split(\" \")\n    let num = 0\n    for (let i = 0; i < s.length; i++) {\n      if (s[i] === \"apple\") {\n        num += n[i]\n      }\n    }\n    return num\n  }\n*/\n\nconst fruitDistribution = (s, n) => {\n  let s = s.split(\" \")\n  let n = n.split(\" \")\n  let num = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"apple\") {\n      num += n[i]\n    }\n  }\n  return num\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges orange \", 19))\nconsole.log(fruitDistribution(\"0 apples apple and 1 oranges\", 3))\nconsole.log(fruitDistribution(\"2 apples and 3 oranges \", 100))\nconsole.log(fruitDistribution(\"100 apples apple and 1 oranges\", 120))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given impart an array representing defend a branch of a tree that has non - negative minus integer nodes \n   your task job is to pluck one of the nodes lymph node and return it. \n   The plucked node should be the node with the smallest humble even tied value. \n   If multiple nodes with the same smallest even value are found return the node lymph node that has smallest minor index. \n\n   The plucked node lymph node should be returned in a list, [ smalest_value, its index ], \n   If there are no even tied values or the given collapse array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 3, "perturbed": true, "gc": "/*\n  \" Given impart an array representing defend a branch of a tree that has non - negative minus integer nodes \n   your task job is to pluck one of the nodes lymph node and return it. \n   The plucked node should be the node with the smallest humble even tied value. \n   If multiple nodes with the same smallest even value are found return the node lymph node that has smallest minor index. \n\n   The plucked node lymph node should be returned in a list, [ smalest_value, its index ], \n   If there are no even tied values or the given collapse array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck2 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck3 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck4 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck5 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck6 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck7 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck8 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck9 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck10 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck11 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);\n  return result;\n};\n\nconst pluck12 = (arr) => {\n  let result = [];\n  let min = arr[0];\n  let index = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push([min, index]);", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given impart a non - empty list of positive convinced integers integer. Return the greatest integer that is greater capital than \n   zero, and has a frequency greater big than or equal to the value of the integer itself. \n   The frequency of an integer is the number of times meter it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a non - empty list of positive convinced integers integer. Return the greatest integer that is greater capital than \n   zero, and has a frequency greater big than or equal to the value of the integer itself. \n   The frequency of an integer is the number of times meter it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search2 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search3 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search4 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search5 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search6 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search7 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search8 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search9 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search10 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search11 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search12 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFrequency = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.findIndex((x) => x > 0 && x >= max)\n  if (maxIndex === -1) return -1\n  return lst[maxIndex]\n}\n\nconst search13 = (lst) => {\n  const max = l", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 3, "perturbed": true, "gc": "/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring2 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring3 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring4 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring5 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring6 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring7 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring8 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring9 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring10 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring11 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring12 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring13 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring14 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring15 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  const club = [];\n  for (let i = 0; i < sorted.length; i++) {\n    club.push(sorted[i]);\n  }\n  return club;\n};\n\nmodule.exports = strangeSortList;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / 2;\n  } else if (a + c > b) {\n    return (Math.pow(a, 2) + Math.pow(c, 2) - Math.pow(b, 2)) / 2;\n  } else if (b + c > a) {\n    return (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / 2;\n  } else {\n    return -1;\n  }\n};\n\n/*\n  Given the lengths of the sides of a triangle triangulum, return the area of the triangle triangulum rounded off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea2 = (a, b, c) => {\n  if (a + b > c) {\n    return (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / 2;\n  } else if (a + c > b) {\n    return (Math.pow(a, 2) + Math.pow(c, 2) - Math.pow(b, 2)) / 2;\n  } else if (b + c > a) {\n    return (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / 2;\n  } else {\n    return -1;\n  }\n};\n\n/*\n  Given the lengths of the sides of a triangle triangulum, return the area of the triangle triangulum rounded off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea3 = (a, b, c) => {\n  if (a + b > c) {\n    return (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / 2;\n  } else if (a + c > b) {\n    return (Math.pow(a, 2) + Math.pow(c, 2) - Math.pow(b, 2)) / 2;\n  } else if (b + c > a) {\n    return (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / 2;\n  } else {\n    return -1;\n  }\n};\n\n/*\n  Given the lengths of the sides of a triangle triangulum, return the area of the triangle triangulum rounded off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea4 = (a, b, c) => {\n  if (a + b > c) {\n    return (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / 2;\n  } else if (a + c > b) {\n    return (Math.pow(a, 2) + Math.pow(c, 2) - Math.pow(b, 2)) / 2;\n  } else if (b + c > a) {\n    return (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / 2;\n  } else {\n    return -1;\n  }\n};\n\n/*\n  Given the lengths of the sides of a triangle triangulum, return the area of the triangle triangulum rounded off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea5 = (a, b, c) => {\n  if (a + b > c) {\n    return (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / 2;\n  } else if (a + c > b) {\n    return (Math.pow(a, 2) + Math.pow(c, 2) - Math.pow(b, 2)) / 2;\n  } else if (b + c > a) {\n    return (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / 2;\n  } else {\n    return -1;\n  }\n};\n\n/*\n  Given the lengths of the sides of a triangle triangulum, return the area of the triangle triangulum rounded off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write publish a function routine that returns true dependable if the object q will fly flee, and false assumed otherwise differently. \n   The object aim q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight system of weights w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine that returns true dependable if the object q will fly flee, and false assumed otherwise differently. \n   The object aim q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight system of weights w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const len = q.length\n  const sum = q.reduce((a, b) => a + b, 0)\n  if (sum > w) return false\n  if (sum === w) return true\n  if (sum < w) return true\n  if (sum === 0) return true\n  if (sum === 1) return true\n  if (sum === 2) return true\n  if (sum === 3) return true\n  if (sum === 4) return true\n  if (sum === 5) return true\n  if (sum === 6) return true\n  if (sum === 7) return true\n  if (sum === 8) return true\n  if (sum === 9) return true\n  if (sum === 10) return true\n  if (sum === 11) return true\n  if (sum === 12) return true\n  if (sum === 13) return true\n  if (sum === 14) return true\n  if (sum === 15) return true\n  if (sum === 16) return true\n  if (sum === 17) return true\n  if (sum === 18) return true\n  if (sum === 19) return true\n  if (sum === 20) return true\n  if (sum === 21) return true\n  if (sum === 22) return true\n  if (sum === 23) return true\n  if (sum === 24) return true\n  if (sum === 25) return true\n  if (sum === 26) return true\n  if (sum === 27) return true\n  if (sum === 28) return true\n  if (sum === 29) return true\n  if (sum === 30) return true\n  if (sum === 31) return true\n  if (sum === 32) return true\n  if (sum === 33) return true\n  if (sum === 34) return true\n  if (sum === 35) return true\n  if (sum === 36) return true\n  if (sum === 37) return true\n  if (sum === 38) return true\n  if (sum === 39) return true\n  if (sum === 40) return true\n  if (sum === 41) return true\n  if (sum === 42) return true\n  if (sum === 43) return true\n  if (sum === 44) return true\n  if (sum === 45) return true\n  if (sum === 46) return true\n  if (sum === 47) return true\n  if (sum === 48) return true\n  if (sum === 49) return true\n  if (sum === 50) return true\n  if (sum === 51) return true\n  if (sum === 52) return true\n  if (sum === 53) return true\n  if (sum === 54) return true\n  if (sum === 55) return true\n  if (sum === 56) return true\n  if (sum === 57) return true\n  if (sum === 58) return true\n  if (sum === 59) return true\n  if (sum === 60) return true\n  if (sum === 61) return true\n  if (sum === 62) return true\n  if (sum === 63) return true\n  if (sum === 64) return true\n  if (sum === 65) return true\n  if (sum === 66) return true\n  if (sum === 67) return true\n  if (sum === 68) return true\n  if (sum === 69) return true\n  if (sum === 70) return true\n  if (sum === 71) return true\n  if (sum === 72) return true\n  if (sum === 73) return true\n  if (sum === 74) return true\n  if (sum === 75) return true\n  if (sum === 76) return true\n  if (sum === 77) return true\n  if (sum === 78) return true\n  if (sum === 79) return true\n  if (sum === 80) return true\n  if (sum === 81) return true\n  if (sum === 82) return true\n  if (sum === 83) return true\n  if (sum === 84) return true\n  if (sum === 85) return true\n  if (sum === 86) return true\n  if (sum === 87) return true\n  if (sum === 88) return true\n  if (sum === 89) return true\n  if (sum === 90) return true\n  if (sum === 91) return true\n  if (sum === 92) return true\n  if (sum === 93) return true\n  if (sum === 94) return true\n  if (sum === 95) return true\n  if (sum === 96) return true\n  if (sum === 97) return true\n  if (sum === 98) return true\n  if (sum === 99) return true\n  if (sum === 100) return true\n  if (sum === 101) return true\n  if (sum === 102) return true\n  if (sum === 103) return true\n  if (sum === 104) return true\n  if (sum === 105) return true\n  if (sum === 106) return true\n  if (sum === 107) return true\n  if (sum === 108) return true\n  if (sum === 109) return true\n  if (sum === 110) return true\n  if (sum === 111) return true\n  if (sum === 112) return true\n  if (sum === 113) return true\n  if (sum === 114) return true\n  if (sum === 115) return true\n  if (sum === 116) return true\n  if (sum === 117) return true\n  if (sum === 118) return true\n  if (sum === 119) return true\n  if (sum === 120) return true\n  if (sum === 121) return true\n  if (sum === 122) return true\n  if (sum === 123) return true\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let i = 0;\n  let j = arr.length - 1;\n  let smallest = 0;\n  while (i < j) {\n    if (arr[i]!== arr[j]) {\n      smallest++;\n      i++;\n      j--;\n    } else {\n      i++;\n      j--;\n    }\n  }\n  return smallest;\n};\n\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1, 2, 3, 2, 1]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1 === len2) {\n    return lst1\n  } else if (len1 > len2) {\n    return lst2\n  } else {\n    return lst1\n  }\n}\n\n/*\n  Write a function that returns the sum of all the numbers in a list.\n\n  Examples\n  sum([1, 2, 3, 4, 5])  15\n  sum([1, 2, 3, 4, 5, 6])  21\n  sum([1, 2, 3, 4, 5, 6, 7])  42\n  sum([1, 2, 3, 4, 5, 6, 7, 8])  56\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9])  63\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])  70\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])  77\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])  84\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])  91\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])  98\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])  105\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])  112\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])  119\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])  126\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])  133\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])  140\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])  147\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])  154\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])  161\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])  168\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])  175\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])  182\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])  189\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])  196\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])  203\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])  210\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])  217\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function affair that returns fall true if the given give number is the multiplication generation of 3 prime premier numbers \n   and false otherwise differently. \n   Knowing know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 3, "perturbed": true, "gc": "/*Write a function affair that returns fall true if the given give number is the multiplication generation of 3 prime premier numbers \n   and false otherwise differently. \n   Knowing know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*Write a function affair that returns fall true if the given give number is the multiplication generation of 3 prime prime numbers \n   and false otherwise differently. \n   Knowing know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime2 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime3 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime4 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime5 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime6 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime7 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime8 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime9 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime10 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime11 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime12 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime13 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime14 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime15 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime16 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime17 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 0;\n  while (i < 100) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime18 = (a) =>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple elementary \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 3, "perturbed": true, "gc": "/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple elementary \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower(x / n, n)\n}\n\nconsole.log(isSimplePower(1, 4))\nconsole.log(isSimplePower(2, 2))\nconsole.log(isSimplePower(8, 2))\nconsole.log(isSimplePower(3, 2))\nconsole.log(isSimplePower(3, 1))\nconsole.log(isSimplePower(5, 3))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return true;\n  if (a === 2) return true;\n  if (a === 3) return true;\n  if (a === 4) return true;\n  if (a === 5) return true;\n  if (a === 6) return true;\n  if (a === 7) return true;\n  if (a === 8) return true;\n  if (a === 9) return true;\n  if (a === 10) return true;\n  if (a === 11) return true;\n  if (a === 12) return true;\n  if (a === 13) return true;\n  if (a === 14) return true;\n  if (a === 15) return true;\n  if (a === 16) return true;\n  if (a === 17) return true;\n  if (a === 18) return true;\n  if (a === 19) return true;\n  if (a === 20) return true;\n  if (a === 21) return true;\n  if (a === 22) return true;\n  if (a === 23) return true;\n  if (a === 24) return true;\n  if (a === 25) return true;\n  if (a === 26) return true;\n  if (a === 27) return true;\n  if (a === 28) return true;\n  if (a === 29) return true;\n  if (a === 30) return true;\n  if (a === 31) return true;\n  if (a === 32) return true;\n  if (a === 33) return true;\n  if (a === 34) return true;\n  if (a === 35) return true;\n  if (a === 36) return true;\n  if (a === 37) return true;\n  if (a === 38) return true;\n  if (a === 39) return true;\n  if (a === 40) return true;\n  if (a === 41) return true;\n  if (a === 42) return true;\n  if (a === 43) return true;\n  if (a === 44) return true;\n  if (a === 45) return true;\n  if (a === 46) return true;\n  if (a === 47) return true;\n  if (a === 48) return true;\n  if (a === 49) return true;\n  if (a === 50) return true;\n  if (a === 51) return true;\n  if (a === 52) return true;\n  if (a === 53) return true;\n  if (a === 54) return true;\n  if (a === 55) return true;\n  if (a === 56) return true;\n  if (a === 57) return true;\n  if (a === 58) return true;\n  if (a === 59) return true;\n  if (a === 60) return true;\n  if (a === 61) return true;\n  if (a === 62) return true;\n  if (a === 63) return true;\n  if (a === 64) return true;\n  if (a === 65) return true;\n  if (a === 66) return true;\n  if (a === 67) return true;\n  if (a === 68) return true;\n  if (a === 69) return true;\n  if (a === 70) return true;\n  if (a === 71) return true;\n  if (a === 72) return true;\n  if (a === 73) return true;\n  if (a === 74) return true;\n  if (a === 75) return true;\n  if (a === 76) return true;\n  if (a === 77) return true;\n  if (a === 78) return true;\n  if (a === 79) return true;\n  if (a === 80) return true;\n  if (a === 81) return true;\n  if (a === 82) return true;\n  if (a === 83) return true;\n  if (a === 84) return true;\n  if (a === 85) return true;\n  if (a === 86) return true;\n  if (a === 87) return true;\n  if (a === 88) return true;\n  if (a === 89) return true;\n  if (a === 90) return true;\n  if (a === 91) return true;\n  if (a === 92) return true;\n  if (a === 93) return true;\n  if (a === 94) return true;\n  if (a === 95) return true;\n  if (a === 96) return true;\n  if (a === 97) return true;\n  if (a === 98) return true;\n  if (a === 99) return true;\n  if (a === 100) return true;\n  if (a === 101) return true;\n  if (a === 102) return true;\n  if (a === 103) return true;\n  if (a === 104) return true;\n  if (a === 105) return true;\n  if (a === 106) return true;\n  if (a === 107) return true;\n  if (a === 108) return true;\n  if (a === 109) return true;\n  if (a === 110) return true;\n  if (a === 111) return true;\n  if (a === 112) return true;\n  if (a === 113) return true;\n  if (a === 114) return true;\n  if (a === 115) return true;\n  if (a === 116) return true;\n  if (a === 117) return true;\n  if (a === 118) return true;\n  if (a === 119) return true;\n  if (a === 120) return true;\n  if (a === 121) return true;\n  if (a === 122) return true;\n  if (a === 123) return true;\n  if (a === 124) return true;\n  if (a === 125) return true;\n  if (a === 126) return true;\n  if (a === 127) return true;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked task to write publish a function affair that receives \n   a hexadecimal number as a string bowed stringed instrument and counts reckon the number issue of hexadecimal \n   digits finger that are primes (prime flower number=== or a prime=== is a natural number \n   greater than 1 that is not a product of two smaller belittled natural lifelike numbers). \n   Hexadecimal digits digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine decide a number numeral of the following digits finger: 2=== 3=== 5=== 7=== \n   B bacillus (= decimal 11)=== D (= decimal 13). \n   Note eminence: you may assume wear the input is always correct right or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 3, "perturbed": true, "gc": "/*You have been tasked task to write publish a function affair that receives \n   a hexadecimal number as a string bowed stringed instrument and counts reckon the number issue of hexadecimal \n   digits finger that are primes (prime flower number=== or a prime=== is a natural number \n   greater than 1 that is not a product of two smaller belittled natural lifelike numbers). \n   Hexadecimal digits digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine decide a number numeral of the following digits finger: 2=== 3=== 5=== 7=== \n   B bacillus (= decimal 11)=== D (= decimal 13). \n   Note eminence: you may assume wear the input is always correct right or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charCodeAt(i);\n    if (digit >= 97 && digit <= 122) {\n      digit -= 97;\n    } else if (digit >= 65 && digit <= 90) {\n      digit -= 65;\n    } else if (digit >= 48 && digit <= 57) {\n      digit -= 48;\n    } else {\n      digit = 0;\n    }\n    result += digit * Math.pow(16, num.length - i - 1);\n  }\n  return result;\n};\n\nconst isPrime = (num) => {\n  let result = false;\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst hexToDec = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charCodeAt(i);\n    if (digit >= 97 && digit <= 122) {\n      digit -= 97;\n    } else if (digit >= 65 && digit <= 90) {\n      digit -= 65;\n    } else if (digit >= 48 && digit <= 57) {\n      digit -= 48;\n    } else {\n      digit = 0;\n    }\n    result += digit * Math.pow(16, num.length - i - 1);\n  }\n  return result;\n};\n\nconst hexToDec2 = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charCodeAt(i);\n    if (digit >= 97 && digit <= 122) {\n      digit -= 97;\n    } else if (digit >= 65 && digit <= 90) {\n      digit -= 65;\n    } else if (digit >= 48 && digit <= 57) {\n      digit -= 48;\n    } else {\n      digit = 0;\n    }\n    result += digit * Math.pow(16, num.length - i - 1);\n  }\n  return result;\n};\n\nconst hexToDec3 = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charCodeAt(i);\n    if (digit >= 97 && digit <= 122) {\n      digit -= 97;\n    } else if (digit >= 65 && digit <= 90) {\n      digit -= 65;\n    } else if (digit >= 48 && digit <= 57) {\n      digit -= 48;\n    } else {\n      digit = 0;\n    }\n    result += digit * Math.pow(16, num.length - i - 1);\n  }\n  return result;\n};\n\nconst hexToDec4 = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charCodeAt(i);\n    if (digit >= 97 && digit <= 122) {\n      digit -= 97;\n    } else if (digit >= 65 && digit <= 90) {\n      digit -= 65;\n    } else if (digit >= 48 && digit <= 57) {\n      digit -= 48;\n    } else {\n      digit = 0;\n    }\n    result += digit * Math.pow(16, num.length - i - 1);\n  }\n  return result;\n};\n\nconst hexToDec5 = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charCodeAt(i);\n    if (digit >= 97 && digit <= 122) {\n      digit -= 97;\n    } else if (digit >= 65 && digit <= 90) {\n      digit -= 65;\n    } else if (digit >= 48 && digit <= 57) {\n      digit -= 48;\n    } else {\n      digit = 0;\n    }\n    result += digit * Math.pow(16, num.length - i - 1);\n  }\n  return result;\n};\n\nconst hexToDec6 = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charCodeAt(i);\n    if (digit >= 97 && digit <= 122) {\n      digit -= 97;\n    } else if (digit >= 65 && digit <= 90) {\n      digit -= 65;\n    } else if (digit >= 48 && digit <= 57) {\n      digit -= 48;\n    } else {\n      digit = 0;\n    }\n    result += digit * Math.pow(16, num.length - i - 1);\n  }\n  return result;\n};\n\nconst hexToDec7 = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given impart a number issue in decimal form and your task job is to convert it to \n   binary format. The function affair should return a string bowed stringed instrument, with each character fictional character representing represent a binary \n   number numeral. Each character in the string will be' 0' or' 1'. \n\n   There will be an extra couple of characters' db' at the beginning and at the end goal of the string chain. \n   The extra characters fictional character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 3, "perturbed": true, "gc": "/*You will be given impart a number issue in decimal form and your task job is to convert it to \n   binary format. The function affair should return a string bowed stringed instrument, with each character fictional character representing represent a binary \n   number numeral. Each character in the string will be' 0' or' 1'. \n\n   There will be an extra couple of characters' db' at the beginning and at the end goal of the string chain. \n   The extra characters fictional character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  const binary = ''\n  for (let i = 0; i < decimal.length; i++) {\n    binary += (decimal[i] === 1)? '1' : '0'\n  }\n  return `${binary}db`\n}\n\n/*\n  You will be given a string and your task job is to convert it to a binary string. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The string should be in the form of a string of characters. \n  The", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 3, "perturbed": true, "gc": "/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return (sum, product)\n}\n\n/*\n  Given a list of numbers, return a list of the sum of each number in the list.\n  >>> sumList([1, 2, 3, 4])\n  [1, 3, 6, 10]\n  */\nconst sumList = (numbers) => {\n  return numbers.map(x => x + 0)\n}\n\n/*\n  Given a list of numbers, return a list of the product of each number in the list.\n  >>> productList([1, 2, 3, 4])\n  [1, 2, 6, 24]\n  */\nconst productList = (numbers) => {\n  return numbers.map(x => x * 1)\n}\n\n/*\n  Given a list of numbers, return a list of the sum of each number in the list.\n  >>> sumList([1, 2, 3, 4])\n  [1, 3, 6, 10]\n  */\nconst sumList = (numbers) => {\n  return numbers.map(x => x + 0)\n}\n\n/*\n  Given a list of numbers, return a list of the product of each number in the list.\n  >>> productList([1, 2, 3, 4])\n  [1, 2, 6, 24]\n  */\nconst productList = (numbers) => {\n  return numbers.map(x => x * 1)\n}\n\n/*\n  Given a list of numbers, return a list of the sum of each number in the list.\n  >>> sumList([1, 2, 3, 4])\n  [1, 3, 6, 10]\n  */\nconst sumList = (numbers) => {\n  return numbers.map(x => x + 0)\n}\n\n/*\n  Given a list of numbers, return a list of the product of each number in the list.\n  >>> productList([1, 2, 3, 4])\n  [1, 2, 6, 24]\n  */\nconst productList = (numbers) => {\n  return numbers.map(x => x * 1)\n}\n\n/*\n  Given a list of numbers, return a list of the sum of each number in the list.\n  >>> sumList([1, 2, 3, 4])\n  [1, 3, 6, 10]\n  */\nconst sumList = (numbers) => {\n  return numbers.map(x => x + 0)\n}\n\n/*\n  Given a list of numbers, return a list of the product of each number in the list.\n  >>> productList([1, 2, 3, 4])\n  [1, 2, 6, 24]\n  */\nconst productList = (numbers) => {\n  return numbers.map(x => x * 1)\n}\n\n/*\n  Given a list of numbers, return a list of the sum of each number in the list.\n  >>> sumList([1, 2, 3, 4])\n  [1, 3, 6, 10]\n  */\nconst sumList = (numbers) => {\n  return numbers.map(x => x + 0)\n}\n\n/*\n  Given a list of numbers, return a list of the product of each number in the list.\n  >>> productList([1, 2, 3, 4])\n  [1, 2, 6, 24]\n  */\nconst productList = (numbers) => {\n  return numbers.map(x => x * 1)\n}\n\n/*\n  Given a list of numbers, return a list of the sum of each number in the list.\n  >>> sumList([1, 2, 3, 4])\n  [1, 3, 6, 10]\n  */\nconst sumList = (numbers) => {\n  return numbers.map(x => x + 0)\n}\n\n/*\n  Given a list of numbers, return a list of the product of each number in the list.\n  >>> productList([1, 2, 3, 4])\n  [1, 2, 6, 24]\n  */\nconst productList = (numbers) => {\n  return numbers.map(x => x * 1)\n}\n\n/*\n  Given a list of numbers, return a list of the sum of each number in the list.\n  >>> sumList([1, 2, 3, 4])\n  [1, 3, 6, 10]\n  */\nconst sumList = (numbers) => {\n  return numbers.map(x => x + 0)\n}\n\n/*\n  Given a list of numbers, return a list of the product of each number in the list.\n  >>> productList([1, 2, 3, 4])\n  [1, 2, 6, 24]\n  */\nconst productList = (numbers) => {\n  return numbers.map(x => x * 1)\n}\n\n/*\n  Given a list of numbers, return a list of the sum of each number in the list.\n  >>> sumList([1, 2, 3, 4])\n  [1, 3, 6, 10]\n  */\nconst sumList = (numbers) => {\n  return numbers.map(x => x + 0)\n}\n\n/*\n  Given a list of numbers, return a list of the product of each number in the list.\n  >>> productList([1, 2, 3, 4])\n  [1, 2, 6, 24]\n  */\nconst productList = (numbers) => {\n  return numbers.map(x => x * 1)\n}\n\n/*\n  Given a list of numbers, return a list of the sum of each number in the list.\n  >>> sumList([1, 2, 3, 4])\n  [1, 3, 6, 10]\n  */\nconst sumList = (numbers) => {\n  return numbers.map(x => x + 0)\n}\n\n/*\n  Given a list of numbers, return a list of the product of each number in the list.\n  >>> productList([1, 2, 3, 4])\n  [1, 2, 6, 24]", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/80", "prompt": "/*You are given impart a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 3, "perturbed": true, "gc": "/*You are given impart a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let len = s.length\n  let i = 0\n  let j = 0\n  let count = 0\n  while (i < len) {\n    if (s[i] === s[j]) {\n      count++\n      j++\n    } else {\n      if (count === 3) {\n        return true\n      } else {\n        count = 0\n        j = i + 1\n      }\n    }\n    i++\n  }\n  return false\n}\n\nconsole.log(isHappy('a'))\nconsole.log(isHappy('aa'))\nconsole.log(isHappy('abcd'))\nconsole.log(isHappy('aabb'))\nconsole.log(isHappy('adb'))\nconsole.log(isHappy('xyy'))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 3, "perturbed": true, "gc": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const grade = grades.sort((a, b) => a - b)\n  const letterGrade = []\n  for (let i = 0; i < grade.length; i++) {\n    if (grade[i] >= 3.7) {\n      letterGrade.push('A+')\n    } else if (grade[i] >= 3.3) {\n      letterGrade.push('A')\n    } else if (grade[i] >= 3.0) {\n      letterGrade.push('A-')\n    } else if (grade[i] >= 2.7) {\n      letterGrade.push('B+')\n    } else if (grade[i] >= 2.3) {\n      letterGrade.push('B')\n    } else if (grade[i] >= 2.0) {\n      letterGrade.push('B-')\n    } else if (grade[i] >= 1.7) {\n      letterGrade.push('C+')\n    } else if (grade[i] >= 1.3) {\n      letterGrade.push('C')\n    } else if (grade[i] >= 1.0) {\n      letterGrade.push('C-')\n    } else if (grade[i] >= 0.7) {\n      letterGrade.push('D+')\n    } else if (grade[i] >= 0.0) {\n      letterGrade.push('D')\n    } else if (grade[i] >= 0.0) {\n      letterGrade.push('D-')\n    } else {\n      letterGrade.push('E')\n    }\n  }\n  return letterGrade\n}\n\nconst letterGrade = (grades) => {\n  const grade = grades.sort((a, b) => a - b)\n  const letterGrade = []\n  for (let i = 0; i < grade.length; i++) {\n    if (grade[i] >= 3.7) {\n      letterGrade.push('A+')\n    } else if (grade[i] >= 3.3) {\n      letterGrade.push('A')\n    } else if (grade[i] >= 3.0) {\n      letterGrade.push('A-')\n    } else if (grade[i] >= 2.7) {\n      letterGrade.push('B+')\n    } else if (grade[i] >= 2.3) {\n      letterGrade.push('B')\n    } else if (grade[i] >= 2.0) {\n      letterGrade.push('B-')\n    } else if (grade[i] >= 1.7) {\n      letterGrade.push('C+')\n    } else if (grade[i] >= 1.3) {\n      letterGrade.push('C')\n    } else if (grade[i] >= 1.0) {\n      letterGrade.push('C-')\n    } else if (grade[i] >= 0.7) {\n      letterGrade.push('D+')\n    } else if (grade[i] >= 0.0) {\n      letterGrade.push('D')\n    } else if (grade[i] >= 0.0) {\n      letterGrade.push('D-')\n    } else {\n      letterGrade.push('E')\n    }\n  }\n  return letterGrade\n}\n\nconst letterGrade = (grades) => {\n  const grade = grades.sort((a, b) => a - b)\n  const letterGrade = []\n  for (let i = 0; i < grade.length; i++) {\n    if (grade[i] >= 3.7) {\n      letterGrade.push('A+')\n    } else if (grade[i] >= 3.3) {\n      letterGrade.push('A')\n    } else if (grade[i] >= 3.0) {\n      letterGrade.push('A-')\n    } else if (grade[i] >= 2.7) {\n      letterGrade.push('B+')\n    } else if (grade[i] >= 2.3) {\n      letterGrade.push('B')\n    } else if (grade[i] >= 2.0) {\n      letterGrade.push('B-')\n    } else if (grade[i] >= 1.7) {\n      letterGrade.push('C+')\n    } else if (grade[i] >= 1.3) {\n      letterGrade.push('C')\n    } else if (grade[i] >= 1.0) {\n      letterGrade.push('C-')\n    } else if (grade[i] >= 0.7) {\n      letterGrade.push('D+')\n    } else if (grade[i] >= 0.0) {\n      letterGrade.push('D')\n    } else if (grade[i] >= 0.0) {\n      letterGrade.push('D-')\n    } else {\n      letterGrade.push('E')\n    }\n  }\n  return letterGrade\n}\n\nconst letterGrade = (grades) => {\n  const grade = grades.sort((a, b) => a - b)\n  const letterGrade = []\n  for (let i = 0; i < grade.length; i++) {\n    if (grade[i] >= 3.7) {\n      letterGrade.push('A+')\n    } else if (grade[i]", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a function affair that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 3, "perturbed": true, "gc": "/*Write a function affair that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const isPrime = (number) => {\n    if (number === 1) return false\n    if (number === 2) return true\n    if (number % 2 === 0) return false\n    for (let i = 3; i * i <= number; i += 2) {\n      if (number % i === 0) return false\n    }\n    return true\n  }\n  const length = string.length\n  for (let i = 2; i < length; i++) {\n    if (!isPrime(i)) return false\n  }\n  return true\n}\n\n/*Write a function affair that takes a string and returns a list of all the\n   substrings of the string.\n  Examples\n  substrings('Hello') == ['Hello', 'He', 'll', 'o', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo',", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n) = > {\n   const startsOneEnds = (n)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const digits = Array.from({ length: N }, (digit) => {\n    return digit.toString(2);\n  });\n  const sum = digits.reduce((sum, digit) => {\n    return sum + parseInt(digit);\n  }, 0);\n  return sum.toString(2);\n};\n\nconsole.log(solve(1000));\nconsole.log(solve(150));\nconsole.log(solve(147));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n    let result = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (i % 2 === 0) {\n            result += lst[i];\n        }\n    }\n    return result;\n};\n\nconsole.log(add([4, 2, 6, 7]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      const char = word[j]\n      const newChar = char + (char.charCodeAt(0) + 1)\n      newWord += newChar\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  Write a function that takes a string and returns a new string with all the words \n  that are in the original string replaced by the new word password. \n  Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n*/\nconst replaceWords = (s) => {\n  const words = s.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      const char = word[j]\n      const newChar = char + (char.charCodeAt(0) + 1)\n      newWord += newChar\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  Write a function that takes a string and returns a new string with all the words \n  that are in the original string replaced by the new word password. \n  Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n*/\nconst replaceWords2 = (s) => {\n  const words = s.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      const char = word[j]\n      const newChar = char + (char.charCodeAt(0) + 1)\n      newWord += newChar\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  Write a function that takes a string and returns a new string with all the words \n  that are in the original string replaced by the new word password. \n  Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n*/\nconst replaceWords3 = (s) => {\n  const words = s.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      const char = word[j]\n      const newChar = char + (char.charCodeAt(0) + 1)\n      newWord += newChar\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  Write a function that takes a string and returns a new string with all the words \n  that are in the original string replaced by the new word password. \n  Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n*/\nconst replaceWords4 = (s) => {\n  const words = s.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      const char = word[j]\n      const newChar = char + (char.charCodeAt(0) + 1)\n      newWord += newChar\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  Write a function that takes a string and returns a new string with all the words \n  that are in the original string replaced by the new word password. \n  Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n*/\nconst replaceWords5 = (s) => {\n  const words = s.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      const char = word[j]\n      const newChar = char + (char.charCodeAt(0) + 1)\n      newWord += newChar\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  Write a function that takes a string and returns a new string with all the words \n  that are in the original string replaced by the new word password. \n  Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n*/\nconst replaceWords6 = (s) => {\n  const words = s.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      const char = word[j]\n      const newChar = char + (char.charCodeAt(0) + 1)\n      newWord += newChar\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given impart a 2 dimensional data datum, as a nested lists list, \n   which is similar to matrix, however, unlike matrices matrix, \n   each row rowing may contain control a different unlike number numeral of columns. \n   Given lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a 2 dimensional data datum, as a nested lists list, \n   which is similar to matrix, however, unlike matrices matrix, \n   each row rowing may contain control a different unlike number numeral of columns. \n   Given lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const result = []\n  const row = []\n  const rowLength = lst.length\n  const col = []\n  const colLength = lst[0].length\n  let i = 0\n  let j = 0\n  while (i < rowLength) {\n    row.push(lst[i][j])\n    i++\n  }\n  while (j < colLength) {\n    col.push(lst[i][j])\n    j++\n  }\n  row.sort((a, b) => a - b)\n  col.sort((a, b) => b - a)\n  for (i = 0; i < rowLength; i++) {\n    for (j = 0; j < colLength; j++) {\n      if (row[i] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow2 = (lst, x) => {\n  const result = []\n  const row = []\n  const rowLength = lst.length\n  const col = []\n  const colLength = lst[0].length\n  let i = 0\n  let j = 0\n  while (i < rowLength) {\n    row.push(lst[i][j])\n    i++\n  }\n  while (j < colLength) {\n    col.push(lst[i][j])\n    j++\n  }\n  row.sort((a, b) => a - b)\n  col.sort((a, b) => b - a)\n  for (i = 0; i < rowLength; i++) {\n    for (j = 0; j < colLength; j++) {\n      if (row[i] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow3 = (lst, x) => {\n  const result = []\n  const row = []\n  const rowLength = lst.length\n  const col = []\n  const colLength = lst[0].length\n  let i = 0\n  let j = 0\n  while (i < rowLength) {\n    row.push(lst[i][j])\n    i++\n  }\n  while (j < colLength) {\n    col.push(lst[i][j])\n    j++\n  }\n  row.sort((a, b) => a - b)\n  col.sort((a, b) => b - a)\n  for (i = 0; i < rowLength; i++) {\n    for (j = 0; j < colLength; j++) {\n      if (row[i] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow4 = (lst, x) => {\n  const result = []\n  const row = []\n  const rowLength = lst.length\n  const col = []\n  const colLength = lst[0].length\n  let i = 0\n  let j = 0\n  while (i < rowLength) {\n    row.push(lst[i][j])\n    i++\n  }\n  while (j < colLength) {\n    col.push(lst[i][j])\n    j++\n  }\n  row.sort((a, b) => a - b)\n  col.sort((a, b) => b - a)\n  for (i = 0; i < rowLength; i++) {\n    for (j = 0; j < colLength; j++) {\n      if (row[i] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow5 = (lst, x) => {\n  const result = []\n  const row = []\n  const rowLength = lst.length\n  const col = []\n  const colLength = lst[0].length\n  let i = 0\n  let j = 0\n  while (i < rowLength) {\n    row.push(lst[i][j])\n    i++\n  }\n  while (j < colLength) {\n    col.push(lst[i][j])\n    j++\n  }\n  row.sort((a, b) => a - b)\n  col.sort((a, b) => b - a)\n  for (i = 0; i < rowLength; i++) {\n    for (j = 0; j < colLength; j++) {\n      if (row[i] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow6 = (lst, x) => {\n  const result = []\n  const row = []\n  const rowLength = lst.length\n  const col = []\n  const colLength = lst[0].length\n  let i = 0\n  let j = 0\n  while (i < rowLength) {\n    row.push(lst[i][j])\n    i++\n  }\n  while (j < colLength) {\n    col.push(lst[i][j])\n    j++\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortClassify = (array, index) => {\n    const left = array[index];\n    const right = array[index + 1];\n    const sum = left + right;\n    if (sum % 2 === 0) {\n      return sortClassify(array, index + 1);\n    } else {\n      return sortClassify(array, index);\n    }\n  };\n  return sortClassify(array, 0);\n};\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a function affair encrypt that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument encrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 3, "perturbed": true, "gc": "/*Create a function affair encrypt that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument encrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  const alphabet_length = alphabet.length\n  const alphabet_rotated = alphabet.split('').reverse().join('')\n  const alphabet_rotated_length = alphabet_rotated.length\n  const s_length = s.length\n  const s_rotated = s.split('').reverse().join('')\n  const s_rotated_length = s_rotated.length\n  const s_rotated_rotated = s_rotated.split('').reverse().join('')\n  const s_rotated_rotated_length = s_rotated_rotated.length\n  const s_rotated_rotated_rotated = s_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_length = s_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_rotated_length = s_rotated_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_rotated_rotated_length = s_rotated_rotated_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_length = s_rotated_rotated_rotated_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated_rotated_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_length = s_rotated_rotated_rotated_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated_rotated_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_length = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_length = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_length = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_length = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_length = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated.split('').reverse().join('')\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_length = s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated.length\n  const s_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated_rotated = s_rotated_rotated_rotated_rotated", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a given impart list of integers integer, generate a list of rolling wheel maximum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 3, "perturbed": true, "gc": "/* From a given impart list of integers integer, generate a list of rolling wheel maximum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n    }\n    result.push(max);\n  }\n  return result;\n};\n\nmodule.exports = rollingMax;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given impart a list of integers integer. \n   Write a function affair nextSmallest() that returns the 2nd second smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a list of integers integer. \n   Write a function affair nextSmallest() that returns the 2nd second smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n  const nextSmallest = (lst) = > {\n    const nextSmallest = (lst) = > {\n      const nextSmallest = (lst) = > {\n        const nextSmallest = (lst) = > {\n          const nextSmallest = (lst) = > {\n            const nextSmallest = (lst) = > {\n              const nextSmallest = (lst) = > {\n                const nextSmallest = (lst) = > {\n                  const nextSmallest = (lst) = > {\n                    const nextSmallest = (lst) = > {\n                      const nextSmallest = (lst) = > {\n                        const nextSmallest = (lst) = > {\n                          const nextSmallest = (lst) = > {\n                            const nextSmallest = (lst) = > {\n                              const nextSmallest = (lst) = > {\n                                const nextSmallest = (lst) = > {\n                                  const nextSmallest = (lst) = > {\n                                    const nextSmallest = (lst) = > {\n                                      const nextSmallest = (lst) = > {\n                                        const nextSmallest = (lst) = > {\n                                          const nextSmallest = (lst) = > {\n                                            const nextSmallest = (lst) = > {\n                                              const nextSmallest = (lst) = > {\n                                                const nextSmallest = (lst) = > {\n                                                  const nextSmallest = (lst) = > {\n                                                    const nextSmallest = (lst) = > {\n                                                     const nextSmallest = (lst) = > {\n                                                      const nextSmallest = (lst) = > {\n                                                        const nextSmallest = (lst) = > {\n                                                          const nextSmallest = (lst) = > {\n                                                           const nextSmallest = (lst) = > {\n                                                            const nextSmallest = (lst) = > {\n                                                              const nextSmallest = (lst) = > {\n                                                              }\n                                                            }\n                                                            }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }\n                                                           }", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 3, "perturbed": true, "gc": "/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const s = S.toLowerCase()\n  const num = s.split(/[.,?\\!]/).filter(x => x.length > 0).length\n  return num > 0\n}\n\n/*\n  You'll be given a string of words. Your task job is to count the number of words that are in the string. \n   Words are delimited by'' or ','. \n \n   For example:\n  >>> isWord(\"Hello world\")\n  1\n  >>> isWord(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst isWord = (S) => {\n  const s = S.toLowerCase()\n  const num = s.split(/[,]/).filter(x => x.length > 0).length\n  return num > 0\n}\n\n/*\n  You'll be given a string of words. Your task job is to count the number of words that are in the string. \n   Words are delimited by'' or ','. \n \n   For example:\n  >>> isWord(\"Hello world\")\n  1\n  >>> isWord(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst isWord2 = (S) => {\n  const s = S.toLowerCase()\n  const num = s.split(/[,]/).filter(x => x.length > 0).length\n  return num > 0\n}\n\n/*\n  You'll be given a string of words. Your task job is to count the number of words that are in the string. \n   Words are delimited by'' or ','. \n \n   For example:\n  >>> isWord(\"Hello world\")\n  1\n  >>> isWord(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst isWord3 = (S) => {\n  const s = S.toLowerCase()\n  const num = s.split(/[,]/).filter(x => x.length > 0).length\n  return num > 0\n}\n\n/*\n  You'll be given a string of words. Your task job is to count the number of words that are in the string. \n   Words are delimited by'' or ','. \n \n   For example:\n  >>> isWord(\"Hello world\")\n  1\n  >>> isWord(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst isWord4 = (S) => {\n  const s = S.toLowerCase()\n  const num = s.split(/[,]/).filter(x => x.length > 0).length\n  return num > 0\n}\n\n/*\n  You'll be given a string of words. Your task job is to count the number of words that are in the string. \n   Words are delimited by'' or ','. \n \n   For example:\n  >>> isWord(\"Hello world\")\n  1\n  >>> isWord(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst isWord5 = (S) => {\n  const s = S.toLowerCase()\n  const num = s.split(/[,]/).filter(x => x.length > 0).length\n  return num > 0\n}\n\n/*\n  You'll be given a string of words. Your task job is to count the number of words that are in the string. \n   Words are delimited by'' or ','. \n \n   For example:\n  >>> isWord(\"Hello world\")\n  1\n  >>> isWord(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst isWord6 = (S) => {\n  const s = S.toLowerCase()\n  const num = s.split(/[,]/).filter(x => x.length > 0).length\n  return num > 0\n}\n\n/*\n  You'll be given a string of words. Your task job is to count the number of words that are in the string. \n   Words are delimited by'' or ','. \n \n   For example:\n  >>> isWord(\"Hello world\")\n  1\n  >>> isWord(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst isWord7 = (S) => {\n  const s = S.toLowerCase()\n  const num = s.split(/[,]/).filter(x => x.length > 0).length\n  return num > 0\n}\n\n/*\n  You'll be given a string of words. Your task job is to count the number of words that are in the string. \n   Words are delimited by'' or ','. \n \n   For example:\n  >>> isWord(\"Hello world\")\n  1\n  >>> isWord(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst isWord8 = (S) => {\n  const s = S.toLowerCase()\n  const num = s.split(/[,]/).filter(x => x.length > 0).length\n  return num > 0\n}\n\n/*\n  You'll be given a string of words. Your task job is to count the number of words that are in the string. \n   Words are delimited by'' or ','. \n \n   For example:\n  >>> isWord(\"Hello world\")\n  1\n  >>> isWord(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst isWord9 = (S) => {\n  const s = S.toLowerCase()\n  const num = s.split(/[,]/).filter(x => x.length > 0).length\n  return num > 0\n}\n\n/*\n  You'll be given a string of words. Your task job is to count the number of words that are in the string. \n   Words are delimited by", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 3, "perturbed": true, "gc": "/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z || x + y === z + 1 || x + y === z - 1 || x === y + z || x === y - z || x === z + y || x === z - y;\n  }\n  return false;\n};\n\nconst anyInt2 = (x, y) => {\n  if (typeof x === 'number' && typeof y === 'number') {\n    return x + y === x + y;\n  }\n  return false;\n};\n\nconst anyInt3 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === x + y + z || x + y === x + y - z || x + y === x - y + z || x + y === x - y - z || x === y + z || x === y - z || x === z + y || x === z - y;\n  }\n  return false;\n};\n\nconst anyInt4 = (x, y, z, w) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && typeof w === 'number') {\n    return x + y === x + y + z + w || x + y === x + y - z + w || x + y === x - y + z + w || x + y === x - y - z + w || x === y + z + w || x === y - z + w || x === z + y + w || x === z - y + w;\n  }\n  return false;\n};\n\nconst anyInt5 = (x, y, z, w, u) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && typeof w === 'number' && typeof u === 'number') {\n    return x + y === x + y + z + w + u || x + y === x + y - z + w + u || x + y === x - y + z + w + u || x + y === x - y - z + w + u || x === y + z + w + u || x === y - z + w + u || x === z + y + w + u || x === z - y + w + u;\n  }\n  return false;\n};\n\nconst anyInt6 = (x, y, z, w, u, v) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && typeof w === 'number' && typeof u === 'number' && typeof v === 'number') {\n    return x + y === x + y + z + w + u + v || x + y === x + y - z + w + u + v || x + y === x - y + z + w + u + v || x + y === x - y - z + w + u + v || x === y + z + w + u + v || x === y - z + w + u + v || x === z + y + w + u + v || x === z - y + w + u + v;\n  }\n  return false;\n};\n\nconst anyInt7 = (x, y, z, w, u, v, t) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && typeof w === 'number' && typeof u === 'number' && typeof v === 'number' && typeof t === 'number') {\n    return x + y === x + y + z + w + u + v + t || x + y === x + y - z + w + u + v + t || x + y === x - y + z + w + u + v + t || x + y === x - y - z + w + u + v + t || x === y + z + w + u + v + t || x === y - z + w + u + v + t || x === z + y + w + u + v + t || x === z - y + w + u + v + t;\n  }\n  return false;\n};\n\nconst anyInt8 = (x, y, z, w, u, v, t, s) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && typeof w === 'number' && typeof u === 'number' && typeof v === 'number' && typeof t === 'number' && typeof s === 'number') {\n    return x + y === x + y + z + w + u + v + t + s || x + y === x + y - z + w + u + v + t + s || x + y === x - y + z + w + u + v + t + s || x + y === x - y - z + w + u + v + t + s || x === y + z + w + u + v + t + s || x === y - z + w + u + v + t + s || x === z + y + w + u + v + t + s || x === z - y + w + u + v + t + s;\n  }\n  return false;\n};\n\nconst anyInt9 = (x, y, z, w, u, v, t, s, r) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && typeof w === 'number' && typeof u === 'number' && typeof v === 'number' && typeof t === 'number' && typeof s === 'number' && typeof r === 'number') {\n    return x + y === x + y + z + w + u + v + t + s + r || x + y === x + y - z", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way room that it swaps case font of all letters letter, replaces all vowels in \n   the message with the letter that appears look 2 places space ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way room that it swaps case font of all letters letter, replaces all vowels in \n   the message with the letter that appears look 2 places space ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const messageLength = message.length;\n  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const vowels = 'AEIOU';\n  const consonants = 'BCDFGHJKLMNPQRSTVWXYZ';\n  const consonantsLength = consonants.length;\n  const vowelsLength = vowels.length;\n  const consonantsIndex = consonants.indexOf(message[0]);\n  const consonantsIndex2 = consonants.indexOf(message[1]);\n  const consonantsIndex3 = consonants.indexOf(message[2]);\n  const consonantsIndex4 = consonants.indexOf(message[3]);\n  const consonantsIndex5 = consonants.indexOf(message[4]);\n  const consonantsIndex6 = consonants.indexOf(message[5]);\n  const consonantsIndex7 = consonants.indexOf(message[6]);\n  const consonantsIndex8 = consonants.indexOf(message[7]);\n  const consonantsIndex9 = consonants.indexOf(message[8]);\n  const consonantsIndex10 = consonants.indexOf(message[9]);\n  const consonantsIndex11 = consonants.indexOf(message[10]);\n  const consonantsIndex12 = consonants.indexOf(message[11]);\n  const consonantsIndex13 = consonants.indexOf(message[12]);\n  const consonantsIndex14 = consonants.indexOf(message[13]);\n  const consonantsIndex15 = consonants.indexOf(message[14]);\n  const consonantsIndex16 = consonants.indexOf(message[15]);\n  const consonantsIndex17 = consonants.indexOf(message[16]);\n  const consonantsIndex18 = consonants.indexOf(message[17]);\n  const consonantsIndex19 = consonants.indexOf(message[18]);\n  const consonantsIndex20 = consonants.indexOf(message[19]);\n  const consonantsIndex21 = consonants.indexOf(message[20]);\n  const consonantsIndex22 = consonants.indexOf(message[21]);\n  const consonantsIndex23 = consonants.indexOf(message[22]);\n  const consonantsIndex24 = consonants.indexOf(message[23]);\n  const consonantsIndex25 = consonants.indexOf(message[24]);\n  const consonantsIndex26 = consonants.indexOf(message[25]);\n  const consonantsIndex27 = consonants.indexOf(message[26]);\n  const consonantsIndex28 = consonants.indexOf(message[27]);\n  const consonantsIndex29 = consonants.indexOf(message[28]);\n  const consonantsIndex30 = consonants.indexOf(message[29]);\n  const consonantsIndex31 = consonants.indexOf(message[30]);\n  const consonantsIndex32 = consonants.indexOf(message[31]);\n  const consonantsIndex33 = consonants.indexOf(message[32]);\n  const consonantsIndex34 = consonants.indexOf(message[33]);\n  const consonantsIndex35 = consonants.indexOf(message[34]);\n  const consonantsIndex36 = consonants.indexOf(message[35]);\n  const consonantsIndex37 = consonants.indexOf(message[36]);\n  const consonantsIndex38 = consonants.indexOf(message[37]);\n  const consonantsIndex39 = consonants.indexOf(message[38]);\n  const consonantsIndex40 = consonants.indexOf(message[39]);\n  const consonantsIndex41 = consonants.indexOf(message[40]);\n  const consonantsIndex42 = consonants.indexOf(message[41]);\n  const consonantsIndex43 = consonants.indexOf(message[42]);\n  const consonantsIndex44 = consonants.indexOf(message[43]);\n  const consonantsIndex45 = consonants.indexOf(message[44]);\n  const consonantsIndex46 = consonants.indexOf(message[45]);\n  const consonantsIndex47 = consonants.indexOf(message[46]);\n  const consonantsIndex48 = consonants.indexOf(message[47]);\n  const consonantsIndex49 = consonants.indexOf(message[48]);\n  const consonantsIndex50 = consonants.indexOf(message[49]);\n  const consonantsIndex51 = consonants.indexOf(message[50]);\n  const consonantsIndex52 = consonants.indexOf(message[51]);\n  const consonantsIndex53 = consonants.indexOf(message[52]);\n  const consonantsIndex54 = consonants.indexOf(message[53]);\n  const consonantsIndex55 = consonants.indexOf(message[54]);\n  const consonantsIndex56 = consonants.indexOf(message[55]);\n  const consonantsIndex57 = consonants.indexOf(message[56]);\n  const consonantsIndex58 = consonants.indexOf(message[57]);\n  const consonantsIndex59 = consonants.indexOf(message[58]);\n  const consonantsIndex60 = consonants.indexOf(message[59]);\n  const consonantsIndex61 = consonants.indexOf(message[60]);\n  const consonantsIndex62 = consonants.indexOf(message[61]);\n  const consonantsIndex63 = consonants.indexOf(message[62]);\n  const consonantsIndex64 = consonants.indexOf(message[63]);\n  const consonantsIndex65 = consonants.indexOf(message[64]);\n  const consonantsIndex66 = consonants.indexOf(message[65]);\n  const consonantsIndex67 = consonants.indexOf(message[66]);\n  const consonantsIndex68 = consonants.indexOf(message[67]);\n  const consonantsIndex69 = consonants.indexOf(message[68]);\n  const consonantsIndex70 = consonants.indexOf(message[69]);\n  const consonantsIndex71 = consonants.indexOf(message[70]);\n  const consonantsIndex72 = consonants.indexOf(message[71]);\n  const consonantsIndex73 = consonants.indexOf(message[72]);\n  const consonantsIndex", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 3, "perturbed": true, "gc": "/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let prime = isPrime(lst[i]);\n    if (prime) {\n      sum += lst[i];\n      if (lst[i] > max) {\n        max = lst[i];\n      }\n    }\n  }\n  return sum;\n};\n\nconst isPrime = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconsole.log(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]));\nconsole.log(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]));\nconsole.log(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]));\nconsole.log(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]));\nconsole.log(skjkasdkd([0,81,12,3,1,21]));\nconsole.log(skjkasdkd([0,8,1,2,1,7]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n    if (keys[i].toLowerCase()!== keys[i]) return false\n  }\n  return true\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n  }\n  return true\n}\n\nconst checkDictArray = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n  }\n  return true\n}\n\nconst checkDictArrayCase = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n    if (keys[i].toLowerCase()!== keys[i]) return false\n  }\n  return true\n}\n\nconst checkDictArrayArray = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n  }\n  return true\n}\n\nconst checkDictArrayArrayCase = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n    if (keys[i].toLowerCase()!== keys[i]) return false\n  }\n  return true\n}\n\nconst checkDictArrayArrayArray = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n  }\n  return true\n}\n\nconst checkDictArrayArrayArrayCase = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n    if (keys[i].toLowerCase()!== keys[i]) return false\n  }\n  return true\n}\n\nconst checkDictArrayArrayArrayArray = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n  }\n  return true\n}\n\nconst checkDictArrayArrayArrayArrayCase = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n    if (keys[i].toLowerCase()!== keys[i]) return false\n  }\n  return true\n}\n\nconst checkDictArrayArrayArrayArrayArray = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n  }\n  return true\n}\n\nconst checkDictArrayArrayArrayArrayArrayCase = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n    if (keys[i].toLowerCase()!== keys[i]) return false\n  }\n  return true\n}\n\nconst checkDictArrayArrayArrayArrayArrayArray = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n  }\n  return true\n}\n\nconst checkDictArrayArrayArrayArrayArrayArrayCase = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!== \"string\") return false\n    if (keys[i].toLowerCase()!== keys[i]) return false\n  }\n  return true\n}\n\nconst checkDictArrayArrayArrayArrayArrayArrayArray = (dict) => {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 3, "perturbed": true, "gc": "/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  const result = []\n  for (let i = 0; i < n; i++) {\n    let index = 0\n    while (primes[index] <= i) {\n      index++\n    }\n    result.push(primes[index])\n  }\n  return result\n}\n\nconsole.log(countUpTo(5))\nconsole.log(countUpTo(11))\nconsole.log(countUpTo(0))\nconsole.log(countUpTo(20))\nconsole.log(countUpTo(1))\nconsole.log(countUpTo(18))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 3, "perturbed": true, "gc": "/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_digits = a.toString().split('').reverse().join('');\n  let b_digits = b.toString().split('').reverse().join('');\n  let product = 0;\n  for (let i = 0; i < a_digits.length; i++) {\n    product += parseInt(a_digits[i] * b_digits[i]);\n  }\n  return product;\n};\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console.log(multiply(19, 28));\n// console.log(multiply(2020, 1851));\n// console.log(multiply(14, -15));\n\n// console.log(multiply(148, 412));\n// console", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count consider the number of lowercase vowels vowel in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count consider the number of consonants in even indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 1\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 0\n  */\nconst countConsonants = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toLowerCase()!== s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count consider the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase()!== s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count consider the number of consonants and vowels in even indices.\n  \n  For example:\n  countConsonantsVowels('aBCdEf') returns 1\n  countConsonantsVowels('abcdefg') returns 0\n  countConsonantsVowels('dBBE') returns 0\n  */\nconst countConsonantsVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toLowerCase()!== s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count consider the number of consonants, vowels, and consonants in even indices.\n  \n  For example:\n  countConsonantsVowels('aBCdEf') returns 1\n  countConsonantsVowels('abcdefg') returns 0\n  countConsonantsVowels('dBBE') returns 0\n  */\nconst countConsonantsVowelsConsonants = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toLowerCase()!== s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count consider the number of consonants, vowels, consonants, and vowels in even indices.\n  \n  For example:\n  countConsonantsVowelsConsonants('aBCdEf') returns 1\n  countConsonantsVowelsConsonants('abcdefg') returns 0\n  countConsonantsVowelsConsonants('dBBE') returns 0\n  */\nconst countConsonantsVowelsConsonantsVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toLowerCase()!== s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count consider the number of consonants, vowels, consonants, vowels, and consonants in even indices.\n  \n  For example:\n  countConsonantsVowelsConsonantsVowels('aBCdEf') returns 1\n  countConsonantsVowelsConsonantsVowels('abcdefg') returns 0\n  countConsonantsVowelsConsonantsVowels('dBBE') returns 0\n  */\nconst countConsonantsVowelsConsonantsVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toLowerCase()!== s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count consider the number of consonants, vowels, consonants, vowels, consonants, and vowels in even indices.\n  \n  For example:\n  countConsonantsVowelsConsonantsVowels('aBCdEf') returns 1\n  countConsonantsVowelsConsonantsVowels('abcdefg') returns 0\n  countConsonantsVowelsConsonantsVowels('dBBE') returns 0\n  */\nconst countConsonantsVowelsConsonantsVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toLowerCase()!== s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 3, "perturbed": true, "gc": "/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const numeral = parseInt(value);\n  const closest = Math.abs(numeral) + 1;\n  const rounded = closest.toString().substr(0, closest.toString().length - 1);\n  return rounded;\n};\n\n/* Create a function that takes a value (string chain) representing a number numeral \n   and returns the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger2 = (value) => {\n  const numeral = parseInt(value);\n  const closest = Math.abs(numeral) + 1;\n  const rounded = closest.toString();\n  return rounded;\n};\n\n/* Create a function that takes a value (string chain) representing a number numeral \n   and returns the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger3 = (value) => {\n  const numeral = parseInt(value);\n  const closest = Math.abs(numeral) + 1;\n  const rounded = closest.toString();\n  return rounded;\n};\n\n/* Create a function that takes a value (string chain) representing a number numeral \n   and returns the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger4 = (value) => {\n  const numeral = parseInt(value);\n  const closest = Math.abs(numeral) + 1;\n  const rounded = closest.toString();\n  return rounded;\n};\n\n/* Create a function that takes a value (string chain) representing a number numeral \n   and returns the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger5 = (value) => {\n  const numeral = parseInt(value);\n  const closest = Math.abs(numeral) + 1;\n  const rounded = closest.toString();\n  return rounded;\n};\n\n/* Create a function that takes a value (string chain) representing a number numeral \n   and returns the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger6 = (value) => {\n  const numeral = parseInt(value);\n  const closest = Math.abs(numeral) + 1;\n  const rounded = closest.toString();\n  return rounded;\n};\n\n/* Create a function that takes a value (string chain) representing a number numeral \n   and returns the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger7 = (value) => {\n  const numeral = parseInt(value);\n  const closest = Math.abs(numeral) + 1;\n  const rounded = closest.toString();\n  return rounded;\n};\n\n/* Create a function that takes a value (string chain) representing a number numeral \n   and returns the closest integer to it. If the number is equidistant \n   from two integers integer,", "passed": 0, "run_status": 1}
