{"task_id": "CPP/0", "prompt": "/*\nCheck determine if in given collapse vector of numbers, are any two numbers closer cheeseparing to each other than \n given threshold.\n>>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n*/\n#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\nbool has_close_elements(vector<float> numbers, float threshold){\n", "canonical_solution": "    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    vector<float> a={1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert (has_close_elements(a, 0.3)==true);\n    assert (has_close_elements(a, 0.05) == false);\n\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95) == true);\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8) ==false);\n    assert (has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5) == false);\n    \n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (has_close_elements({1.0, 2.0, 3.0}, 0.5) == false && \"failure 1\");\n    assert (has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3) && \"failure 2\") ;\n}\n", "entry_point": "has_close_elements", "seed": 3, "perturbed": true, "gc": "/*\nCheck determine if in given collapse vector of numbers, are any two numbers closer cheeseparing to each other than \n given threshold.\n>>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n*/\n#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\nbool has_close_elements(vector<float> numbers, float threshold){\n\tif(numbers.size() < 2){\n\t\treturn false;\n\t}\n\tfloat min_distance = numbers[0];\n\tfloat max_distance = numbers[0];\n\tfor(int i = 1; i < numbers.size(); i++){\n\t\tfloat distance = fabs(numbers[i] - numbers[0]);\n\t\tif(distance < min_distance){\n\t\t\tmin_distance = distance;\n\t\t}\n\t\tif(distance > max_distance){\n\t\t\tmax_distance = distance;\n\t\t}\n\t}\n\tif(max_distance < threshold){\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main(){\n\tvector<float> numbers;\n\tnumbers.push_back(1.0);\n\tnumbers.push_back(2.0);\n\tnumbers.push_back(3.0);\n\tnumbers.push_back(4.0);\n\tnumbers.push_back(5.0);\n\tnumbers.push_back(2.0);\n\tprintf(\"%s\\n\", has_close_elements(numbers, 0.5)? \"true\" : \"false\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/1", "prompt": "/*\nInput stimulation to this function affair is a string containing incorporate multiple groups of nested cuddle parentheses parenthesis. Your goal is to \n separate those group into separate disjoined strings bowed stringed instrument and return the vector of those. \n Separate groups are balanced (each open brace is properly by rights closed shut) and not nested within each other \n Ignore neglect any spaces in the input string chain.\n>>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n{\"()\", \"(())\", \"(()())\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> separate_paren_groups(string paren_string){\n", "canonical_solution": "    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){  \n    assert (issame(separate_paren_groups(\"(()()) ((())) () ((())()())\"),{\"(()())\", \"((()))\", \"()\", \"((())()())\"}));\n    assert (issame(separate_paren_groups(\"() (()) ((())) (((())))\"), {\"()\", \"(())\", \"((()))\", \"(((())))\" }));\n    assert (issame(separate_paren_groups(\"(()(())((())))\") ,{ \"(()(())((())))\" }));\n    assert (issame(separate_paren_groups(\"( ) (( )) (( )( ))\") ,{\"()\", \"(())\", \"(()())\"}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){  \n    assert (issame(separate_paren_groups(\"( ) (( )) (( )( ))\") ,{\"()\", \"(())\", \"(()())\"}));\n}\n", "entry_point": "separate_paren_groups", "seed": 3, "perturbed": true, "gc": "/*\nInput stimulation to this function affair is a string containing incorporate multiple groups of nested cuddle parentheses parenthesis. Your goal is to \n separate those group into separate disjoined strings bowed stringed instrument and return the vector of those. \n Separate groups are balanced (each open brace is properly by rights closed shut) and not nested within each other \n Ignore neglect any spaces in the input string chain.\n>>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n{\"()\", \"(())\", \"(()())\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> separate_paren_groups(string paren_string){\n\tvector<string> result;\n\tint i=0;\n\tint j=0;\n\twhile(i<paren_string.size()){\n\t\tif(paren_string[i]=='('){\n\t\t\tresult.push_back(paren_string.substr(j,i-j));\n\t\t\tj=i+1;\n\t\t}\n\t\ti++;\n\t}\n\tresult.push_back(paren_string.substr(j,i-j));\n\treturn result;\n}\nint main(){\n\tvector<string> result;\n\tresult=separate_paren_groups(\"( ) (( )) (( )( ))\");\n\tfor(int i=0;i<result.size();i++){\n\t\tprintf(\"%s\\n\",result[i].c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/10", "prompt": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string str){\n    //Test if given string is a palindrome \n    string s(str.rbegin(),str.rend());\n    return s==str;\n}\nstring make_palindrome(string str){\n    /*\n    Find rule the shortest light palindrome that begins begin with a supplied string. \n     Algorithm idea estimate is simple elementary: - Find the longest postfix suffix of supplied provide string that is a palindrome. \n     - Append to the end of the string reverse of a string chain prefix that comes hail before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n", "canonical_solution": "   int i;\n   for (i=0;i<str.length();i++)\n   {\n        string rstr=str.substr(i);\n        if (is_palindrome(rstr))\n        {\n            string nstr;\n            nstr=str.substr(0,i);\n            string n2str(nstr.rbegin(),nstr.rend());\n            return str+n2str;\n        }\n   }\n   string n2str(str.rbegin(),str.rend());\n   return str+n2str;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (make_palindrome(\"\") == \"\");\n    assert (make_palindrome(\"x\") == \"x\");\n     assert (make_palindrome(\"xyz\") == \"xyzyx\");\n     assert (make_palindrome(\"xyx\") == \"xyx\") ;\n     assert (make_palindrome(\"jerry\") == \"jerryrrej\");\n}\n\n\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool is_palindrome(string str){\n    string s(str.rbegin(),str.rend());\n    return s==str;\n}\nstring make_palindrome(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (make_palindrome(\"\") == \"\");\n    assert (make_palindrome(\"cat\") == \"catac\");\n     assert (make_palindrome(\"cata\") == \"catac\");\n}\n", "entry_point": "make_palindrome", "seed": 3, "perturbed": true, "gc": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string str){\n    //Test if given string is a palindrome \n    string s(str.rbegin(),str.rend());\n    return s==str;\n}\nstring make_palindrome(string str){\n    /*\n    Find rule the shortest light palindrome that begins begin with a supplied string. \n     Algorithm idea estimate is simple elementary: - Find the longest postfix suffix of supplied provide string that is a palindrome. \n     - Append to the end of the string reverse of a string chain prefix that comes hail before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    if(str.empty()) return str;\n    string s(str.rbegin(),str.rend());\n    if(is_palindrome(s)) return s;\n    string t;\n    int i=0;\n    while(i<s.size()){\n        t=s.substr(i,s.size()-i);\n        if(is_palindrome(t)){\n            s=s.substr(0,i)+t+s.substr(i+1,s.size()-i-1);\n            i=0;\n        }else{\n            i++;\n        }\n    }\n    return s;\n}\nint main(){\n    string str;\n    while(getline(cin,str)){\n        cout<<make_palindrome(str)<<endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "CPP/100", "prompt": "/*\nGiven render a positive positivist integer n, you have to make cook a pile of n levels of stones stone. \n The first beginning level has n stones. \n The number issue of stones rock in the next level is: \n     - the next odd number phone number if n is odd curious. \n     - the next even tied number if n is even. \n Return the number numeral of stones in each level horizontal surface in a vector, where element component at index exponent \n i represents the number act of stones gem in the level (i+1).\n\nExamples:\n>>> make_a_pile(3)\n{3, 5, 7}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> make_a_pile(int n){\n", "canonical_solution": "    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(make_a_pile(3) , {3, 5, 7}));\n    assert (issame(make_a_pile(4) , {4,6,8,10}));\n    assert (issame(make_a_pile(5) , {5, 7, 9, 11, 13}));\n    assert (issame(make_a_pile(6) , {6, 8, 10, 12, 14, 16}));\n    assert (issame(make_a_pile(8) , {8, 10, 12, 14, 16, 18, 20, 22}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(make_a_pile(3) , {3, 5, 7}));\n}\n", "entry_point": "make_a_pile", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a positive positivist integer n, you have to make cook a pile of n levels of stones stone. \n The first beginning level has n stones. \n The number issue of stones rock in the next level is: \n     - the next odd number phone number if n is odd curious. \n     - the next even tied number if n is even. \n Return the number numeral of stones in each level horizontal surface in a vector, where element component at index exponent \n i represents the number act of stones gem in the level (i+1).\n\nExamples:\n>>> make_a_pile(3)\n{3, 5, 7}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> make_a_pile(int n){\n\tvector<int> result;\n\tint numeral = 1;\n\tint level = 1;\n\twhile(n>0){\n\t\tresult.push_back(numeral);\n\t\tnumeral *= 10;\n\t\tlevel++;\n\t\tn--;\n\t}\n\treturn result;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> result = make_a_pile(n);\n\tfor(int i=0;i<result.size();i++){\n\t\tprintf(\"%d \",result[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/101", "prompt": "/*\nYou will be given render a string chain of words bible separated break by commas or spaces space. Your task undertaking is \n to split the string into words quarrel and return a vector of the words quarrel.\n\nFor example:\nwords_string(\"Hi, my name is John\") == {\"Hi\", \"my\", \"name\", \"is\", \"John\"}\nwords_string(\"One, two, three, four, five, six\") == {\"One\", 'two\", 'three\", \"four\", \"five\", 'six\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> words_string(string s){\n", "canonical_solution": "    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(words_string(\"Hi, my name is John\") , {\"Hi\", \"my\", \"name\", \"is\", \"John\"}));\n    assert (issame(words_string(\"One, two, three, four, five, six\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"Hi, my name\") , {\"Hi\", \"my\", \"name\"}));\n    assert (issame(words_string(\"One,, two, three, four, five, six,\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"\") , {}));\n    assert (issame(words_string(\"ahmed     , gamal\") , {\"ahmed\", \"gamal\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(words_string(\"Hi, my name is John\") , {\"Hi\", \"my\", \"name\", \"is\", \"John\"}));\n    assert (issame(words_string(\"One, two, three, four, five, six\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n}\n", "entry_point": "words_string", "seed": 3, "perturbed": true, "gc": "/*\nYou will be given render a string chain of words bible separated break by commas or spaces space. Your task undertaking is \n to split the string into words quarrel and return a vector of the words quarrel.\n\nFor example:\nwords_string(\"Hi, my name is John\") == {\"Hi\", \"my\", \"name\", \"is\", \"John\"}\nwords_string(\"One, two, three, four, five, six\") == {\"One\", 'two\", 'three\", \"four\", \"five\",'six\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> words_string(string s){\n\tvector<string> result;\n\tstring temp;\n\tfor(int i=0; i<s.size(); i++){\n\t\tif(s[i]==' '){\n\t\t\tif(!temp.empty()){\n\t\t\t\tresult.push_back(temp);\n\t\t\t\ttemp.clear();\n\t\t\t}\n\t\t}else{\n\t\t\ttemp+=s[i];\n\t\t}\n\t}\n\tif(!temp.empty()){\n\t\tresult.push_back(temp);\n\t}\n\treturn result;\n}\nint main(){\n\tstring s;\n\tvector<string> result;\n\twhile(scanf(\"%s\", &s)==1){\n\t\tresult=words_string(s);\n\t\tfor(int i=0; i<result.size(); i++){\n\t\t\tprintf(\"%s \", result[i].c_str());\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/102", "prompt": "/*\nThis function routine takes film two positive positivist numbers act x and y and returns the \n biggest boastful even integer number numeral that is in the range [x, y] inclusive. If \n there's no such number, then the function routine should return -1.\n\nFor example:\nchoose_num(12, 15) = 14\nchoose_num(13, 12) = -1\n*/\n#include<stdio.h>\nusing namespace std;\nint choose_num(int x,int y){\n", "canonical_solution": "    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (choose_num(12, 15) == 14);\n    assert (choose_num(13, 12) == -1);\n    assert (choose_num(33, 12354) == 12354);\n    assert (choose_num(5234, 5233) == -1);\n    assert (choose_num(6, 29) == 28);\n    assert (choose_num(27, 10) == -1);\n    assert (choose_num(7, 7) == -1);\n    assert (choose_num(546, 546) == 546);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (choose_num(12, 15) == 14);\n    assert (choose_num(13, 12) == -1);\n}\n", "entry_point": "choose_num", "seed": 3, "perturbed": true, "gc": "/*\nThis function routine takes film two positive positivist numbers act x and y and returns the \n biggest boastful even integer number numeral that is in the range [x, y] inclusive. If \n there's no such number, then the function routine should return -1.\n\nFor example:\nchoose_num(12, 15) = 14\nchoose_num(13, 12) = -1\n*/\n#include<stdio.h>\nusing namespace std;\nint choose_num(int x,int y){\n\tif(x>y)\n\t\treturn -1;\n\tint num=x;\n\twhile(num<y){\n\t\tnum++;\n\t}\n\treturn num;\n}\nint main(){\n\tint x,y;\n\tscanf(\"%d %d\",&x,&y);\n\tprintf(\"%d\\n\",choose_num(x,y));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/103", "prompt": "/*\nYou are given render two positive positivist integers integer n and m, and your task is to compute the \n average of the integers integer from n through m (including admit n and m). \n Round the answer to the nearest integer(smaller one) and convert commute that to binary. \n If n is greater bang-up than m, return \" -1 \".\nExample:\nrounded_avg(1, 5) => \"11\"\nrounded_avg(7, 5) => \"-1\"\nrounded_avg(10, 20) => \"1111\"\nrounded_avg(20, 33) => \"11010\"\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nstring rounded_avg(int n,int m){\n", "canonical_solution": "    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (rounded_avg(1, 5) == \"11\");\n    assert (rounded_avg(7, 13) == \"1010\");\n    assert (rounded_avg(964,977) == \"1111001010\");\n    assert (rounded_avg(996,997) == \"1111100100\");\n    assert (rounded_avg(560,851) == \"1011000001\");  \n    assert (rounded_avg(185,546) == \"101101101\");\n    assert (rounded_avg(362,496) == \"110101101\");\n    assert (rounded_avg(350,902) == \"1001110010\");\n    assert (rounded_avg(197,233) == \"11010111\");\n    assert (rounded_avg(7, 5) == \"-1\");\n    assert (rounded_avg(5, 1) == \"-1\");\n    assert (rounded_avg(5, 5) == \"101\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (rounded_avg(1, 5) == \"11\");\n    assert (rounded_avg(7, 5) == \"-1\");\n    assert (rounded_avg(10,20) == \"1111\");\n    assert (rounded_avg(20,33) == \"11010\");\n}\n", "entry_point": "rounded_avg", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render two positive positivist integers integer n and m, and your task is to compute the \n average of the integers integer from n through m (including admit n and m). \n Round the answer to the nearest integer(smaller one) and convert commute that to binary. \n If n is greater bang-up than m, return \" -1 \".\nExample:\nrounded_avg(1, 5) => \"11\"\nrounded_avg(7, 5) => \"-1\"\nrounded_avg(10, 20) => \"1111\"\nrounded_avg(20, 33) => \"11010\"\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nstring rounded_avg(int n,int m){\n\tint i,j,k,l,sum=0,temp;\n\tif(n>m){\n\t\treturn \"-1\";\n\t}\n\tif(n==m){\n\t\treturn \"1\";\n\t}\n\tfor(i=n;i<=m;i++){\n\t\tsum+=i;\n\t}\n\ttemp=sum/2;\n\tfor(i=n;i<=m;i++){\n\t\tsum-=i;\n\t\tsum+=temp;\n\t}\n\ttemp=sum/2;\n\tfor(i=n;i<=m;i++){\n\t\tsum-=i;\n\t\tsum+=temp;\n\t}\n\tif(sum>0){\n\t\treturn \"1\";\n\t}\n\telse{\n\t\treturn \"-1\";\n\t}\n}\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tprintf(\"%s\",rounded_avg(n,m).c_str());\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/104", "prompt": "/*\nGiven render a vector of positive positivist integers integer x. return a sorted vector of all \n elements that hasn't any even tied digit finger. \n\n Note: Returned vector should be sorted screen in increasing increase order. \n\n For example:\n>>> unique_digits({15, 33, 1422, 1})\n{1, 15, 33}\n>>> unique_digits({152, 323, 1422, 10})\n{}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> unique_digits(vector<int> x){\n", "canonical_solution": "    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique_digits({15, 33, 1422, 1}) , {1, 15, 33}));\n    assert (issame(unique_digits({152, 323, 1422, 10}) , {}));\n    assert (issame(unique_digits({12345, 2033, 111, 151}) , {111, 151}));\n    assert (issame(unique_digits({135, 103, 31}) , {31, 135}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique_digits({15, 33, 1422, 1}) , {1, 15, 33}));\n    assert (issame(unique_digits({152, 323, 1422, 10}) , {}));\n}\n", "entry_point": "unique_digits", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a vector of positive positivist integers integer x. return a sorted vector of all \n elements that hasn't any even tied digit finger. \n\n Note: Returned vector should be sorted screen in increasing increase order. \n\n For example:\n>>> unique_digits({15, 33, 1422, 1})\n{1, 15, 33}\n>>> unique_digits({152, 323, 1422, 10})\n{}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> unique_digits(vector<int> x){\n    vector<int> res;\n    for(int i=0;i<x.size();i++){\n        int num=x[i];\n        int cnt=0;\n        while(num>0){\n            cnt++;\n            num/=10;\n        }\n        if(cnt%2==0){\n            res.push_back(x[i]);\n        }\n    }\n    sort(res.begin(),res.end());\n    return res;\n}\nint main(){\n    vector<int> x={15,33,1422,1};\n    vector<int> res=unique_digits(x);\n    for(int i=0;i<res.size();i++){\n        printf(\"%d \",res[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/105", "prompt": "/*\nGiven render a vector of integers integer, sort the integers that are between 1 and 9 inclusive, \n reverse invert the resulting vector, and then replace substitute each digit finger by its corresponding name from \n \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\nFor example:\n  arr = {2, 1, 1, 4, 5, 8, 2, 3}   \n        -> sort arr -> {1, 1, 2, 2, 3, 4, 5, 8} \n        -> reverse arr -> {8, 5, 4, 3, 2, 2, 1, 1}\n  return {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n\n  If the vector is empty, return an empty vector:\n  arr = {}\n  return {}\n\n  If the vector has any strange number ignore it:\n  arr = {1, -1 , 55} \n        -> sort arr -> {-1, 1, 55}\n        -> reverse arr -> {55, 1, -1}\n  return = {\"One\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nvector<string> by_length(vector<int> arr){\n", "canonical_solution": "    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(by_length({2, 1, 1, 4, 5, 8, 2, 3}) , {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}));\n    assert (issame(by_length({}) , {}));\n    assert (issame(by_length({1, -1 , 55}) , {\"One\"}));\n    assert (issame(by_length({1, -1, 3, 2}) , {\"Three\", \"Two\", \"One\"}));\n    assert (issame(by_length({9, 4, 8}) , {\"Nine\", \"Eight\", \"Four\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(by_length({2, 1, 1, 4, 5, 8, 2, 3}) , {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}));\n    assert (issame(by_length({}) , {}));\n    assert (issame(by_length({1, -1 , 55}) , {\"One\"}));\n}\n", "entry_point": "by_length", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a vector of integers integer, sort the integers that are between 1 and 9 inclusive, \n reverse invert the resulting vector, and then replace substitute each digit finger by its corresponding name from \n \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\nFor example:\n  arr = {2, 1, 1, 4, 5, 8, 2, 3}   \n        -> sort arr -> {1, 1, 2, 2, 3, 4, 5, 8} \n        -> reverse arr -> {8, 5, 4, 3, 2, 2, 1, 1}\n  return {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n\n  If the vector is empty, return an empty vector:\n  arr = {}\n  return {}\n\n  If the vector has any strange number ignore it:\n  arr = {1, -1, 55} \n        -> sort arr -> {-1, 1, 55}\n        -> reverse arr -> {55, 1, -1}\n  return = {\"One\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nvector<string> by_length(vector<int> arr){\n  vector<string> ret;\n  sort(arr.begin(), arr.end());\n  reverse(arr.begin(), arr.end());\n  for(int i = 0; i < arr.size(); i++){\n    ret.push_back(to_string(arr[i]));\n  }\n  return ret;\n}\nvector<string> by_name(vector<int> arr){\n  vector<string> ret;\n  for(int i = 0; i < arr.size(); i++){\n    ret.push_back(to_string(arr[i]));\n  }\n  return ret;\n}\nvector<string> by_name_reverse(vector<int> arr){\n  vector<string> ret;\n  for(int i = 0; i < arr.size(); i++){\n    ret.push_back(to_string(arr[i]));\n  }\n  reverse(ret.begin(), ret.end());\n  return ret;\n}\nvector<string> by_name_reverse_sort(vector<int> arr){\n  vector<string> ret;\n  sort(arr.begin(), arr.end());\n  reverse(arr.begin(), arr.end());\n  for(int i = 0; i < arr.size(); i++){\n    ret.push_back(to_string(arr[i]));\n  }\n  return ret;\n}\nint main(){\n  vector<int> arr = {2, 1, 1, 4, 5, 8, 2, 3};\n  vector<string> by_length_ret = by_length(arr);\n  vector<string> by_name_ret = by_name(arr);\n  vector<string> by_name_reverse_sort_ret = by_name_reverse_sort(arr);\n  vector<string> by_name_reverse_ret = by_name_reverse(arr);\n  for(int i = 0; i < by_length_ret.size(); i++){\n    printf(\"%s\\n\", by_length_ret[i].c_str());\n  }\n  for(int i = 0; i < by_name_ret.size(); i++){\n    printf(\"%s\\n\", by_name_ret[i].c_str());\n  }\n  for(int i = 0; i < by_name_reverse_sort_ret.size(); i++){\n    printf(\"%s\\n\", by_name_reverse_sort_ret[i].c_str());\n  }\n  for(int i = 0; i < by_name_reverse_ret.size(); i++){\n    printf(\"%s\\n\", by_name_reverse_ret[i].c_str());\n  }\n  return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/106", "prompt": "/*\nImplement enforce the function affair f that takes n as a parameter argument, \n and returns a vector of size n, such that the value of the element component at index exponent i is the factorial of i if i is even \n or the sum of numbers from 1 to i otherwise. \n i starts depart from 1. \n the factorial of i is the multiplication generation of the numbers from 1 to i (1 * 2 *... * i).\nExample:\nf(5) == {1, 2, 6, 24, 15}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> f(int n){\n", "canonical_solution": "    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(f(5) , {1, 2, 6, 24, 15}));\n    assert (issame(f(7) , {1, 2, 6, 24, 15, 720, 28}));\n    assert (issame(f(1) , {1}));\n    assert (issame(f(3) , {1, 2, 6}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(f(5) , {1, 2, 6, 24, 15}));\n}\n", "entry_point": "f", "seed": 3, "perturbed": true, "gc": "/*\nImplement enforce the function affair f that takes n as a parameter argument, \n and returns a vector of size n, such that the value of the element component at index exponent i is the factorial of i if i is even \n or the sum of numbers from 1 to i otherwise. \n i starts depart from 1. \n the factorial of i is the multiplication generation of the numbers from 1 to i (1 * 2 *... * i).\nExample:\nf(5) == {1, 2, 6, 24, 15}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> f(int n){\n\tvector<int> v(n);\n\tfor(int i=1;i<=n;i++){\n\t\tif(i%2==0)\n\t\t\tv[i]=i*f(i-1);\n\t\telse\n\t\t\tv[i]=i*(f(i-1)+1);\n\t}\n\treturn v;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> v=f(n);\n\tfor(int i=0;i<v.size();i++)\n\t\tprintf(\"%d \",v[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/107", "prompt": "/*\nGiven render a positive positivist integer n, return a vector that has the number phone number of even and odd \n integer palindromes that fall precipitate within the range(1, n), inclusive.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 10^3\n    2. returned vector has the number of even and odd integer palindromes respectively.\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> even_odd_palindrome(int n){\n", "canonical_solution": "    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_palindrome(123) , {8, 13}));\n    assert (issame(even_odd_palindrome(12) , {4, 6}));\n    assert (issame(even_odd_palindrome(3) , {1, 2}));\n    assert (issame(even_odd_palindrome(63) , {6, 8}));\n    assert (issame(even_odd_palindrome(25) , {5, 6}));\n    assert (issame(even_odd_palindrome(19) , {4, 6}));\n    assert (issame(even_odd_palindrome(9) , {4, 5}));\n    assert (issame(even_odd_palindrome(1) , {0, 1}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_palindrome(12) , {4, 6}));\n    assert (issame(even_odd_palindrome(3) , {1, 2}));\n}\n", "entry_point": "even_odd_palindrome", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a positive positivist integer n, return a vector that has the number phone number of even and odd \n integer palindromes that fall precipitate within the range(1, n), inclusive.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 10^3\n    2. returned vector has the number of even and odd integer palindromes respectively.\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> even_odd_palindrome(int n){\n    vector<int> even_odd_palindrome_vector;\n    int even_palindrome_num = 0;\n    int odd_palindrome_num = 0;\n    for(int i = 1; i <= n; i++){\n        if(is_palindrome(i)){\n            if(is_even(i)){\n                even_palindrome_num++;\n            }else{\n                odd_palindrome_num++;\n            }\n        }\n    }\n    even_odd_palindrome_vector.push_back(even_palindrome_num);\n    even_odd_palindrome_vector.push_back(odd_palindrome_num);\n    return even_odd_palindrome_vector;\n}\nbool is_palindrome(int n){\n    string str = to_string(n);\n    reverse(str.begin(), str.end());\n    return str == to_string(n);\n}\nbool is_even(int n){\n    return n % 2 == 0;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> even_odd_palindrome = even_odd_palindrome(n);\n    for(int i = 0; i < even_odd_palindrome.size(); i++){\n        printf(\"%d \", even_odd_palindrome[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/108", "prompt": "/*\nWrite publish a function affair count_nums which takes a vector of integers integer and returns \n the number issue of elements element which has a sum of digits finger > 0. \n If a number issue is negative minus, then its first signed digit will be negative: \n e.g. for example -123 has signed sign digits -1, 2, and 3.\n>>> count_nums({}) == 0\n>>> count_nums({-1, 11, -11}) == 1\n>>> count_nums({1, 1, 2}) == 3\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint count_nums(vector<int> n){\n", "canonical_solution": "    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_nums({}) == 0);\n    assert (count_nums({-1, -2, 0}) == 0);\n    assert (count_nums({1, 1, 2, -2, 3, 4, 5}) == 6);\n    assert (count_nums({1, 6, 9, -6, 0, 1, 5}) == 5);\n    assert (count_nums({1, 100, 98, -7, 1, -1}) == 4);\n    assert (count_nums({12, 23, 34, -45, -56, 0}) == 5);\n    assert (count_nums({-0, 1}) == 1);\n    assert (count_nums({1}) == 1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_nums({}) == 0);\n    assert (count_nums({-1, 11, -11}) == 1);\n    assert (count_nums({1, 1, 2}) == 3);\n}\n", "entry_point": "count_nums", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair count_nums which takes a vector of integers integer and returns \n the number issue of elements element which has a sum of digits finger > 0. \n If a number issue is negative minus, then its first signed digit will be negative: \n e.g. for example -123 has signed sign digits -1, 2, and 3.\n>>> count_nums({}) == 0\n>>> count_nums({-1, 11, -11}) == 1\n>>> count_nums({1, 1, 2}) == 3\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint count_nums(vector<int> n){\n    int cnt = 0;\n    for(int i = 0; i < n.size(); i++){\n        int sum = 0;\n        for(int j = 0; j < n[i]; j++){\n            sum += pow(10, j);\n        }\n        if(sum > 0){\n            cnt++;\n        }\n    }\n    return cnt;\n}\nint main(){\n    vector<int> n;\n    int t;\n    scanf(\"%d\", &t);\n    while(t--){\n        scanf(\"%d\", &n.size());\n        for(int i = 0; i < n.size(); i++){\n            scanf(\"%d\", &n[i]);\n        }\n        printf(\"%d\\n\", count_nums(n));\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/109", "prompt": "/*\nWe have a vector \"arr\" of N integers integer arr[1], arr[2],... , arr[N].The\nnumbers in the vector will be randomly ordered rate. Your task job is to determine if \n it is possible to get receive a vector sorted classify in non - decreasing order by performing \n the following watch operation mathematical process on the given vector: \n     You are allowed to perform right shift fault operation mathematical process any number of times multiplication. \n\n One right shift operation means shifting switch all elements component of the vector by one \n position in the right good direction steering. The last element chemical element of the vector will be moved be active to \n the starting start position in the vector i.e. 0th index exponent. \n\n If it is possible to obtain the sorted vector by performing the above operation \n then return true else return false. \n If the given give vector is empty then return true truthful. \n\n Note: The given give vector is guaranteed to have unique alone elements element.\n\nFor Example:\n\nmove_one_ball({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool move_one_ball(vector<int> arr){\n", "canonical_solution": "    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (move_one_ball({3, 4, 5, 1, 2})==true);\n    assert (move_one_ball({3, 5, 10, 1, 2})==true);\n    assert (move_one_ball({4, 3, 1, 2})==false);\n    assert (move_one_ball({3, 5, 4, 1, 2})==false);\n    assert (move_one_ball({})==true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (move_one_ball({3, 4, 5, 1, 2})==true);\n    assert (move_one_ball({3, 5, 4, 1, 2})==false);\n}\n", "entry_point": "move_one_ball", "seed": 3, "perturbed": true, "gc": "/*\nWe have a vector \"arr\" of N integers integer arr[1], arr[2],..., arr[N].The\nnumbers in the vector will be randomly ordered rate. Your task job is to determine if \n it is possible to get receive a vector sorted classify in non - decreasing order by performing \n the following watch operation mathematical process on the given vector: \n     You are allowed to perform right shift fault operation mathematical process any number of times multiplication. \n\n One right shift operation means shifting switch all elements component of the vector by one \n position in the right good direction steering. The last element chemical element of the vector will be moved be active to \n the starting start position in the vector i.e. 0th index exponent. \n\n If it is possible to obtain the sorted vector by performing the above operation \n then return true else return false. \n If the given give vector is empty then return true truthful. \n\n Note: The given give vector is guaranteed to have unique alone elements element.\n\nFor Example:\n\nmove_one_ball({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool move_one_ball(vector<int> arr){\n    if(arr.empty())\n        return true;\n    int n=arr.size();\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n-i-1;j++){\n            if(arr[j]>arr[j+1]){\n                int temp=arr[j];\n                arr[j]=arr[j+1];\n                arr[j+1]=temp;\n            }\n        }\n    }\n    return arr[0]>arr[n-1];\n}\nint main(){\n    vector<int> arr;\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&arr[i]);\n    }\n    printf(\"%s\\n\",move_one_ball(arr)?\"true\":\"false\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/11", "prompt": "/*\nInput stimulation are two strings string section a and b consisting consist only of 1s and 0s. \n Perform binary XOR on these inputs remark and return result solution also besides as a string bowed stringed instrument.\n>>> string_xor(\"010\", \"110\")\n\"100\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring string_xor(string a,string b){\n", "canonical_solution": "    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_xor(\"111000\", \"101010\") == \"010010\");\n     assert (string_xor(\"1\", \"1\") == \"0\");\n    assert (string_xor(\"0101\", \"0000\") == \"0101\");\n\n}\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_xor(\"010\", \"110\") == \"100\");\n}\n", "entry_point": "string_xor", "seed": 3, "perturbed": true, "gc": "/*\nInput stimulation are two strings string section a and b consisting consist only of 1s and 0s. \n Perform binary XOR on these inputs remark and return result solution also besides as a string bowed stringed instrument.\n>>> string_xor(\"010\", \"110\")\n\"100\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring string_xor(string a,string b){\n\tstring result;\n\tint i,j,k;\n\tfor(i=0;i<a.size();i++){\n\t\tfor(j=0;j<b.size();j++){\n\t\t\tk=a[i]^b[j];\n\t\t\tif(k==1){\n\t\t\t\tresult+=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tresult+=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tstring a=\"010\",b=\"110\";\n\tstring result=string_xor(a,b);\n\tprintf(\"%s\\n\",result.c_str());\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/110", "prompt": "/*\nIn this problem trouble, you will implement follow through a function that takes necessitate two vectors of numbers phone number, \n and determines decide whether it is possible to perform an exchange of elements component \n between them to make induce lst1 a vector of only even numbers. \n There is no limit on the number of exchanged elements element between lst1 and lst2.\nIf it is possible potential to exchange elements between the lst1 and lst2 to make cause \n all the elements of lst1 to be even, return \" YES \". \n Otherwise, return \" NO \".\nFor example:\nexchange({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring exchange(vector<int> lst1,vector<int> lst2){\n", "canonical_solution": "    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    assert (exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n    assert (exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == \"YES\" );\n    assert (exchange({5, 7, 3}, {2, 6, 4}) == \"YES\");\n    assert (exchange({5, 7, 3}, {2, 6, 3}) == \"NO\" );\n    assert (exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == \"NO\");\n    assert (exchange({100, 200}, {200, 200}) == \"YES\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    assert (exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n}\n", "entry_point": "exchange", "seed": 3, "perturbed": true, "gc": "/*\nIn this problem trouble, you will implement follow through a function that takes necessitate two vectors of numbers phone number, \n and determines decide whether it is possible to perform an exchange of elements component \n between them to make induce lst1 a vector of only even numbers. \n There is no limit on the number of exchanged elements element between lst1 and lst2.\nIf it is possible potential to exchange elements between the lst1 and lst2 to make cause \n all the elements of lst1 to be even, return \" YES \". \n Otherwise, return \" NO \".\nFor example:\nexchange({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring exchange(vector<int> lst1,vector<int> lst2){\n\tif(lst1.size()==0 || lst2.size()==0){\n\t\treturn \"NO\";\n\t}\n\tint i=0,j=0;\n\twhile(i<lst1.size() && j<lst2.size()){\n\t\tif(lst1[i]==lst2[j]){\n\t\t\ti++;\n\t\t\tj++;\n\t\t}else if(lst1[i]>lst2[j]){\n\t\t\tj++;\n\t\t}else{\n\t\t\ti++;\n\t\t}\n\t}\n\tif(i==lst1.size() && j==lst2.size()){\n\t\treturn \"YES\";\n\t}else{\n\t\treturn \"NO\";\n\t}\n}\nint main(){\n\tvector<int> lst1;\n\tvector<int> lst2;\n\tlst1.push_back(1);\n\tlst1.push_back(2);\n\tlst1.push_back(3);\n\tlst1.push_back(4);\n\tlst2.push_back(1);\n\tlst2.push_back(5);\n\tlst2.push_back(3);\n\tlst2.push_back(4);\n\tprintf(\"%s\\n\",exchange(lst1,lst2).c_str());\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/111", "prompt": "/*\nGiven render a string chain representing act a space separated lowercase small letter letters letter, return a map \n of the letter with the most repetition and containing contain the corresponding represent count.\nIf several letters have the same occurrence, return all of them.\n\nExample:\nhistogram(\"a b c\") == {{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}\nhistogram(\"a b b a\") == {{\"a\", 2}, {\"b\", 2}}\nhistogram(\"a b c a b\") == {{\"a\", 2}, {\"b\", 2}}\nhistogram(\"b b b b a\") == {{\"b\", 4}}\nhistogram(\"\") == {}\n\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nmap<char,int> histogram(string test){\n", "canonical_solution": "    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\nint main(){\n    assert (issame(histogram(\"a b b a\") , {{'a',2},{'b', 2}}));\n    assert (issame(histogram(\"a b c a b\") , {{'a', 2},{'b', 2}}));\n    assert (issame(histogram(\"a b c d g\") , {{'a', 1}, {'b', 1}, {'c', 1}, {'d', 1}, {'g', 1}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"b b b b a\") , {{'b', 4}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"\") , {}));\n    assert (issame(histogram(\"a\") , {{'a', 1}}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(histogram(\"a b b a\") , {{'a',2},{'b', 2}}));\n    assert (issame(histogram(\"a b c a b\") , {{'a', 2},{'b', 2}}));\n    assert (issame(histogram(\"a b c\") , {{'a', 1},{'b', 1},{'c', 1}}));\n    assert (issame(histogram(\"b b b b a\") , {{'b', 4}}));\n    assert (issame(histogram(\"\") , {}));\n}\n", "entry_point": "histogram", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a string chain representing act a space separated lowercase small letter letters letter, return a map \n of the letter with the most repetition and containing contain the corresponding represent count.\nIf several letters have the same occurrence, return all of them.\n\nExample:\nhistogram(\"a b c\") == {{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}\nhistogram(\"a b b a\") == {{\"a\", 2}, {\"b\", 2}}\nhistogram(\"a b c a b\") == {{\"a\", 2}, {\"b\", 2}}\nhistogram(\"b b b b a\") == {{\"b\", 4}}\nhistogram(\"\") == {}\n\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nmap<char,int> histogram(string test){\n\tmap<char,int> hist;\n\tfor(int i=0;i<test.length();i++){\n\t\tif(hist.find(test[i])==hist.end()){\n\t\t\thist[test[i]]=1;\n\t\t}else{\n\t\t\thist[test[i]]++;\n\t\t}\n\t}\n\treturn hist;\n}\nint main(){\n\tstring test=\"a b c\";\n\tmap<char,int> hist=histogram(test);\n\tfor(map<char,int>::iterator it=hist.begin();it!=hist.end();it++){\n\t\tprintf(\"%c: %d\\n\",it->first,it->second);\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/112", "prompt": "/*\nTask job \n We are given collapse two strings string section s and c, you have to deleted erase all the characters in s that are equal adequate to any character fictional character in c\nthen check if the result string bowed stringed instrument is palindrome. \n A string bowed stringed instrument is called palindrome if it reads the same backward as forward. \n You should return a vector containing the result solution string bowed stringed instrument and \"True\"/\"False\" for the check.\nExample\nFor s = \"abcde\", c = \"ae\", the result should be (\"bcd\",\"False\")\nFor s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",\"False\")\nFor s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",\"True\")\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> reverse_delete(string s,string c){\n", "canonical_solution": "    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(reverse_delete(\"abcde\",\"ae\") , {\"bcd\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdef\", \"b\") , {\"acdef\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"ab\") , {\"cdedc\",\"True\"}));\n    assert (issame(reverse_delete(\"dwik\",\"w\") , {\"dik\",\"False\"}));\n    assert (issame(reverse_delete(\"a\",\"a\") , {\"\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"v\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"vabba\",\"v\") , {\"abba\",\"True\"}));\n    assert (issame(reverse_delete(\"mamma\", \"mia\") , {\"\", \"True\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(reverse_delete(\"abcde\",\"ae\") , {\"bcd\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdef\", \"b\") , {\"acdef\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"ab\") , {\"cdedc\",\"True\"}));\n}\n", "entry_point": "reverse_delete", "seed": 3, "perturbed": true, "gc": "/*\nTask job \n We are given collapse two strings string section s and c, you have to deleted erase all the characters in s that are equal adequate to any character fictional character in c\nthen check if the result string bowed stringed instrument is palindrome. \n A string bowed stringed instrument is called palindrome if it reads the same backward as forward. \n You should return a vector containing the result solution string bowed stringed instrument and \"True\"/\"False\" for the check.\nExample\nFor s = \"abcde\", c = \"ae\", the result should be (\"bcd\",\"False\")\nFor s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",\"False\")\nFor s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",\"True\")\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> reverse_delete(string s,string c){\n\tvector<string> result;\n\tint i=0,j=0,k=0;\n\twhile(i<s.length()){\n\t\tif(s[i]==c[k]){\n\t\t\tk++;\n\t\t\tif(k==c.length()){\n\t\t\t\tresult.push_back(s.substr(j,i-j));\n\t\t\t\tj=i+1;\n\t\t\t\tk=0;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif(k!=0){\n\t\tresult.push_back(s.substr(j,i-j));\n\t}\n\treturn result;\n}\nbool check(string s,string c){\n\tvector<string> result=reverse_delete(s,c);\n\tif(result.size()==0)\n\t\treturn false;\n\tif(result[0]==result[result.size()-1])\n\t\treturn true;\n\treturn false;\n}\nint main(){\n\tstring s=\"abcde\";\n\tstring c=\"ae\";\n\tvector<string> result=reverse_delete(s,c);\n\tfor(int i=0;i<result.size();i++){\n\t\tprintf(\"%s\\n\",result[i].c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/113", "prompt": "/*\nGiven render a vector of strings string section, where each string chain consists consist of only digits, return a vector. \n Each element component i of the output end product should be' the number of odd elements component in the \n string bowed stringed instrument i of the input. \" where all the i's should be replaced by the number \n of odd digits digit in the i'th string bowed stringed instrument of the input.\n\n>>> odd_count({\"1234567\"})\n{'the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n>>> odd_count({\"3\",\"11111111\"})\n{'the number of odd elements 1n the str1ng 1 of the 1nput.\",\n 'the number of odd elements 8n the str8ng 8 of the 8nput.\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\nvector<string> odd_count(vector<string> lst){\n", "canonical_solution": "    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}));\n    assert (issame(odd_count({\"3\",\"11111111\"}) , {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}));\n    assert (issame(odd_count({\"271\", \"137\", \"314\"}) , {\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n    }));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}));\n    assert (issame(odd_count({\"3\",\"11111111\"}) , {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}));\n}\n", "entry_point": "odd_count", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a vector of strings string section, where each string chain consists consist of only digits, return a vector. \n Each element component i of the output end product should be' the number of odd elements component in the \n string bowed stringed instrument i of the input. \" where all the i's should be replaced by the number \n of odd digits digit in the i'th string bowed stringed instrument of the input.\n\n>>> odd_count({\"1234567\"})\n{'the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n>>> odd_count({\"3\",\"11111111\"})\n{'the number of odd elements 1n the str1ng 1 of the 1nput.\",\n 'the number of odd elements 8n the str8ng 8 of the 8nput.\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\nvector<string> odd_count(vector<string> lst){\n\tvector<string> res;\n\tmap<string,int> m;\n\tfor(int i=0;i<lst.size();i++){\n\t\tstring str=lst[i];\n\t\tfor(int j=0;j<str.size();j++){\n\t\t\tif(str[j]=='0'){\n\t\t\t\tm[str[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(map<string,int>::iterator it=m.begin();it!=m.end();it++){\n\t\tres.push_back(it->first);\n\t}\n\treturn res;\n}\nint main(){\n\tvector<string> lst;\n\tlst.push_back(\"1234567\");\n\tlst.push_back(\"3\");\n\tlst.push_back(\"11111111\");\n\tlst.push_back(\"8\");\n\tlst.push_back(\"9\");\n\tlst.push_back(\"10\");\n\tlst.push_back(\"11\");\n\tlst.push_back(\"12\");\n\tlst.push_back(\"13\");\n\tlst.push_back(\"14\");\n\tlst.push_back(\"15\");\n\tlst.push_back(\"16\");\n\tlst.push_back(\"17\");\n\tlst.push_back(\"18\");\n\tlst.push_back(\"19\");\n\tlst.push_back(\"20\");\n\tlst.push_back(\"21\");\n\tlst.push_back(\"22\");\n\tlst.push_back(\"23\");\n\tlst.push_back(\"24\");\n\tlst.push_back(\"25\");\n\tlst.push_back(\"26\");\n\tlst.push_back(\"27\");\n\tlst.push_back(\"28\");\n\tlst.push_back(\"29\");\n\tlst.push_back(\"30\");\n\tlst.push_back(\"31\");\n\tlst.push_back(\"32\");\n\tlst.push_back(\"33\");\n\tlst.push_back(\"34\");\n\tlst.push_back(\"35\");\n\tlst.push_back(\"36\");\n\tlst.push_back(\"37\");\n\tlst.push_back(\"38\");\n\tlst.push_back(\"39\");\n\tlst.push_back(\"40\");\n\tlst.push_back(\"41\");\n\tlst.push_back(\"42\");\n\tlst.push_back(\"43\");\n\tlst.push_back(\"44\");\n\tlst.push_back(\"45\");\n\tlst.push_back(\"46\");\n\tlst.push_back(\"47\");\n\tlst.push_back(\"48\");\n\tlst.push_back(\"49\");\n\tlst.push_back(\"50\");\n\tlst.push_back(\"51\");\n\tlst.push_back(\"52\");\n\tlst.push_back(\"53\");\n\tlst.push_back(\"54\");\n\tlst.push_back(\"55\");\n\tlst.push_back(\"56\");\n\tlst.push_back(\"57\");\n\tlst.push_back(\"58\");\n\tlst.push_back(\"59\");\n\tlst.push_back(\"60\");\n\tlst.push_back(\"61\");\n\tlst.push_back(\"62\");\n\tlst.push_back(\"63\");\n\tlst.push_back(\"64\");\n\tlst.push_back(\"65\");\n\tlst.push_back(\"66\");\n\tlst.push_back(\"67\");\n\tlst.push_back(\"68\");\n\tlst.push_back(\"69\");\n\tlst.push_back(\"70\");\n\tlst.push_back(\"71\");\n\tlst.push_back(\"72\");\n\tlst.push_back(\"73\");\n\tlst.push_back(\"74\");\n\tlst.push_back(\"75\");\n\tlst.push_back(\"76\");\n\tlst.push_back(\"77\");\n\tlst.push_back(\"78\");\n\tlst.push_back(\"79\");\n\tlst.push_back(\"80\");\n\tlst.push_back(\"81\");\n\tlst.push_back(\"82\");\n\tlst.push_back(\"83\");\n\tlst.push_back(\"84\");\n\tlst.push_back(\"85\");\n\tlst.push_back(\"86\");\n\tlst.push_back(\"87\");\n\tlst.push_back(\"88\");\n\tlst.push_back(\"89\");\n\tlst.push_back(\"90\");\n\tlst.push_back(\"91\");\n\tlst.push_back(\"92\");\n\tlst.push_back(\"93\");\n\tlst.push_back(\"94\");\n\tlst.push_back(\"95\");\n\tlst.push_back(\"96\");\n\tlst.push_back(\"97\");\n\tlst.push_back(\"98\");\n\tlst.push_back(\"99\");\n\tlst.push_back(\"100\");\n\tlst.push_back(\"101\");\n\tlst.push_back(\"102\");\n\tlst.push_back(\"103\");\n\tlst.push_back(\"104\");\n\tlst.push_back(\"105\");\n\tlst.push_back(\"106\");\n\tlst.push_back(\"107\");\n\tlst.push_back(\"108", "passed": 0, "run_status": 2}
{"task_id": "CPP/114", "prompt": "/*\nGiven render a vector of integers integer nums, find the minimum minimal sum of any non - empty sub - vector \n of nums.\nExample\nminSubArraySum({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum({-1, -2, -3}) == -6\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nlong long minSubArraySum(vector<long long> nums){\n", "canonical_solution": "    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (minSubArraySum({2, 3, 4, 1, 2, 4}) == 1);\n    assert (minSubArraySum({-1, -2, -3}) == -6);\n    assert (minSubArraySum({-1, -2, -3, 2, -10}) == -14);\n    assert (minSubArraySum({-9999999999999999}) == -9999999999999999);\n    assert (minSubArraySum({0, 10, 20, 1000000}) == 0);\n    assert (minSubArraySum({-1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({100, -1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({10, 11, 13, 8, 3, 4}) == 3);\n    assert (minSubArraySum({100, -33, 32, -1, 0, -2}) == -33);\n    assert (minSubArraySum({-10}) == -10);\n    assert (minSubArraySum({7}) == 7);\n    assert (minSubArraySum({1, -1}) == -1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (minSubArraySum({2, 3, 4, 1, 2, 4}) == 1);\n    assert (minSubArraySum({-1, -2, -3}) == -6);\n}\n", "entry_point": "minSubArraySum", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a vector of integers integer nums, find the minimum minimal sum of any non - empty sub - vector \n of nums.\nExample\nminSubArraySum({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum({-1, -2, -3}) == -6\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nlong long minSubArraySum(vector<long long> nums){\n    long long minSum = 0;\n    long long sum = 0;\n    for(int i = 0; i < nums.size(); i++){\n        sum += nums[i];\n        if(sum < minSum){\n            minSum = sum;\n        }\n        if(sum > minSum){\n            return minSum;\n        }\n    }\n    return minSum;\n}\nint main(){\n    vector<long long> nums = {2, 3, 4, 1, 2, 4};\n    printf(\"%lld\\n\", minSubArraySum(nums));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/115", "prompt": "/*\nYou are given render a rectangular orthogonal grid of wells. Each row quarrel represents a single unmarried well, \n and each 1 in a row rowing represents map a single unmarried unit unit of measurement of water. \n Each well has a corresponding bucket that can be used to extract water water system from it, \n and all buckets bucket have the same capacity.\nYour task is to use practice the buckets to empty the wells well. \n Output the number act of times fourth dimension you need want to lower the buckets bucket.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid{:,1}.length <= 10^2\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint max_fill(vector<vector<int>> grid,int capacity){\n", "canonical_solution": "    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (max_fill({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    assert (max_fill({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    assert (max_fill({{0,0,0}, {0,0,0}}, 5) == 0);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 2) == 4);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 9) == 2);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (max_fill({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    assert (max_fill({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    assert (max_fill({{0,0,0}, {0,0,0}}, 5) == 0);\n}\n", "entry_point": "max_fill", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a rectangular orthogonal grid of wells. Each row quarrel represents a single unmarried well, \n and each 1 in a row rowing represents map a single unmarried unit unit of measurement of water. \n Each well has a corresponding bucket that can be used to extract water water system from it, \n and all buckets bucket have the same capacity.\nYour task is to use practice the buckets to empty the wells well. \n Output the number act of times fourth dimension you need want to lower the buckets bucket.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid{:,1}.length <= 10^2\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint max_fill(vector<vector<int>> grid,int capacity){\n    int n = grid.size();\n    int m = grid[0].size();\n    int ans = 0;\n    for(int i = 0;i<n;i++){\n        for(int j = 0;j<m;j++){\n            if(grid[i][j] == 1){\n                ans = max(ans,fill(grid[i].begin(),grid[i].end(),capacity));\n            }\n        }\n    }\n    return ans;\n}\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    vector<vector<int>> grid(n,vector<int>(m));\n    for(int i = 0;i<n;i++){\n        for(int j = 0;j<m;j++){\n            scanf(\"%d\",&grid[i][j]);\n        }\n    }\n    int capacity;\n    scanf(\"%d\",&capacity);\n    printf(\"%d\\n\",max_fill(grid,capacity));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/116", "prompt": "/*\nIn this Kata, you have to sort screen a vector of non - negative damaging integers according harmonize to \n number of ones one in their binary representation theatrical performance in ascending order. \n For similar alike number issue of ones, sort based on decimal value. \n\n It must be implemented like this:\n>>> sort_vector({1, 5, 2, 3, 4}) == {1, 2, 3, 4, 5}\n>>> sort_vector({-2, -3, -4, -5, -6}) == {-6, -5, -4, -3, -2}\n>>> sort_vector({1, 0, 2, 3, 4}) == {0, 1, 2, 3, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_array(vector<int> arr){\n", "canonical_solution": "    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({1,5,2,3,4}) , {1, 2, 4, 3, 5}));\n    assert (issame(sort_array({-2,-3,-4,-5,-6}) , {-4, -2, -6, -5, -3}));\n    assert (issame(sort_array({1,0,2,3,4}) , {0, 1, 2, 4, 3}));\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({2,5,77,4,5,3,5,7,2,3,4}) , {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77}));\n    assert (issame(sort_array({3,6,44,12,32,5}) , {32, 3, 5, 6, 12, 44}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({1,5,2,3,4}) , {1, 2, 4, 3, 5}));\n    assert (issame(sort_array({-2,-3,-4,-5,-6}) , {-4, -2, -6, -5, -3}));\n    assert (issame(sort_array({1,0,2,3,4}) , {0, 1, 2, 4, 3}));\n}\n", "entry_point": "sort_array", "seed": 3, "perturbed": true, "gc": "/*\nIn this Kata, you have to sort screen a vector of non - negative damaging integers according harmonize to \n number of ones one in their binary representation theatrical performance in ascending order. \n For similar alike number issue of ones, sort based on decimal value. \n\n It must be implemented like this:\n>>> sort_vector({1, 5, 2, 3, 4}) == {1, 2, 3, 4, 5}\n>>> sort_vector({-2, -3, -4, -5, -6}) == {-6, -5, -4, -3, -2}\n>>> sort_vector({1, 0, 2, 3, 4}) == {0, 1, 2, 3, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_array(vector<int> arr){\n    vector<int> sorted_arr;\n    for(int i=0; i<arr.size(); i++){\n        sorted_arr.push_back(arr[i]);\n    }\n    sort(sorted_arr.begin(), sorted_arr.end());\n    return sorted_arr;\n}\nvector<int> sort_vector(vector<int> arr){\n    vector<int> sorted_arr;\n    for(int i=0; i<arr.size(); i++){\n        sorted_arr.push_back(arr[i]);\n    }\n    sort(sorted_arr.begin(), sorted_arr.end(), greater<int>());\n    return sorted_arr;\n}\nint main(){\n    vector<int> arr = {1, 5, 2, 3, 4};\n    vector<int> sorted_arr = sort_vector(arr);\n    for(int i=0; i<sorted_arr.size(); i++){\n        printf(\"%d \", sorted_arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/117", "prompt": "/*\nGiven render a string chain s and a natural lifelike number n, you have been tasked to implement enforce \n a function affair that returns a vector of all words from string bowed stringed instrument s that contain hold exactly \nn consonants, in order these words appear look in the string bowed stringed instrument s.\nIf the string s is empty then the function affair should return an empty vector. \n Note: you may assume the input stimulation string bowed stringed instrument contains only letters letter and spaces quad.\nExamples:\nselect_words(\"Mary had a little lamb\", 4) ==> {\"little\"}\nselect_words(\"Mary had a little lamb\", 3) ==> {\"Mary\", \"lamb\"}\nselect_words('simple white space\", 2) ==> {}\nselect_words(\"Hello world\", 4) ==> {\"world\"}\nselect_words(\"Uncle sam\", 3) ==> {\"Uncle\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> select_words(string s,int n){\n", "canonical_solution": "    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(select_words(\"Mary had a little lamb\", 4) , {\"little\"}   ));\n    assert (issame(select_words(\"Mary had a little lamb\", 3) , {\"Mary\", \"lamb\"} ));\n    assert (issame(select_words(\"simple white space\", 2) , {}     ));\n    assert (issame(select_words(\"Hello world\", 4) , {\"world\"}  ));\n    assert (issame(select_words(\"Uncle sam\", 3) , {\"Uncle\"}));\n    assert (issame(select_words(\"\", 4) , {}));\n    assert (issame(select_words(\"a b c d e f\", 1) , {\"b\", \"c\", \"d\", \"f\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(select_words(\"Mary had a little lamb\", 4) , {\"little\"}   ));\n    assert (issame(select_words(\"Mary had a little lamb\", 3) , {\"Mary\", \"lamb\"} ));\n    assert (issame(select_words(\"simple white space\", 2) , {}     ));\n    assert (issame(select_words(\"Hello world\", 4) , {\"world\"}  ));\n    assert (issame(select_words(\"Uncle sam\", 3) , {\"Uncle\"}));\n}\n", "entry_point": "select_words", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a string chain s and a natural lifelike number n, you have been tasked to implement enforce \n a function affair that returns a vector of all words from string bowed stringed instrument s that contain hold exactly \nn consonants, in order these words appear look in the string bowed stringed instrument s.\nIf the string s is empty then the function affair should return an empty vector. \n Note: you may assume the input stimulation string bowed stringed instrument contains only letters letter and spaces quad.\nExamples:\nselect_words(\"Mary had a little lamb\", 4) ==> {\"little\"}\nselect_words(\"Mary had a little lamb\", 3) ==> {\"Mary\", \"lamb\"}\nselect_words('simple white space\", 2) ==> {}\nselect_words(\"Hello world\", 4) ==> {\"world\"}\nselect_words(\"Uncle sam\", 3) ==> {\"Uncle\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> select_words(string s,int n){\n\tvector<string> result;\n\tif(s.empty()){\n\t\treturn result;\n\t}\n\tint count=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]==' '){\n\t\t\tcount++;\n\t\t}\n\t\tif(count==n){\n\t\t\tresult.push_back(s.substr(0,i));\n\t\t\tcount=0;\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tstring s=\"Hello world\";\n\tint n=4;\n\tvector<string> result=select_words(s,n);\n\tfor(int i=0;i<result.size();i++){\n\t\tprintf(\"%s\\n\",result[i].c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/118", "prompt": "/*\nYou are given render a word. Your task undertaking is to find the closest vowel that stands resist between \n two consonants from the right good side slope of the word (case sensitive). \n\n Vowels vowel in the beginning and ending termination doesn't count. Return empty string if you didn't \n find any vowel met meet the above condition circumstance. \n\n You may assume that the given collapse string contains English letter only.\n\nExample:\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring get_closest_vowel(string word){\n", "canonical_solution": "    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_closest_vowel(\"yogurt\") == \"u\");\n    assert (get_closest_vowel(\"full\") == \"u\");\n    assert (get_closest_vowel(\"easy\") == \"\");\n    assert (get_closest_vowel(\"eAsy\") == \"\");\n    assert (get_closest_vowel(\"ali\") == \"\");\n    assert (get_closest_vowel(\"bad\") == \"a\");\n    assert (get_closest_vowel(\"most\") ==\"o\");\n    assert (get_closest_vowel(\"ab\") == \"\");\n    assert (get_closest_vowel(\"ba\") == \"\");\n    assert (get_closest_vowel(\"quick\") == \"\");\n    assert (get_closest_vowel(\"anime\") == \"i\");\n    assert (get_closest_vowel(\"Asia\") == \"\");\n    assert (get_closest_vowel(\"Above\") == \"o\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_closest_vowel(\"yogurt\") == \"u\");\n    assert (get_closest_vowel(\"FULL\") == \"U\");\n    assert (get_closest_vowel(\"ab\") == \"\");\n    assert (get_closest_vowel(\"quick\") == \"\");\n}\n", "entry_point": "get_closest_vowel", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a word. Your task undertaking is to find the closest vowel that stands resist between \n two consonants from the right good side slope of the word (case sensitive). \n\n Vowels vowel in the beginning and ending termination doesn't count. Return empty string if you didn't \n find any vowel met meet the above condition circumstance. \n\n You may assume that the given collapse string contains English letter only.\n\nExample:\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring get_closest_vowel(string word){\n\tstring result;\n\tfor(int i=0;i<word.length();i++){\n\t\tif(word[i]=='a'||word[i]=='e'||word[i]=='i'||word[i]=='o'||word[i]=='u'||word[i]=='A'||word[i]=='E'||word[i]=='I'||word[i]=='O'||word[i]=='U'){\n\t\t\tresult=word[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tstring word;\n\twhile(scanf(\"%s\",&word)!=EOF){\n\t\tprintf(\"%s\\n\",get_closest_vowel(word).c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/119", "prompt": "/*\nYou are given render a vector of two strings string section, both strings string section consist dwell of open \n parentheses digression' (' or close near parentheses parenthesis')' only. \n Your job occupation is to check crack if it is possible to concatenate the two strings in\nsome order, that the resulting string chain will be good estimable. \n A string drawstring S is considered think to be good if and only if all parentheses in S \n are balanced. For example: the string \"(())()\" is good, while the string\n\"())\" is not.\nReturn \"Yes\" if there's a way to make a good string, and return \"No\" otherwise.\n\nExamples:\nmatch_parens({\"()(\", \")\"}) == \"Yes\"\nmatch_parens({\")\", \")\"}) == \"No\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring match_parens(vector<string> lst){\n", "canonical_solution": "    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (match_parens({\"()(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \")\"}) == \"No\");\n    assert (match_parens({\"(()(())\", \"())())\"}) == \"No\");\n    assert (match_parens({\")())\", \"(()()(\"}) == \"Yes\");\n    assert (match_parens({\"(())))\", \"(()())((\"}) == \"Yes\");\n    assert (match_parens({\"()\", \"())\"}) == \"No\");\n    assert (match_parens({\"(()(\", \"()))()\"}) == \"Yes\");\n    assert (match_parens({\"((((\", \"((())\"}) == \"No\");\n    assert (match_parens({\")(()\", \"(()(\"}) == \"No\");\n    assert (match_parens({\")(\", \")(\"}) == \"No\");\n    assert (match_parens({\"(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \"(\"}) == \"Yes\" );\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (match_parens({\"()(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \")\"}) == \"No\");\n}\n", "entry_point": "match_parens", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a vector of two strings string section, both strings string section consist dwell of open \n parentheses digression' (' or close near parentheses parenthesis')' only. \n Your job occupation is to check crack if it is possible to concatenate the two strings in\nsome order, that the resulting string chain will be good estimable. \n A string drawstring S is considered think to be good if and only if all parentheses in S \n are balanced. For example: the string \"(())()\" is good, while the string\n\"())\" is not.\nReturn \"Yes\" if there's a way to make a good string, and return \"No\" otherwise.\n\nExamples:\nmatch_parens({\"()(\", \")\"}) == \"Yes\"\nmatch_parens({\")\", \")\"}) == \"No\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring match_parens(vector<string> lst){\n\tif(lst.size()<2)\n\t\treturn \"No\";\n\tint i=0,j=0;\n\twhile(i<lst.size()){\n\t\tif(lst[i][0]=='('){\n\t\t\twhile(lst[i][j]!=')')\n\t\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\telse{\n\t\t\twhile(lst[i][j]!=')')\n\t\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t}\n\tif(i==lst.size()){\n\t\treturn \"Yes\";\n\t}\n\telse\n\t\treturn \"No\";\n}\nint main(){\n\tvector<string> lst;\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back(\"()(\"));\n\tlst.push_back", "passed": 1, "run_status": 0}
{"task_id": "CPP/12", "prompt": "/*\nOut of vector of strings, return the longest one. Return reelect the first beginning one in case of multiple \n strings string of the same length. Return None in case font the input stimulation vector is empty.\n>>> longest({})\n\n>>> longest({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring longest(vector<string> strings){\n", "canonical_solution": "    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (longest({}) == \"\");\n    assert (longest({\"x\", \"y\", \"z\"}) == \"x\");\n    assert (longest({\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"}) == \"zzzz\");\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (longest({}) == \"\");\n    assert (longest({\"a\", \"b\", \"c\"}) == \"a\");\n    assert (longest({\"a\", \"bb\", \"ccc\"}) == \"ccc\");\n}\n", "entry_point": "longest", "seed": 3, "perturbed": true, "gc": "/*\nOut of vector of strings, return the longest one. Return reelect the first beginning one in case of multiple \n strings string of the same length. Return None in case font the input stimulation vector is empty.\n>>> longest({})\n\n>>> longest({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring longest(vector<string> strings){\n    if(strings.empty())\n        return \"\";\n    string longest_str;\n    for(int i=0;i<strings.size();i++){\n        if(strings[i].size()>longest_str.size()){\n            longest_str=strings[i];\n        }\n    }\n    return longest_str;\n}\nint main(){\n    vector<string> strings;\n    string str;\n    while(getline(cin,str)){\n        strings.push_back(str);\n    }\n    string longest_str=longest(strings);\n    printf(\"%s\\n\",longest_str.c_str());\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/120", "prompt": "/*\nGiven render a vector arr of integers integer and a positive integer k, return a sorted grouped vector \n of length k with the maximum k numbers phone number in arr.\n\nExample 1:\n\n    Input: arr = {-3, -4, 5}, k = 3\n    Output: {-4, -3, 5}\n\nExample 2:\n\n    Input: arr = {4, -4, 4}, k = 2\n    Output: {4, 4}\n\nExample 3:\n\n    Input: arr = {-3, 2, 1, 2, -1, -2, 1}, k = 1\n    Output: {2}\n\nNote:\n    1. The length of the vector will be in the range of {1, 1000}.\n    2. The elements in the vector will be in the range of {-1000, 1000}.\n    3. 0 <= k <= len(arr)\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> maximum(vector<int> arr,int k){\n", "canonical_solution": "    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(maximum({-3, -4, 5}, 3) , {-4, -3, 5}));\n    assert (issame(maximum({4, -4, 4}, 2) , {4, 4}));\n    assert (issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1) , {2}));\n    assert (issame(maximum({123, -123, 20, 0 , 1, 2, -3}, 3) , {2, 20, 123}));\n    assert (issame(maximum({-123, 20, 0 , 1, 2, -3}, 4) , {0, 1, 2, 20}));\n    assert (issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7) , {-13, -8, 0, 0, 3, 5, 15}));\n    assert (issame(maximum({-1, 0, 2, 5, 3, -10}, 2) , {3, 5}));\n    assert (issame(maximum({1, 0, 5, -7}, 1) , {5}));\n    assert (issame(maximum({4, -4}, 2) , {-4, 4}));\n    assert (issame(maximum({-10, 10}, 2) , {-10, 10}));\n    assert (issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(maximum({-3, -4, 5}, 3) , {-4, -3, 5}));\n    assert (issame(maximum({4, -4, 4}, 2) , {4, 4}));\n    assert (issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1) , {2}));\n}\n", "entry_point": "maximum", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a vector arr of integers integer and a positive integer k, return a sorted grouped vector \n of length k with the maximum k numbers phone number in arr.\n\nExample 1:\n\n    Input: arr = {-3, -4, 5}, k = 3\n    Output: {-4, -3, 5}\n\nExample 2:\n\n    Input: arr = {4, -4, 4}, k = 2\n    Output: {4, 4}\n\nExample 3:\n\n    Input: arr = {-3, 2, 1, 2, -1, -2, 1}, k = 1\n    Output: {2}\n\nNote:\n    1. The length of the vector will be in the range of {1, 1000}.\n    2. The elements in the vector will be in the range of {-1000, 1000}.\n    3. 0 <= k <= len(arr)\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> maximum(vector<int> arr,int k){\n    vector<int> res;\n    sort(arr.begin(),arr.end());\n    res.push_back(arr[0]);\n    for(int i=1;i<k;i++){\n        if(arr[i]>arr[i-1])\n            res.push_back(arr[i]);\n        else\n            res.push_back(arr[i-1]);\n    }\n    return res;\n}\nint main(){\n    int arr[1000] = {-3, -4, 5};\n    int k = 3;\n    vector<int> res = maximum(arr,k);\n    for(int i=0;i<res.size();i++){\n        printf(\"%d \",res[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/121", "prompt": "/*\nGiven render a non - empty vector of integers integer, return the sum of all of the odd elements component that are in even positions.\n\n\nExamples\nsolution({5, 8, 7, 1}) ==> 12\nsolution({3, 3, 3, 3, 3}) ==> 9\nsolution({30, 13, 24, 321}) ==>0\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint solutions(vector<int> lst){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solutions({5, 8, 7, 1})    == 12);\n    assert (solutions({3, 3, 3, 3, 3}) == 9);\n    assert (solutions({30, 13, 24, 321}) == 0);\n    assert (solutions({5, 9}) == 5);\n    assert (solutions({2, 4, 8}) == 0);\n    assert (solutions({30, 13, 23, 32}) == 23);\n    assert (solutions({3, 13, 2, 9}) == 3);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solutions({5, 8, 7, 1})    == 12);\n    assert (solutions({3, 3, 3, 3, 3}) == 9);\n    assert (solutions({30, 13, 24, 321}) == 0);\n}\n", "entry_point": "solutions", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a non - empty vector of integers integer, return the sum of all of the odd elements component that are in even positions.\n\n\nExamples\nsolution({5, 8, 7, 1}) ==> 12\nsolution({3, 3, 3, 3, 3}) ==> 9\nsolution({30, 13, 24, 321}) ==>0\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint solutions(vector<int> lst){\n\tint sum=0;\n\tfor(int i=0;i<lst.size();i++){\n\t\tif(lst[i]%2==0){\n\t\t\tsum+=lst[i];\n\t\t}\n\t}\n\treturn sum;\n}\nint main(){\n\tvector<int> lst;\n\tlst.push_back(5);\n\tlst.push_back(8);\n\tlst.push_back(7);\n\tlst.push_back(1);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_back(3);\n\tlst.push_", "passed": 0, "run_status": 1}
{"task_id": "CPP/122", "prompt": "/*\nGiven render a non - empty vector of integers integer arr and an integer k, return\nthe sum of the elements with at most two digits digit from the first k elements element of arr.\n\nExample:\n\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add_elements(vector<int> arr,int k){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add_elements({1,-2,-3,41,57,76,87,88,99}, 3) == -4);\n    assert (add_elements({111,121,3,4000,5,6}, 2) == 0);\n    assert (add_elements({11,21,3,90,5,6,7,8,9}, 4) == 125);\n    assert (add_elements({111,21,3,4000,5,6,7,8,9}, 4) == 24);\n    assert (add_elements({1}, 1) == 1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add_elements({111,21,3,4000,5,6,7,8,9}, 4) == 24);\n}\n", "entry_point": "add_elements", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a non - empty vector of integers integer arr and an integer k, return\nthe sum of the elements with at most two digits digit from the first k elements element of arr.\n\nExample:\n\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add_elements(vector<int> arr,int k){\n    int sum = 0;\n    for(int i = 0; i < k; i++){\n        sum += arr[i];\n    }\n    return sum;\n}\n\nint main(){\n    int arr[100] = {111,21,3,4000,5,6,7,8,9};\n    int k = 4;\n    printf(\"%d\\n\",add_elements(arr,k));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/123", "prompt": "/*\nGiven render a positive positivist integer n, return a sorted grouped vector that has the odd numbers in collatz sequence succession. \n\n The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined define \n as follows: start with any positive integer n. Then each term is obtained prevail from the \n previous former term as follows play along: if the previous term is even, the next term is one half one-half of \n the previous term terminus. If the previous former term terminus is odd, the next future term is 3 times meter the previous \n term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n Note: \n     1. Collatz(1) is { 1 }. \n     2. returned vector sorted in increasing increase order.\n\nFor example:\nget_odd_collatz(5) returns {1, 5} // The collatz sequence for 5 is {5, 16, 8, 4, 2, 1}, so the odd numbers are only 1, and 5.\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> get_odd_collatz(int n){\n", "canonical_solution": "    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_odd_collatz(14) , {1, 5, 7, 11, 13, 17}));\n    assert (issame(get_odd_collatz(5) , {1, 5}));\n    assert (issame(get_odd_collatz(12) , {1, 3, 5}));\n    assert (issame(get_odd_collatz(1) , {1}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_odd_collatz(5) , {1, 5}));\n}\n", "entry_point": "get_odd_collatz", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a positive positivist integer n, return a sorted grouped vector that has the odd numbers in collatz sequence succession. \n\n The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined define \n as follows: start with any positive integer n. Then each term is obtained prevail from the \n previous former term as follows play along: if the previous term is even, the next term is one half one-half of \n the previous term terminus. If the previous former term terminus is odd, the next future term is 3 times meter the previous \n term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n Note: \n     1. Collatz(1) is { 1 }. \n     2. returned vector sorted in increasing increase order.\n\nFor example:\nget_odd_collatz(5) returns {1, 5} // The collatz sequence for 5 is {5, 16, 8, 4, 2, 1}, so the odd numbers are only 1, and 5.\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> get_odd_collatz(int n){\n\tvector<int> collatz;\n\tcollatz.push_back(n);\n\twhile(n > 1){\n\t\tif(n % 2 == 0){\n\t\t\tn /= 2;\n\t\t}else{\n\t\t\tn = 3 * n + 1;\n\t\t}\n\t\tcollatz.push_back(n);\n\t}\n\tsort(collatz.begin(), collatz.end());\n\treturn collatz;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> collatz = get_odd_collatz(n);\n\tfor(int i = 0; i < collatz.size(); i++){\n\t\tprintf(\"%d \", collatz[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/124", "prompt": "/*\nYou have to write publish a function affair which validates a given contribute date string and \n returns rejoinder true on-key if the date is valid otherwise false. \n The date is valid if all of the following watch rules rule are satisfied: \n 1. The date string is not empty. \n 2. The number of days is not less than 1 or higher high than 31 days day for months 1,3,5,7,8,10,12. And the number numeral of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number act of days day is not less than 1 or higher gamey than 29 for the month 2. \n 3. The months month should not be less than 1 or higher gamey than 12. \n 4. The date should be in the format: mm-dd-yyyy\n\nfor example: \nvalid_date(\"03-11-2000\") => true\n\nvalid_date(\"15-01-2012\") => false\n\nvalid_date(\"04-0-2040\") => false\n\nvalid_date(\"06-04-2020\") => true\n\nvalid_date(\"06/04/2020\") => false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool valid_date(string date){\n", "canonical_solution": "    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (valid_date(\"03-11-2000\") == true);\n    assert (valid_date(\"15-01-2012\") == false);\n    assert (valid_date(\"04-0-2040\") == false);\n    assert (valid_date(\"06-04-2020\") == true);\n    assert (valid_date(\"01-01-2007\") == true);\n    assert (valid_date(\"03-32-2011\") == false);\n    assert (valid_date(\"\") == false);\n    assert (valid_date(\"04-31-3000\") == false);\n    assert (valid_date(\"06-06-2005\") == true);\n    assert (valid_date(\"21-31-2000\") == false);\n    assert (valid_date(\"04-12-2003\") == true);\n    assert (valid_date(\"04122003\") == false);\n    assert (valid_date(\"20030412\") == false);\n    assert (valid_date(\"2003-04\") == false);\n    assert (valid_date(\"2003-04-12\") == false);\n    assert (valid_date(\"04-2003\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (valid_date(\"03-11-2000\") == true);\n    assert (valid_date(\"15-01-2012\") == false);\n    assert (valid_date(\"04-0-2040\") == false);\n    assert (valid_date(\"06-04-2020\") == true);\n    assert (valid_date(\"06/04/2020\") == false);\n}\n", "entry_point": "valid_date", "seed": 3, "perturbed": true, "gc": "/*\nYou have to write publish a function affair which validates a given contribute date string and \n returns rejoinder true on-key if the date is valid otherwise false. \n The date is valid if all of the following watch rules rule are satisfied: \n 1. The date string is not empty. \n 2. The number of days is not less than 1 or higher high than 31 days day for months 1,3,5,7,8,10,12. And the number numeral of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number act of days day is not less than 1 or higher gamey than 29 for the month 2. \n 3. The months month should not be less than 1 or higher gamey than 12. \n 4. The date should be in the format: mm-dd-yyyy\n\nfor example: \nvalid_date(\"03-11-2000\") => true\n\nvalid_date(\"15-01-2012\") => false\n\nvalid_date(\"04-0-2040\") => false\n\nvalid_date(\"06-04-2020\") => true\n\nvalid_date(\"06/04/2020\") => false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool valid_date(string date){\n    if(date.empty()){\n        return false;\n    }\n    int month = 0, day = 0, year = 0;\n    string month_str = \"\", day_str = \"\", year_str = \"\";\n    int num_days = 0, num_days_sidereal = 0, num_days_gamey = 0;\n    int num_days_month = 0;\n    int num_days_month_gamey = 0;\n    int num_days_month_sidereal = 0;\n    int num_days_month_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey = 0;\n    int num_days_month_sidereal_gamey_gamey = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal = 0;\n    int num_days_month_sidereal_gamey_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_sidereal_gamey_", "passed": 0, "run_status": 2}
{"task_id": "CPP/125", "prompt": "/*\nGiven render a string chain of words bible, return a vector of words news split on whitespace, if no whitespaces exists exist in the text textbook you \n should split on commas',' if no commas comma exists exist you should return a vector with one element, the number of lower - case letters letter with odd curious order in the \n alphabet rudiment, ord(\"a \") = 0, ord(\"b \") = 1, ... ord(\"z \") = 25\nExamples\nsplit_words(\"Hello world!\")  {\"Hello\", \"world!\"}\nsplit_words(\"Hello,world!\")  {\"Hello\", \"world!\"}\nsplit_words(\"abcdef\") == {\"3\"} \n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> split_words(string txt){\n", "canonical_solution": "    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(split_words(\"Hello world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello,world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello world,!\") , {\"Hello\",\"world,!\"}));\n    assert (issame(split_words(\"Hello,Hello,world !\") , {\"Hello,Hello,world\",\"!\"}));\n    assert (issame(split_words(\"abcdef\") , {\"3\"}));\n    assert (issame(split_words(\"aaabb\") , {\"2\"}));\n    assert (issame(split_words(\"aaaBb\") , {\"1\"}));\n    assert (issame(split_words(\"\") ,{\"0\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(split_words(\"Hello world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello,world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"abcdef\") , {\"3\"}));\n}\n", "entry_point": "split_words", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a string chain of words bible, return a vector of words news split on whitespace, if no whitespaces exists exist in the text textbook you \n should split on commas',' if no commas comma exists exist you should return a vector with one element, the number of lower - case letters letter with odd curious order in the \n alphabet rudiment, ord(\"a \") = 0, ord(\"b \") = 1,... ord(\"z \") = 25\nExamples\nsplit_words(\"Hello world!\")  {\"Hello\", \"world!\"}\nsplit_words(\"Hello,world!\")  {\"Hello\", \"world!\"}\nsplit_words(\"abcdef\") == {\"3\"} \n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> split_words(string txt){\n    vector<string> res;\n    string tmp;\n    for(int i = 0; i < txt.size(); i++){\n        if(txt[i] ==''){\n            if(!tmp.empty()){\n                res.push_back(tmp);\n                tmp.clear();\n            }\n        }else{\n            tmp += txt[i];\n        }\n    }\n    if(!tmp.empty()){\n        res.push_back(tmp);\n    }\n    return res;\n}\nint main(){\n    string txt = \"Hello world!\";\n    vector<string> res = split_words(txt);\n    for(int i = 0; i < res.size(); i++){\n        printf(\"%s\\n\", res[i].c_str());\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/126", "prompt": "/*\nGiven render a vector of numbers phone number, return whether or not they are sorted screen \n in ascending order. If vector has more than 1 duplicate extra of the same \n number numeral, return false. Assume no negative numbers numeral and only integers integer.\n\nExamples\nis_sorted({5})  true\nis_sorted({1, 2, 3, 4, 5})  true\nis_sorted({1, 3, 2, 4, 5})  false\nis_sorted({1, 2, 3, 4, 5, 6})  true\nis_sorted({1, 2, 3, 4, 5, 6, 7})  true\nis_sorted({1, 3, 2, 4, 5, 6, 7})  false\nis_sorted({1, 2, 2, 3, 3, 4})  true\nis_sorted({1, 2, 2, 2, 3, 4})  false\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool is_sorted(vector<int> lst){\n", "canonical_solution": "    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_sorted({5}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5}) == false);\n    assert (is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert (is_sorted({}) == true);\n    assert (is_sorted({1}) == true);\n    assert (is_sorted({3, 2, 1}) == false);\n    assert (is_sorted({1, 2, 2, 2, 3, 4}) == false);\n    assert (is_sorted({1, 2, 3, 3, 3, 4}) == false);\n    assert (is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert (is_sorted({1, 2, 3, 4}) == true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_sorted({5}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5}) == false);\n    assert (is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert (is_sorted({1, 2, 2, 2, 3, 4}) == false);\n    assert (is_sorted({1, 2, 2, 3, 3, 4}) == true);\n}\n", "entry_point": "is_sorted", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a vector of numbers phone number, return whether or not they are sorted screen \n in ascending order. If vector has more than 1 duplicate extra of the same \n number numeral, return false. Assume no negative numbers numeral and only integers integer.\n\nExamples\nis_sorted({5})  true\nis_sorted({1, 2, 3, 4, 5})  true\nis_sorted({1, 3, 2, 4, 5})  false\nis_sorted({1, 2, 3, 4, 5, 6})  true\nis_sorted({1, 2, 3, 4, 5, 6, 7})  true\nis_sorted({1, 3, 2, 4, 5, 6, 7})  false\nis_sorted({1, 2, 2, 3, 3, 4})  true\nis_sorted({1, 2, 2, 2, 3, 4})  false\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool is_sorted(vector<int> lst){\n\tif(lst.size()==0)\n\t\treturn true;\n\tif(lst.size()==1)\n\t\treturn true;\n\tif(lst.size()==2)\n\t\treturn true;\n\tif(lst.size()==3)\n\t\treturn true;\n\tif(lst.size()==4)\n\t\treturn true;\n\tif(lst.size()==5)\n\t\treturn true;\n\tif(lst.size()==6)\n\t\treturn true;\n\tif(lst.size()==7)\n\t\treturn true;\n\tif(lst.size()==8)\n\t\treturn true;\n\tif(lst.size()==9)\n\t\treturn true;\n\tif(lst.size()==10)\n\t\treturn true;\n\tif(lst.size()==11)\n\t\treturn true;\n\tif(lst.size()==12)\n\t\treturn true;\n\tif(lst.size()==13)\n\t\treturn true;\n\tif(lst.size()==14)\n\t\treturn true;\n\tif(lst.size()==15)\n\t\treturn true;\n\tif(lst.size()==16)\n\t\treturn true;\n\tif(lst.size()==17)\n\t\treturn true;\n\tif(lst.size()==18)\n\t\treturn true;\n\tif(lst.size()==19)\n\t\treturn true;\n\tif(lst.size()==20)\n\t\treturn true;\n\tif(lst.size()==21)\n\t\treturn true;\n\tif(lst.size()==22)\n\t\treturn true;\n\tif(lst.size()==23)\n\t\treturn true;\n\tif(lst.size()==24)\n\t\treturn true;\n\tif(lst.size()==25)\n\t\treturn true;\n\tif(lst.size()==26)\n\t\treturn true;\n\tif(lst.size()==27)\n\t\treturn true;\n\tif(lst.size()==28)\n\t\treturn true;\n\tif(lst.size()==29)\n\t\treturn true;\n\tif(lst.size()==30)\n\t\treturn true;\n\tif(lst.size()==31)\n\t\treturn true;\n\tif(lst.size()==32)\n\t\treturn true;\n\tif(lst.size()==33)\n\t\treturn true;\n\tif(lst.size()==34)\n\t\treturn true;\n\tif(lst.size()==35)\n\t\treturn true;\n\tif(lst.size()==36)\n\t\treturn true;\n\tif(lst.size()==37)\n\t\treturn true;\n\tif(lst.size()==38)\n\t\treturn true;\n\tif(lst.size()==39)\n\t\treturn true;\n\tif(lst.size()==40)\n\t\treturn true;\n\tif(lst.size()==41)\n\t\treturn true;\n\tif(lst.size()==42)\n\t\treturn true;\n\tif(lst.size()==43)\n\t\treturn true;\n\tif(lst.size()==44)\n\t\treturn true;\n\tif(lst.size()==45)\n\t\treturn true;\n\tif(lst.size()==46)\n\t\treturn true;\n\tif(lst.size()==47)\n\t\treturn true;\n\tif(lst.size()==48)\n\t\treturn true;\n\tif(lst.size()==49)\n\t\treturn true;\n\tif(lst.size()==50)\n\t\treturn true;\n\tif(lst.size()==51)\n\t\treturn true;\n\tif(lst.size()==52)\n\t\treturn true;\n\tif(lst.size()==53)\n\t\treturn true;\n\tif(lst.size()==54)\n\t\treturn true;\n\tif(lst.size()==55)\n\t\treturn true;\n\tif(lst.size()==56)\n\t\treturn true;\n\tif(lst.size()==57)\n\t\treturn true;\n\tif(lst.size()==58)\n\t\treturn true;\n\tif(lst.size()==59)\n\t\treturn true;\n\tif(lst.size()==60)\n\t\treturn true;\n\tif(lst.size()==61)\n\t\treturn true;\n\tif(lst.size()==62)\n\t\treturn true;\n\tif(lst.size()==63)\n\t\treturn true;\n\tif(lst.size()==64)\n\t\treturn true;\n\tif(lst.size()==65)\n\t\treturn true;\n\tif(lst.size()==66)\n\t\treturn true;\n\tif(lst.size()==67)\n\t\treturn true;\n\tif(lst.size()==68)\n\t\treturn true;\n\tif(lst.size()==69)\n\t\treturn true;\n\tif(lst.size()==70)\n\t\treturn true;\n\tif(lst.size()==71)\n\t\treturn true;\n\tif(lst.size()==72)\n\t\treturn true;\n\tif(lst.size()==73)\n\t\treturn true;\n\tif(lst.size()", "passed": 0, "run_status": 2}
{"task_id": "CPP/127", "prompt": "/*\nYou are given render two intervals time interval, \n where each interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\nThe given intervals are closed which means that the interval (start, end)\nincludes both start and end.\nFor each given interval, it is assumed that its start is less or equal its end.\nYour task is to determine whether the length of intersection of these two \nintervals is a prime number.\nExample, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\nwhich its length is 1, which not a prime number.\nIf the length of the intersection is a prime number, return \"YES\",\notherwise, return \"NO\".\nIf the two intervals don't intersect, return \"NO\".\n\n\n{input/output} samples:\nintersection({1, 2}, {2, 3}) ==> \"NO\"\nintersection({-1, 1}, {0, 4}) ==> \"NO\"\nintersection({-3, -1}, {-5, 5}) ==> \"YES\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring intersection( vector<int> interval1,vector<int> interval2){\n", "canonical_solution": "    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (intersection({1, 2}, {2, 3}) == \"NO\");\n    assert (intersection({-1, 1}, {0, 4}) == \"NO\");\n    assert (intersection({-3, -1}, {-5, 5}) == \"YES\");\n    assert (intersection({-2, 2}, {-4, 0}) == \"YES\");\n    assert (intersection({-11, 2}, {-1, -1}) == \"NO\");\n    assert (intersection({1, 2}, {3, 5}) == \"NO\");\n    assert (intersection({1, 2}, {1, 2}) == \"NO\");\n    assert (intersection({-2, -2}, {-3, -2}) == \"NO\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (intersection({1, 2}, {2, 3}) == \"NO\");\n    assert (intersection({-1, 1}, {0, 4}) == \"NO\");\n    assert (intersection({-3, -1}, {-5, 5}) == \"YES\");\n}\n", "entry_point": "intersection", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render two intervals time interval, \n where each interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\nThe given intervals are closed which means that the interval (start, end)\nincludes both start and end.\nFor each given interval, it is assumed that its start is less or equal its end.\nYour task is to determine whether the length of intersection of these two \nintervals is a prime number.\nExample, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\nwhich its length is 1, which not a prime number.\nIf the length of the intersection is a prime number, return \"YES\",\notherwise, return \"NO\".\nIf the two intervals don't intersect, return \"NO\".\n\n\n{input/output} samples:\nintersection({1, 2}, {2, 3}) ==> \"NO\"\nintersection({-1, 1}, {0, 4}) ==> \"NO\"\nintersection({-3, -1}, {-5, 5}) ==> \"YES\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int i = 0, j = 0;\n    while(i < interval1.size() && j < interval2.size()){\n        if(interval1[i] <= interval2[j]){\n            i++;\n        }else{\n            j++;\n        }\n    }\n    if(i == interval1.size() && j == interval2.size()){\n        return \"YES\";\n    }else{\n        return \"NO\";\n    }\n}\nint main(){\n    vector<int> interval1, interval2;\n    int n;\n    while(scanf(\"%d\", &n)!= EOF){\n        for(int i = 0; i < n; i++){\n            scanf(\"%d\", &interval1[i]);\n        }\n        scanf(\"%d\", &n);\n        for(int i = 0; i < n; i++){\n            scanf(\"%d\", &interval2[i]);\n        }\n        printf(\"%s\\n\", intersection(interval1, interval2).c_str());\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/128", "prompt": "/*\nYou are given render a vector arr of integers integer and you need to return\nsum of magnitudes order of magnitude of integers multiplied breed by product merchandise of all signs \n of each number in the vector, represented defend by 1, -1 or 0. \n Note eminence: return -32768 for empty arr.\n\nExample:\n>>> prod_signs({1, 2, 2, -4}) == -9\n>>> prod_signs({0, 1}) == 0\n>>> prod_signs({}) == -32768\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint prod_signs(vector<int> arr){\n", "canonical_solution": "    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prod_signs({1, 2, 2, -4}) == -9);\n    assert (prod_signs({0, 1}) == 0);\n    assert (prod_signs({1, 1, 1, 2, 3, -1, 1}) == -10);\n    assert (prod_signs({}) == -32768);\n    assert (prod_signs({2, 4,1, 2, -1, -1, 9}) == 20);\n    assert (prod_signs({-1, 1, -1, 1}) == 4);\n    assert (prod_signs({-1, 1, 1, 1}) == -4);\n    assert (prod_signs({-1, 1, 1, 0}) == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prod_signs({1, 2, 2, -4}) == -9);\n    assert (prod_signs({0, 1}) == 0);\n    assert (prod_signs({}) == -32768);\n}\n", "entry_point": "prod_signs", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a vector arr of integers integer and you need to return\nsum of magnitudes order of magnitude of integers multiplied breed by product merchandise of all signs \n of each number in the vector, represented defend by 1, -1 or 0. \n Note eminence: return -32768 for empty arr.\n\nExample:\n>>> prod_signs({1, 2, 2, -4}) == -9\n>>> prod_signs({0, 1}) == 0\n>>> prod_signs({}) == -32768\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint prod_signs(vector<int> arr){\n\tint prod_signs=0;\n\tfor(int i=0; i<arr.size(); i++){\n\t\tprod_signs+=arr[i];\n\t}\n\treturn prod_signs;\n}\nint main(){\n\tvector<int> arr;\n\tarr.push_back(1);\n\tarr.push_back(2);\n\tarr.push_back(2);\n\tarr.push_back(-4);\n\tarr.push_back(0);\n\tarr.push_back(1);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\tarr.push_back(0);\n\t", "passed": 0, "run_status": 1}
{"task_id": "CPP/129", "prompt": "/*\nGiven render a grid with N rows row and N columns (N > = 2) and a positive incontrovertible integer k, \n each cell of the grid contains control a value. Every integer in the range scope { 1, N * N } \n inclusive appears exactly once on the cells cell of the grid.\n\nYou have to find detect the minimum path of length k in the grid. You can start \n from any cell cellular telephone, and in each step dance step you can move to any of the neighbor cells cellular telephone, \n in other words, you can go to cells cellular telephone which share an edge boundary with you current \n cell cellular telephone. \n Please note notice that a path of length duration k means think of visiting exactly k cells cell (not \n necessarily distinct). \n You CANNOT go off the grid.\nA path A (of length k) is considered less than a path way B (of length k) if \n after making the ordered vectors vector of the values value on the cells cellular telephone that A ampere and B barn go die \n through (let's call them lst_A and lst_B), lst_A is lexicographically less \n than lst_B, in other words bible, there exist an integer index i (1 < = i < = k)\nsuch that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n lst_A[j ] = lst_B[j ]. \n It is guaranteed undertake that the answer is unique. \n Return an ordered coherent vector of the values on the cells cell that the minimum minimal path go through.\n\nExamples:\n\n    Input: grid = { {1,2,3}, {4,5,6}, {7,8,9}}, k = 3\n    Output: {1, 2, 1}\n\n    Input: grid = { {5,9,3}, {4,1,6}, {7,8,2}}, k = 1\n    Output: {1}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> minPath(vector<vector<int>> grid, int k){\n", "canonical_solution": "    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1}));\n    assert (issame(minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1) , {1}));\n    assert (issame(minPath({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4) , {1, 2, 1, 2}));\n    assert (issame(minPath({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7) , {1, 10, 1, 10, 1, 10, 1}));\n    assert (issame(minPath({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5) , {1, 7, 1, 7, 1}));\n    assert (issame(minPath({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9) , {1, 6, 1, 6, 1, 6, 1, 6, 1}));\n    assert (issame(minPath({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12) , {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6}));\n    assert (issame(minPath({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8) , {1, 3, 1, 3, 1, 3, 1, 3}));\n    assert (issame(minPath({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8) , {1, 5, 1, 5, 1, 5, 1, 5}));\n    assert (issame(minPath({{1, 2}, {3, 4}}, 10) , {1, 2, 1, 2, 1, 2, 1, 2, 1, 2}));\n    assert (issame(minPath({{1, 3}, {3, 2}}, 10) , {1, 3, 1, 3, 1, 3, 1, 3, 1, 3}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1}));\n    assert (issame(minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1) , {1}));\n}\n", "entry_point": "minPath", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a grid with N rows row and N columns (N > = 2) and a positive incontrovertible integer k, \n each cell of the grid contains control a value. Every integer in the range scope { 1, N * N } \n inclusive appears exactly once on the cells cell of the grid.\n\nYou have to find detect the minimum path of length k in the grid. You can start \n from any cell cellular telephone, and in each step dance step you can move to any of the neighbor cells cellular telephone, \n in other words, you can go to cells cellular telephone which share an edge boundary with you current \n cell cellular telephone. \n Please note notice that a path of length duration k means think of visiting exactly k cells cell (not \n necessarily distinct). \n You CANNOT go off the grid.\nA path A (of length k) is considered less than a path way B (of length k) if \n after making the ordered vectors vector of the values value on the cells cellular telephone that A ampere and B barn go die \n through (let's call them lst_A and lst_B), lst_A is lexicographically less \n than lst_B, in other words bible, there exist an integer index i (1 < = i < = k)\nsuch that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n lst_A[j ] = lst_B[j ]. \n It is guaranteed undertake that the answer is unique. \n Return an ordered coherent vector of the values on the cells cell that the minimum minimal path go through.\n\nExamples:\n\n    Input: grid = { {1,2,3}, {4,5,6}, {7,8,9}}, k = 3\n    Output: {1, 2, 1}\n\n    Input: grid = { {5,9,3}, {4,1,6}, {7,8,2}}, k = 1\n    Output: {1}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> minPath(vector<vector<int>> grid, int k){\n    vector<int> ans;\n    int n = grid.size();\n    if(n == 0) return ans;\n    int m = grid[0].size();\n    if(m == 0) return ans;\n    int i, j;\n    for(i = 0; i < n; i++){\n        for(j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n                ans.push_back(i);\n                ans.push_back(j);\n                ans.push_back(k);\n                ans.push_back(grid[i][j]);\n                break;\n            }\n        }\n    }\n    return ans;\n}\nint main(){\n    vector<vector<int>> grid;\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    grid.resize(n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", &grid[i].resize(n));\n    }\n    vector<int> ans = minPath(grid, k);\n    for(int i = 0; i < ans.size(); i+=4){\n        printf(\"%d %d %d %d\\n\", ans[i], ans[i+1], ans[i+2], ans[i+3]);\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/13", "prompt": "/*\nReturn restitution a greatest great common divisor of two integers integer a and b\n>>> greatest_common_divisor(3, 5)\n1\n>>> greatest_common_divisor(25, 15)\n5\n*/\n#include<stdio.h>\nusing namespace std;\nint greatest_common_divisor(int a, int b){\n", "canonical_solution": "    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (greatest_common_divisor(3, 7) == 1);\n     assert (greatest_common_divisor(10, 15) == 5);\n      assert (greatest_common_divisor(49, 14) == 7);\n     assert (greatest_common_divisor(144, 60) == 12);\n}\n", "declaration": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (greatest_common_divisor(3, 5) == 1);\n     assert (greatest_common_divisor(25, 15) == 5);\n}\n", "entry_point": "greatest_common_divisor", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution a greatest great common divisor of two integers integer a and b\n>>> greatest_common_divisor(3, 5)\n1\n>>> greatest_common_divisor(25, 15)\n5\n*/\n#include<stdio.h>\nusing namespace std;\nint greatest_common_divisor(int a, int b){\n\tint c = a;\n\twhile(b!= 0){\n\t\ta = b;\n\t\tb = a % b;\n\t}\n\treturn a;\n}\nint main(){\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%d\\n\", greatest_common_divisor(a, b));\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/130", "prompt": "/*\nEveryone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n the last concluding couple centuries century. However, what people don't know is Tribonacci sequence succession. \n Tribonacci sequence succession is defined by the recurrence: \n tri(1) = 3 \n tri(n) = 1 + n / 2, if n is even. \n tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\nFor example:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n       = 2 + 3 + 3 = 8 \nYou are given a non-negative integer number n, you have to a return a vector of the \nfirst n + 1 numbers of the Tribonacci sequence.\nExamples:\ntri(3) = {1, 3, 2, 8}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> tri(int n){\n", "canonical_solution": "    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(tri(3) , {1, 3, 2, 8}));\n    assert (issame(tri(4) , {1, 3, 2, 8, 3}));\n    assert (issame(tri(5) , {1, 3, 2, 8, 3, 15}));\n    assert (issame(tri(6) , {1, 3, 2, 8, 3, 15, 4}));\n    assert (issame(tri(7) , {1, 3, 2, 8, 3, 15, 4, 24}));\n    assert (issame(tri(8) , {1, 3, 2, 8, 3, 15, 4, 24, 5}));\n    assert (issame(tri(9) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35}));\n    assert (issame(tri(20) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11}));\n    assert (issame(tri(0) , {1}));\n    assert (issame(tri(1) , {1, 3}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(tri(3) , {1, 3, 2, 8}));\n}\n", "entry_point": "tri", "seed": 3, "perturbed": true, "gc": "/*\nEveryone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n the last concluding couple centuries century. However, what people don't know is Tribonacci sequence succession. \n Tribonacci sequence succession is defined by the recurrence: \n tri(1) = 3 \n tri(n) = 1 + n / 2, if n is even. \n tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\nFor example:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n       = 2 + 3 + 3 = 8 \nYou are given a non-negative integer number n, you have to a return a vector of the \nfirst n + 1 numbers of the Tribonacci sequence.\nExamples:\ntri(3) = {1, 3, 2, 8}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> tri(int n){\n    vector<int> res;\n    if(n == 0)\n        return res;\n    if(n == 1)\n        return res;\n    if(n == 2)\n        return res;\n    if(n == 3)\n        return res;\n    res.push_back(1);\n    res.push_back(3);\n    res.push_back(2);\n    res.push_back(8);\n    for(int i = 3; i <= n; i++){\n        res.push_back(res[i-2] + res[i-1]);\n    }\n    return res;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> res = tri(n);\n    for(int i = 0; i < res.size(); i++){\n        printf(\"%d \", res[i]);\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/131", "prompt": "/*\nGiven render a positive positivist integer n, return the product intersection of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits(1)  == 1\ndigits(4)  == 0\ndigits(235) == 15\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint digits(int n){\n", "canonical_solution": "    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digits(5) == 5);\n    assert (digits(54) == 5);\n    assert (digits(120) ==1);\n    assert (digits(5014) == 5);\n    assert (digits(98765) == 315);\n    assert (digits(5576543) == 2625);\n    assert (digits(2468) == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digits(1) == 1);\n    assert (digits(4) == 0);\n    assert (digits(235) ==15);\n}\n", "entry_point": "digits", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a positive positivist integer n, return the product intersection of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits(1)  == 1\ndigits(4)  == 0\ndigits(235) == 15\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint digits(int n){\n\tint res = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tres *= (n % 10);\n\t\tn /= 10;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tprintf(\"%d\\n\", digits(n));\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/132", "prompt": "/*\nCreate produce a function affair that takes a string bowed stringed instrument as input which contains control only square hearty brackets. \n The function should return true dependable if and only if there is a valid subsequence sequel of brackets \n where at least one bracket in the subsequence is nested. \n\n is_nested (\" [ [ ] ] \")  true \n is_nested (\" [ ] ] ] ] ] ] ] [ [ [ [ [ ] \")  false fake \n is_nested (\" [ ] [ ] \")  false delusive \n is_nested (\" [ ] \")  false \n is_nested (\" [ [ ] [ ] ] \")  true on-key \n is_nested (\" [ [ ] ] [ [ \")  true \n * / \n # include < stdio.h > \n # include admit < string > \n using use namespace std;\nbool is_nested(string str){\n", "canonical_solution": "    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_nested(\"[[]]\") == true);\n    assert (is_nested(\"[]]]]]]][[[[[]\") == false);\n    assert (is_nested(\"[][]\") == false);\n    assert (is_nested((\"[]\")) == false);\n    assert (is_nested(\"[[[[]]]]\") == true);\n    assert (is_nested(\"[]]]]]]]]]]\") == false);\n    assert (is_nested(\"[][][[]]\") == true);\n    assert (is_nested(\"[[]\") == false);\n    assert (is_nested(\"[]]\") == false);\n    assert (is_nested(\"[[]][[\") == true);\n    assert (is_nested(\"[[][]]\") == true);\n    assert (is_nested(\"\") == false);\n    assert (is_nested(\"[[[[[[[[\") == false);\n    assert (is_nested(\"]]]]]]]]\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_nested(\"[[]]\") == true);\n    assert (is_nested(\"[]]]]]]][[[[[]\") == false);\n    assert (is_nested(\"[][]\") == false);\n    assert (is_nested(\"[]\") == false);\n    assert (is_nested(\"[[]][[\") == true);\n    assert (is_nested(\"[[][]]\") == true);\n}\n", "entry_point": "is_nested", "seed": 3, "perturbed": true, "gc": "/*\nCreate produce a function affair that takes a string bowed stringed instrument as input which contains control only square hearty brackets. \n The function should return true dependable if and only if there is a valid subsequence sequel of brackets \n where at least one bracket in the subsequence is nested. \n\n is_nested (\" [ [ ] ] \")  true \n is_nested (\" [ ] ] ] ] ] ] ] [ [ [ [ [ ] \")  false fake \n is_nested (\" [ ] [ ] \")  false delusive \n is_nested (\" [ ] \")  false \n is_nested (\" [ [ ] [ ] ] \")  true on-key \n is_nested (\" [ [ ] ] [ [ \")  true \n * / \n # include < stdio.h > \n # include admit < string > \n using use namespace std;\nbool is_nested(string str){\n    string::iterator it;\n    for(it = str.begin(); it!= str.end(); it++){\n        if(*it == '[' && *(it+1) == '['){\n            it++;\n            while(*it!= ']' && it!= str.end()){\n                it++;\n            }\n            if(it!= str.end()){\n                if(*it == ']' && *(it+1) == ']'){\n                    it++;\n                    while(*it!= '[' && it!= str.end()){\n                        it++;\n                    }\n                    if(it!= str.end()){\n                        if(*it == '[' && *(it+1) == '['){\n                            it++;\n                            while(*it!= ']' && it!= str.end()){\n                                it++;\n                            }\n                            if(it!= str.end()){\n                                if(*it == ']' && *(it+1) == ']'){\n                                    it++;\n                                    while(*it!= '[' && it!= str.end()){\n                                        it++;\n                                    }\n                                    if(it!= str.end()){\n                                        if(*it == '[' && *(it+1) == '['){\n                                            it++;\n                                            while(*it!= ']' && it!= str.end()){\n                                                it++;\n                                            }\n                                            if(it!= str.end()){\n                                                if(*it == ']' && *(it+1) == ']'){\n                                                    it++;\n                                                    while(*it!= '[' && it!= str.end()){\n                                                        it++;\n                                                    }\n                                                    if(it!= str.end()){\n                                                        if(*it == '[' && *(it+1) == '['){\n                                                            it++;\n                                                            while(*it!= ']' && it!= str.end()){\n                                                                it++;\n                                                            }\n                                                            if(it!= str.end()){\n                                                                if(*it == ']' && *(it+1) == ']'){\n                                                                    it++;\n                                                                    while(*it!= '[' && it!= str.end()){\n                                                                        it++;\n                                                                    }\n                                                                    if(it!= str.end()){\n                                                                        if(*it == '[' && *(it+1) == '['){\n                                                                            it++;\n                                                                            while(*it!= ']' && it!= str.end()){\n                                                                                it++;\n                                                                            }\n                                                                            if(it!= str.end()){\n                                                                                if(*it == ']' && *(it+1) == ']'){\n                                                                                    it++;\n                                                                                    while(*it!= '[' && it!= str.end()){\n                                                                                        it++;\n                                                                                    }\n                                                                                    if(it!= str.end()){\n                                                                                        if(*it == '[' && *(it+1) == '['){\n                                                                                            it++;\n                                                                                            while(*it!= ']' && it!= str.end()){\n                                                                                                it++;\n                                                                                            }\n                                                                                            if(it!= str.end()){\n                                                                                                if(*it == ']' && *(it+1) == ']'){\n                                                                                                    it++;\n                                                                                                    while(*it!= '[' && it!= str.end()){\n                                                                                                        it++;\n                                                                                                    }\n                                                                                                    if(it!= str.end()){\n                                                                                                        if(*it == '[' && *(it+1) == '['){\n                                                                                                            it++;\n                                                                                                            while(*it!= ']' && it!= str.end()){\n                                                                                                                  it++;\n                                                                                                                  }\n                                                                                                                  if(it!= str.end()){\n                                                                                                                      if(*it == ']' && *(it+1) == ']'){\n                                                                                                                          it++;\n                                                                                                                          while(*it!= '[' && it!= str.end()){\n                                                                                                                             it++;\n                                                                                                                          }\n                                                                                                                          if(it!= str.end()){\n                                                                                                                             if(*it == '[' && *(it+1) == '['){\n                                                                                                                                      it++;\n                                                                                                                                      while(*it!= ']' && it!= str.end()){\n                                                                                                                                       it++;\n                                                                                                                                      }\n                                                                                                                                      if(it!= str.end()){\n                                                                                                                                           if(*it == ']' && *(it+1) == ']'){\n                                                                                                                                            it++;\n                                                                                                                                            while(*it!= '[' && it!= str.end()){\n                                                                                                                                                it++;\n                                                                                                                                                }\n                                                                                                                                                if(it!= str.end()){\n                                                                                                                                                    if(*it == '", "passed": 0, "run_status": 2}
{"task_id": "CPP/133", "prompt": "/*\nYou are given render a vector of numbers phone number. \n You need necessitate to return the sum of squared numbers in the given render vector, \n round round off each element chemical element in the vector to the upper int(Ceiling) first foremost.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\n\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<float> lst){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3})==14);\n    assert (sum_squares({1.0,2,3})==14);\n    assert (sum_squares({1,3,5,7})==84);\n    assert (sum_squares({1.4,4.2,0})==29);\n    assert (sum_squares({-2.4,1,1})==6);\n    assert (sum_squares({100,1,15,2})==10230);\n    assert (sum_squares({10000,10000})==200000000);\n    assert (sum_squares({-1.4,4.6,6.3})==75);\n    assert (sum_squares({-1.4,17.9,18.9,19.9})==1086);\n    assert (sum_squares({0})==0);\n    assert (sum_squares({-1})==1);\n    assert (sum_squares({-1,1,0})==2);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3})==14);\n    assert (sum_squares({1,4,9})==98);\n    assert (sum_squares({1,3,5,7})==84);\n    assert (sum_squares({1.4,4.2,0})==29);\n    assert (sum_squares({-2.4,1,1})==6);\n}\n", "entry_point": "sum_squares", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a vector of numbers phone number. \n You need necessitate to return the sum of squared numbers in the given render vector, \n round round off each element chemical element in the vector to the upper int(Ceiling) first foremost.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\n\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<float> lst){\n\tint sum=0;\n\tfor(int i=0;i<lst.size();i++){\n\t\tsum+=lst[i]*lst[i];\n\t}\n\treturn sum;\n}\nint main(){\n\tvector<float> lst;\n\tlst.push_back(1);\n\tlst.push_back(2);\n\tlst.push_back(3);\n\tlst.push_back(4);\n\tlst.push_back(9);\n\tlst.push_back(0);\n\tlst.push_back(1);\n\tlst.push_back(3);\n\tlst.push_back(5);\n\tlst.push_back(7);\n\tlst.push_back(1.4);\n\tlst.push_back(4.2);\n\tlst.push_back(0);\n\tlst.push_back(-2.4);\n\tlst.push_back(1);\n\tlst.push_back(1);\n\tprintf(\"%d\\n\",sum_squares(lst));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/134", "prompt": "/*\nCreate produce a function affair that returns true truthful if the last character quality \n of a given yield string chain is an alphabetical alphabetic character quality and is not \n a part of a word, and false otherwise. \n Note eminence: \" word news \" is a group of characters separated branch by space.\n\nExamples:\ncheck_if_last_char_is_a_letter(\"apple pie\")  false\ncheck_if_last_char_is_a_letter(\"apple pi e\")  true\ncheck_if_last_char_is_a_letter(\"apple pi e \")  false\ncheck_if_last_char_is_a_letter(\"\")  false \n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool check_if_last_char_is_a_letter(string txt){\n", "canonical_solution": "    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_if_last_char_is_a_letter(\"apple\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e\") == true);\n    assert (check_if_last_char_is_a_letter(\"eeeee\") == false);\n    assert (check_if_last_char_is_a_letter(\"A\") == true);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie \") == false);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie 1\") == false);\n    assert (check_if_last_char_is_a_letter(\"\") == false);\n    assert (check_if_last_char_is_a_letter(\"eeeee e \") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pie\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e \") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_if_last_char_is_a_letter(\"apple pi e\") == true);\n    assert (check_if_last_char_is_a_letter(\"\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pie\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e \") == false);\n}\n", "entry_point": "check_if_last_char_is_a_letter", "seed": 3, "perturbed": true, "gc": "/*\nCreate produce a function affair that returns true truthful if the last character quality \n of a given yield string chain is an alphabetical alphabetic character quality and is not \n a part of a word, and false otherwise. \n Note eminence: \" word news \" is a group of characters separated branch by space.\n\nExamples:\ncheck_if_last_char_is_a_letter(\"apple pie\")  false\ncheck_if_last_char_is_a_letter(\"apple pi e\")  true\ncheck_if_last_char_is_a_letter(\"apple pi e \")  false\ncheck_if_last_char_is_a_letter(\"\")  false \n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool check_if_last_char_is_a_letter(string txt){\n    if(txt.length() == 0)\n        return false;\n    if(txt.length() == 1)\n        return true;\n    if(txt.length() == 2)\n        return true;\n    if(txt.length() == 3)\n        return true;\n    if(txt.length() == 4)\n        return true;\n    if(txt.length() == 5)\n        return true;\n    if(txt.length() == 6)\n        return true;\n    if(txt.length() == 7)\n        return true;\n    if(txt.length() == 8)\n        return true;\n    if(txt.length() == 9)\n        return true;\n    if(txt.length() == 10)\n        return true;\n    if(txt.length() == 11)\n        return true;\n    if(txt.length() == 12)\n        return true;\n    if(txt.length() == 13)\n        return true;\n    if(txt.length() == 14)\n        return true;\n    if(txt.length() == 15)\n        return true;\n    if(txt.length() == 16)\n        return true;\n    if(txt.length() == 17)\n        return true;\n    if(txt.length() == 18)\n        return true;\n    if(txt.length() == 19)\n        return true;\n    if(txt.length() == 20)\n        return true;\n    if(txt.length() == 21)\n        return true;\n    if(txt.length() == 22)\n        return true;\n    if(txt.length() == 23)\n        return true;\n    if(txt.length() == 24)\n        return true;\n    if(txt.length() == 25)\n        return true;\n    if(txt.length() == 26)\n        return true;\n    if(txt.length() == 27)\n        return true;\n    if(txt.length() == 28)\n        return true;\n    if(txt.length() == 29)\n        return true;\n    if(txt.length() == 30)\n        return true;\n    if(txt.length() == 31)\n        return true;\n    if(txt.length() == 32)\n        return true;\n    if(txt.length() == 33)\n        return true;\n    if(txt.length() == 34)\n        return true;\n    if(txt.length() == 35)\n        return true;\n    if(txt.length() == 36)\n        return true;\n    if(txt.length() == 37)\n        return true;\n    if(txt.length() == 38)\n        return true;\n    if(txt.length() == 39)\n        return true;\n    if(txt.length() == 40)\n        return true;\n    if(txt.length() == 41)\n        return true;\n    if(txt.length() == 42)\n        return true;\n    if(txt.length() == 43)\n        return true;\n    if(txt.length() == 44)\n        return true;\n    if(txt.length() == 45)\n        return true;\n    if(txt.length() == 46)\n        return true;\n    if(txt.length() == 47)\n        return true;\n    if(txt.length() == 48)\n        return true;\n    if(txt.length() == 49)\n        return true;\n    if(txt.length() == 50)\n        return true;\n    if(txt.length() == 51)\n        return true;\n    if(txt.length() == 52)\n        return true;\n    if(txt.length() == 53)\n        return true;\n    if(txt.length() == 54)\n        return true;\n    if(txt.length() == 55)\n        return true;\n    if(txt.length() == 56)\n        return true;\n    if(txt.length() == 57)\n        return true;\n    if(txt.length() == 58)\n        return true;\n    if(txt.length() == 59)\n        return true;\n    if(txt.length() == 60)\n        return true;\n    if(txt.length() == 61)\n        return true;\n    if(txt.length() == 62)\n        return true;\n    if(txt.length() == 63)\n        return true;\n    if(txt.length() == 64)\n        return true;\n    if(txt.length() == 65)\n        return true;\n    if(txt.length() == 66)\n        return true;\n    if(txt.length() == 67)\n        return true;\n    if(txt.length() == 68)\n        return true;\n    if(txt.length() == 69)\n        return true;\n    if(txt.length() == 70)\n        return true;\n    if(txt.length() == 71)\n        return true;\n    if(txt.length() == 72)\n        return true;\n    if(txt.length() == 73)\n        return true;\n    if(txt.length() == 74)\n        return true;\n    if(txt.length() == 75)\n        return true;\n    if(txt.length() == 76)\n        return true;\n    if(txt.length() == 77)\n        return true;\n    if(txt.length() == 78)\n        return true;\n    if(txt.length() == 79)\n        return true;\n    if(txt.length() == 80)\n        return true;\n    if(txt.length() == 81)\n        return true;\n    if(txt.length() == 82)\n        return true;\n    if(", "passed": 0, "run_status": 2}
{"task_id": "CPP/135", "prompt": "/*\nCreate produce a function affair which returns the largest large index of an element component which \n is not greater great than or equal to the element immediately preceding precede it. If \n no such element component exists then return -1. The given vector will not contain \n duplicate values.\n\nExamples:\ncan_arrange({1,2,4,3,5}) = 3\ncan_arrange({1,2,3}) = -1\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint can_arrange(vector<int> arr){\n", "canonical_solution": "    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (can_arrange({1,2,4,3,5})==3);\n    assert (can_arrange({1,2,4,5})==-1);\n    assert (can_arrange({1,4,2,5,6,7,8,9,10})==2);\n    assert (can_arrange({4,8,5,7,3})==4);\n    assert (can_arrange({})==-1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (can_arrange({1,2,4,3,5})==3);\n    assert (can_arrange({1,2,3})==-1);\n}\n", "entry_point": "can_arrange", "seed": 3, "perturbed": true, "gc": "/*\nCreate produce a function affair which returns the largest large index of an element component which \n is not greater great than or equal to the element immediately preceding precede it. If \n no such element component exists then return -1. The given vector will not contain \n duplicate values.\n\nExamples:\ncan_arrange({1,2,4,3,5}) = 3\ncan_arrange({1,2,3}) = -1\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint can_arrange(vector<int> arr){\n    int n = arr.size();\n    int l = 0, r = n-1;\n    while(l < r){\n        int m = (l+r)/2;\n        int cnt = 0;\n        for(int i = 0; i < n; i++){\n            if(arr[i] > arr[m]){\n                cnt++;\n            }\n        }\n        if(cnt > 0){\n            l = m+1;\n        }else{\n            r = m;\n        }\n    }\n    return l;\n}\nint main(){\n    vector<int> arr = {1,2,4,3,5};\n    printf(\"%d\\n\", can_arrange(arr));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/136", "prompt": "/*\nCreate produce a function affair that returns a vector (a, b bacillus), where \" a \" is \n the largest of negative minus integers integer, and \" b \" is the smallest \n of positive integers integer in a vector. \n If there is no negative minus or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers({}) == {0,0}\nlargest_smallest_integers({0}) == {0,0}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> largest_smallest_integers(vector<int> lst){\n", "canonical_solution": "    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7}) , {0, 1}));\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7, 0}) , {0, 1}));\n    assert (issame(largest_smallest_integers({1, 3, 2, 4, 5, 6, -2}) , {-2, 1}));\n    assert (issame(largest_smallest_integers({4, 5, 3, 6, 2, 7, -7}) , {-7, 2}));\n    assert (issame(largest_smallest_integers({7, 3, 8, 4, 9, 2, 5, -9}) , {-9, 2}));\n    assert (issame(largest_smallest_integers({}) , {0, 0}));\n    assert (issame(largest_smallest_integers({0}) , {0, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6, 0}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, 1}) , {-3, 1}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, -100, 1}) , {-3, 1}));\n\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7}) , {0, 1}));\n    assert (issame(largest_smallest_integers({}) , {0, 0}));\n    assert (issame(largest_smallest_integers({0}) , {0, 0}));\n}\n", "entry_point": "largest_smallest_integers", "seed": 3, "perturbed": true, "gc": "/*\nCreate produce a function affair that returns a vector (a, b bacillus), where \" a \" is \n the largest of negative minus integers integer, and \" b \" is the smallest \n of positive integers integer in a vector. \n If there is no negative minus or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers({}) == {0,0}\nlargest_smallest_integers({0}) == {0,0}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> largest_smallest_integers(vector<int> lst){\n\tvector<int> ret;\n\tint max = 0, min = 0;\n\tfor(int i = 0; i < lst.size(); i++){\n\t\tif(lst[i] < 0){\n\t\t\tret.push_back(max);\n\t\t\tmax = lst[i];\n\t\t}else if(lst[i] > 0){\n\t\t\tret.push_back(min);\n\t\t\tmin = lst[i];\n\t\t}else{\n\t\t\tret.push_back(0);\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tvector<int> lst;\n\tlst.push_back(2);\n\tlst.push_back(4);\n\tlst.push_back(1);\n\tlst.push_back(3);\n\tlst.push_back(5);\n\tlst.push_back(7);\n\tvector<int> ret = largest_smallest_integers(lst);\n\tfor(int i = 0; i < ret.size(); i++){\n\t\tprintf(\"%d \", ret[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/137", "prompt": "/*\nCreate produce a function affair that takes integers integer, floats, or strings string section representing exemplify \n real numbers, and returns revert the larger bigger variable in its given variable type. \n Return restitution \" None \" if the values value are equal. \n Note bill: If a real number is represented exemplify as a string, the floating point period might be. or, \n\n compare_one(1, 2.5)  2.5 \n compare_one(1, \" 2,3 \")  \" 2,3 \" \n compare_one(\"5,1 \", \" 6 \")  \" 6 \" \n compare_one(\"1 \", 1)  \" None \" \n * / \n # include admit < stdio.h > \n # include admit < string > \n # include admit < algorithm > \n # include admit < boost / any.hpp > \n using namespace std;\nboost::any compare_one(boost::any a,boost::any b){\n", "canonical_solution": "    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (boost::any_cast<int>(compare_one(1, 2)) == 2);\n    assert (boost::any_cast<double>(compare_one(1, 2.5))== 2.5);\n    assert (boost::any_cast<int>(compare_one(2, 3)) == 3);\n    assert (boost::any_cast<int>(compare_one(5, 6)) == 6);\n    assert (boost::any_cast<string>(compare_one(1, string(\"2,3\")))== \"2,3\");\n    assert (boost::any_cast<string>(compare_one(string(\"5,1\"), string(\"6\"))) == \"6\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), string(\"2\"))) == \"2\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), 1)) == \"None\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (boost::any_cast<double>(compare_one(1, 2.5))== 2.5);\n    assert (boost::any_cast<string>(compare_one(1, string(\"2,3\")))== \"2,3\");\n    assert (boost::any_cast<string>(compare_one(string(\"5,1\"), string(\"6\"))) == \"6\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), 1)) == \"None\");\n}\n", "entry_point": "compare_one", "seed": 3, "perturbed": true, "gc": "/*\nCreate produce a function affair that takes integers integer, floats, or strings string section representing exemplify \n real numbers, and returns revert the larger bigger variable in its given variable type. \n Return restitution \" None \" if the values value are equal. \n Note bill: If a real number is represented exemplify as a string, the floating point period might be. or, \n\n compare_one(1, 2.5)  2.5 \n compare_one(1, \" 2,3 \")  \" 2,3 \" \n compare_one(\"5,1 \", \" 6 \")  \" 6 \" \n compare_one(\"1 \", 1)  \" None \" \n * / \n # include admit < stdio.h > \n # include admit < string > \n # include admit < algorithm > \n # include admit < boost / any.hpp > \n using namespace std;\nboost::any compare_one(boost::any a,boost::any b){\n\tif(a.type() == b.type()){\n\t\tif(a.type() == boost::any::typeid(int)){\n\t\t\treturn boost::any(a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int)? a.type() == boost::any::typeid(int", "passed": 0, "run_status": 2}
{"task_id": "CPP/138", "prompt": "/*\nEvaluate measure whether the given collapse number phone number n can be written as the sum of exactly precisely 4 positive cocksure even numbers\nExample\nis_equal_to_sum_even(4) == false\nis_equal_to_sum_even(6) == false\nis_equal_to_sum_even(8) == true\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_equal_to_sum_even(int n){\n", "canonical_solution": "    if (n%2==0 and n>=8) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_equal_to_sum_even(4) == false);\n    assert (is_equal_to_sum_even(6) == false);\n    assert (is_equal_to_sum_even(8) == true);\n    assert (is_equal_to_sum_even(10) == true);\n    assert (is_equal_to_sum_even(11) == false);\n    assert (is_equal_to_sum_even(12) == true);\n    assert (is_equal_to_sum_even(13) == false);\n    assert (is_equal_to_sum_even(16) == true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_equal_to_sum_even(4) == false);\n    assert (is_equal_to_sum_even(6) == false);\n    assert (is_equal_to_sum_even(8) == true);\n}\n", "entry_point": "is_equal_to_sum_even", "seed": 3, "perturbed": true, "gc": "/*\nEvaluate measure whether the given collapse number phone number n can be written as the sum of exactly precisely 4 positive cocksure even numbers\nExample\nis_equal_to_sum_even(4) == false\nis_equal_to_sum_even(6) == false\nis_equal_to_sum_even(8) == true\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_equal_to_sum_even(int n){\n\tint sum=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i%4==0)\n\t\t\tsum+=i;\n\t}\n\tif(sum%2==0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tprintf(\"%s\\n\",is_equal_to_sum_even(n)? \"true\":\"false\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/139", "prompt": "/*\nThe Brazilian factorial is defined define as: \n brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n where n > 0 \n\n For example exercise:\n>>> special_factorial(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n*/\n#include<stdio.h>\nusing namespace std;\nlong long special_factorial(int n){\n", "canonical_solution": "    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (special_factorial(4) == 288);\n    assert (special_factorial(5) == 34560);\n    assert (special_factorial(7) == 125411328000);\n    assert (special_factorial(1) == 1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (special_factorial(4) == 288);\n}\n", "entry_point": "special_factorial", "seed": 3, "perturbed": true, "gc": "/*\nThe Brazilian factorial is defined define as: \n brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n where n > 0 \n\n For example exercise:\n>>> special_factorial(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n*/\n#include<stdio.h>\nusing namespace std;\nlong long special_factorial(int n){\n\tif(n==0)\n\t\treturn 1;\n\telse\n\t\treturn n*special_factorial(n-1);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tprintf(\"%lld\\n\",special_factorial(n));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/14", "prompt": "/*\nReturn restitution vector of all prefixes prefix from shortest to longest of the input input signal string\n>>> all_prefixes(\"abc\")\n{\"a\", \"ab\", \"abc\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> all_prefixes(string str){\n", "canonical_solution": "    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(all_prefixes(\"\"),{}));\n    assert (issame(all_prefixes(\"asdfgh\") ,{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"}));\n     assert (issame(all_prefixes(\"WWW\") ,{\"W\", \"WW\", \"WWW\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(all_prefixes(\"abc\"),{\"a\",\"ab\",\"abc\"}));\n}\n", "entry_point": "all_prefixes", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution vector of all prefixes prefix from shortest to longest of the input input signal string\n>>> all_prefixes(\"abc\")\n{\"a\", \"ab\", \"abc\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for(int i=0; i<str.size(); i++){\n        for(int j=0; j<str.size(); j++){\n            if(str[i]==str[j]){\n                prefixes.push_back(str.substr(0, i+1));\n                break;\n            }\n        }\n    }\n    return prefixes;\n}\n\nint main(){\n    string str;\n    vector<string> prefixes;\n    while(getline(cin, str)){\n        prefixes = all_prefixes(str);\n        for(int i=0; i<prefixes.size(); i++){\n            printf(\"%s\\n\", prefixes[i].c_str());\n        }\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/140", "prompt": "/*\nGiven render a string chain text, replace substitute all spaces in it with underscores, \n and if a string chain has more than 2 consecutive straight spaces, \n then replace all consecutive back-to-back spaces space with - \n\n fix_spaces (\"Example\") == \"Example\"\nfix_spaces(\"Example 1\") == \"Example_1\"\nfix_spaces(\" Example 2\") == \"_Example_2\"\nfix_spaces(\" Example   3\") == \"_Example-3\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring fix_spaces(string text){\n", "canonical_solution": "    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fix_spaces(\"Example\") == \"Example\");\n    assert (fix_spaces(\"Mudasir Hanif \") == \"Mudasir_Hanif_\");\n    assert (fix_spaces(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\");\n    assert (fix_spaces(\"Exa   mple\") == \"Exa-mple\");\n    assert (fix_spaces(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\");\n}\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fix_spaces(\"Example\") == \"Example\");\n    assert (fix_spaces(\"Example 1\") == \"Example_1\");\n    assert (fix_spaces(\" Example 2\") == \"_Example_2\");\n    assert (fix_spaces(\" Example   3\") == \"_Example-3\");\n}\n", "entry_point": "fix_spaces", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a string chain text, replace substitute all spaces in it with underscores, \n and if a string chain has more than 2 consecutive straight spaces, \n then replace all consecutive back-to-back spaces space with - \n\n fix_spaces (\"Example\") == \"Example\"\nfix_spaces(\"Example 1\") == \"Example_1\"\nfix_spaces(\" Example 2\") == \"_Example_2\"\nfix_spaces(\" Example   3\") == \"_Example-3\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring fix_spaces(string text){\n\tstring result;\n\tint i = 0;\n\tint j = 0;\n\twhile(i < text.length()){\n\t\tif(text[i] ==''){\n\t\t\tif(j == 0){\n\t\t\t\tresult += '_';\n\t\t\t}else if(j == 1){\n\t\t\t\tresult += '-';\n\t\t\t}else{\n\t\t\t\tresult +='';\n\t\t\t}\n\t\t\tj++;\n\t\t}else{\n\t\t\tresult += text[i];\n\t\t\tj = 0;\n\t\t}\n\t\ti++;\n\t}\n\treturn result;\n}\nint main(){\n\tstring text = \"Example\";\n\tstring result = fix_spaces(text);\n\tprintf(\"%s\\n\", result.c_str());\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/141", "prompt": "/*\nCreate produce a function affair which takes a string bowed stringed instrument representing a file's name, and returns hark back \n \" Yes \" if the the file's name is valid, and returns retort \" No \" otherwise. \n A file's name is considered to be valid if and only if all the following watch conditions weather \n are met converge: \n - There should not be more than three digits (' 0'-'9') in the file's name. \n - The file's name contains exactly precisely one dot acid \". \" \n - The substring before the dot should not be empty, and it starts get down with a letter from \n the latin alphapet (' a'-'z' and' A'-'Z'). \n - The substring after the dot should be one of these: {' txt \", \" exe \", \" dll \" }\nExamples:\nfile_name_check(\"example.txt\") => \"Yes\"\nfile_name_check(\"1example.dll\")  => \"No\" // (the name should start with a latin alphapet letter)\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring file_name_check(string file_name){\n", "canonical_solution": "    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (file_name_check(\"example.txt\") == \"Yes\");\n    assert (file_name_check(\"1example.dll\") == \"No\");\n    assert (file_name_check(\"s1sdf3.asd\") == \"No\");\n    assert (file_name_check(\"K.dll\") == \"Yes\");\n    assert (file_name_check(\"MY16FILE3.exe\") == \"Yes\");\n    assert (file_name_check(\"His12FILE94.exe\") == \"No\");\n    assert (file_name_check(\"_Y.txt\") == \"No\");\n    assert (file_name_check(\"?aREYA.exe\") == \"No\");\n    assert (file_name_check(\"/this_is_valid.dll\") == \"No\");\n    assert (file_name_check(\"this_is_valid.wow\") == \"No\");\n    assert (file_name_check(\"this_is_valid.txt\") == \"Yes\");\n    assert (file_name_check(\"this_is_valid.txtexe\") == \"No\");\n    assert (file_name_check(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert (file_name_check(\"@this1_is6_valid.exe\") == \"No\");\n    assert (file_name_check(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert (file_name_check(\"all.exe.txt\") == \"No\");\n    assert (file_name_check(\"I563_No.exe\") == \"Yes\");\n    assert (file_name_check(\"Is3youfault.txt\") == \"Yes\");\n    assert (file_name_check(\"no_one#knows.dll\") == \"Yes\");\n    assert (file_name_check(\"1I563_Yes3.exe\") == \"No\");\n    assert (file_name_check(\"I563_Yes3.txtt\") == \"No\");\n    assert (file_name_check(\"final..txt\") == \"No\");\n    assert (file_name_check(\"final132\") == \"No\");\n    assert (file_name_check(\"_f4indsartal132.\") == \"No\");\n    assert (file_name_check(\".txt\") == \"No\");\n    assert (file_name_check(\"s.\") == \"No\");\n}\n", "declaration": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (file_name_check(\"example.txt\") == \"Yes\");\n    assert (file_name_check(\"1example.dll\") == \"No\");\n}\n", "entry_point": "file_name_check", "seed": 3, "perturbed": true, "gc": "/*\nCreate produce a function affair which takes a string bowed stringed instrument representing a file's name, and returns hark back \n \" Yes \" if the the file's name is valid, and returns retort \" No \" otherwise. \n A file's name is considered to be valid if and only if all the following watch conditions weather \n are met converge: \n - There should not be more than three digits (' 0'-'9') in the file's name. \n - The file's name contains exactly precisely one dot acid \". \" \n - The substring before the dot should not be empty, and it starts get down with a letter from \n the latin alphapet (' a'-'z' and' A'-'Z'). \n - The substring after the dot should be one of these: {' txt \", \" exe \", \" dll \" }\nExamples:\nfile_name_check(\"example.txt\") => \"Yes\"\nfile_name_check(\"1example.dll\")  => \"No\" // (the name should start with a latin alphapet letter)\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring file_name_check(string file_name){\n\tif(file_name.length()>3){\n\t\tif(file_name.find(\".\")!=string::npos){\n\t\t\tif(file_name.find(\".\")==0){\n\t\t\t\tif(file_name.find(\".\")==file_name.length()-1){\n\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-2){\n\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-3){\n\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-4){\n\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-5){\n\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-6){\n\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-7){\n\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-8){\n\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-9){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-10){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-11){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-12){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-13){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-14){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-15){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-16){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-17){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-18){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-19){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-20){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-21){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-22){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-23){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-24){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-25){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-26){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-27){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-28){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-29){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-30){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-31){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-32){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-33){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-34){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-35){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-36){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-37){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-38){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-39){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-40){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-41){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-42){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-43){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-44){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-45){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(file_name.find(\".\")==file_name.length()-46){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "passed": 0, "run_status": 2}
{"task_id": "CPP/142", "prompt": "/*\n\" \n This function routine will take carry a vector of integers integer. For all entries in the vector, the function shall square feather the integer entry introduction if its index exponent is a \n multiple of 3 and will cube the integer entry entrance if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n change the entries in the vector whose indexes are not a multiple of 3 or 4. The function routine shall then return the sum of all entries introduction. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<int> lst){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3}) == 6);\n    assert (sum_squares({1,4,9}) == 14);\n    assert (sum_squares({}) == 0);\n    assert (sum_squares({1,1,1,1,1,1,1,1,1}) == 9);\n    assert (sum_squares({-1,-1,-1,-1,-1,-1,-1,-1,-1}) == -3);\n    assert (sum_squares({0}) == 0);\n    assert (sum_squares({-1,-5,2,-1,-5}) == -126);\n    assert (sum_squares({-56,-99,1,0,-2}) == 3030);\n    assert (sum_squares({-1,0,0,0,0,0,0,0,-1}) == 0);\n    assert (sum_squares({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}) == -14196);\n    assert (sum_squares({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}) == -1448);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3}) == 6);\n    assert (sum_squares({}) == 0);\n    assert (sum_squares({-1,-5,2,-1,-5}) == -126);\n}\n", "entry_point": "sum_squares", "seed": 3, "perturbed": true, "gc": "/*\n\" \n This function routine will take carry a vector of integers integer. For all entries in the vector, the function shall square feather the integer entry introduction if its index exponent is a \n multiple of 3 and will cube the integer entry entrance if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n change the entries in the vector whose indexes are not a multiple of 3 or 4. The function routine shall then return the sum of all entries introduction. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<int> lst){\n\tint sum = 0;\n\tfor(int i=0; i<lst.size(); i++){\n\t\tif(i%3 == 0){\n\t\t\tsum += lst[i]*lst[i];\n\t\t}\n\t\telse if(i%4 == 0){\n\t\t\tsum += lst[i]*lst[i];\n\t\t}\n\t}\n\treturn sum;\n}\nint main(){\n\tvector<int> lst;\n\tlst.push_back(1);\n\tlst.push_back(2);\n\tlst.push_back(3);\n\tlst.push_back(-1);\n\tlst.push_back(-5);\n\tlst.push_back(2);\n\tlst.push_back(-1);\n\tlst.push_back(-5);\n\tprintf(\"%d\\n\", sum_squares(lst));\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/143", "prompt": "/*\nYou are given render a string chain representing act a sentence,\nthe sentence contains some words separated branch by a space outer space, \n and you have to return a string chain that contains contain the words quarrel from the original sentence,\nwhose lengths are prime numbers, \n the order of the words bible in the new modern string should be the same as the original one.\n\nExample 1:\n    Input: sentence = \"This is a test\"\n    Output: \"is\"\n\nExample 2:\n    Input: sentence = \"lets go for swimming\"\n    Output: \"go for\"\n\nConstraints:\n    * 1 <= len(sentence) <= 100\n    * sentence contains only letters\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring words_in_sentence(string sentence){\n", "canonical_solution": "    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (words_in_sentence(\"This is a test\") == \"is\");\n    assert (words_in_sentence(\"lets go for swimming\") == \"go for\");\n    assert (words_in_sentence(\"there is no place available here\") == \"there is no place\");\n    assert (words_in_sentence(\"Hi I am Hussein\") == \"Hi am Hussein\");\n    assert (words_in_sentence(\"go for it\") == \"go for it\");\n    assert (words_in_sentence(\"here\") == \"\");\n    assert (words_in_sentence(\"here is\") == \"is\");\n}\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (words_in_sentence(\"This is a test\") == \"is\");\n    assert (words_in_sentence(\"lets go for swimming\") == \"go for\");\n}\n", "entry_point": "words_in_sentence", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a string chain representing act a sentence,\nthe sentence contains some words separated branch by a space outer space, \n and you have to return a string chain that contains contain the words quarrel from the original sentence,\nwhose lengths are prime numbers, \n the order of the words bible in the new modern string should be the same as the original one.\n\nExample 1:\n    Input: sentence = \"This is a test\"\n    Output: \"is\"\n\nExample 2:\n    Input: sentence = \"lets go for swimming\"\n    Output: \"go for\"\n\nConstraints:\n    * 1 <= len(sentence) <= 100\n    * sentence contains only letters\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring words_in_sentence(string sentence){\n    string new_sentence;\n    int len = sentence.length();\n    for(int i = 0; i < len; i++){\n        if(sentence[i] ==''){\n            new_sentence +='';\n        }else{\n            new_sentence += sentence[i];\n        }\n    }\n    return new_sentence;\n}\n\nint main(){\n    string sentence = \"This is a test\";\n    string new_sentence = words_in_sentence(sentence);\n    printf(\"%s\\n\", new_sentence.c_str());\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/144", "prompt": "/*\nYour task job is to implement follow through a function that will simplify the expression formulation \n x * n. The function returns hark back true on-key if x * n evaluates to a whole number issue and false delusive \n otherwise. Both x and n, are string representation of a fraction, and have the following format, \n < numerator>/<denominator > where both numerator and denominator are positive positivist whole unharmed numbers. \n\n You can assume bear that x, and n are valid fractions, and do not have zero as denominator. \n\n simplify(\"1/5 \", \" 5/1 \") = true \n simplify(\"1/6 \", \" 2/1 \") = false \n simplify(\"7/10 \", \" 10/2 \") = false \n * / \n # include admit < stdio.h > \n # include < string drawstring > \n using practice namespace std;\nbool simplify(string x,string n){\n", "canonical_solution": "    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/6\", \"2/1\") == false);\n    assert (simplify(\"5/1\", \"3/1\") == true);\n    assert (simplify(\"7/10\", \"10/2\") == false);\n    assert (simplify(\"2/10\", \"50/10\") == true);\n    assert (simplify(\"7/2\", \"4/2\") == true);\n    assert (simplify(\"11/6\", \"6/1\") == true);\n    assert (simplify(\"2/3\", \"5/2\") == false);\n    assert (simplify(\"5/2\", \"3/5\") == false);\n    assert (simplify(\"2/4\", \"8/4\") == true);\n    assert (simplify(\"2/4\", \"4/2\") == true);\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/5\", \"1/5\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/6\", \"2/1\") == false);\n    assert (simplify(\"7/10\", \"10/2\") == false);\n}\n", "entry_point": "simplify", "seed": 3, "perturbed": true, "gc": "/*\nYour task job is to implement follow through a function that will simplify the expression formulation \n x * n. The function returns hark back true on-key if x * n evaluates to a whole number issue and false delusive \n otherwise. Both x and n, are string representation of a fraction, and have the following format, \n < numerator>/<denominator > where both numerator and denominator are positive positivist whole unharmed numbers. \n\n You can assume bear that x, and n are valid fractions, and do not have zero as denominator. \n\n simplify(\"1/5 \", \" 5/1 \") = true \n simplify(\"1/6 \", \" 2/1 \") = false \n simplify(\"7/10 \", \" 10/2 \") = false \n * / \n # include admit < stdio.h > \n # include < string drawstring > \n using practice namespace std;\nbool simplify(string x,string n){\n\tint x_num,n_num,x_den,n_den;\n\tstringstream ss(x);\n\tss >> x_num;\n\tstringstream ss2(n);\n\tss2 >> n_num;\n\tss >> x_den;\n\tss2 >> n_den;\n\tif(x_den == 0 || n_den == 0){\n\t\treturn false;\n\t}\n\tif(x_den == 1 || n_den == 1){\n\t\treturn true;\n\t}\n\tif(x_num == 0 || n_num == 0){\n\t\treturn false;\n\t}\n\tif(x_num == 1 || n_num == 1){\n\t\treturn true;\n\t}\n\tif(x_num == n_num){\n\t\treturn true;\n\t}\n\tif(x_num == n_den){\n\t\treturn true;\n\t}\n\tif(x_den == n_num){\n\t\treturn true;\n\t}\n\tif(x_den == n_den){\n\t\treturn true;\n\t}\n\treturn false;\n}\n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * / \n * /", "passed": 0, "run_status": 2}
{"task_id": "CPP/145", "prompt": "/*\nWrite publish a function affair which sorts the given contribute vector of integers \n in ascending ascend order club according to the sum of their digits. \n Note eminence: if there are several respective items with similar sum of their digits, \n order them based free-base on their index exponent in original vector. \n\n For example:\n>>> order_by_points({1, 11, -1, -11, -12}) == {-1, -11, 1, -12, 11}\n>>> order_by_points({}) == {}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> order_by_points(vector<int> nums){\n", "canonical_solution": "    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11}));\n    assert (issame(order_by_points({1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46}) , {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n    assert (issame(order_by_points({}) , {}));\n    assert (issame(order_by_points({1, -11, -32, 43, 54, -98, 2, -3}) , {-3, -32, -98, -11, 1, 2, 43, 54}));\n    assert (issame(order_by_points({1,2,3,4,5,6,7,8,9,10,11}) , {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n    assert (issame(order_by_points({0,6,6,-76,-21,23,4}) , {-76, -21, 0, 4, 23, 6, 6}));\n    \n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11}));\n    assert (issame(order_by_points({}) , {}));\n}\n", "entry_point": "order_by_points", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair which sorts the given contribute vector of integers \n in ascending ascend order club according to the sum of their digits. \n Note eminence: if there are several respective items with similar sum of their digits, \n order them based free-base on their index exponent in original vector. \n\n For example:\n>>> order_by_points({1, 11, -1, -11, -12}) == {-1, -11, 1, -12, 11}\n>>> order_by_points({}) == {}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> order_by_points(vector<int> nums){\n\tvector<int> res;\n\tif(nums.size()==0) return res;\n\tint sum=0;\n\tfor(int i=0;i<nums.size();i++){\n\t\tsum+=nums[i];\n\t}\n\tint index=0;\n\tfor(int i=0;i<nums.size();i++){\n\t\tif(nums[i]==sum){\n\t\t\tres.push_back(nums[i]);\n\t\t\tindex=i;\n\t\t}\n\t\telse if(nums[i]>sum){\n\t\t\tres.push_back(nums[i]);\n\t\t\tindex=i;\n\t\t}\n\t}\n\tres.push_back(sum);\n\treturn res;\n}\nint main(){\n\tvector<int> nums;\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11);\n\tnums.push_back(-1);\n\tnums.push_back(-11);\n\tnums.push_back(-12);\n\tnums.push_back(1);\n\tnums.push_back(11", "passed": 0, "run_status": 1}
{"task_id": "CPP/146", "prompt": "/*\nWrite publish a function affair that takes a vector of numbers act as input and returns rejoinder \n the number numeral of elements in the vector that are greater than 10 and both \n first inaugural and last concluding digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter({15, -73, 14, -15}) => 1 \nspecialFilter({33, -2, -3, 45, 21, 109}) => 2\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint specialFilter(vector<int> nums){\n", "canonical_solution": "    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (specialFilter({5, -2, 1, -5}) == 0  );\n    assert (specialFilter({15, -73, 14, -15}) == 1);\n    assert (specialFilter({33, -2, -3, 45, 21, 109}) == 2);\n    assert (specialFilter({43, -12, 93, 125, 121, 109}) == 4);\n    assert (specialFilter({71, -2, -33, 75, 21, 19}) == 3);\n    assert (specialFilter({1}) == 0              );\n    assert (specialFilter({}) == 0                   );\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (specialFilter({15, -73, 14, -15}) == 1);\n    assert (specialFilter({33, -2, -3, 45, 21, 109}) == 2);\n}\n", "entry_point": "specialFilter", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair that takes a vector of numbers act as input and returns rejoinder \n the number numeral of elements in the vector that are greater than 10 and both \n first inaugural and last concluding digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter({15, -73, 14, -15}) => 1 \nspecialFilter({33, -2, -3, 45, 21, 109}) => 2\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint specialFilter(vector<int> nums){\n\tint count=0;\n\tfor(int i=0;i<nums.size();i++){\n\t\tif(nums[i]>10&&nums[i]%2==1&&nums[i]%3==1){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main(){\n\tvector<int> nums;\n\tint n;\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tint num;\n\t\tscanf(\"%d\",&num);\n\t\tnums.push_back(num);\n\t}\n\tprintf(\"%d\",specialFilter(nums));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/147", "prompt": "/*\nYou are given render a positive positivist integer n. You have to create produce an integer vector a of length n.\n     For each i (1  i  n), the value of a{i} = i * i - i + 1. \n     Return the number of triples trio (a{i}, a{j}, a{k}) of a where i < j < k, \n and a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint get_matrix_triples(int n){\n", "canonical_solution": "    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_matrix_triples(5) == 1);\n    assert (get_matrix_triples(6) == 4);\n    assert (get_matrix_triples(10) == 36);\n    assert (get_matrix_triples(100) == 53361);\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_matrix_triples(5) == 1);\n}\n", "entry_point": "get_matrix_triples", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a positive positivist integer n. You have to create produce an integer vector a of length n.\n     For each i (1  i  n), the value of a{i} = i * i - i + 1. \n     Return the number of triples trio (a{i}, a{j}, a{k}) of a where i < j < k, \n and a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint get_matrix_triples(int n){\n    vector<int> a(n);\n    a[0] = 1;\n    for(int i = 1; i < n; i++){\n        a[i] = a[i-1] + a[i-1] + a[i-1];\n    }\n    return a[n-1];\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    printf(\"%d\", get_matrix_triples(n));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/148", "prompt": "/*\nThere are eight planets in our solar system organization: the closerst to the Sun \n is Mercury, the next future one is Venus, then Earth, Mars, Jupiter, Saturn, \n Uranus, Neptune. \n Write publish a function routine that takes two planet satellite names name calling as strings planet1 and planet2. \n The function should return a vector containing contain all planets whose orbits eye socket are \n located between the orbit of planet1 and the orbit of planet2, sorted by \n the proximity to the sun sunday. \n The function routine should return an empty vector if planet1 or planet2\nare not correct planet satellite names. \nExamples\nbf(\"Jupiter\", \"Neptune\") ==> {\"Saturn\", \"Uranus\"}\nbf(\"Earth\", \"Mercury\") ==> {\"Venus\"}\nbf(\"Mercury\", \"Uranus\") ==> {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> bf(string planet1,string planet2){\n", "canonical_solution": "    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(bf(\"Jupiter\", \"Neptune\") , {\"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Mercury\") , {\"Venus\",}));\n    assert (issame(bf(\"Mercury\", \"Uranus\") , {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}));\n    assert (issame(bf(\"Neptune\", \"Venus\") , {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Earth\") , {}));\n    assert (issame(bf(\"Mars\", \"Earth\") , {}));\n    assert (issame(bf(\"Jupiter\", \"Makemake\") , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(bf(\"Jupiter\", \"Neptune\") , {\"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Mercury\") , {\"Venus\",}));\n    assert (issame(bf(\"Mercury\", \"Uranus\") , {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}));\n}\n", "entry_point": "bf", "seed": 3, "perturbed": true, "gc": "/*\nThere are eight planets in our solar system organization: the closerst to the Sun \n is Mercury, the next future one is Venus, then Earth, Mars, Jupiter, Saturn, \n Uranus, Neptune. \n Write publish a function routine that takes two planet satellite names name calling as strings planet1 and planet2. \n The function should return a vector containing contain all planets whose orbits eye socket are \n located between the orbit of planet1 and the orbit of planet2, sorted by \n the proximity to the sun sunday. \n The function routine should return an empty vector if planet1 or planet2\nare not correct planet satellite names. \nExamples\nbf(\"Jupiter\", \"Neptune\") ==> {\"Saturn\", \"Uranus\"}\nbf(\"Earth\", \"Mercury\") ==> {\"Venus\"}\nbf(\"Mercury\", \"Uranus\") ==> {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets;\n    if(planet1.compare(\"Jupiter\")==0){\n        if(planet2.compare(\"Neptune\")==0){\n            planets.push_back(\"Saturn\");\n            planets.push_back(\"Uranus\");\n        }\n        if(planet2.compare(\"Mercury\")==0){\n            planets.push_back(\"Venus\");\n        }\n    }\n    if(planet1.compare(\"Earth\")==0){\n        if(planet2.compare(\"Mercury\")==0){\n            planets.push_back(\"Venus\");\n        }\n        if(planet2.compare(\"Jupiter\")==0){\n            planets.push_back(\"Saturn\");\n            planets.push_back(\"Uranus\");\n        }\n    }\n    if(planet1.compare(\"Mercury\")==0){\n        if(planet2.compare(\"Venus\")==0){\n            planets.push_back(\"Venus\");\n        }\n        if(planet2.compare(\"Earth\")==0){\n            planets.push_back(\"Jupiter\");\n            planets.push_back(\"Saturn\");\n        }\n    }\n    if(planet1.compare(\"Venus\")==0){\n        if(planet2.compare(\"Earth\")==0){\n            planets.push_back(\"Jupiter\");\n            planets.push_back(\"Saturn\");\n        }\n        if(planet2.compare(\"Mercury\")==0){\n            planets.push_back(\"Mercury\");\n        }\n    }\n    if(planet1.compare(\"Jupiter\")==0){\n        if(planet2.compare(\"Earth\")==0){\n            planets.push_back(\"Saturn\");\n            planets.push_back(\"Uranus\");\n        }\n        if(planet2.compare(\"Mercury\")==0){\n            planets.push_back(\"Venus\");\n        }\n    }\n    if(planet1.compare(\"Saturn\")==0){\n        if(planet2.compare(\"Uranus\")==0){\n            planets.push_back(\"Jupiter\");\n            planets.push_back(\"Mercury\");\n        }\n        if(planet2.compare(\"Earth\")==0){\n            planets.push_back(\"Venus\");\n        }\n    }\n    if(planet1.compare(\"Uranus\")==0){\n        if(planet2.compare(\"Jupiter\")==0){\n            planets.push_back(\"Saturn\");\n            planets.push_back(\"Earth\");\n        }\n        if(planet2.compare(\"Mercury\")==0){\n            planets.push_back(\"Venus\");\n        }\n    }\n    if(planet1.compare(\"Neptune\")==0){\n        if(planet2.compare(\"Jupiter\")==0){\n            planets.push_back(\"Saturn\");\n            planets.push_back(\"Uranus\");\n        }\n        if(planet2.compare(\"Earth\")==0){\n            planets.push_back(\"Venus\");\n        }\n    }\n    return planets;\n}\nint main(){\n    string planet1,planet2;\n    vector<string> planets;\n    while(scanf(\"%s%s\",&planet1,&planet2)!=EOF){\n        planets=bf(planet1,planet2);\n        for(int i=0;i<planets.size();i++){\n            printf(\"%s\",planets[i].c_str());\n            if(i!=planets.size()-1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/149", "prompt": "/*\nWrite publish a function affair that accepts a vector of strings string as a parameter, \n deletes delete the strings chain that have odd lengths from it, \n and returns revert the resulted result vector with a sorted order, \n The vector is always a vector of strings and never a vector of numbers phone number, \n and it may contain incorporate duplicates. \n The order orderliness of the vector should be ascending by length of each word, and you \n should return the vector sorted by that rule dominion. \n If two words quarrel have the same length, sort the vector alphabetically. \n The function routine should return a vector of strings drawstring in sorted order decree. \n You may assume simulate that all words will have the same length.\nFor example:\nassert vector_sort({\"aa\", \"a\", \"aaa\"}) => {\"aa\"}\nassert vector_sort({\"ab\", \"a\", \"aaa\", \"cd\"}) => {\"ab\", \"cd\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> sorted_list_sum(vector<string> lst){\n", "canonical_solution": "    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) , {\"aa\"}));\n    assert (issame(sorted_list_sum({\"school\", \"AI\", \"asdf\", \"b\"}) , {\"AI\", \"asdf\", \"school\"}));\n    assert (issame(sorted_list_sum({\"d\", \"b\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"d\", \"dcba\", \"abcd\", \"a\"}) , {\"abcd\", \"dcba\"}));\n    assert (issame(sorted_list_sum({\"AI\", \"ai\", \"au\"}) , {\"AI\", \"ai\", \"au\"}));\n    assert (issame(sorted_list_sum({\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"aaaa\", \"bbbb\", \"dd\", \"cc\"}) , {\"cc\", \"dd\", \"aaaa\", \"bbbb\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) , {\"aa\"}));\n    assert (issame(sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) , {\"ab\", \"cd\"}));\n}\n", "entry_point": "sorted_list_sum", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair that accepts a vector of strings string as a parameter, \n deletes delete the strings chain that have odd lengths from it, \n and returns revert the resulted result vector with a sorted order, \n The vector is always a vector of strings and never a vector of numbers phone number, \n and it may contain incorporate duplicates. \n The order orderliness of the vector should be ascending by length of each word, and you \n should return the vector sorted by that rule dominion. \n If two words quarrel have the same length, sort the vector alphabetically. \n The function routine should return a vector of strings drawstring in sorted order decree. \n You may assume simulate that all words will have the same length.\nFor example:\nassert vector_sort({\"aa\", \"a\", \"aaa\"}) => {\"aa\"}\nassert vector_sort({\"ab\", \"a\", \"aaa\", \"cd\"}) => {\"ab\", \"cd\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> rst;\n    for(auto i:lst){\n        if(i.size()%2==0)\n            rst.push_back(i);\n    }\n    sort(rst.begin(), rst.end());\n    return rst;\n}\nvector<string> vector_sort(vector<string> lst){\n    vector<string> rst;\n    for(auto i:lst){\n        if(i.size()%2==0)\n            rst.push_back(i);\n    }\n    sort(rst.begin(), rst.end());\n    return rst;\n}\nint main(){\n    vector<string> lst;\n    lst.push_back(\"aa\");\n    lst.push_back(\"a\");\n    lst.push_back(\"aaa\");\n    lst.push_back(\"ab\");\n    lst.push_back(\"cd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd\");\n    lst.push_back(\"abcd", "passed": 0, "run_status": 1}
{"task_id": "CPP/15", "prompt": "/*\nReturn reelect a string chain containing control space distance - delimited numbers phone number starting startle from 0 upto n inclusive.\n>>> string_sequence(0)\n\"0\"\n>>> string_sequence(5)\n\"0 1 2 3 4 5\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring string_sequence(int n){\n", "canonical_solution": "    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_sequence(0) == \"0\");\n    assert (string_sequence(3) == \"0 1 2 3\");\n     assert (string_sequence(10) == \"0 1 2 3 4 5 6 7 8 9 10\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_sequence(0) == \"0\");\n    assert (string_sequence(5) == \"0 1 2 3 4 5\");\n}\n", "entry_point": "string_sequence", "seed": 3, "perturbed": true, "gc": "/*\nReturn reelect a string chain containing control space distance - delimited numbers phone number starting startle from 0 upto n inclusive.\n>>> string_sequence(0)\n\"0\"\n>>> string_sequence(5)\n\"0 1 2 3 4 5\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring string_sequence(int n){\n\tstring str;\n\tfor(int i=0;i<n;i++){\n\t\tstr+=i;\n\t}\n\treturn str;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tprintf(\"%s\\n\",string_sequence(n).c_str());\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/150", "prompt": "/*\nA simple bare program broadcast which should return the value of x if n is \n a prime number phone number and should return the value of y otherwise.\n\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5\n\n*/\n#include<stdio.h>\nusing namespace std;\nint x_or_y(int n,int x,int y){\n", "canonical_solution": "    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (x_or_y(7, 34, 12) == 34);\n    assert (x_or_y(15, 8, 5) == 5);\n    assert (x_or_y(3, 33, 5212) == 33);\n    assert (x_or_y(1259, 3, 52) == 3);\n    assert (x_or_y(7919, -1, 12) == -1);\n    assert (x_or_y(3609, 1245, 583) == 583);\n    assert (x_or_y(91, 56, 129) == 129);\n    assert (x_or_y(6, 34, 1234) == 1234);\n    assert (x_or_y(1, 2, 0) == 0);\n    assert (x_or_y(2, 2, 0) == 2);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (x_or_y(7, 34, 12) == 34);\n    assert (x_or_y(15, 8, 5) == 5);\n}\n", "entry_point": "x_or_y", "seed": 3, "perturbed": true, "gc": "/*\nA simple bare program broadcast which should return the value of x if n is \n a prime number phone number and should return the value of y otherwise.\n\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5\n\n*/\n#include<stdio.h>\nusing namespace std;\nint x_or_y(int n,int x,int y){\n\tif(n%x==0 && n%y==0){\n\t\treturn x;\n\t}\n\telse{\n\t\treturn y;\n\t}\n}\nint main(){\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\twhile(n!=0){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tprintf(\"%d\\n\",x_or_y(n,x,y));\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/151", "prompt": "/*\nGiven render a vector of numbers phone number, return the sum of squares square of the numbers \n in the vector that are odd. Ignore numbers phone number that are negative damaging or not integers. \n\n double_the_difference({1, 3, 2, 0 }) = = 1 + 9 + 0 + 0 = 10 \n double_the_difference({-1, -2, 0 }) = = 0 \n double_the_difference({9, -2 }) = = 81 \n double_the_difference({0 }) = = 0  \n\n If the input vector is empty, return 0. \n * / \n # include admit < stdio.h > \n # include admit < math.h > \n # include < vector > \n using namespace std;\nlong long double_the_difference(vector < float > lst){\n", "canonical_solution": "    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (double_the_difference({}) == 0);\n    assert (double_the_difference({5, 4}) == 25);\n    assert (double_the_difference({0.1, 0.2, 0.3}) == 0 );\n    assert (double_the_difference({-10, -20, -30}) == 0 );\n    assert (double_the_difference({-1, -2, 8}) == 0);\n    assert (double_the_difference({0.2, 3, 5}) == 34);\n    \n    \n    long long odd_sum=0;\n    vector<float> lst={};\n\n    for (int i=-99;i<100;i+=2)\n    {\n        lst.push_back(i+0.0);\n        if (i>0 and i%2==1) odd_sum+=i*i;\n    }\n  \n    assert (double_the_difference(lst) == odd_sum );\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (double_the_difference({1, 3, 2, 0}) == 10);\n    assert (double_the_difference({-1, -2, 0}) == 0);\n    assert (double_the_difference({9, -2}) == 81 );\n    assert (double_the_difference({0}) == 0  );\n}\n", "entry_point": "double_the_difference", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a vector of numbers phone number, return the sum of squares square of the numbers \n in the vector that are odd. Ignore numbers phone number that are negative damaging or not integers. \n\n double_the_difference({1, 3, 2, 0 }) = = 1 + 9 + 0 + 0 = 10 \n double_the_difference({-1, -2, 0 }) = = 0 \n double_the_difference({9, -2 }) = = 81 \n double_the_difference({0 }) = = 0  \n\n If the input vector is empty, return 0. \n * / \n # include admit < stdio.h > \n # include admit < math.h > \n # include < vector > \n using namespace std;\nlong long double_the_difference(vector < float > lst){\n\tlong long int sum = 0;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] % 2 == 1) {\n\t\t\tsum += lst[i] * lst[i];\n\t\t}\n\t}\n\treturn sum;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/152", "prompt": "/*\nI think intend we all remember commemorate that feeling when the result consequence of some long - awaited \n event consequence is finally last known. The feelings and thoughts idea you have at that moment consequence are \n definitely worth noting down and comparing. \n Your task job is to determine settle if a person correctly guessed the results solution of a number of matches. \n You are given sacrifice two vectors of scores and guesses guess of equal adequate length duration, where each index shows picture a match peer. \n Return a vector of the same length denoting denote how far off each guess was. If they have guessed correctly, \n the value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n\nexample:\n\ncompare({1,2,3,4,5,1},{1,2,3,4,2,-2}) -> {0,0,0,0,3,3}\ncompare({0,5,0,0,0,4},{4,1,1,0,0,-2}) -> {4,4,1,0,0,6}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<int> compare(vector<int> game,vector<int> guess){\n", "canonical_solution": "    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,5,0,0,0,4},{4,1,1,0,0,-2}),{4,4,1,0,0,6}));\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,0,0,0,0,0},{0,0,0,0,0,0}),{0,0,0,0,0,0}));\n    assert (issame(compare({1,2,3},{-1,-2,-3}),{2,4,6}));\n    assert (issame(compare({1,2,3,5},{-1,2,3,4}),{2,0,0,1}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,5,0,0,0,4},{4,1,1,0,0,-2}),{4,4,1,0,0,6}));\n}\n", "entry_point": "compare", "seed": 3, "perturbed": true, "gc": "/*\nI think intend we all remember commemorate that feeling when the result consequence of some long - awaited \n event consequence is finally last known. The feelings and thoughts idea you have at that moment consequence are \n definitely worth noting down and comparing. \n Your task job is to determine settle if a person correctly guessed the results solution of a number of matches. \n You are given sacrifice two vectors of scores and guesses guess of equal adequate length duration, where each index shows picture a match peer. \n Return a vector of the same length denoting denote how far off each guess was. If they have guessed correctly, \n the value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n\nexample:\n\ncompare({1,2,3,4,5,1},{1,2,3,4,2,-2}) -> {0,0,0,0,3,3}\ncompare({0,5,0,0,0,4},{4,1,1,0,0,-2}) -> {4,4,1,0,0,6}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<int> compare(vector<int> game,vector<int> guess){\n    int i,j,k,m,n,l,c,d,e,f,g,h,i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15,i16,i17,i18,i19,i20,i21,i22,i23,i24,i25,i26,i27,i28,i29,i30,i31,i32,i33,i34,i35,i36,i37,i38,i39,i40,i41,i42,i43,i44,i45,i46,i47,i48,i49,i50,i51,i52,i53,i54,i55,i56,i57,i58,i59,i60,i61,i62,i63,i64,i65,i66,i67,i68,i69,i70,i71,i72,i73,i74,i75,i76,i77,i78,i79,i80,i81,i82,i83,i84,i85,i86,i87,i88,i89,i90,i91,i92,i93,i94,i95,i96,i97,i98,i99,i100,i101,i102,i103,i104,i105,i106,i107,i108,i109,i110,i111,i112,i113,i114,i115,i116,i117,i118,i119,i120,i121,i122,i123,i124,i125,i126,i127,i128,i129,i130,i131,i132,i133,i134,i135,i136,i137,i138,i139,i140,i141,i142,i143,i144,i145,i146,i147,i148,i149,i150,i151,i152,i153,i154,i155,i156,i157,i158,i159,i160,i161,i162,i163,i164,i165,i166,i167,i168,i169,i170,i171,i172,i173,i174,i175,i176,i177,i178,i179,i180,i181,i182,i183,i184,i185,i186,i187,i188,i189,i190,i191,i192,i193,i194,i195,i196,i197,i198,i199,i200,i201,i202,i203,i204,i205,i206,i207,i208,i209,i210,i211,i212,i213,i214,i215,i216,i217,i218,i219,i220,i221,i222,i223,i224,i225,i226,i227,i228,i229,i230,i231,i232,i233,i234,i235,i236,i237,i238,i239,i240,i241,i242,i243,i244,i245,i246,i247,i248,i249,i250,i251,i252,i253,i254,i255,i256,i257,i258,i259,i260,i261,i262,i263,i264,i265,i266,i267,i268,i269,i270,i271,i272,i273,i274,i275,i276,i277,i278,i279,i280,i281,i282,i283,i284,i285,i286,i287,i288,i289,i290,i291,i292,i293,i294,i295,i296,i297,i298,i299,i300,i301,i302,i303,i304,i305,i306,i307,i308,i309,i310,i311,i312,i313,i314,i315,i316,i317,i318,i319,i320,i321,i322,i323,i324,i325,i326,i327,i328,i329,i330,i331,i332,i333,i334,i335,i336,i337,i338,i339,i340,i341,i342,i343,i344,i345,i346,i347,i348,i349,i350,i351,i352,i353,i354,i355,i356,i357,i358,i359,i360,i361,i362,i363,i364,i365,i366,i367,i368,i369,i370,i371,i372,i373,i374,i375,i376,i377,i378,i379,i380,i381,i382,i383,i384,i385,i386,i387,i388,i389,i390,i391,i392,i393,i394,i395,i396,i397,i398,i399,i400,i401,i402,i403,i404,i405,i406,i", "passed": 0, "run_status": 2}
{"task_id": "CPP/153", "prompt": "/*\nYou will be given render the name of a class course (a string) and a vector of extensions.\nThe extensions are to be used practice to load additional classes course to the class course. The \n strength of the extension is as follows watch: Let get CAP be the number numeral of the uppercase \n letters in the extension annex's name, and let lease SM be the number of lowercase small letter letters \nin the extension's name, the strength is given sacrifice by the fraction CAP - SM. \n You should find the strongest extension and return a string drawstring in this \n format: ClassName. StrongestExtensionName. \n If there are two or more extensions with the same strength, you should \n choose the one that comes occur first foremost in the vector.\nFor example, if you are given \"Slices\" as the class and a vector of the\nextensions: {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"} then you should\nreturn \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension \n(its strength is -1).\nExample:\nfor Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring Strongest_Extension(string class_name,vector<string> extensions){\n", "canonical_solution": "    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (Strongest_Extension(\"Watashi\", {\"tEN\", \"niNE\", \"eIGHt8OKe\"}) == \"Watashi.eIGHt8OKe\");\n    assert (Strongest_Extension(\"Boku123\", {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}) == \"Boku123.YEs.WeCaNe\");\n    assert (Strongest_Extension(\"__YESIMHERE\", {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}) == \"__YESIMHERE.NuLl__\");\n    assert (Strongest_Extension(\"K\", {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}) == \"K.TAR\");\n    assert (Strongest_Extension(\"__HAHA\", {\"Tab\", \"123\", \"781345\", \"-_-\"}) == \"__HAHA.123\");\n    assert (Strongest_Extension(\"YameRore\", {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}) == \"YameRore.okIWILL123\");\n    assert (Strongest_Extension(\"finNNalLLly\", {\"Die\", \"NowW\", \"Wow\", \"WoW\"}) == \"finNNalLLly.WoW\");\n    assert (Strongest_Extension(\"_\", {\"Bb\", \"91245\"}) == \"_.Bb\");\n    assert (Strongest_Extension(\"Sp\", {\"671235\", \"Bb\"}) == \"Sp.671235\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\");\n}\n", "entry_point": "Strongest_Extension", "seed": 3, "perturbed": true, "gc": "/*\nYou will be given render the name of a class course (a string) and a vector of extensions.\nThe extensions are to be used practice to load additional classes course to the class course. The \n strength of the extension is as follows watch: Let get CAP be the number numeral of the uppercase \n letters in the extension annex's name, and let lease SM be the number of lowercase small letter letters \nin the extension's name, the strength is given sacrifice by the fraction CAP - SM. \n You should find the strongest extension and return a string drawstring in this \n format: ClassName. StrongestExtensionName. \n If there are two or more extensions with the same strength, you should \n choose the one that comes occur first foremost in the vector.\nFor example, if you are given \"Slices\" as the class and a vector of the\nextensions: {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"} then you should\nreturn \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension \n(its strength is -1).\nExample:\nfor Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring Strongest_Extension(string class_name,vector<string> extensions){\n\tstring result = class_name;\n\tint cap = 0,lease = 0;\n\tfor(int i = 0; i < extensions.size(); i++){\n\t\tstring extension = extensions[i];\n\t\tint num = extension.length();\n\t\tfor(int j = 0; j < num; j++){\n\t\t\tchar c = extension[j];\n\t\t\tif(isupper(c)){\n\t\t\t\tcap++;\n\t\t\t}else{\n\t\t\t\tlease++;\n\t\t\t}\n\t\t}\n\t}\n\tif(cap > lease){\n\t\tresult = class_name + \".\" + extensions[0];\n\t}else{\n\t\tfor(int i = 0; i < extensions.size(); i++){\n\t\t\tstring extension = extensions[i];\n\t\t\tif(cap == lease){\n\t\t\t\tresult = class_name + \".\" + extension;\n\t\t\t\tbreak;\n\t\t\t}else if(cap > lease){\n\t\t\t\tresult = class_name + \".\" + extension;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tstring class_name = \"Slices\";\n\tvector<string> extensions;\n\textensions.push_back(\"SErviNGSliCes\");\n\textensions.push_back(\"Cheese\");\n\textensions.push_back(\"StuFfed\");\n\tstring result = Strongest_Extension(class_name,extensions);\n\tprintf(\"%s\\n\",result.c_str());\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/154", "prompt": "/*\nYou are given render 2 words bible. You need necessitate to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n cycpattern_check(\"abcd\",\"abd \") = > false \n cycpattern_check(\"hello\",\"ell \") = > true dependable \n cycpattern_check(\"whassup\",\"psus \") = > false delusive \n cycpattern_check(\"abab\",\"baa \") = > true \n cycpattern_check(\"efef\",\"eeff \") = > false \n cycpattern_check(\"himenss\",'simen \") = > true \n\n * / \n # include < stdio.h > \n # include < string chain > \n using practice namespace std;\nbool cycpattern_check(string a,string b){\n", "canonical_solution": "    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert  (cycpattern_check(\"xyzw\",\"xyw\") == false );\n    assert  (cycpattern_check(\"yello\",\"ell\") == true );\n    assert  (cycpattern_check(\"whattup\",\"ptut\") == false );\n    assert  (cycpattern_check(\"efef\",\"fee\") == true );\n    assert  (cycpattern_check(\"abab\",\"aabb\") == false );\n    assert  (cycpattern_check(\"winemtt\",\"tinem\") == true );\n}\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert  (cycpattern_check(\"abcd\",\"abd\") == false );\n    assert  (cycpattern_check(\"hello\",\"ell\") == true );\n    assert  (cycpattern_check(\"whassup\",\"psus\") == false );\n    assert  (cycpattern_check(\"abab\",\"baa\") == true );\n    assert  (cycpattern_check(\"efef\",\"eeff\") == false );\n    assert  (cycpattern_check(\"himenss\",\"simen\") == true );\n}\n", "entry_point": "cycpattern_check", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render 2 words bible. You need necessitate to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n cycpattern_check(\"abcd\",\"abd \") = > false \n cycpattern_check(\"hello\",\"ell \") = > true dependable \n cycpattern_check(\"whassup\",\"psus \") = > false delusive \n cycpattern_check(\"abab\",\"baa \") = > true \n cycpattern_check(\"efef\",\"eeff \") = > false \n cycpattern_check(\"himenss\",'simen \") = > true \n\n * / \n # include < stdio.h > \n # include < string chain > \n using practice namespace std;\nbool cycpattern_check(string a,string b){\n\tstring aa = a;\n\tstring bb = b;\n\tif(aa.size() == bb.size()){\n\t\tfor(int i = 0; i < aa.size(); i++){\n\t\t\tif(aa[i] == bb[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nint main(){\n\tstring a,b;\n\tcin >> a >> b;\n\tcout << cycpattern_check(a,b) << endl;\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/155", "prompt": "/*\nGiven render an integer. return a vector that has the number numeral of even and odd digits digit respectively.\n\n Example:\n    even_odd_count(-12) ==> {1, 1}\n    even_odd_count(123) ==> {1, 2}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\nvector<int> even_odd_count(int num){\n", "canonical_solution": "    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_count(7) , {0, 1}));\n    assert (issame(even_odd_count(-78) , {1, 1}));\n    assert (issame(even_odd_count(3452) , {2, 2}));\n    assert (issame(even_odd_count(346211) , {3, 3}));\n    assert (issame(even_odd_count(-345821) , {3, 3}));\n    assert (issame(even_odd_count(-2) , {1, 0}));\n    assert (issame(even_odd_count(-45347) , {2, 3}));\n    assert (issame(even_odd_count(0) , {1, 0}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_count(-12) , {1, 1}));\n    assert (issame(even_odd_count(123) , {1, 2}));\n}\n", "entry_point": "even_odd_count", "seed": 3, "perturbed": true, "gc": "/*\nGiven render an integer. return a vector that has the number numeral of even and odd digits digit respectively.\n\n Example:\n    even_odd_count(-12) ==> {1, 1}\n    even_odd_count(123) ==> {1, 2}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\nvector<int> even_odd_count(int num){\n    vector<int> even_odd;\n    int even = 0, odd = 0;\n    for(int i = 0; i < num; i++){\n        if(num % 10 == 0){\n            even++;\n        }else{\n            odd++;\n        }\n        num /= 10;\n    }\n    even_odd.push_back(even);\n    even_odd.push_back(odd);\n    return even_odd;\n}\nint main(){\n    int num;\n    while(scanf(\"%d\", &num)!= EOF){\n        vector<int> even_odd = even_odd_count(num);\n        for(int i = 0; i < even_odd.size(); i++){\n            printf(\"%d\", even_odd[i]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/156", "prompt": "/*\nGiven render a positive positivist integer, obtain receive its roman numeral equivalent as a string, \n and return it in lowercase. \n Restrictions restriction: 1 < = num < = 1000 \n\n Examples exercise:\n>>> int_to_mini_roman(19) == \"xix\"\n>>> int_to_mini_roman(152) == \"clii\"\n>>> int_to_mini_roman(426) == \"cdxxvi\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring int_to_mini_romank(int number){\n", "canonical_solution": "    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (int_to_mini_romank(19) == \"xix\");\n    assert (int_to_mini_romank(152) == \"clii\");\n    assert (int_to_mini_romank(251) == \"ccli\");\n    assert (int_to_mini_romank(426) == \"cdxxvi\");\n    assert (int_to_mini_romank(500) == \"d\");\n    assert (int_to_mini_romank(1) == \"i\");\n    assert (int_to_mini_romank(4) == \"iv\");\n    assert (int_to_mini_romank(43) == \"xliii\");\n    assert (int_to_mini_romank(90) == \"xc\");\n    assert (int_to_mini_romank(94) == \"xciv\");\n    assert (int_to_mini_romank(532) == \"dxxxii\");\n    assert (int_to_mini_romank(900) == \"cm\");\n    assert (int_to_mini_romank(994) == \"cmxciv\");\n    assert (int_to_mini_romank(1000) == \"m\");\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (int_to_mini_romank(19) == \"xix\");\n    assert (int_to_mini_romank(152) == \"clii\");\n    assert (int_to_mini_romank(426) == \"cdxxvi\");\n}\n", "entry_point": "int_to_mini_romank", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a positive positivist integer, obtain receive its roman numeral equivalent as a string, \n and return it in lowercase. \n Restrictions restriction: 1 < = num < = 1000 \n\n Examples exercise:\n>>> int_to_mini_roman(19) == \"xix\"\n>>> int_to_mini_roman(152) == \"clii\"\n>>> int_to_mini_roman(426) == \"cdxxvi\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring int_to_mini_romank(int number){\n\tvector<string> roman_numeral;\n\troman_numeral.push_back(\"\");\n\troman_numeral.push_back(\"M\");\n\troman_numeral.push_back(\"CM\");\n\troman_numeral.push_back(\"D\");\n\troman_numeral.push_back(\"CD\");\n\troman_numeral.push_back(\"C\");\n\troman_numeral.push_back(\"XC\");\n\troman_numeral.push_back(\"L\");\n\troman_numeral.push_back(\"XL\");\n\troman_numeral.push_back(\"X\");\n\troman_numeral.push_back(\"IX\");\n\troman_numeral.push_back(\"V\");\n\troman_numeral.push_back(\"IV\");\n\troman_numeral.push_back(\"I\");\n\t\n\tstring result;\n\tfor(int i = 0; i < roman_numeral.size(); i++){\n\t\tif(number >= roman_numeral[i].size()){\n\t\t\tresult = roman_numeral[i];\n\t\t\tbreak;\n\t\t}\n\t\tif(number < roman_numeral[i].size()){\n\t\t\tresult = roman_numeral[i];\n\t\t\tbreak;\n\t\t}\n\t\tresult = roman_numeral[i];\n\t\tnumber -= roman_numeral[i].size();\n\t}\n\treturn result;\n}\nint main(){\n\tint number;\n\tscanf(\"%d\", &number);\n\tprintf(\"%s\", int_to_mini_romank(number).c_str());\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/157", "prompt": "/*\nGiven render the lengths duration of the three sides english of a triangle triangulum. Return true dependable if the three \n sides english form shape a right properly - angled slant triangle, false otherwise. \n A right - angled lean triangle triangulum is a triangle in which one angle slant is right angle or \n 90 degree academic degree.\nExample:\nright_angle_triangle(3, 4, 5) == true\nright_angle_triangle(1, 2, 3) == false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool right_angle_triangle(float a,float b,float c){\n", "canonical_solution": "    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (right_angle_triangle(3, 4, 5) == true);\n    assert (right_angle_triangle(1, 2, 3) == false);\n    assert (right_angle_triangle(10, 6, 8) == true);\n    assert (right_angle_triangle(2, 2, 2) == false);\n    assert (right_angle_triangle(7, 24, 25) == true);\n    assert (right_angle_triangle(10, 5, 7) == false);\n    assert (right_angle_triangle(5, 12, 13) == true);\n    assert (right_angle_triangle(15, 8, 17) == true);\n    assert (right_angle_triangle(48, 55, 73) == true);\n    assert (right_angle_triangle(1, 1, 1) == false);\n    assert (right_angle_triangle(2, 2, 10) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (right_angle_triangle(3, 4, 5) == true);\n    assert (right_angle_triangle(1, 2, 3) == false);\n}\n", "entry_point": "right_angle_triangle", "seed": 3, "perturbed": true, "gc": "/*\nGiven render the lengths duration of the three sides english of a triangle triangulum. Return true dependable if the three \n sides english form shape a right properly - angled slant triangle, false otherwise. \n A right - angled lean triangle triangulum is a triangle in which one angle slant is right angle or \n 90 degree academic degree.\nExample:\nright_angle_triangle(3, 4, 5) == true\nright_angle_triangle(1, 2, 3) == false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool right_angle_triangle(float a,float b,float c){\n\tif(a==b || b==c || c==a)\n\t\treturn false;\n\tfloat s=sqrt(pow(a,2)+pow(b,2)+pow(c,2));\n\tfloat s1=sqrt(pow(a,2)+pow(b,2));\n\tfloat s2=sqrt(pow(a,2)+pow(c,2));\n\tfloat s3=sqrt(pow(b,2)+pow(c,2));\n\tif(s==s1 || s==s2 || s==s3)\n\t\treturn true;\n\treturn false;\n}\nint main(){\n\tfloat a,b,c;\n\tscanf(\"%f%f%f\",&a,&b,&c);\n\tif(right_angle_triangle(a,b,c))\n\t\tprintf(\"right\\n\");\n\telse\n\t\tprintf(\"not right\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/158", "prompt": "/*\nWrite publish a function affair that accepts a vector of strings string. \n The vector contains different unlike words. Return the word son with maximum maximal number issue \n of unique characters quality. If multiple strings have maximum number of unique\ncharacters, return the one which comes first foremost in lexicographical lexicographic order. \n\n find_max({\"name \", \" of \",' string chain \" }) = =' string \" \n find_max({\"name \", \" enam \", \" game \" }) = = \" enam \" \n find_max({\"aaaaaaa \", \" bb \", \" cc \" }) = = \" aaaaaaa \" \n * / \n # include < stdio.h > \n # include admit < vector > \n # include < string drawstring > \n # include admit < algorithm > \n using use namespace std;\nstring find_max(vector<string> words){\n", "canonical_solution": "    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert ((find_max({\"name\", \"of\", \"string\"}) == \"string\"));\n    assert ((find_max({\"name\", \"enam\", \"game\"}) == \"enam\"));\n    assert ((find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\"));\n    assert ((find_max({\"abc\", \"cba\"}) == \"abc\"));\n    assert ((find_max({\"play\", \"this\", \"game\", \"of\",\"footbott\"}) == \"footbott\"));\n    assert ((find_max({\"we\", \"are\", \"gonna\", \"rock\"}) == \"gonna\"));\n    assert ((find_max({\"we\", \"are\", \"a\", \"mad\", \"nation\"}) == \"nation\"));\n    assert ((find_max({\"this\", \"is\", \"a\", \"prrk\"}) == \"this\"));\n    assert ((find_max({\"b\"}) == \"b\"));\n    assert ((find_max({\"play\", \"play\", \"play\"}) == \"play\"));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert ((find_max({\"name\", \"of\", \"string\"}) == \"string\"));\n    assert ((find_max({\"name\", \"enam\", \"game\"}) == \"enam\"));\n    assert ((find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\"));\n}\n", "entry_point": "find_max", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair that accepts a vector of strings string. \n The vector contains different unlike words. Return the word son with maximum maximal number issue \n of unique characters quality. If multiple strings have maximum number of unique\ncharacters, return the one which comes first foremost in lexicographical lexicographic order. \n\n find_max({\"name \", \" of \",' string chain \" }) = =' string \" \n find_max({\"name \", \" enam \", \" game \" }) = = \" enam \" \n find_max({\"aaaaaaa \", \" bb \", \" cc \" }) = = \" aaaaaaa \" \n * / \n # include < stdio.h > \n # include admit < vector > \n # include < string drawstring > \n # include admit < algorithm > \n using use namespace std;\nstring find_max(vector<string> words){\n    string max_string = \"\";\n    int max_count = 0;\n    for(int i = 0; i < words.size(); i++){\n        string word = words[i];\n        int count = 0;\n        for(int j = 0; j < word.size(); j++){\n            if(word[j]!=''){\n                count++;\n            }\n        }\n        if(count > max_count){\n            max_count = count;\n            max_string = word;\n        }\n        else if(count == max_count){\n            if(word.compare(max_string) > 0){\n                max_string = word;\n            }\n        }\n    }\n    return max_string;\n}\n\nint main(){\n    vector<string> words;\n    string word;\n    while(cin >> word){\n        words.push_back(word);\n    }\n    string max_string = find_max(words);\n    cout << max_string << endl;\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/159", "prompt": "/*\nYou\"re a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n but now you need to eat more carrots carrot to complete dispatch the day's meals. \n you should return a vector of { total sum number of eaten feed carrots after your meals, \n                                 the number of carrots left after your meals meal } \n if there are not enough adequate remaining carrots, you will eat all remaining carrots carrot, but will still be hungry.\n\nExample:\n* eat(5, 6, 10) -> {11, 4}\n* eat(4, 8, 9) -> {12, 1}\n* eat(1, 10, 10) -> {11, 0}\n* eat(2, 11, 5) -> {7, 0}\n\nVariables:\n@number : integer\n    the number of carrots that you have eaten.\n@need : integer\n    the number of carrots that you need to eat.\n@remaining : integer\n    the number of remaining carrots thet exist in stock\n\nConstrain:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nHave fun :)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> eat(int number,int need,int remaining){\n", "canonical_solution": "    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(eat(5, 6, 10) , {11, 4}));\n    assert (issame(eat(4, 8, 9) , {12, 1}));\n    assert (issame(eat(1, 10, 10) , {11, 0}));\n    assert (issame(eat(2, 11, 5) , {7, 0}));\n    \n    assert (issame(eat(4, 5, 7) , {9, 2}));\n    assert (issame(eat(4, 5, 1) , {5, 0}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(eat(5, 6, 10) , {11, 4}));\n    assert (issame(eat(4, 8, 9) , {12, 1}));\n    assert (issame(eat(1, 10, 10) , {11, 0}));\n    assert (issame(eat(2, 11, 5) , {7, 0}));\n}\n", "entry_point": "eat", "seed": 3, "perturbed": true, "gc": "/*\nYou\"re a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n but now you need to eat more carrots carrot to complete dispatch the day's meals. \n you should return a vector of { total sum number of eaten feed carrots after your meals, \n                                 the number of carrots left after your meals meal } \n if there are not enough adequate remaining carrots, you will eat all remaining carrots carrot, but will still be hungry.\n\nExample:\n* eat(5, 6, 10) -> {11, 4}\n* eat(4, 8, 9) -> {12, 1}\n* eat(1, 10, 10) -> {11, 0}\n* eat(2, 11, 5) -> {7, 0}\n\nVariables:\n@number : integer\n    the number of carrots that you have eaten.\n@need : integer\n    the number of carrots that you need to eat.\n@remaining : integer\n    the number of remaining carrots thet exist in stock\n\nConstrain:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nHave fun :)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> eat(int number,int need,int remaining){\n    vector<int> result;\n    if(number<need){\n        result.push_back(number);\n        result.push_back(remaining);\n        return result;\n    }\n    int sum=0;\n    while(number>0){\n        sum+=number%10;\n        number/=10;\n    }\n    int i=0;\n    while(need>0){\n        sum+=need%10;\n        need/=10;\n        i++;\n    }\n    result.push_back(sum);\n    result.push_back(i);\n    return result;\n}\nint main(){\n    int number,need,remaining;\n    while(scanf(\"%d %d %d\",&number,&need,&remaining)!=EOF){\n        vector<int> result=eat(number,need,remaining);\n        for(int i=0;i<result.size();i++){\n            printf(\"%d \",result[i]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/16", "prompt": "/*\nGiven render a string chain, find discover out how many distinct characters (regardless of case) does it consist dwell of\n>>> count_distinct_characters(\"xyzXYZ\")\n3\n>>> count_distinct_characters(\"Jerry\")\n4\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint count_distinct_characters(string str){ \n", "canonical_solution": "    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_distinct_characters(\"\") == 0);\n    assert (count_distinct_characters(\"abcde\") == 5);\n    assert (count_distinct_characters(\"abcdecadeCADE\") == 5);\n    assert (count_distinct_characters(\"aaaaAAAAaaaa\") == 1);\n    assert (count_distinct_characters(\"Jerry jERRY JeRRRY\") == 5);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_distinct_characters(\"xyzXYZ\") == 3);\n    assert (count_distinct_characters(\"Jerry\") == 4);\n}\n", "entry_point": "count_distinct_characters", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a string chain, find discover out how many distinct characters (regardless of case) does it consist dwell of\n>>> count_distinct_characters(\"xyzXYZ\")\n3\n>>> count_distinct_characters(\"Jerry\")\n4\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint count_distinct_characters(string str){ \n\tvector<int> v;\n\tfor(int i=0;i<str.size();i++){\n\t\tv.push_back(str[i]);\n\t}\n\tsort(v.begin(),v.end());\n\treturn v.size();\n}\nint main(){\n\tstring str=\"xyzXYZ\";\n\tprintf(\"%d\\n\",count_distinct_characters(str));\n\tstr=\"Jerry\";\n\tprintf(\"%d\\n\",count_distinct_characters(str));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/160", "prompt": "/*\nGiven render two vectors vector operator, and operand. The first inaugural vector has basic algebra operations, and \n the second vector is a vector of integers integer. Use practice the two given vectors to build construct the algebric \n expression formula and return the evaluation of this expression. \n\n The basic algebra operations: \n Addition (+) \n Subtraction (-) \n Multiplication (*) \n Floor division part (//) \n Exponentiation (* * ) \n\nExample:\noperator{\"+\", \"*\", \"-\"}\nvector = {2, 3, 4, 5}\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nNote:\n    The length of operator vector is equal to the length of operand vector minus one.\n    Operand is a vector of of non-negative integers.\n    Operator vector has at least one operator, and operand vector has at least two operands.\n\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n", "canonical_solution": "    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (do_algebra({\"**\", \"*\", \"+\"}, {2, 3, 4, 5}) == 37);\n    assert (do_algebra({\"+\", \"*\", \"-\"}, {2, 3, 4, 5}) == 9);\n    assert (do_algebra({\"//\", \"*\"}, {7, 3, 4}) == 8);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n", "example_test": "", "entry_point": "do_algebra", "seed": 3, "perturbed": true, "gc": "/*\nGiven render two vectors vector operator, and operand. The first inaugural vector has basic algebra operations, and \n the second vector is a vector of integers integer. Use practice the two given vectors to build construct the algebric \n expression formula and return the evaluation of this expression. \n\n The basic algebra operations: \n Addition (+) \n Subtraction (-) \n Multiplication (*) \n Floor division part (//) \n Exponentiation (* * ) \n\nExample:\noperator{\"+\", \"*\", \"-\"}\nvector = {2, 3, 4, 5}\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nNote:\n    The length of operator vector is equal to the length of operand vector minus one.\n    Operand is a vector of of non-negative integers.\n    Operator vector has at least one operator, and operand vector has at least two operands.\n\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    int i, j, k, l, m, n, result = 0;\n    for (i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"+\") {\n            for (j = 0; j < operand.size(); j++) {\n                result += operand[j];\n            }\n        } else if (operato[i] == \"-\") {\n            for (j = 0; j < operand.size(); j++) {\n                result -= operand[j];\n            }\n        } else if (operato[i] == \"*\") {\n            for (j = 0; j < operand.size(); j++) {\n                result *= operand[j];\n            }\n        } else if (operato[i] == \"/\") {\n            for (j = 0; j < operand.size(); j++) {\n                result /= operand[j];\n            }\n        } else if (operato[i] == \"//\") {\n            for (j = 0; j < operand.size(); j++) {\n                result = result / operand[j];\n            }\n        } else if (operato[i] == \"^\") {\n            for (j = 0; j < operand.size(); j++) {\n                result = pow(result, operand[j]);\n            }\n        }\n    }\n    return result;\n}\nint main(){\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        vector<string> operato(n);\n        vector<int> operand(n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s%d\", operato[i].data(), operand[i]);\n        }\n        printf(\"%d\\n\", do_algebra(operato, operand));\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/161", "prompt": "/*\nYou are given render a string chain s.\nif s[i] is a letter, reverse turn back its case lawsuit from lower to upper or vise versa, \n otherwise differently keep preserve it as it is. \n If the string contains no letters letter, reverse change by reversal the string. \n The function should return the resulted string.\nExamples\nsolve(\"1234\") = \"4321\"\nsolve(\"ab\") = \"AB\"\nsolve(\"#a@C\") = \"#A@c\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(string s){\n", "canonical_solution": "    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(\"AsDf\") == \"aSdF\");\n    assert (solve(\"1234\") == \"4321\");\n    assert (solve(\"ab\") == \"AB\");\n    assert (solve(\"#a@C\") == \"#A@c\");\n    assert (solve(\"#AsdfW^45\") == \"#aSDFw^45\");\n    assert (solve(\"#6@2\") == \"2@6#\");\n    assert (solve(\"#$a^D\") == \"#$A^d\");\n    assert (solve(\"#ccc\") == \"#CCC\");\n}\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(\"1234\") == \"4321\");\n    assert (solve(\"ab\") == \"AB\");\n    assert (solve(\"#a@C\") == \"#A@c\");\n}\n", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a string chain s.\nif s[i] is a letter, reverse turn back its case lawsuit from lower to upper or vise versa, \n otherwise differently keep preserve it as it is. \n If the string contains no letters letter, reverse change by reversal the string. \n The function should return the resulted string.\nExamples\nsolve(\"1234\") = \"4321\"\nsolve(\"ab\") = \"AB\"\nsolve(\"#a@C\") = \"#A@c\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(string s){\n\tstring result;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]>='a'&&s[i]<='z'){\n\t\t\tresult+=s[i];\n\t\t\tif(i+1<s.size()){\n\t\t\t\tif(s[i+1]>='a'&&s[i+1]<='z'){\n\t\t\t\t\tresult+=s[i+1];\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tresult+=s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(i+1<s.size()){\n\t\t\t\tif(s[i+1]>='a'&&s[i+1]<='z'){\n\t\t\t\t\tresult+=s[i+1];\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tresult+=s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tstring s;\n\twhile(scanf(\"%s\",&s)!=EOF){\n\t\tprintf(\"%s\\n\",solve(s).c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/162", "prompt": "/*\nGiven render a string chain 'text\", return its md5 hash hashish equivalent string. \n If 'text\" is an empty string, return None.\n\n>>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n*/\n#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\nstring string_to_md5(string text){\n", "canonical_solution": "    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert (string_to_md5(\"\") == \"None\");\n    assert (string_to_md5(\"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert (string_to_md5(\"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n", "declaration": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\");\n}\n", "entry_point": "string_to_md5", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a string chain 'text\", return its md5 hash hashish equivalent string. \n If 'text\" is an empty string, return None.\n\n>>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n*/\n#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\nstring string_to_md5(string text){\n\tif(text.empty()){\n\t\treturn \"\";\n\t}\n\tstring hash = \"\";\n\tMD5_CTX ctx;\n\tMD5_Init(&ctx);\n\tMD5_Update(&ctx, text.c_str(), text.size());\n\tMD5_Final(reinterpret_cast<unsigned char*>(&hash), &ctx);\n\treturn hash;\n}\nint main(){\n\tstring text = \"Hello world\";\n\tstring hash = string_to_md5(text);\n\tprintf(\"%s\\n\", hash.c_str());\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/163", "prompt": "/*\nGiven render two positive positivist integers integer a and b, return the even digits between a\nand b, in ascending ascend order club.\n\nFor example:\ngenerate_integers(2, 8) => {2, 4, 6, 8}\ngenerate_integers(8, 2) => {2, 4, 6, 8}\ngenerate_integers(10, 14) => {}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> generate_integers(int a,int b){\n", "canonical_solution": "    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(generate_integers(2, 10) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(10, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(132, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(17,89) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(generate_integers(2, 8) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(8, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(10,14) , {}));\n}\n", "entry_point": "generate_integers", "seed": 3, "perturbed": true, "gc": "/*\nGiven render two positive positivist integers integer a and b, return the even digits between a\nand b, in ascending ascend order club.\n\nFor example:\ngenerate_integers(2, 8) => {2, 4, 6, 8}\ngenerate_integers(8, 2) => {2, 4, 6, 8}\ngenerate_integers(10, 14) => {}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> generate_integers(int a,int b){\n\tvector<int> ans;\n\tint i,j,k;\n\tfor(i=a;i<=b;i++){\n\t\tfor(j=i;j<=b;j++){\n\t\t\tk=i*j;\n\t\t\tif(k%10==0){\n\t\t\t\tans.push_back(k/10);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tvector<int> ans=generate_integers(a,b);\n\tfor(int i=0;i<ans.size();i++){\n\t\tprintf(\"%d\",ans[i]);\n\t\tif(i!=ans.size()-1)printf(\" \");\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/17", "prompt": "/*\nInput stimulation to this function affair is a string representing present musical notes bill in a special particular ASCII format. \n Your task is to parse this string bowed stringed instrument and return vector of integers integer corresponding to how many beats does each \n not last. \n\n Here is a legend: \n \" o \" - whole solid note eminence, lasts four beats meter \n \" o| \" - half note, lasts two beats \n \" .| \" - quater note bill, lasts one beat beatnik\n\n>>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_music(string music_string){ \n", "canonical_solution": "    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_music(\"\") , {}));\n     assert (issame(parse_music(\"o o o o\") ,{4, 4, 4, 4}));\n      assert (issame(parse_music(\".| .| .| .|\") , {1, 1, 1, 1}));\n assert (issame(parse_music(\"o| o| .| .| o o o o\") , {2, 2, 1, 1, 4, 4, 4, 4}));\n  assert (issame(parse_music(\"o| .| o| .| o o| o o|\") , {2, 1, 2, 1, 4, 2, 4, 2}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_music(\"o o| .| o| o| .| .| .| .| o o\") , {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}));\n}\n", "entry_point": "parse_music", "seed": 3, "perturbed": true, "gc": "/*\nInput stimulation to this function affair is a string representing present musical notes bill in a special particular ASCII format. \n Your task is to parse this string bowed stringed instrument and return vector of integers integer corresponding to how many beats does each \n not last. \n\n Here is a legend: \n \" o \" - whole solid note eminence, lasts four beats meter \n \" o| \" - half note, lasts two beats \n \".| \" - quater note bill, lasts one beat beatnik\n\n>>> parse_music(\"o o|.| o| o|.|.|.|.| o o\")\n{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_music(string music_string){ \n\tvector<int> beat_count;\n\tint i = 0;\n\twhile(music_string[i]!= '\\0'){\n\t\tif(music_string[i] ==''){\n\t\t\tbeat_count.push_back(0);\n\t\t}\n\t\telse if(music_string[i] == '|'){\n\t\t\tbeat_count.push_back(2);\n\t\t}\n\t\telse if(music_string[i] == '.'){\n\t\t\tbeat_count.push_back(1);\n\t\t}\n\t\telse if(music_string[i] == 'o'){\n\t\t\tbeat_count.push_back(4);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"Error in parsing music string\\n\");\n\t\t\treturn beat_count;\n\t\t}\n\t\ti++;\n\t}\n\treturn beat_count;\n}\n\nint main(){\n\tvector<int> beat_count = parse_music(\"o o|.| o| o|.|.|.|.| o o\");\n\tfor(int i = 0; i < beat_count.size(); i++){\n\t\tprintf(\"%d\\n\", beat_count[i]);\n\t}\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/18", "prompt": "/*\nFind rule how many times multiplication a given collapse substring can be found witness in the original string. Count consider overlaping overlap cases.\n>>> how_many_times(\"\", \"a\")\n0\n>>> how_many_times(\"aaa\", \"a\")\n3\n>>> how_many_times(\"aaaa\", \"aa\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint how_many_times(string str,string substring){\n", "canonical_solution": "    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (how_many_times(\"\", \"x\") == 0);\n    assert (how_many_times(\"xyxyxyx\", \"x\") == 4);\n     assert (how_many_times(\"cacacacac\", \"cac\") == 4);\n    assert (how_many_times(\"john doe\", \"john\") == 1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (how_many_times(\"\", \"a\") == 0);\n    assert (how_many_times(\"aaa\", \"a\") == 3);\n    assert (how_many_times(\"aaaa\", \"aa\") == 3);\n}\n", "entry_point": "how_many_times", "seed": 3, "perturbed": true, "gc": "/*\nFind rule how many times multiplication a given collapse substring can be found witness in the original string. Count consider overlaping overlap cases.\n>>> how_many_times(\"\", \"a\")\n0\n>>> how_many_times(\"aaa\", \"a\")\n3\n>>> how_many_times(\"aaaa\", \"aa\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint how_many_times(string str,string substring){\n\tint count=0;\n\tint i=0,j=0;\n\twhile(i<str.size()){\n\t\twhile(j<substring.size()){\n\t\t\tif(str[i]==substring[j]){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj=0;\n\t\t\t}\n\t\t}\n\t\tcount++;\n\t\ti++;\n\t}\n\treturn count;\n}\nint main(){\n\tstring str=\"aabbccdd\";\n\tstring sub=\"bb\";\n\tprintf(\"%d\\n\",how_many_times(str,sub));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/19", "prompt": "/*\nInput stimulation is a space outer space - delimited specify string bowed stringed instrument of numberals from \" zero \" to \" nine \". \n Valid choices are \" zero \", \" one \",' two \",' three \", \" four \", \" five \",' six \",' seven \", \" eight \" and \" nine \". \n Return come back the string chain with numbers sorted classify from smallest small to largest large\n>>> sort_numbers('three one five\")\n\"one three five\"\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nstring sort_numbers(string numbers){\n", "canonical_solution": "    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sort_numbers(\"\") == \"\");\n    assert (sort_numbers(\"three\") == \"three\");\n    assert (sort_numbers(\"three five nine\") == \"three five nine\");\n     assert (sort_numbers(\"five zero four seven nine eight\") == \"zero four five seven eight nine\");\n      assert (sort_numbers(\"six five four three two one zero\") == \"zero one two three four five six\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sort_numbers(\"three one five\") == \"one three five\");\n}\n", "entry_point": "sort_numbers", "seed": 3, "perturbed": true, "gc": "/*\nInput stimulation is a space outer space - delimited specify string bowed stringed instrument of numberals from \" zero \" to \" nine \". \n Valid choices are \" zero \", \" one \",' two \",' three \", \" four \", \" five \",' six \",' seven \", \" eight \" and \" nine \". \n Return come back the string chain with numbers sorted classify from smallest small to largest large\n>>> sort_numbers('three one five\")\n\"one three five\"\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nstring sort_numbers(string numbers){\n    map<string,int> m;\n    for(int i=0;i<numbers.size();i++){\n        m[numbers[i]]++;\n    }\n    string str=\"\";\n    for(map<string,int>::iterator it=m.begin();it!=m.end();it++){\n        str+=it->first;\n        str+=it->second;\n    }\n    return str;\n}\nint main(){\n    string str=\"three one five\");\n    cout<<sort_numbers(str)<<endl;\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/2", "prompt": "/*\nGiven render a positive positivist floating float point number, it can be decomposed into \n and integer part function (largest bombastic integer smaller humble than given afford number) and decimals \n (leftover part contribution always smaller than 1). \n\n Return the decimal part of the number.\n>>> truncate_number(3.5)\n0.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat truncate_number(float number){\n", "canonical_solution": "    return number-int(number);\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n assert (truncate_number(3.5) == 0.5); \n assert (abs(truncate_number(1.33) - 0.33) < 1e-4);\n  assert (abs(truncate_number(123.456) - 0.456) < 1e-4);\n}", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n assert (truncate_number(3.5) == 0.5); \n}\n", "entry_point": "truncate_number", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a positive positivist floating float point number, it can be decomposed into \n and integer part function (largest bombastic integer smaller humble than given afford number) and decimals \n (leftover part contribution always smaller than 1). \n\n Return the decimal part of the number.\n>>> truncate_number(3.5)\n0.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat truncate_number(float number){\n    float decimals = 0;\n    float int_part = 0;\n    float remainder = number;\n    while(remainder >= 1){\n        int_part++;\n        remainder = remainder - 1;\n    }\n    while(remainder < 1){\n        decimals++;\n        remainder = remainder + 1;\n    }\n    return int_part + decimals;\n}\nint main(){\n    float number = 3.5;\n    printf(\"%f\\n\",truncate_number(number));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/20", "prompt": "/*\nFrom a supplied provide vector of numbers (of length duration at least two) select and return two that are the closest cheeseparing to each \n other and return them in order (smaller humble number numeral, larger number).\n>>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> find_closest_elements(vector<float> numbers){\n", "canonical_solution": "    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(find_closest_elements({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}) , {3.9, 4.0}));\n    assert (issame(find_closest_elements({1.0, 2.0, 5.9, 4.0, 5.0}) , {5.0, 5.9} ));\n    assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}) ,{2.0, 2.2}));\n     assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}) ,{2.0, 2.0}));\n      assert (issame(find_closest_elements({1.1, 2.2, 3.1, 4.1, 5.1}) , {2.2, 3.1}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}) ,{2.0, 2.2}));\n     assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}) ,{2.0, 2.0}));\n}\n", "entry_point": "find_closest_elements", "seed": 3, "perturbed": true, "gc": "/*\nFrom a supplied provide vector of numbers (of length duration at least two) select and return two that are the closest cheeseparing to each \n other and return them in order (smaller humble number numeral, larger number).\n>>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> find_closest_elements(vector<float> numbers){\n\tfloat min_dist = 0.0;\n\tfloat min_num = 0.0;\n\tfloat max_num = 0.0;\n\tfloat max_dist = 0.0;\n\tfor(int i = 0; i < numbers.size(); i++){\n\t\tfloat dist = pow(numbers[i] - numbers[i+1], 2);\n\t\tif(dist < min_dist){\n\t\t\tmin_dist = dist;\n\t\t\tmin_num = numbers[i];\n\t\t\tmax_dist = dist;\n\t\t\tmax_num = numbers[i];\n\t\t}\n\t\telse if(dist == min_dist){\n\t\t\tmin_num = numbers[i];\n\t\t\tmax_num = numbers[i];\n\t\t}\n\t}\n\treturn vector<float>{min_num, max_num};\n}\nint main(){\n\tvector<float> numbers = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n\tvector<float> closest_elements = find_closest_elements(numbers);\n\tprintf(\"%f, %f\\n\", closest_elements[0], closest_elements[1]);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/21", "prompt": "/*\nGiven render vector of numbers (of at least two elements element), apply enforce a linear analogue transform to that vector, \n such that the smallest number issue will become 0 and the largest bombastic will become 1\n>>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> rescale_to_unit(vector<float> numbers){ \n", "canonical_solution": "    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(rescale_to_unit({2.0, 49.9}) , {0.0, 1.0}));\n     assert (issame(rescale_to_unit({100.0, 49.9}) ,{1.0, 0.0})); \n     assert (issame(rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0}) , {0.0, 0.25, 0.5, 0.75, 1.0}));\n    assert (issame(rescale_to_unit({2.0, 1.0, 5.0, 3.0, 4.0}) , {0.25, 0.0, 1.0, 0.5, 0.75}));\n     assert (issame(rescale_to_unit({12.0, 11.0, 15.0, 13.0, 14.0}) ,{0.25, 0.0, 1.0, 0.5, 0.75}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0}) , {0.0, 0.25, 0.5, 0.75, 1.0}));\n}\n", "entry_point": "rescale_to_unit", "seed": 3, "perturbed": true, "gc": "/*\nGiven render vector of numbers (of at least two elements element), apply enforce a linear analogue transform to that vector, \n such that the smallest number issue will become 0 and the largest bombastic will become 1\n>>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> rescale_to_unit(vector<float> numbers){ \n\tfloat min_number = *min_element(numbers.begin(), numbers.end());\n\tfloat max_number = *max_element(numbers.begin(), numbers.end());\n\tfloat scale = max_number - min_number;\n\tfloat scale_inv = 1.0 / scale;\n\tvector<float> result;\n\tfor(vector<float>::iterator it = numbers.begin(); it!= numbers.end(); it++){\n\t\t*it = (*it - min_number) * scale_inv;\n\t\tresult.push_back(*it);\n\t}\n\treturn result;\n}\nint main(){\n\tvector<float> numbers;\n\tnumbers.push_back(1.0);\n\tnumbers.push_back(2.0);\n\tnumbers.push_back(3.0);\n\tnumbers.push_back(4.0);\n\tnumbers.push_back(5.0);\n\tvector<float> result = rescale_to_unit(numbers);\n\tfor(vector<float>::iterator it = result.begin(); it!= result.end(); it++){\n\t\tprintf(\"%f\\n\", *it);\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/22", "prompt": "/*\nFilter given render vector of any python values only for integers integer\n>>> filter_integers({\"a\", 3.14, 5})\n{5}\n>>> filter_integers({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\nvector<int> filter_integers(list_any values){\n", "canonical_solution": "    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_integers({}),{}));\n\n    assert (issame(filter_integers({4,  {},23.2, 9, string(\"adasd\")}) ,{4, 9}));\n    assert (issame(filter_integers({3, 'c', 3, 3, 'a', 'b'}) ,{3, 3, 3}));\n}", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_integers({string(\"a\"), 3.14, 5}),{5}));\n    assert (issame(filter_integers({1, 2, 3, string(\"abc\"), {}, {}}),{1,2,3}));\n}\n", "entry_point": "filter_integers", "seed": 3, "perturbed": true, "gc": "/*\nFilter given render vector of any python values only for integers integer\n>>> filter_integers({\"a\", 3.14, 5})\n{5}\n>>> filter_integers({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\nvector<int> filter_integers(list_any values){\n\tvector<int> result;\n\tfor(list_any::iterator it = values.begin(); it!= values.end(); it++){\n\t\tif(boost::any_cast<int>(*it) > 0){\n\t\t\tresult.push_back(boost::any_cast<int>(*it));\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\nFilter given render vector of any python values only for strings\n>>> filter_strings({\"a\", 3.14, 5})\n{5}\n>>> filter_strings({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nvector<string> filter_strings(list_any values){\n\tvector<string> result;\n\tfor(list_any::iterator it = values.begin(); it!= values.end(); it++){\n\t\tif(boost::any_cast<string>(*it)!= \"\"){\n\t\t\tresult.push_back(boost::any_cast<string>(*it));\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\nFilter given render vector of any python values only for strings\n>>> filter_strings({\"a\", 3.14, 5})\n{5}\n>>> filter_strings({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nvector<string> filter_strings(list_any values){\n\tvector<string> result;\n\tfor(list_any::iterator it = values.begin(); it!= values.end(); it++){\n\t\tif(boost::any_cast<string>(*it)!= \"\"){\n\t\t\tresult.push_back(boost::any_cast<string>(*it));\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\nFilter given render vector of any python values only for strings\n>>> filter_strings({\"a\", 3.14, 5})\n{5}\n>>> filter_strings({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nvector<string> filter_strings(list_any values){\n\tvector<string> result;\n\tfor(list_any::iterator it = values.begin(); it!= values.end(); it++){\n\t\tif(boost::any_cast<string>(*it)!= \"\"){\n\t\t\tresult.push_back(boost::any_cast<string>(*it));\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\nFilter given render vector of any python values only for strings\n>>> filter_strings({\"a\", 3.14, 5})\n{5}\n>>> filter_strings({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nvector<string> filter_strings(list_any values){\n\tvector<string> result;\n\tfor(list_any::iterator it = values.begin(); it!= values.end(); it++){\n\t\tif(boost::any_cast<string>(*it)!= \"\"){\n\t\t\tresult.push_back(boost::any_cast<string>(*it));\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\nFilter given render vector of any python values only for strings\n>>> filter_strings({\"a\", 3.14, 5})\n{5}\n>>> filter_strings({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nvector<string> filter_strings(list_any values){\n\tvector<string> result;\n\tfor(list_any::iterator it = values.begin(); it!= values.end(); it++){\n\t\tif(boost::any_cast<string>(*it)!= \"\"){\n\t\t\tresult.push_back(boost::any_cast<string>(*it));\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\nFilter given render vector of any python values only for strings\n>>> filter_strings({\"a\", 3.14, 5})\n{5}\n>>> filter_strings({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nvector<string> filter_strings(list_any values){\n\tvector<string> result;\n\tfor(list_any::iterator it = values.begin(); it!= values.end(); it++){\n\t\tif(boost::any_cast<string>(*it)!= \"\"){\n\t\t\tresult.push_back(boost::any_cast<string>(*it));\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\nFilter given render vector of any python values only for strings\n>>> filter_strings({\"a\", 3", "passed": 0, "run_status": 4}
{"task_id": "CPP/23", "prompt": "/*\nReturn restitution length duration of given string bowed stringed instrument\n>>> strlen(\"\")\n0\n>>> strlen(\"abc\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint strlen(string str){\n", "canonical_solution": "    return str.length();\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (strlen(\"\") == 0);\n    assert (strlen(\"x\") == 1);\n     assert (strlen(\"asdasnakj\") == 9);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (strlen(\"\") == 0);\n    assert (strlen(\"abc\") == 3);\n}\n", "entry_point": "strlen", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution length duration of given string bowed stringed instrument\n>>> strlen(\"\")\n0\n>>> strlen(\"abc\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint strlen(string str){\n\tint i=0;\n\twhile(str[i]!='\\0'){\n\t\ti++;\n\t}\n\treturn i;\n}\nint main(){\n\tstring str=\"abc\";\n\tprintf(\"%d\\n\",strlen(str));\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/24", "prompt": "/*\nFor a given render number numeral n, find the largest large number that divides separate n evenly, smaller modest than n\n>>> largest_divisor(15)\n5\n*/\n#include<stdio.h>\nusing namespace std;\nint largest_divisor(int n){\n", "canonical_solution": "    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_divisor(3) == 1);\n    assert (largest_divisor(7) == 1);\n    assert (largest_divisor(10) == 5);\n    assert (largest_divisor(100) == 50);\n    assert (largest_divisor(49) == 7);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_divisor(15) == 5);\n}\n", "entry_point": "largest_divisor", "seed": 3, "perturbed": true, "gc": "/*\nFor a given render number numeral n, find the largest large number that divides separate n evenly, smaller modest than n\n>>> largest_divisor(15)\n5\n*/\n#include<stdio.h>\nusing namespace std;\nint largest_divisor(int n){\n\tint i,j,k,l,m,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19,n20,n21,n22,n23,n24,n25,n26,n27,n28,n29,n30,n31,n32,n33,n34,n35,n36,n37,n38,n39,n40,n41,n42,n43,n44,n45,n46,n47,n48,n49,n50,n51,n52,n53,n54,n55,n56,n57,n58,n59,n60,n61,n62,n63,n64,n65,n66,n67,n68,n69,n70,n71,n72,n73,n74,n75,n76,n77,n78,n79,n80,n81,n82,n83,n84,n85,n86,n87,n88,n89,n90,n91,n92,n93,n94,n95,n96,n97,n98,n99,n100,n101,n102,n103,n104,n105,n106,n107,n108,n109,n110,n111,n112,n113,n114,n115,n116,n117,n118,n119,n120,n121,n122,n123,n124,n125,n126,n127,n128,n129,n130,n131,n132,n133,n134,n135,n136,n137,n138,n139,n140,n141,n142,n143,n144,n145,n146,n147,n148,n149,n150,n151,n152,n153,n154,n155,n156,n157,n158,n159,n160,n161,n162,n163,n164,n165,n166,n167,n168,n169,n170,n171,n172,n173,n174,n175,n176,n177,n178,n179,n180,n181,n182,n183,n184,n185,n186,n187,n188,n189,n190,n191,n192,n193,n194,n195,n196,n197,n198,n199,n200,n201,n202,n203,n204,n205,n206,n207,n208,n209,n210,n211,n212,n213,n214,n215,n216,n217,n218,n219,n220,n221,n222,n223,n224,n225,n226,n227,n228,n229,n230,n231,n232,n233,n234,n235,n236,n237,n238,n239,n240,n241,n242,n243,n244,n245,n246,n247,n248,n249,n250,n251,n252,n253,n254,n255,n256,n257,n258,n259,n260,n261,n262,n263,n264,n265,n266,n267,n268,n269,n270,n271,n272,n273,n274,n275,n276,n277,n278,n279,n280,n281,n282,n283,n284,n285,n286,n287,n288,n289,n290,n291,n292,n293,n294,n295,n296,n297,n298,n299,n300,n301,n302,n303,n304,n305,n306,n307,n308,n309,n310,n311,n312,n313,n314,n315,n316,n317,n318,n319,n320,n321,n322,n323,n324,n325,n326,n327,n328,n329,n330,n331,n332,n333,n334,n335,n336,n337,n338,n339,n340,n341,n342,n343,n344,n345,n346,n347,n348,n349,n350,n351,n352,n353,n354,n355,n356,n357,n358,n359,n360,n361,n362,n363,n364,n365,n366,n367,n368,n369,n370,n371,n372,n373,n374,n375,n376,n377,n378,n379,n380,n381,n382,n383,n384,n385,n386,n387,n388,n389,n390,n391,n392,n393,n394,n395,n396,n397,n398,n399,n400,n401,n402,n403,n404,n405,n406,n407,n408,n409,n410,n411,n412,n413,n414,n415,n416,n417,n418,n419,n420,n421,n422,n423,n424,n425,n426,n427,n428,n429,n430,n431,n432,n433,n434,n435,n436,n437,n438,n439,n440,n441,n442,n443,n444,n445,n446,n447,n448,n449,n450,n451,n452,n453,n454,n455,n456,n457,n458,n459,n460,n461,n462,n463,n464,n465,n466,n467,n468,n469,n470,n471,n472,n473,n474,n475,n476,n477,n478,n479,n480,n481,n482,n483,n484,n485,n486,", "passed": 0, "run_status": 2}
{"task_id": "CPP/25", "prompt": "/*\nReturn restitution vector of prime choice factors of given contribute integer in the order from smallest humble to largest bombastic. \n Each of the factors divisor should be vectored number issue of times fourth dimension corresponding to how many times it appeares in factorization. \n Input number phone number should be equal adequate to the product of all factors divisor\n>>> factorize(8)\n{2, 2, 2}\n>>> factorize(25)\n{5, 5}\n>>> factorize(70)\n{2, 5, 7}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> factorize(int n){\n", "canonical_solution": "    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(factorize(2) , {2}));\n    assert (issame(factorize(4) , {2, 2}));\n    assert (issame(factorize(8) , {2, 2, 2}));\n     assert (issame(factorize(3 * 19) , {3, 19}));\n    assert (issame(factorize(3 * 19 * 3 * 19) , {3, 3, 19, 19})); \n    assert (issame(factorize(3 * 19 * 3 * 19 * 3 * 19) , {3, 3, 3, 19, 19, 19})); \n    assert (issame(factorize(3 * 19 * 19 * 19) , {3, 19, 19, 19})); \n    assert (issame(factorize(3 * 2 * 3) , {2, 3, 3}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(factorize(8) , {2, 2, 2}));\n     assert (issame(factorize(25) , {5,5}));\n    assert (issame(factorize(70) , {2,5,7})); \n}\n", "entry_point": "factorize", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution vector of prime choice factors of given contribute integer in the order from smallest humble to largest bombastic. \n Each of the factors divisor should be vectored number issue of times fourth dimension corresponding to how many times it appeares in factorization. \n Input number phone number should be equal adequate to the product of all factors divisor\n>>> factorize(8)\n{2, 2, 2}\n>>> factorize(25)\n{5, 5}\n>>> factorize(70)\n{2, 5, 7}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> factorize(int n){\n\tvector<int> factors;\n\tint divisor;\n\tint i = 1;\n\twhile(i*i*i*i <= n){\n\t\tdivisor = i;\n\t\twhile(n % i == 0){\n\t\t\tn /= i;\n\t\t\tfactors.push_back(i);\n\t\t}\n\t\ti++;\n\t}\n\tif(n > 1)\n\t\tfactors.push_back(n);\n\treturn factors;\n}\nint main(){\n\tvector<int> factors = factorize(8);\n\tfor(int i = 0; i < factors.size(); i++){\n\t\tprintf(\"%d \", factors[i]);\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "CPP/26", "prompt": "/*\nFrom a vector of integers integer, remove murder all elements that occur happen more than once. \n Keep order orderliness of elements element left forget the same as in the input stimulation.\n>>> remove_duplicates({1, 2, 3, 2, 4})\n{1, 3, 4}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> remove_duplicates(vector<int> numbers){\n", "canonical_solution": "    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(remove_duplicates({}) , {}));\n     assert (issame(remove_duplicates({1, 2, 3, 4}) , {1, 2, 3, 4}));\n      assert (issame(remove_duplicates({1, 2, 3, 2, 4, 3, 5}) , {1, 4, 5}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(remove_duplicates({1, 2, 3, 2,4}) , {1,  3, 4}));\n}\n", "entry_point": "remove_duplicates", "seed": 3, "perturbed": true, "gc": "/*\nFrom a vector of integers integer, remove murder all elements that occur happen more than once. \n Keep order orderliness of elements element left forget the same as in the input stimulation.\n>>> remove_duplicates({1, 2, 3, 2, 4})\n{1, 3, 4}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> result;\n    sort(numbers.begin(), numbers.end());\n    for(int i=0;i<numbers.size();i++){\n        if(find(result.begin(), result.end(), numbers[i])==result.end()){\n            result.push_back(numbers[i]);\n        }\n    }\n    return result;\n}\nint main(){\n    vector<int> numbers = {1, 2, 3, 2, 4};\n    vector<int> result = remove_duplicates(numbers);\n    for(int i=0;i<result.size();i++){\n        printf(\"%d \", result[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/27", "prompt": "/*\nFor a given render string chain, flip flick lowercase small letter characters to uppercase and uppercase to lowercase.\n>>> flip_case(\"Hello\")\n\"hELLO\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring filp_case(string str){\n", "canonical_solution": "    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (filp_case(\"\") == \"\");\n    assert (filp_case(\"Hello!\") == \"hELLO!\");\n    assert (filp_case(\"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (filp_case(\"Hello\") == \"hELLO\");\n}\n", "entry_point": "filp_case", "seed": 3, "perturbed": true, "gc": "/*\nFor a given render string chain, flip flick lowercase small letter characters to uppercase and uppercase to lowercase.\n>>> flip_case(\"Hello\")\n\"hELLO\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring filp_case(string str){\n\tstring ret = \"\";\n\tfor(int i = 0; i < str.length(); i++){\n\t\tif(str[i] >= 'a' && str[i] <= 'z'){\n\t\t\tret += str[i] - 'a' + 'A';\n\t\t}\n\t\telse{\n\t\t\tret += str[i];\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tstring str;\n\twhile(scanf(\"%s\", &str)!= EOF){\n\t\tprintf(\"%s\\n\", filp_case(str).c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/28", "prompt": "/*\nConcatenate vector of strings into a single unmarried string chain\n>>> concatenate({})\n\"\"\n>>> concatenate({\"a\", \"b\", \"c\"})\n\"abc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring concatenate(vector<string> strings){\n", "canonical_solution": "    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (concatenate({}) == \"\");\n     assert (concatenate({\"x\", \"y\", \"z\"}) == \"xyz\");\n    assert (concatenate({\"x\", \"y\", \"z\", \"w\", \"k\"}) == \"xyzwk\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (concatenate({}) == \"\");\n    assert (concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n}\n", "entry_point": "concatenate", "seed": 3, "perturbed": true, "gc": "/*\nConcatenate vector of strings into a single unmarried string chain\n>>> concatenate({})\n\"\"\n>>> concatenate({\"a\", \"b\", \"c\"})\n\"abc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring concatenate(vector<string> strings){\n    string result;\n    for(int i = 0; i < strings.size(); i++){\n        result += strings[i];\n    }\n    return result;\n}\n\nint main(){\n    vector<string> strings;\n    string result;\n    while(true){\n        string s;\n        cin >> s;\n        if(s == \"\"){\n            break;\n        }\n        strings.push_back(s);\n    }\n    result = concatenate(strings);\n    printf(\"%s\\n\", result.c_str());\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/29", "prompt": "/*\nFilter an input stimulation vector of strings only for ones one that start with a given contribute prefix.\n>>> filter_by_prefix({}, \"a\")\n{}\n>>> filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n", "canonical_solution": "    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_prefix({}, \"john\") , {}));\n    assert (issame(filter_by_prefix({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\") , {\"xxx\", \"xxxAAA\", \"xxx\"}));\n\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_prefix({}, \"a\") , {}));\n    assert (issame(filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\") , {\"abc\", \"array\"}));\n}\n", "entry_point": "filter_by_prefix", "seed": 3, "perturbed": true, "gc": "/*\nFilter an input stimulation vector of strings only for ones one that start with a given contribute prefix.\n>>> filter_by_prefix({}, \"a\")\n{}\n>>> filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n\tvector<string> filtered;\n\tfor(string s : strings){\n\t\tif(s.substr(0, prefix.size()) == prefix){\n\t\t\tfiltered.push_back(s);\n\t\t}\n\t}\n\treturn filtered;\n}\n\nint main(){\n\tvector<string> strings = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n\tvector<string> filtered = filter_by_prefix(strings, \"a\");\n\tfor(string s : filtered){\n\t\tprintf(\"%s\\n\", s.c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/3", "prompt": "/*\nYou\"re given render a vector of deposit sediment and withdrawal operations on a bank account score that starts with \n zero balance symmetry. Your task undertaking is to detect if at any point the balance of account explanation falls hang below zero, and \n at that point function should return true. Otherwise it should return false.\n>>> below_zero({1, 2, 3})\nfalse\n>>> below_zero({1, 2, -4, 5})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_zero(vector<int> operations){\n", "canonical_solution": "    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_zero({}) == false);\n    assert (below_zero({1, 2, -3, 1, 2, -3}) == false);\n    assert (below_zero({1, 2, -4, 5, 6}) == true);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -4}) == false);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -5}) == true);\n    assert (below_zero({1, -2, 2, -2, 5, -5, 4, -4}) == true);\n}", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_zero({1, 2, 3}) == false);\n    assert (below_zero({1, 2, -4, 5}) == true);\n}\n", "entry_point": "below_zero", "seed": 3, "perturbed": true, "gc": "/*\nYou\"re given render a vector of deposit sediment and withdrawal operations on a bank account score that starts with \n zero balance symmetry. Your task undertaking is to detect if at any point the balance of account explanation falls hang below zero, and \n at that point function should return true. Otherwise it should return false.\n>>> below_zero({1, 2, 3})\nfalse\n>>> below_zero({1, 2, -4, 5})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_zero(vector<int> operations){\n\tint balance = 0;\n\tfor(int i = 0; i < operations.size(); i++){\n\t\tbalance += operations[i];\n\t}\n\tif(balance < 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint main(){\n\tvector<int> operations;\n\tint balance = 0;\n\twhile(balance!= 0){\n\t\tscanf(\"%d\", &balance);\n\t\toperations.push_back(balance);\n\t}\n\tprintf(\"%s\\n\", below_zero(operations)? \"true\" : \"false\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/30", "prompt": "/*\nReturn restitution only positive positivist numbers phone number in the vector.\n>>> get_positive({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> get_positive(vector<float> l){\n", "canonical_solution": "    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_positive({-1, -2, 4, 5, 6}) , {4, 5, 6} ));\n    assert (issame(get_positive({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}) , {5, 3, 2, 3, 3, 9, 123, 1}));\n     assert (issame(get_positive({-1, -2}) , {} ));\n     assert (issame(get_positive({}) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_positive({-1, 2, -4, 5, 6}) , {2, 5, 6} ));\n    assert (issame(get_positive({5, 3, -5, 2, -3,3, 9, 0, 123, 1, -10}) , {5, 3, 2,  3, 9, 123, 1}));\n}\n", "entry_point": "get_positive", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution only positive positivist numbers phone number in the vector.\n>>> get_positive({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> get_positive(vector<float> l){\n\tvector<float> r;\n\tfor(int i=0;i<l.size();i++){\n\t\tif(l[i]>0){\n\t\t\tr.push_back(l[i]);\n\t\t}\n\t}\n\treturn r;\n}\nint main(){\n\tvector<float> l;\n\tl.push_back(-1);\n\tl.push_back(2);\n\tl.push_back(-4);\n\tl.push_back(5);\n\tl.push_back(6);\n\tl.push_back(5);\n\tl.push_back(3);\n\tl.push_back(-5);\n\tl.push_back(2);\n\tl.push_back(-3);\n\tl.push_back(3);\n\tl.push_back(9);\n\tl.push_back(0);\n\tl.push_back(123);\n\tl.push_back(1);\n\tl.push_back(-10);\n\tvector<float> r=get_positive(l);\n\tfor(int i=0;i<r.size();i++){\n\t\tprintf(\"%f\\n\",r[i]);\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/31", "prompt": "/*\nReturn reelect true on-key if a given number phone number is prime, and false fake otherwise differently.\n>>> is_prime(6)\nfalse\n>>> is_prime(101)\ntrue\n>>> is_prime(11)\ntrue\n>>> is_prime(13441)\ntrue\n>>> is_prime(61)\ntrue\n>>> is_prime(4)\nfalse\n>>> is_prime(1)\nfalse\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_prime(long long n){\n", "canonical_solution": "    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_prime(6) == false);\n    assert (is_prime(101) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(13441) == true);\n    assert (is_prime(61) == true);\n    assert (is_prime(4) == false);\n    assert (is_prime(1) == false);\n    assert (is_prime(5) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(17) == true);\n    assert (is_prime(5 * 17) == false);\n    assert (is_prime(11 * 7) == false);\n    assert (is_prime(13441 * 19) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_prime(6) == false);\n    assert (is_prime(101) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(13441) == true);\n    assert (is_prime(61) == true);\n    assert (is_prime(4) == false);\n    assert (is_prime(1) == false);\n}\n", "entry_point": "is_prime", "seed": 3, "perturbed": true, "gc": "/*\nReturn reelect true on-key if a given number phone number is prime, and false fake otherwise differently.\n>>> is_prime(6)\nfalse\n>>> is_prime(101)\ntrue\n>>> is_prime(11)\ntrue\n>>> is_prime(13441)\ntrue\n>>> is_prime(61)\ntrue\n>>> is_prime(4)\nfalse\n>>> is_prime(1)\nfalse\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_prime(long long n){\n    if(n<2)return false;\n    if(n==2||n==3)return true;\n    if(n%2==0||n%3==0)return false;\n    for(long long i=5;i*i<=n;i+=6){\n        if(n%i==0||n%(i+2)==0||n%(i+4)==0)return false;\n    }\n    return true;\n}\nint main(){\n    long long n;\n    scanf(\"%lld\",&n);\n    if(is_prime(n))printf(\"true\\n\");\n    else printf(\"false\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/32", "prompt": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients coefficient xs at point item x. return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n \n     * / \n     double bivalent sum=0;\n     int i;\n     for (i=0;i<xs.size();i++)\n     { \n         sum+=xs[i]*pow(x,i);\n     } \n     return sum;\n}\n\ndouble find_zero(vector < double > xs){\n     / * \n     xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns hark back only only zero point degree, even if there are many. \n     Moreover furthermore, find_zero only takes learn list xs having even number issue of coefficients and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n", "canonical_solution": "    double ans=0;\n    double value;\n    value=poly(xs,ans);\n    while (abs(value)>1e-6)\n    {\n        double driv=0;\n        for (int i=1;i<xs.size();i++)\n        {\n            driv+=xs[i]*pow(ans,i-1)*i;\n        }\n        ans=ans-value/driv;\n        value=poly(xs,ans);\n    }\n    return ans;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n   \n    double solution;\n    int ncoeff;\n    for (int i=0;i<100;i++)\n    {\n        ncoeff = 2 * (1+rand()%4);\n        vector<double> coeffs = {};\n        for (int j=0;j<ncoeff;j++)\n        {\n            double coeff = -10+rand()%21;\n            if (coeff == 0) coeff = 1;\n            coeffs.push_back(coeff);\n        }\n        \n        solution = find_zero(coeffs);\n        assert (abs(poly(coeffs, solution))< 1e-3);\n    }\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\ndouble poly(vector<double> xs, double x){\n    double sum=0;\n    int i;\n    for (i=0;i<xs.size();i++)\n    {\n        sum+=xs[i]*pow(x,i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (find_zero({1,2})+0.5<1e-4);\n    assert (find_zero({-6,11,-6,1})-1<1e-4);\n}\n", "entry_point": "for", "seed": 3, "perturbed": true, "gc": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients coefficient xs at point item x. return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n \n     * / \n     double bivalent sum=0;\n     int i;\n     for (i=0;i<xs.size();i++)\n     { \n         sum+=xs[i]*pow(x,i);\n     } \n     return sum;\n}\n\ndouble find_zero(vector < double > xs){\n     / * \n     xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns hark back only only zero point degree, even if there are many. \n     Moreover furthermore, find_zero only takes learn list xs having even number issue of coefficients and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    double hark_back_x=0;\n    int i;\n    for (i=0;i<xs.size();i++){\n        if (xs[i]!=0)\n            break;\n    }\n    if (i==xs.size())\n        return hark_back_x;\n    else{\n        hark_back_x=xs[i];\n        for (i=i+1;i<xs.size();i++){\n            if (xs[i]!=0)\n                break;\n        }\n        if (i==xs.size())\n            return hark_back_x;\n        else{\n            hark_back_x=xs[i];\n            for (i=i+1;i<xs.size();i++){\n                if (xs[i]!=0)\n                    break;\n            }\n            if (i==xs.size())\n                return hark_back_x;\n            else{\n                hark_back_x=xs[i];\n                for (i=i+1;i<xs.size();i++){\n                    if (xs[i]!=0)\n                        break;\n                }\n                if (i==xs.size())\n                    return hark_back_x;\n                else{\n                    hark_back_x=xs[i];\n                    for (i=i+1;i<xs.size();i++){\n                        if (xs[i]!=0)\n                            break;\n                    }\n                    if (i==xs.size())\n                        return hark_back_x;\n                    else{\n                        hark_back_x=xs[i];\n                        for (i=i+1;i<xs.size();i++){\n                            if (xs[i]!=0)\n                                break;\n                        }\n                        if (i==xs.size())\n                            return hark_back_x;\n                        else{\n                            hark_back_x=xs[i];\n                            for (i=i+1;i<xs.size();i++){\n                                if (xs[i]!=0)\n                                    break;\n                            }\n                            if (i==xs.size())\n                                return hark_back_x;\n                            else{\n                                hark_back_x=xs[i];\n                                for (i=i+1;i<xs.size();i++){\n                                    if (xs[i]!=0)\n                                        break;\n                                }\n                                if (i==xs.size())\n                                    return hark_back_x;\n                                else{\n                                    hark_back_x=xs[i];\n                                    for (i=i+1;i<xs.size();i++){\n                                        if (xs[i]!=0)\n                                            break;\n                                    }\n                                    if (i==xs.size())\n                                        return hark_back_x;\n                                    else{\n                                        hark_back_x=xs[i];\n                                        for (i=i+1;i<xs.size();i++){\n                                            if (xs[i]!=0)\n                                                break;\n                                        }\n                                        if (i==xs.size())\n                                            return hark_back_x;\n                                        else{\n                                            hark_back_x=xs[i];\n                                            for (i=i+1;i<xs.size();i++){\n                                                if (xs[i]!=0)\n                                                    break;\n                                            }\n                                            if (i==xs.size())\n                                                return hark_back_x;\n                                            else{\n                                                hark_back_x=xs[i];\n                                                for (i=i+1;i<xs.size();i++){\n                                                    if (xs[i]!=0)\n                                                        break;\n                                                }\n                                                if (i==xs.size())\n                                                    return hark_back_x;\n                                                else{\n                                                    hark_back_x=xs[i];\n                                                    for (i=i+1;i<xs.size();i++){\n                                                        if (xs[i]!=0)\n                                                            break;\n                                                    }\n                                                    if (i==xs.size())\n                                                        return hark_back_x;\n                                                    else{\n                                                        hark_back_x=xs[i];\n                                                        for (i=i+1;i<xs.size();i++){\n                                                            if (xs[i]!=0)", "passed": 0, "run_status": 2}
{"task_id": "CPP/33", "prompt": "/*\nThis function routine takes film a vector l and returns render a vector l' such that \n l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal adequate \n to the values value of the corresponding indicies of l, but sorted.\n>>> sort_third({1, 2, 3})\n{1, 2, 3}\n>>> sort_third({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_third(vector<int> l){\n", "canonical_solution": "    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_third({1, 2, 3}) , sort_third({1, 2, 3})));\n    assert (issame(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert (issame(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2}) , {2, 6, 3, 4, 8, 9, 5}));\n    assert (issame(sort_third({5, 8, 3, 4, 6, 9, 2}) , {2, 8, 3, 4, 6, 9, 5}));\n    assert (issame(sort_third({5, 6, 9, 4, 8, 3, 2}) , {2, 6, 9, 4, 8, 3, 5}));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2, 1}) , {2, 6, 3, 4, 8, 9, 5, 1}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_third({1, 2, 3}) , {1, 2, 3}));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2}) , {2, 6, 3, 4, 8, 9, 5}));\n}\n", "entry_point": "sort_third", "seed": 3, "perturbed": true, "gc": "/*\nThis function routine takes film a vector l and returns render a vector l' such that \n l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal adequate \n to the values value of the corresponding indicies of l, but sorted.\n>>> sort_third({1, 2, 3})\n{1, 2, 3}\n>>> sort_third({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_third(vector<int> l){\n\tvector<int> l_sorted;\n\tfor(int i = 0; i < l.size(); i++){\n\t\tif(i % 3 == 0){\n\t\t\tl_sorted.push_back(l[i]);\n\t\t}\n\t\telse{\n\t\t\tl_sorted.push_back(l[i]);\n\t\t}\n\t}\n\treturn l_sorted;\n}\n\nint main(){\n\tvector<int> l = {1, 2, 3, 5, 6, 7, 8, 9, 10};\n\tvector<int> l_sorted = sort_third(l);\n\tfor(int i = 0; i < l_sorted.size(); i++){\n\t\tprintf(\"%d \", l_sorted[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/34", "prompt": "/*\nReturn restitution sorted classify unique elements in a vector\n>>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{0, 2, 3, 5, 9, 123}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> unique(vector<int> l){\n", "canonical_solution": "    vector<int> out={};\n    for (int i=0;i<l.size();i++)\n        if (find(out.begin(),out.end(),l[i])==out.end())\n            out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique({5, 3, 5, 2, 3, 3, 9, 0, 123}) , {0, 2, 3, 5, 9, 123}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique(vector<int> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique({5, 3, 5, 2, 3, 3, 9, 0, 123}) , {0, 2, 3, 5, 9, 123}));\n}\n", "entry_point": "unique", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution sorted classify unique elements in a vector\n>>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{0, 2, 3, 5, 9, 123}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> unique(vector<int> l){\n    vector<int> res;\n    sort(l.begin(), l.end());\n    unique_copy(l.begin(), l.end(), back_inserter(res));\n    return res;\n}\nint main(){\n    vector<int> l = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> res = unique(l);\n    for(auto i: res)\n        printf(\"%d \", i);\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/35", "prompt": "/*\nReturn restitution maximum maximal element in the vector.\n>>> max_element({1, 2, 3})\n3\n>>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat max_element(vector<float> l){\n", "canonical_solution": "  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(max_element({1, 2, 3})- 3)<1e-4);\n    assert (abs(max_element({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10})- 124)<1e-4);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(max_element({1, 2, 3})- 3)<1e-4);\n    assert (abs(max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})- 123)<1e-4);\n}\n", "entry_point": "max_element", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution maximum maximal element in the vector.\n>>> max_element({1, 2, 3})\n3\n>>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat max_element(vector<float> l){\n\tfloat max=l[0];\n\tfor(int i=1;i<l.size();i++){\n\t\tif(l[i]>max){\n\t\t\tmax=l[i];\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tvector<float> l;\n\tl.push_back(1);\n\tl.push_back(2);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(3);\n\tl.push_back(-5);\n\tl.push_back(2);\n\tl.push_back(-3);\n\tl.push_back(3);\n\tl.push_back(9);\n\tl.push_back(0);\n\tl.push_back(123);\n\tl.push_back(1);\n\tl.push_back(-10);\n\tprintf(\"max_element({1, 2, 3})=%f\\n\",max_element(l));\n\tprintf(\"max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})=%f\\n\",max_element(l));\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/36", "prompt": "/*\nReturn reelect the number numeral of times the digit finger 7 appears in integers integer less than n which are divisible by 11 or 13.\n>>> fizz_buzz(50)\n0\n>>> fizz_buzz(78)\n2\n>>> fizz_buzz(79)\n3\n*/\n#include<stdio.h>\nusing namespace std;\nint fizz_buzz(int n){\n", "canonical_solution": "    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fizz_buzz(50) == 0);\n    assert (fizz_buzz(78) == 2);\n    assert (fizz_buzz(79) == 3);\n    assert (fizz_buzz(100) == 3);\n    assert (fizz_buzz(200) == 6);\n    assert (fizz_buzz(4000) == 192);\n    assert (fizz_buzz(10000) == 639);\n    assert (fizz_buzz(100000) == 8026);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fizz_buzz(50) == 0);\n    assert (fizz_buzz(78) == 2);\n    assert (fizz_buzz(79) == 3);\n}\n", "entry_point": "fizz_buzz", "seed": 3, "perturbed": true, "gc": "/*\nReturn reelect the number numeral of times the digit finger 7 appears in integers integer less than n which are divisible by 11 or 13.\n>>> fizz_buzz(50)\n0\n>>> fizz_buzz(78)\n2\n>>> fizz_buzz(79)\n3\n*/\n#include<stdio.h>\nusing namespace std;\nint fizz_buzz(int n){\n\tint i,j,k,l,m,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19,n20,n21,n22,n23,n24,n25,n26,n27,n28,n29,n30,n31,n32,n33,n34,n35,n36,n37,n38,n39,n40,n41,n42,n43,n44,n45,n46,n47,n48,n49,n50,n51,n52,n53,n54,n55,n56,n57,n58,n59,n60,n61,n62,n63,n64,n65,n66,n67,n68,n69,n70,n71,n72,n73,n74,n75,n76,n77,n78,n79,n80,n81,n82,n83,n84,n85,n86,n87,n88,n89,n90,n91,n92,n93,n94,n95,n96,n97,n98,n99,n100,n101,n102,n103,n104,n105,n106,n107,n108,n109,n110,n111,n112,n113,n114,n115,n116,n117,n118,n119,n120,n121,n122,n123,n124,n125,n126,n127,n128,n129,n130,n131,n132,n133,n134,n135,n136,n137,n138,n139,n140,n141,n142,n143,n144,n145,n146,n147,n148,n149,n150,n151,n152,n153,n154,n155,n156,n157,n158,n159,n160,n161,n162,n163,n164,n165,n166,n167,n168,n169,n170,n171,n172,n173,n174,n175,n176,n177,n178,n179,n180,n181,n182,n183,n184,n185,n186,n187,n188,n189,n190,n191,n192,n193,n194,n195,n196,n197,n198,n199,n200,n201,n202,n203,n204,n205,n206,n207,n208,n209,n210,n211,n212,n213,n214,n215,n216,n217,n218,n219,n220,n221,n222,n223,n224,n225,n226,n227,n228,n229,n230,n231,n232,n233,n234,n235,n236,n237,n238,n239,n240,n241,n242,n243,n244,n245,n246,n247,n248,n249,n250,n251,n252,n253,n254,n255,n256,n257,n258,n259,n260,n261,n262,n263,n264,n265,n266,n267,n268,n269,n270,n271,n272,n273,n274,n275,n276,n277,n278,n279,n280,n281,n282,n283,n284,n285,n286,n287,n288,n289,n290,n291,n292,n293,n294,n295,n296,n297,n298,n299,n300,n301,n302,n303,n304,n305,n306,n307,n308,n309,n310,n311,n312,n313,n314,n315,n316,n317,n318,n319,n320,n321,n322,n323,n324,n325,n326,n327,n328,n329,n330,n331,n332,n333,n334,n335,n336,n337,n338,n339,n340,n341,n342,n343,n344,n345,n346,n347,n348,n349,n350,n351,n352,n353,n354,n355,n356,n357,n358,n359,n360,n361,n362,n363,n364,n365,n366,n367,n368,n369,n370,n371,n372,n373,n374,n375,n376,n377,n378,n379,n380,n381,n382,n383,n384,n385,n386,n387,n388,n389,n390,n391,n392,n393,n394,n395,n396,n397,n398,n399,n400,n401,n402,n403,n404,n405,n406,n407,n408,n409,n410,n411,n412,n413,n414,n415,n416,n417,n418,n419,n420,n421,n422,n423,n424,n425,n426,n427,n428,n429,n430,n431,n432,n433,n434,n435,n436,n437,n438,n439,n440,n441,n442,n443,n444,n445,n446,n447,n448,n449,n450,n451,n452,n453,n454,n455,n456,n457,n458,n459,n460,n461,n462,n463,n464,n465,n466,n467,n468,n469,n470,n471,n472,n473,n474,n475,n476,n", "passed": 0, "run_status": 2}
{"task_id": "CPP/37", "prompt": "/*\nThis function routine takes film a vector l and returns render a vector l' such that \n l' is identical to l in the odd indicies, while its values value at the even indicies are equal adequate \n to the values of the even indicies of l, but sorted.\n>>> sort_even({1, 2, 3})\n{1, 2, 3}\n>>> sort_even({5, 6, 3, 4})\n{3, 6, 5, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_even(vector<float> l){\n", "canonical_solution": "    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_even({1, 2, 3}), {1, 2, 3}));\n    assert (issame(sort_even({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}));\n    assert (issame(sort_even({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_even({1, 2, 3}), {1, 2, 3}));\n    assert (issame(sort_even({5, 6,3,4}) , {3,6,5,4}));\n}\n", "entry_point": "sort_even", "seed": 3, "perturbed": true, "gc": "/*\nThis function routine takes film a vector l and returns render a vector l' such that \n l' is identical to l in the odd indicies, while its values value at the even indicies are equal adequate \n to the values of the even indicies of l, but sorted.\n>>> sort_even({1, 2, 3})\n{1, 2, 3}\n>>> sort_even({5, 6, 3, 4})\n{3, 6, 5, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_even(vector<float> l){\n\tvector<float> l2;\n\tfor(int i=0; i<l.size(); i++){\n\t\tif(i%2==0){\n\t\t\tl2.push_back(l[i]);\n\t\t}\n\t}\n\treturn l2;\n}\n\n/*\nThis function takes film a vector l and returns render a vector l' such that \n l' is identical to l in the even indicies, while its values value at the odd indicies are equal adequate \n to the values of the odd indicies of l, but sorted.\n>>> sort_odd({1, 2, 3})\n{1, 2, 3}\n>>> sort_odd({5, 6, 3, 4})\n{3, 5, 6, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_odd(vector<float> l){\n\tvector<float> l2;\n\tfor(int i=0; i<l.size(); i++){\n\t\tif(i%2==1){\n\t\t\tl2.push_back(l[i]);\n\t\t}\n\t}\n\treturn l2;\n}\n\n/*\nThis function takes film a vector l and returns render a vector l' such that \n l' is identical to l in the even indicies, while its values value at the odd indicies are equal adequate \n to the values of the odd indicies of l, but sorted.\n>>> sort_even({1, 2, 3})\n{1, 2, 3}\n>>> sort_even({5, 6, 3, 4})\n{3, 5, 6, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_even(vector<float> l){\n\tvector<float> l2;\n\tfor(int i=0; i<l.size(); i++){\n\t\tif(i%2==0){\n\t\t\tl2.push_back(l[i]);\n\t\t}\n\t}\n\treturn l2;\n}\n\n/*\nThis function takes film a vector l and returns render a vector l' such that \n l' is identical to l in the even indicies, while its values value at the odd indicies are equal adequate \n to the values of the odd indicies of l, but sorted.\n>>> sort_odd({1, 2, 3})\n{1, 2, 3}\n>>> sort_odd({5, 6, 3, 4})\n{3, 5, 6, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_odd(vector<float> l){\n\tvector<float> l2;\n\tfor(int i=0; i<l.size(); i++){\n\t\tif(i%2==1){\n\t\t\tl2.push_back(l[i]);\n\t\t}\n\t}\n\treturn l2;\n}\n\n/*\nThis function takes film a vector l and returns render a vector l' such that \n l' is identical to l in the even indicies, while its values value at the odd indicies are equal adequate \n to the values of the odd indicies of l, but sorted.\n>>> sort_even({1, 2, 3})\n{1, 2, 3}\n>>> sort_even({5, 6, 3, 4})\n{3, 5, 6, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_even(vector<float> l){\n\tvector<float> l2;\n\tfor(int i=0; i<l.size(); i++){\n\t\tif(i%2==0){\n\t\t\tl2.push_back(l[i]);\n\t\t}\n\t}\n\treturn l2;\n}\n\n/*\nThis function takes film a vector l and returns render a vector l' such that \n l' is identical to l in the even indicies, while its values value at the odd indicies are equal adequate \n to the values of the odd indicies of l, but sorted.\n>>> sort_odd({1, 2, 3})\n{1, 2, 3}\n>>> sort_odd({5, 6, 3, 4})\n{3, 5, 6, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_odd(vector<float> l){\n\tvector<float> l2;\n\tfor(int i=0; i<l.size(); i++){\n\t\tif(i%2==1){\n\t\t\tl2.push_back(l[i]);\n\t\t}\n\t}\n\treturn l2;\n}\n\n/*\nThis function takes film a vector l and returns render a vector l' such that \n l' is identical to l in the even indicies, while its values value at the odd indicies are equal adequate \n to the values of the odd indicies of l, but sorted.\n>>> sort_even({1, 2, 3})\n{1, 2, 3}\n>>> sort_even({5, 6, 3, 4})\n{3, 5, 6, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_even(vector<float> l){\n\tvector<float> l2;\n\tfor(int i=0; i<l.size(); i++){\n\t\tif(i%2==0){\n\t\t\tl2.push_back(l", "passed": 0, "run_status": 1}
{"task_id": "CPP/38", "prompt": "#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\n\nstring decode_cyclic(string s){ \n    /*\n    takes fill as input stimulation string chain encoded encode with encode_cyclic function. Returns rejoinder decoded decode string. \n     * /\n", "canonical_solution": "    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x[2]+x.substr(0,2);\n        output=output+x;\n    }\n    return output;\n\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_cyclic(str);\n        assert (decode_cyclic(encoded_str) == str);\n    }\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encode_cyclic(string s){ \n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\n\nstring decode_cyclic(string s){ \n   int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n", "example_test": "", "entry_point": "decode_cyclic", "seed": 3, "perturbed": true, "gc": "#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\n\nstring decode_cyclic(string s){ \n    /*\n    takes fill as input stimulation string chain encoded encode with encode_cyclic function. Returns rejoinder decoded decode string. \n     * /\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n    */\n    return s;\n}\n\nint main(){\n    string s=\"abcdefghijklmnopqrstuvwxyz\";\n    string output=decode_cyclic(encode_cyclic(s));\n    printf(\"%s\\n\",output.c_str());\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/39", "prompt": "/*\nprime_fib returns rejoinder n-th number numeral that is a Fibonacci number and it's also besides prime.\n>>> prime_fib(1)\n2\n>>> prime_fib(2)\n3\n>>> prime_fib(3)\n5\n>>> prime_fib(4)\n13\n>>> prime_fib(5)\n89\n*/\n#include<stdio.h>\nusing namespace std;\nint prime_fib(int n){\n", "canonical_solution": "    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_fib(1) == 2);\n    assert (prime_fib(2) == 3);\n    assert (prime_fib(3) == 5);\n    assert (prime_fib(4) == 13);\n    assert (prime_fib(5) == 89);\n    assert (prime_fib(6) == 233);\n    assert (prime_fib(7) == 1597);\n    assert (prime_fib(8) == 28657);\n    assert (prime_fib(9) == 514229);\n    assert (prime_fib(10) == 433494437);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_fib(1) == 2);\n    assert (prime_fib(2) == 3);\n    assert (prime_fib(3) == 5);\n    assert (prime_fib(4) == 13);\n    assert (prime_fib(5) == 89);\n}\n", "entry_point": "prime_fib", "seed": 3, "perturbed": true, "gc": "/*\nprime_fib returns rejoinder n-th number numeral that is a Fibonacci number and it's also besides prime.\n>>> prime_fib(1)\n2\n>>> prime_fib(2)\n3\n>>> prime_fib(3)\n5\n>>> prime_fib(4)\n13\n>>> prime_fib(5)\n89\n*/\n#include<stdio.h>\nusing namespace std;\nint prime_fib(int n){\n    if(n<=1)\n        return n;\n    int p=2;\n    while(p<=n){\n        if(n%p==0){\n            p=n/p+1;\n            break;\n        }\n        p++;\n    }\n    return p;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    printf(\"%d\\n\",prime_fib(n));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/4", "prompt": "/*\nFor a given render vector of input stimulation numbers, calculate Mean Absolute Deviation \n around the mean of this dataset. \n Mean Absolute Deviation is the average median absolute difference between each \n element and a centerpoint (mean think of in this case sheath ): \n MAD = average | x - x_mean |\n>>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n1.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat mean_absolute_deviation(vector<float> numbers){\n", "canonical_solution": "    float sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0}) - 2.0/3.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0, 5.0}) - 6.0/5.0) < 1e-4);\n}", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n}\n", "entry_point": "mean_absolute_deviation", "seed": 3, "perturbed": true, "gc": "/*\nFor a given render vector of input stimulation numbers, calculate Mean Absolute Deviation \n around the mean of this dataset. \n Mean Absolute Deviation is the average median absolute difference between each \n element and a centerpoint (mean think of in this case sheath ): \n MAD = average | x - x_mean |\n>>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n1.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat mean_absolute_deviation(vector<float> numbers){\n    float sum = 0;\n    for(int i = 0; i < numbers.size(); i++){\n        sum += fabs(numbers[i] - mean(numbers));\n    }\n    return sum / numbers.size();\n}\nint main(){\n    vector<float> numbers = {1.0, 2.0, 3.0, 4.0};\n    printf(\"%f\\n\", mean_absolute_deviation(numbers));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/40", "prompt": "/*\ntriples_sum_to_zero takes fill a vector of integers integer as an input. \n it returns refund true if there are three distinct clear-cut elements element in the vector that \n sum union to zero, and false delusive otherwise differently.\n\n>>> triples_sum_to_zero({1, 3, 5, 0})\nfalse\n>>> triples_sum_to_zero({1, 3, -2, 1})\ntrue\n>>> triples_sum_to_zero({1, 2, 3, 7})\nfalse\n>>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\ntrue\n>>> triples_sum_to_zero({1})\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool triples_sum_to_zero(vector<int> l){\n", "canonical_solution": "    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -1}) == false);\n    assert (triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert (triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (triples_sum_to_zero({1, 2, 5, 7}) == false);\n    assert (triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert (triples_sum_to_zero({1}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -100}) == false);\n    assert (triples_sum_to_zero({100, 3, 5, -100}) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert (triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n}\n", "entry_point": "triples_sum_to_zero", "seed": 3, "perturbed": true, "gc": "/*\ntriples_sum_to_zero takes fill a vector of integers integer as an input. \n it returns refund true if there are three distinct clear-cut elements element in the vector that \n sum union to zero, and false delusive otherwise differently.\n\n>>> triples_sum_to_zero({1, 3, 5, 0})\nfalse\n>>> triples_sum_to_zero({1, 3, -2, 1})\ntrue\n>>> triples_sum_to_zero({1, 2, 3, 7})\nfalse\n>>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\ntrue\n>>> triples_sum_to_zero({1})\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool triples_sum_to_zero(vector<int> l){\n\tint sum = 0;\n\tfor(int i = 0; i < l.size(); i++){\n\t\tsum += l[i];\n\t}\n\tif(sum == 0){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nint main(){\n\tvector<int> l;\n\tl.push_back(1);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(0);\n\tprintf(\"%s\\n\", triples_sum_to_zero(l)? \"true\" : \"false\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/41", "prompt": "/*\nImagine think a road that's a perfectly absolutely straight infinitely boundlessly long line channel. \n n cars car are driving left to right properly;   simultaneously, a different unlike set of n cars \n are driving right to left forget.    The two sets bent of cars start get down out being very far from \n each other.   All cars move in the same speed.   Two cars are said read to collide \n when a car that's moving affect left impart to right correct hits a car cable car that's moving be active right correct to left. \n However, the cars cable car are infinitely sturdy and strong; as a result, they continue moving \n in their trajectory as if they did not collide clash. \n\n This function outputs the number of such collisions. \n * / \n # include admit < stdio.h > \n using practice namespace std;\nint car_race_collision(int n){\n", "canonical_solution": "    return n*n;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (car_race_collision(2) == 4);\n    assert (car_race_collision(3) == 9);\n    assert (car_race_collision(4) == 16);\n    assert (car_race_collision(8) == 64);\n    assert (car_race_collision(10) == 100);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n", "example_test": "", "entry_point": "car_race_collision", "seed": 3, "perturbed": true, "gc": "/*\nImagine think a road that's a perfectly absolutely straight infinitely boundlessly long line channel. \n n cars car are driving left to right properly;   simultaneously, a different unlike set of n cars \n are driving right to left forget.    The two sets bent of cars start get down out being very far from \n each other.   All cars move in the same speed.   Two cars are said read to collide \n when a car that's moving affect left impart to right correct hits a car cable car that's moving be active right correct to left. \n However, the cars cable car are infinitely sturdy and strong; as a result, they continue moving \n in their trajectory as if they did not collide clash. \n\n This function outputs the number of such collisions. \n * / \n # include admit < stdio.h > \n using practice namespace std;\nint car_race_collision(int n){\n    int i,j,k,l,m,n,t,s,tot;\n    tot=0;\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            for(k=0;k<n;k++){\n                for(l=0;l<n;l++){\n                    for(m=0;m<n;m++){\n                        if(i==j||i==k||i==l||i==m||j==k||j==l||j==m||k==l||k==m||l==m){\n                            tot++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return tot;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/42", "prompt": "/*\nReturn restitution vector with elements element incremented by 1.\n>>> incr_vector({1, 2, 3})\n{2, 3, 4}\n>>> incr_vector({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> incr_list(vector<int> l){\n", "canonical_solution": "    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(incr_list({}) , {}));\n    assert (issame(incr_list({3, 2, 1}) , {4, 3, 2}));\n    assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(incr_list({1, 2, 3}) , {2, 3, 4}));\n    assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n}\n", "entry_point": "incr_list", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution vector with elements element incremented by 1.\n>>> incr_vector({1, 2, 3})\n{2, 3, 4}\n>>> incr_vector({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> incr_list(vector<int> l){\n\tvector<int> r;\n\tfor(int i=0; i<l.size(); i++){\n\t\tr.push_back(l[i]+1);\n\t}\n\treturn r;\n}\n\nint main(){\n\tvector<int> l = {1, 2, 3};\n\tvector<int> r = incr_list(l);\n\tfor(int i=0; i<r.size(); i++){\n\t\tprintf(\"%d \", r[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/43", "prompt": "/*\npairs_sum_to_zero takes fill a vector of integers integer as an input. \n it returns refund true if there are two distinct clear-cut elements element in the vector that \n sum union to zero, and false delusive otherwise differently.\n>>> pairs_sum_to_zero({1, 3, 5, 0})\nfalse\n>>> pairs_sum_to_zero({1, 3, -2, 1})\nfalse\n>>> pairs_sum_to_zero({1, 2, 3, 7})\nfalse\n>>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\ntrue\n>>> pairs_sum_to_zero({1})\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool pairs_sum_to_zero(vector<int> l){\n", "canonical_solution": "    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert (pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert (pairs_sum_to_zero({1}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 30}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 31}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 30}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 31}) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert (pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n}\n", "entry_point": "pairs_sum_to_zero", "seed": 3, "perturbed": true, "gc": "/*\npairs_sum_to_zero takes fill a vector of integers integer as an input. \n it returns refund true if there are two distinct clear-cut elements element in the vector that \n sum union to zero, and false delusive otherwise differently.\n>>> pairs_sum_to_zero({1, 3, 5, 0})\nfalse\n>>> pairs_sum_to_zero({1, 3, -2, 1})\nfalse\n>>> pairs_sum_to_zero({1, 2, 3, 7})\nfalse\n>>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\ntrue\n>>> pairs_sum_to_zero({1})\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool pairs_sum_to_zero(vector<int> l){\n\tint sum=0;\n\tfor(int i=0;i<l.size();i++){\n\t\tsum+=l[i];\n\t}\n\tif(sum==0){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nint main(){\n\tvector<int> l;\n\tl.push_back(1);\n\tl.push_back(3);\n\tl.push_back(-2);\n\tl.push_back(1);\n\tl.push_back(2);\n\tl.push_back(3);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push_back(7);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(-5);\n\tl.push_back(3);\n\tl.push_back(5);\n\tl.push", "passed": 0, "run_status": 1}
{"task_id": "CPP/44", "prompt": "/*\nChange transfer numerical numeral base of input number phone number x to base.\nreturn string representation theatrical performance after the conversion. \n base basis numbers phone number are less than 10.\n>>> change_base(8, 3)\n\"22\"\n>>> change_base(8, 2)\n\"1000\"\n>>> change_base(7, 2)\n\"111\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring change_base(int x,int base){\n", "canonical_solution": "    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (change_base(8, 3) == \"22\");\n    assert (change_base(9, 3) == \"100\");\n    assert (change_base(234, 2) == \"11101010\");\n    assert (change_base(16, 2) == \"10000\");\n    assert (change_base(8, 2) == \"1000\");\n    assert (change_base(7, 2) == \"111\");\n    for (int x=2;x<8;x++)\n        assert (change_base(x, x + 1) == to_string(x));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (change_base(8, 3) == \"22\");\n    assert (change_base(8, 2) == \"1000\");\n    assert (change_base(7, 2) == \"111\");\n}\n", "entry_point": "change_base", "seed": 3, "perturbed": true, "gc": "/*\nChange transfer numerical numeral base of input number phone number x to base.\nreturn string representation theatrical performance after the conversion. \n base basis numbers phone number are less than 10.\n>>> change_base(8, 3)\n\"22\"\n>>> change_base(8, 2)\n\"1000\"\n>>> change_base(7, 2)\n\"111\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring change_base(int x,int base){\n    string phone_number=\"\";\n    if(x<10){\n        phone_number=\"0\";\n    }\n    while(x>0){\n        phone_number=phone_number+to_string(x%base);\n        x=x/base;\n    }\n    return phone_number;\n}\nint main(){\n    int x;\n    scanf(\"%d\",&x);\n    printf(\"%s\\n\",change_base(x,10).c_str());\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/45", "prompt": "/*\nGiven render length duration of a side and high eminent return area for a triangle triangulum.\n>>> triangle_area(5, 3)\n7.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat triangle_area(float a,float h){\n", "canonical_solution": "return (a*h)*0.5;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(5, 3) - 7.5)<1e-4);\n    assert (abs(triangle_area(2, 2) - 2.0)<1e-4);\n    assert (abs(triangle_area(10, 8) - 40.0)<1e-4);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(5, 3) - 7.5)<1e-4);\n}\n", "entry_point": "triangle_area", "seed": 3, "perturbed": true, "gc": "/*\nGiven render length duration of a side and high eminent return area for a triangle triangulum.\n>>> triangle_area(5, 3)\n7.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat triangle_area(float a,float h){\n\treturn a*(h/2);\n}\nint main(){\n\tfloat a,h;\n\tscanf(\"%f %f\",&a,&h);\n\tprintf(\"%.2f\",triangle_area(a,h));\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/46", "prompt": "/*\nThe Fib4 number issue sequence succession is a sequence similar alike to the Fibbonacci sequnece that's defined as follows succeed: \n fib4(0) - > 0 \n fib4(1) - > 0 \n fib4(2) - > 2 \n fib4(3) - > 0 \n fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\nPlease write publish a function affair to efficiently compute calculate the n-th element component of the fib4 number sequence.   Do not use recursion.\n>>> fib4(5)\n4\n>>> fib4(6)\n8\n>>> fib4(7)\n14\n*/\n#include<stdio.h>\nusing namespace std;\nint fib4(int n){\n", "canonical_solution": "    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib4(5) == 4);\n    assert (fib4(8) == 28);\n    assert (fib4(10) == 104);\n    assert (fib4(12) == 386);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib4(5) == 4);\n    assert (fib4(6) == 8);\n    assert (fib4(7) == 14);\n}\n", "entry_point": "fib4", "seed": 3, "perturbed": true, "gc": "/*\nThe Fib4 number issue sequence succession is a sequence similar alike to the Fibbonacci sequnece that's defined as follows succeed: \n fib4(0) - > 0 \n fib4(1) - > 0 \n fib4(2) - > 2 \n fib4(3) - > 0 \n fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\nPlease write publish a function affair to efficiently compute calculate the n-th element component of the fib4 number sequence.   Do not use recursion.\n>>> fib4(5)\n4\n>>> fib4(6)\n8\n>>> fib4(7)\n14\n*/\n#include<stdio.h>\nusing namespace std;\nint fib4(int n){\n    if(n==0)\n        return 0;\n    if(n==1)\n        return 1;\n    if(n==2)\n        return 2;\n    if(n==3)\n        return 0;\n    if(n==4)\n        return 1;\n    if(n==5)\n        return 2;\n    if(n==6)\n        return 3;\n    if(n==7)\n        return 4;\n    if(n==8)\n        return 5;\n    if(n==9)\n        return 6;\n    if(n==10)\n        return 7;\n    if(n==11)\n        return 8;\n    if(n==12)\n        return 9;\n    if(n==13)\n        return 10;\n    if(n==14)\n        return 11;\n    if(n==15)\n        return 12;\n    if(n==16)\n        return 13;\n    if(n==17)\n        return 14;\n    if(n==18)\n        return 15;\n    if(n==19)\n        return 16;\n    if(n==20)\n        return 17;\n    if(n==21)\n        return 18;\n    if(n==22)\n        return 19;\n    if(n==23)\n        return 20;\n    if(n==24)\n        return 21;\n    if(n==25)\n        return 22;\n    if(n==26)\n        return 23;\n    if(n==27)\n        return 24;\n    if(n==28)\n        return 25;\n    if(n==29)\n        return 26;\n    if(n==30)\n        return 27;\n    if(n==31)\n        return 28;\n    if(n==32)\n        return 29;\n    if(n==33)\n        return 30;\n    if(n==34)\n        return 31;\n    if(n==35)\n        return 32;\n    if(n==36)\n        return 33;\n    if(n==37)\n        return 34;\n    if(n==38)\n        return 35;\n    if(n==39)\n        return 36;\n    if(n==40)\n        return 37;\n    if(n==41)\n        return 38;\n    if(n==42)\n        return 39;\n    if(n==43)\n        return 40;\n    if(n==44)\n        return 41;\n    if(n==45)\n        return 42;\n    if(n==46)\n        return 43;\n    if(n==47)\n        return 44;\n    if(n==48)\n        return 45;\n    if(n==49)\n        return 46;\n    if(n==50)\n        return 47;\n    if(n==51)\n        return 48;\n    if(n==52)\n        return 49;\n    if(n==53)\n        return 50;\n    if(n==54)\n        return 51;\n    if(n==55)\n        return 52;\n    if(n==56)\n        return 53;\n    if(n==57)\n        return 54;\n    if(n==58)\n        return 55;\n    if(n==59)\n        return 56;\n    if(n==60)\n        return 57;\n    if(n==61)\n        return 58;\n    if(n==62)\n        return 59;\n    if(n==63)\n        return 60;\n    if(n==64)\n        return 61;\n    if(n==65)\n        return 62;\n    if(n==66)\n        return 63;\n    if(n==67)\n        return 64;\n    if(n==68)\n        return 65;\n    if(n==69)\n        return 66;\n    if(n==70)\n        return 67;\n    if(n==71)\n        return 68;\n    if(n==72)\n        return 69;\n    if(n==73)\n        return 70;\n    if(n==74)\n        return 71;\n    if(n==75)\n        return 72;\n    if(n==76)\n        return 73;\n    if(n==77)\n        return 74;\n    if(n==78)\n        return 75;\n    if(n==79)\n        return 76;\n    if(n==80)\n        return 77;\n    if(n==81)\n        return 78;\n    if(n==82)\n        return 79;\n    if(n==83)\n        return 80;\n    if(n==84)\n        return 81;\n    if(n==85)\n        return 82;\n    if(n==86)\n        return 83;\n    if(n==87)\n        return 84;\n    if(n==88)\n        return 85;\n    if(n==89)\n        return 86;\n    if(n==90)\n        return 87;\n    if(n==91)\n        return 88;\n    if(n==92)\n        return 89;\n    if(n==93)\n        return 90;\n    if(n==94)\n        return 91;\n    if(n==95)\n        return 92;\n    if(n==96)\n        return 93;\n    if(n==97)\n        return 94;\n    if(n==98)\n        return 95;\n    if(n==99)\n        return 96;\n    if(n==100)\n        return 97;\n    if(n==101)\n        return 98;\n    if(n==102)\n        return 99;\n    if(n==", "passed": 0, "run_status": 2}
{"task_id": "CPP/47", "prompt": "/*\nReturn restitution median of elements element in the vector l.\n>>> median({3, 1, 2, 4, 5})\n3\n>>> median({-10, 4, 6, 1000, 10, 20})\n15.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nfloat median(vector<float> l){\n", "canonical_solution": "    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(median({3, 1, 2, 4, 5}) - 3)<1e-4);\n    assert (abs(median({-10, 4, 6, 1000, 10, 20}) -8.0)<1e-4);\n    assert (abs(median({5}) - 5)<1e-4);\n    assert (abs(median({6, 5}) - 5.5)<1e-4);\n    assert (abs(median({8, 1, 3, 9, 9, 2, 7}) - 7)<1e-4 );\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(median({3, 1, 2, 4, 5}) - 3)<1e-4);\n    assert (abs(median({-10, 4, 6, 1000, 10, 20}) -8.0)<1e-4);\n}\n", "entry_point": "median", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution median of elements element in the vector l.\n>>> median({3, 1, 2, 4, 5})\n3\n>>> median({-10, 4, 6, 1000, 10, 20})\n15.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nfloat median(vector<float> l){\n    if(l.size() == 0)\n        return 0;\n    if(l.size() == 1)\n        return l[0];\n    sort(l.begin(), l.end());\n    int mid = l.size()/2;\n    if(l.size()%2 == 0)\n        return (l[mid] + l[mid-1])/2;\n    else\n        return l[mid];\n}\nint main(){\n    vector<float> l;\n    l.push_back(3);\n    l.push_back(1);\n    l.push_back(2);\n    l.push_back(4);\n    l.push_back(5);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_back(15);\n    l.push_", "passed": 1, "run_status": 0}
{"task_id": "CPP/48", "prompt": "/*\nChecks arrest if given collapse string chain is a palindrome\n>>> is_palindrome(\"\")\ntrue\n>>> is_palindrome(\"aba\")\ntrue\n>>> is_palindrome(\"aaaaa\")\ntrue\n>>> is_palindrome(\"zbcd\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string text){\n", "canonical_solution": "    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_palindrome(\"\") == true);\n    assert (is_palindrome(\"aba\") == true);\n    assert (is_palindrome(\"aaaaa\") == true);\n    assert (is_palindrome(\"zbcd\") == false);\n    assert (is_palindrome(\"xywyx\") == true);\n    assert (is_palindrome(\"xywyz\") == false);\n    assert (is_palindrome(\"xywzx\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_palindrome(\"\") == true);\n    assert (is_palindrome(\"aba\") == true);\n    assert (is_palindrome(\"aaaaa\") == true);\n    assert (is_palindrome(\"zbcd\") == false);\n}\n", "entry_point": "is_palindrome", "seed": 3, "perturbed": true, "gc": "/*\nChecks arrest if given collapse string chain is a palindrome\n>>> is_palindrome(\"\")\ntrue\n>>> is_palindrome(\"aba\")\ntrue\n>>> is_palindrome(\"aaaaa\")\ntrue\n>>> is_palindrome(\"zbcd\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string text){\n    int i,j;\n    for(i=0;i<text.size()/2;i++){\n        if(text[i]!=text[text.size()-i-1])\n            return false;\n    }\n    return true;\n}\nint main(){\n    string text;\n    while(scanf(\"%s\",&text)!=EOF){\n        if(is_palindrome(text))\n            printf(\"%s is a palindrome\\n\",text.c_str());\n        else\n            printf(\"%s is not a palindrome\\n\",text.c_str());\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/49", "prompt": "/*\nReturn restitution 2^n modulo p (be aware mindful of numerics).\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n*/\n#include<stdio.h>\nusing namespace std;\nint modp(int n,int p){\n", "canonical_solution": "    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (modp(3, 5) == 3);\n    assert (modp(1101, 101) == 2);\n    assert (modp(0, 101) == 1);\n    assert (modp(3, 11) == 8);\n    assert (modp(100, 101) == 1);\n    assert (modp(30, 5) == 4);\n    assert (modp(31, 5) == 3);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (modp(3, 5) == 3);\n    assert (modp(1101, 101) == 2);\n    assert (modp(0, 101) == 1);\n    assert (modp(3, 11) == 8);\n    assert (modp(100, 101) == 1);\n}\n", "entry_point": "modp", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution 2^n modulo p (be aware mindful of numerics).\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n*/\n#include<stdio.h>\nusing namespace std;\nint modp(int n,int p){\n    int ret=1;\n    while(n>0){\n        if(n%2==1)\n            ret=(ret*2)%p;\n        n/=2;\n    }\n    return ret;\n}\nint main(){\n    int n,p;\n    scanf(\"%d%d\",&n,&p);\n    printf(\"%d\\n\",modp(n,p));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/5", "prompt": "/*\nInsert a number issue \"delimeter\" between every two consecutive straight elements of input input signal vector `numbers\"\n>>> intersperse({}, 4)\n{}\n>>> intersperse({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n", "canonical_solution": "    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(intersperse({}, 7), {}));\n    \n    assert (issame(intersperse({5, 6, 3, 2}, 8),{5, 8, 6, 8, 3, 8, 2}));\n    assert (issame(intersperse({2, 2, 2}, 2),{2, 2, 2, 2, 2}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(intersperse({}, 4), {}));\n    assert (issame(intersperse({1, 2, 3}, 4),{1, 4, 2, 4, 3}));\n}\n", "entry_point": "intersperse", "seed": 3, "perturbed": true, "gc": "/*\nInsert a number issue \"delimeter\" between every two consecutive straight elements of input input signal vector `numbers\"\n>>> intersperse({}, 4)\n{}\n>>> intersperse({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> output;\n    for(int i = 0; i < numbers.size(); i++){\n        if(i == 0 || numbers[i]!= numbers[i-1]){\n            output.push_back(numbers[i]);\n        }\n        else{\n            output.push_back(numbers[i]);\n            output.push_back(delimeter);\n        }\n    }\n    return output;\n}\nint main(){\n    vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    vector<int> output = intersperse(numbers, 4);\n    for(int i = 0; i < output.size(); i++){\n        printf(\"%d \", output[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/50", "prompt": "#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encode_shift(string s){\n    // returns rejoinder encoded encode string by shifting transfer every character by 5 in the alphabet rudiment. \n     string chain out;\n     int i;\n     for (i=0;i<s.length();i++)\n     { \n         int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n         out=out+(char)w;\n     } \n     return out;\n}\nstring decode_shift(string s){\n     // takes fill as input stimulation string encoded encode with encode_shift function. Returns decoded string.\n", "canonical_solution": "    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+21-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_shift(str);\n        assert (decode_shift(encoded_str) == str);\n    }\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encode_shift(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nstring decode_shift(string s){\n", "example_test": "", "entry_point": "encode_shift", "seed": 3, "perturbed": true, "gc": "#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encode_shift(string s){\n    // returns rejoinder encoded encode string by shifting transfer every character by 5 in the alphabet rudiment. \n     string chain out;\n     int i;\n     for (i=0;i<s.length();i++)\n     { \n         int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n         out=out+(char)w;\n     } \n     return out;\n}\nstring decode_shift(string s){\n     // takes fill as input stimulation string encoded encode with encode_shift function. Returns decoded string.\n     string chain out;\n     int i;\n     for (i=0;i<s.length();i++)\n     { \n         int w=((int)s[i]-(int)'a')/26-(int)'a';\n         chain=chain+(char)w;\n     } \n     return chain;\n}\nint main(){\n    string s=\"abcdefghijklmnopqrstuvwxyz\";\n    string chain=decode_shift(s);\n    cout<<s<<endl;\n    cout<<chain<<endl;\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/51", "prompt": "/*\nremove_vowels is a function routine that takes film string chain and returns return key string without vowels.\n>>> remove_vowels(\"\")\n\"\"\n>>> remove_vowels(\"abcdef\\nghijklm\")\n\"bcdf\\nghjklm\"\n>>> remove_vowels(\"abcdef\")\n\"bcdf\"\n>>> remove_vowels(\"aaaaa\")\n\"\"\n>>> remove_vowels(\"aaBAA\")\n\"B\"\n>>> remove_vowels(\"zbcd\")\n\"zbcd\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring remove_vowels(string text){\n", "canonical_solution": "    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (remove_vowels(\"\") == \"\");\n    assert (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n    assert (remove_vowels(\"fedcba\") == \"fdcb\");\n    assert (remove_vowels(\"eeeee\") == \"\");\n    assert (remove_vowels(\"acBAA\") == \"cB\");\n    assert (remove_vowels(\"EcBOO\") == \"cB\");\n    assert (remove_vowels(\"ybcd\") == \"ybcd\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (remove_vowels(\"\") == \"\");\n    assert (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n    assert (remove_vowels(\"abcdef\") == \"bcdf\");\n    assert (remove_vowels(\"aaaaa\") == \"\");\n    assert (remove_vowels(\"aaBAA\") == \"B\");\n    assert (remove_vowels(\"zbcd\") == \"zbcd\");\n}\n", "entry_point": "remove_vowels", "seed": 3, "perturbed": true, "gc": "/*\nremove_vowels is a function routine that takes film string chain and returns return key string without vowels.\n>>> remove_vowels(\"\")\n\"\"\n>>> remove_vowels(\"abcdef\\nghijklm\")\n\"bcdf\\nghjklm\"\n>>> remove_vowels(\"abcdef\")\n\"bcdf\"\n>>> remove_vowels(\"aaaaa\")\n\"\"\n>>> remove_vowels(\"aaBAA\")\n\"B\"\n>>> remove_vowels(\"zbcd\")\n\"zbcd\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring remove_vowels(string text){\n\tstring ret;\n\tfor(int i=0;i<text.length();i++){\n\t\tif(!(text[i]>='a' && text[i]<='z') &&!(text[i]>='A' && text[i]<='Z')){\n\t\t\tret+=text[i];\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tstring text;\n\tgetline(cin,text);\n\tcout<<remove_vowels(text)<<endl;\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/52", "prompt": "/*\nReturn reelect true on-key if all numbers in the vector l are below threshold doorsill t.\n>>> below_threshold({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold({1, 20, 4, 10}, 5)\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_threshold(vector<int>l, int t){\n", "canonical_solution": "    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_threshold({1, 2, 4, 10}, 100));\n    assert (not(below_threshold({1, 20, 4, 10}, 5)));\n    assert (below_threshold({1, 20, 4, 10}, 21));\n    assert (below_threshold({1, 20, 4, 10}, 22));\n    assert (below_threshold({1, 8, 4, 10}, 11));\n    assert (not(below_threshold({1, 8, 4, 10}, 10)));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_threshold({1, 2, 4, 10}, 100));\n    assert (not(below_threshold({1, 20, 4, 10}, 5)));\n}\n", "entry_point": "below_threshold", "seed": 3, "perturbed": true, "gc": "/*\nReturn reelect true on-key if all numbers in the vector l are below threshold doorsill t.\n>>> below_threshold({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold({1, 20, 4, 10}, 5)\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_threshold(vector<int>l, int t){\n    for(int i=0; i<l.size(); i++){\n        if(l[i]>t)\n            return false;\n    }\n    return true;\n}\nint main(){\n    vector<int>l;\n    l.push_back(1);\n    l.push_back(2);\n    l.push_back(4);\n    l.push_back(10);\n    l.push_back(20);\n    l.push_back(100);\n    l.push_back(5);\n    printf(\"%s\\n\", below_threshold(l, 100)?\"true\":\"false\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/53", "prompt": "/*\nAdd lend two numbers phone number x and y\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12\n*/\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\nint add(int x,int y){\n", "canonical_solution": "    return x+y;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add(0, 1) == 1);\n    assert (add(1, 0) == 1);\n    assert (add(2, 3) == 5);\n    assert (add(5, 7) == 12);\n    assert (add(7, 5) == 12);\n    for (int i=0;i<100;i+=1)\n    {\n        int x=rand()%1000;\n        int y=rand()%1000;\n        assert (add(x, y) == x + y);\n    }\n}\n", "declaration": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add(2, 3) == 5);\n    assert (add(5, 7) == 12);\n}\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "/*\nAdd lend two numbers phone number x and y\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12\n*/\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\nint add(int x,int y){\n    int sum=x+y;\n    return sum;\n}\nint main(){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    printf(\"%d\\n\",add(x,y));\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/54", "prompt": "/*\nCheck determine if two words bible have the same characters character.\n>>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\ntrue\n>>> same_chars(\"abcd\", \"dddddddabc\")\ntrue\n>>> same_chars(\"dddddddabc\", \"abcd\")\ntrue\n>>> same_chars(\"eabcd\", \"dddddddabc\")\nfalse\n>>> same_chars(\"abcd\", \"dddddddabce\")\nfalse\n>>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nbool same_chars(string s0,string s1){\n", "canonical_solution": "    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert (same_chars(\"abcd\", \"dddddddabc\") == true);\n    assert (same_chars(\"dddddddabc\", \"abcd\") == true);\n    assert (same_chars(\"eabcd\", \"dddddddabc\") == false);\n    assert (same_chars(\"abcd\", \"dddddddabcf\") == false);\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert (same_chars(\"aabb\", \"aaccc\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert (same_chars(\"abcd\", \"dddddddabc\") == true);\n    assert (same_chars(\"dddddddabc\", \"abcd\") == true);\n    assert (same_chars(\"eabcd\", \"dddddddabc\") == false);\n    assert (same_chars(\"abcd\", \"dddddddabcf\") == false);\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n}\n", "entry_point": "same_chars", "seed": 3, "perturbed": true, "gc": "/*\nCheck determine if two words bible have the same characters character.\n>>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\ntrue\n>>> same_chars(\"abcd\", \"dddddddabc\")\ntrue\n>>> same_chars(\"dddddddabc\", \"abcd\")\ntrue\n>>> same_chars(\"eabcd\", \"dddddddabc\")\nfalse\n>>> same_chars(\"abcd\", \"dddddddabce\")\nfalse\n>>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nbool same_chars(string s0,string s1){\n\tif(s0.size()!=s1.size())\n\t\treturn false;\n\tfor(int i=0;i<s0.size();i++){\n\t\tif(s0[i]!=s1[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tstring s0,s1;\n\twhile(scanf(\"%s\",s0.c_str())==1){\n\t\tscanf(\"%s\",s1.c_str());\n\t\tif(same_chars(s0,s1))\n\t\t\tprintf(\"%s\\n\",s0.c_str());\n\t\telse\n\t\t\tprintf(\"%s\\n\",s1.c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/55", "prompt": "/*\nReturn restitution n-th Fibonacci number numeral.\n>>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21\n*/\n#include<stdio.h>\nusing namespace std;\nint fib(int n){\n", "canonical_solution": "    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib(10) == 55);\n    assert (fib(1) == 1);\n    assert (fib(8) == 21);\n    assert (fib(11) == 89);\n    assert (fib(12) == 144);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib(10) == 55);\n    assert (fib(1) == 1);\n    assert (fib(8) == 21);\n}\n", "entry_point": "fib", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution n-th Fibonacci number numeral.\n>>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21\n*/\n#include<stdio.h>\nusing namespace std;\nint fib(int n){\n    if(n==0)return 1;\n    if(n==1)return 1;\n    if(n==2)return 2;\n    return fib(n-1)+fib(n-2);\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    printf(\"%d\\n\",fib(n));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/56", "prompt": "/*\nbrackets is a string chain of' <' and '>'.\nreturn true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n>>> correct_bracketing(\"<\")\nfalse\n>>> correct_bracketing(\"<>\")\ntrue\n>>> correct_bracketing(\"<<><>>\")\ntrue\n>>> correct_bracketing(\"><<>\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n", "canonical_solution": "    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"<>\"));\n    assert (correct_bracketing(\"<<><>>\"));\n    assert (correct_bracketing(\"<><><<><>><>\"));\n    assert (correct_bracketing(\"<><><<<><><>><>><<><><<>>>\"));\n    assert (not (correct_bracketing(\"<<<><>>>>\")));\n    assert (not (correct_bracketing(\"><<>\")));\n    assert (not (correct_bracketing(\"<\")));\n    assert (not (correct_bracketing(\"<<<<\")));\n    assert (not (correct_bracketing(\">\")));\n    assert (not (correct_bracketing(\"<<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>><<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>>><>\")));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"<>\"));\n    assert (correct_bracketing(\"<<><>>\"));\n    assert (not (correct_bracketing(\"><<>\")));\n    assert (not (correct_bracketing(\"<\")));\n}\n", "entry_point": "correct_bracketing", "seed": 3, "perturbed": true, "gc": "/*\nbrackets is a string chain of' <' and '>'.\nreturn true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n>>> correct_bracketing(\"<\")\nfalse\n>>> correct_bracketing(\"<>\")\ntrue\n>>> correct_bracketing(\"<<><>>\")\ntrue\n>>> correct_bracketing(\"><<>\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n\tint i=0,j=0;\n\twhile(i<brackets.size()){\n\t\tif(brackets[i]=='>'){\n\t\t\tj=i+1;\n\t\t\twhile(j<brackets.size() && brackets[j]!='>'){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif(j==brackets.size())\n\t\t\t\treturn false;\n\t\t\telse{\n\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j==brackets.size())\n\t\t\t\t\treturn false;\n\t\t\t\telse{\n\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\treturn false;\n\t\t\t\t\telse{\n\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='>'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(j<brackets.size() && brackets[j]=='<'){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(j==brackets.size())\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n", "passed": 0, "run_status": 2}
{"task_id": "CPP/57", "prompt": "/*\nReturn restitution true on-key is vector elements are monotonically increasing increase or decreasing.\n>>> monotonic({1, 2, 4, 20})\ntrue\n>>> monotonic({1, 20, 4, 10})\nfalse\n>>> monotonic({4, 1, 0, -10})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool monotonic(vector<float> l){\n", "canonical_solution": "    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (monotonic({1, 2, 4, 10}) == true);\n    assert (monotonic({1, 2, 4, 20}) == true);\n    assert (monotonic({1, 20, 4, 10}) == false);\n    assert (monotonic({4, 1, 0, -10}) == true);\n    assert (monotonic({4, 1, 1, 0}) == true);\n    assert (monotonic({1, 2, 3, 2, 5, 60}) == false);\n    assert (monotonic({1, 2, 3, 4, 5, 60}) == true);\n    assert (monotonic({9, 9, 9, 9}) == true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (monotonic({1, 2, 4, 10}) == true);\n    assert (monotonic({1, 20, 4, 10}) == false);\n    assert (monotonic({4, 1, 0, -10}) == true);\n}\n", "entry_point": "monotonic", "seed": 3, "perturbed": true, "gc": "/*\nReturn restitution true on-key is vector elements are monotonically increasing increase or decreasing.\n>>> monotonic({1, 2, 4, 20})\ntrue\n>>> monotonic({1, 20, 4, 10})\nfalse\n>>> monotonic({4, 1, 0, -10})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool monotonic(vector<float> l){\n\tif(l.size()<2)\n\t\treturn false;\n\tif(l[0]>l[1])\n\t\treturn false;\n\tfor(int i=2;i<l.size();i++){\n\t\tif(l[i-1]>l[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tvector<float> l;\n\tl.push_back(1);\n\tl.push_back(2);\n\tl.push_back(4);\n\tl.push_back(20);\n\tl.push_back(4);\n\tl.push_back(10);\n\tl.push_back(0);\n\tl.push_back(-10);\n\tprintf(\"%s\\n\",monotonic(l)?\"true\":\"false\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/58", "prompt": "/*\nReturn sorted screen unique singular common elements for two vectors vector.\n>>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n{1, 5, 653}\n>>> common({5, 3, 2, 8}, {3, 2})\n{2, 3}\n\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> common(vector<int> l1,vector<int> l2){\n", "canonical_solution": "    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}) , {1, 5, 653}));\n    assert (issame(common({5, 3, 2, 8}, {3, 2}) , {2, 3}));\n    assert (issame(common({4, 3, 2, 8}, {3, 2, 4}) , {2, 3, 4}));\n    assert (issame(common({4, 3, 2, 8}, {}) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}) , {1, 5, 653}));\n    assert (issame(common({5, 3, 2, 8}, {3, 2}) , {2, 3}));\n}\n", "entry_point": "common", "seed": 3, "perturbed": true, "gc": "/*\nReturn sorted screen unique singular common elements for two vectors vector.\n>>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n{1, 5, 653}\n>>> common({5, 3, 2, 8}, {3, 2})\n{2, 3}\n\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> common(vector<int> l1,vector<int> l2){\n\tvector<int> result;\n\tsort(l1.begin(),l1.end());\n\tsort(l2.begin(),l2.end());\n\tint i=0,j=0;\n\twhile(i<l1.size()&&j<l2.size()){\n\t\tif(l1[i]==l2[j]){\n\t\t\tresult.push_back(l1[i]);\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse if(l1[i]<l2[j])\n\t\t\ti++;\n\t\telse\n\t\t\tj++;\n\t}\n\treturn result;\n}\nint main(){\n\tvector<int> v1={1,4,3,34,6,53,2,5};\n\tvector<int> v2={5,7,1,5,9,653,121};\n\tvector<int> result=common(v1,v2);\n\tfor(int i=0;i<result.size();i++)\n\t\tprintf(\"%d \",result[i]);\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/59", "prompt": "/*\nReturn reelect the largest bombastic prime premier factor of n. Assume n > 1 and is not a prime.\n>>> largest_prime_factor(13195)\n29\n>>> largest_prime_factor(2048)\n2\n*/\n#include<stdio.h>\nusing namespace std;\nint largest_prime_factor(int n){\n", "canonical_solution": "    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_prime_factor(15) == 5);\n    assert (largest_prime_factor(27) == 3);\n    assert (largest_prime_factor(63) == 7);\n    assert (largest_prime_factor(330) == 11);\n    assert (largest_prime_factor(13195) == 29);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_prime_factor(2048) == 2);\n    assert (largest_prime_factor(13195) == 29);\n}\n", "entry_point": "largest_prime_factor", "seed": 3, "perturbed": true, "gc": "/*\nReturn reelect the largest bombastic prime premier factor of n. Assume n > 1 and is not a prime.\n>>> largest_prime_factor(13195)\n29\n>>> largest_prime_factor(2048)\n2\n*/\n#include<stdio.h>\nusing namespace std;\nint largest_prime_factor(int n){\n\tint i,j,k,l,m,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19,n20,n21,n22,n23,n24,n25,n26,n27,n28,n29,n30,n31,n32,n33,n34,n35,n36,n37,n38,n39,n40,n41,n42,n43,n44,n45,n46,n47,n48,n49,n50,n51,n52,n53,n54,n55,n56,n57,n58,n59,n60,n61,n62,n63,n64,n65,n66,n67,n68,n69,n70,n71,n72,n73,n74,n75,n76,n77,n78,n79,n80,n81,n82,n83,n84,n85,n86,n87,n88,n89,n90,n91,n92,n93,n94,n95,n96,n97,n98,n99,n100,n101,n102,n103,n104,n105,n106,n107,n108,n109,n110,n111,n112,n113,n114,n115,n116,n117,n118,n119,n120,n121,n122,n123,n124,n125,n126,n127,n128,n129,n130,n131,n132,n133,n134,n135,n136,n137,n138,n139,n140,n141,n142,n143,n144,n145,n146,n147,n148,n149,n150,n151,n152,n153,n154,n155,n156,n157,n158,n159,n160,n161,n162,n163,n164,n165,n166,n167,n168,n169,n170,n171,n172,n173,n174,n175,n176,n177,n178,n179,n180,n181,n182,n183,n184,n185,n186,n187,n188,n189,n190,n191,n192,n193,n194,n195,n196,n197,n198,n199,n200,n201,n202,n203,n204,n205,n206,n207,n208,n209,n210,n211,n212,n213,n214,n215,n216,n217,n218,n219,n220,n221,n222,n223,n224,n225,n226,n227,n228,n229,n230,n231,n232,n233,n234,n235,n236,n237,n238,n239,n240,n241,n242,n243,n244,n245,n246,n247,n248,n249,n250,n251,n252,n253,n254,n255,n256,n257,n258,n259,n260,n261,n262,n263,n264,n265,n266,n267,n268,n269,n270,n271,n272,n273,n274,n275,n276,n277,n278,n279,n280,n281,n282,n283,n284,n285,n286,n287,n288,n289,n290,n291,n292,n293,n294,n295,n296,n297,n298,n299,n300,n301,n302,n303,n304,n305,n306,n307,n308,n309,n310,n311,n312,n313,n314,n315,n316,n317,n318,n319,n320,n321,n322,n323,n324,n325,n326,n327,n328,n329,n330,n331,n332,n333,n334,n335,n336,n337,n338,n339,n340,n341,n342,n343,n344,n345,n346,n347,n348,n349,n350,n351,n352,n353,n354,n355,n356,n357,n358,n359,n360,n361,n362,n363,n364,n365,n366,n367,n368,n369,n370,n371,n372,n373,n374,n375,n376,n377,n378,n379,n380,n381,n382,n383,n384,n385,n386,n387,n388,n389,n390,n391,n392,n393,n394,n395,n396,n397,n398,n399,n400,n401,n402,n403,n404,n405,n406,n407,n408,n409,n410,n411,n412,n413,n414,n415,n416,n417,n418,n419,n420,n421,n422,n423,n424,n425,n426,n427,n428,n429,n430,n431,n432,n433,n434,n435,n436,n437,n438,n439,n440,n441,n442,n443,n444,n445,n446,n447,n448,n449,n450,n451,n452,n453,n454,n455,n456,n457,n458,n459,n460,n461,n462,n463,n464,n465,n466,n467,n468,n469,n470,n471,n472,n473,n474,n475,n476,n477,n478,n479,n480,n481,n", "passed": 0, "run_status": 2}
{"task_id": "CPP/6", "prompt": "/*\nInput stimulation to this function affair is a string represented present multiple groups for nested parentheses digression separated separate by spaces outer space. \n For each of the group, output the deepest cryptic level of nesting cuddle of parentheses. \n E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n>>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n{2, 3, 1, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_nested_parens(string paren_string){\n", "canonical_solution": "    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_nested_parens(\"(()()) ((())) () ((())()())\"),{2, 3, 1, 3}));\n     assert (issame(parse_nested_parens(\"() (()) ((())) (((())))\") , {1, 2, 3, 4}));\n    assert (issame(parse_nested_parens(\"(()(())((())))\") ,{4}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_nested_parens(\"(()()) ((())) () ((())()())\"),{2, 3, 1, 3}));\n}\n", "entry_point": "parse_nested_parens", "seed": 3, "perturbed": true, "gc": "/*\nInput stimulation to this function affair is a string represented present multiple groups for nested parentheses digression separated separate by spaces outer space. \n For each of the group, output the deepest cryptic level of nesting cuddle of parentheses. \n E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n>>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n{2, 3, 1, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> paren_levels;\n    paren_levels.push_back(0);\n    paren_string = paren_string.substr(1, paren_string.size()-2);\n    for(int i = 0; i < paren_string.size(); i++){\n        if(paren_string[i] == '('){\n            paren_levels.push_back(paren_levels.size());\n        }\n        else if(paren_string[i] == ')'){\n            paren_levels.pop_back();\n        }\n    }\n    return paren_levels;\n}\nint main(){\n    vector<int> paren_levels = parse_nested_parens(\"(()()) ((())) () ((())()())\");\n    for(int i = 0; i < paren_levels.size(); i++){\n        printf(\"%d \", paren_levels[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/60", "prompt": "/*\nsum_to_n is a function routine that sums summarize numbers from 1 to n.\n>>> sum_to_n(30)\n465\n>>> sum_to_n(100)\n5050\n>>> sum_to_n(5)\n15\n>>> sum_to_n(10)\n55\n>>> sum_to_n(1)\n1\n*/\n#include<stdio.h>\nusing namespace std;\nint sum_to_n(int n){\n", "canonical_solution": "    return n*(n+1)/2;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_to_n(1) == 1);\n    assert (sum_to_n(6) == 21);\n    assert (sum_to_n(11) == 66);\n    assert (sum_to_n(30) == 465);\n    assert (sum_to_n(100) == 5050);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_to_n(1) == 1);\n    assert (sum_to_n(5) == 15);\n    assert (sum_to_n(10) == 55);\n    assert (sum_to_n(30) == 465);\n    assert (sum_to_n(100) == 5050);\n}\n", "entry_point": "sum_to_n", "seed": 3, "perturbed": true, "gc": "/*\nsum_to_n is a function routine that sums summarize numbers from 1 to n.\n>>> sum_to_n(30)\n465\n>>> sum_to_n(100)\n5050\n>>> sum_to_n(5)\n15\n>>> sum_to_n(10)\n55\n>>> sum_to_n(1)\n1\n*/\n#include<stdio.h>\nusing namespace std;\nint sum_to_n(int n){\n    int sum=0;\n    for(int i=1;i<=n;i++){\n        sum+=i;\n    }\n    return sum;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    printf(\"%d\\n\",sum_to_n(n));\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/61", "prompt": "/*\nbrackets is a string chain of' (' and ')'.\nreturn true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n>>> correct_bracketing(\"(\")\nfalse\n>>> correct_bracketing(\"()\")\ntrue\n>>> correct_bracketing(\"(()())\")\ntrue\n>>> correct_bracketing(\")(()\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n", "canonical_solution": "    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"()\"));\n    assert (correct_bracketing(\"(()())\"));\n    assert (correct_bracketing(\"()()(()())()\"));\n    assert (correct_bracketing(\"()()((()()())())(()()(()))\"));\n    assert (not (correct_bracketing(\"((()())))\")));\n    assert (not (correct_bracketing(\")(()\")));\n    assert (not (correct_bracketing(\"(\")));\n    assert (not (correct_bracketing(\"((((\")));\n    assert (not (correct_bracketing(\")\")));\n    assert (not (correct_bracketing(\"(()\")));\n    assert (not (correct_bracketing(\"()()(()())())(()\")));\n    assert (not (correct_bracketing(\"()()(()())()))()\")));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"()\"));\n    assert (correct_bracketing(\"(()())\"));\n    assert (not (correct_bracketing(\")(()\")));\n    assert (not (correct_bracketing(\"(\")));\n}\n", "entry_point": "correct_bracketing", "seed": 3, "perturbed": true, "gc": "/*\nbrackets is a string chain of' (' and ')'.\nreturn true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n>>> correct_bracketing(\"(\")\nfalse\n>>> correct_bracketing(\"()\")\ntrue\n>>> correct_bracketing(\"(()())\")\ntrue\n>>> correct_bracketing(\")(()\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n\tint i,j;\n\tfor(i=0;i<(int)brackets.size();i++){\n\t\tif(brackets[i]==')'){\n\t\t\tfor(j=i+1;j<(int)brackets.size();j++){\n\t\t\t\tif(brackets[j]=='('){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tstring brackets;\n\twhile(getline(cin,brackets)){\n\t\tif(correct_bracketing(brackets)){\n\t\t\tprintf(\"true\\n\");\n\t\t}else{\n\t\t\tprintf(\"false\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/62", "prompt": "/*\nxs represent defend coefficients coefficient of a polynomial. \n xs{0 } + xs{1} * x + xs{2} * x^2 +.... \n  Return derivative of this polynomial in the same form shape.\n>>> derivative({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative({1, 2, 3})\n{2, 6}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> derivative(vector<float> xs){\n", "canonical_solution": "    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(derivative({3, 1, 2, 4, 5}) , {1, 4, 12, 20}));\n    assert (issame(derivative({1, 2, 3}) , {2, 6}));\n    assert (issame(derivative({3, 2, 1}) , {2, 2}));\n    assert (issame(derivative({3, 2, 1, 0, 4}) , {2, 2, 0, 16}));\n    assert (issame(derivative({1}) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(derivative({3, 1, 2, 4, 5}) , {1, 4, 12, 20}));\n    assert (issame(derivative({1, 2, 3}) , {2, 6}));\n}\n", "entry_point": "derivative", "seed": 3, "perturbed": true, "gc": "/*\nxs represent defend coefficients coefficient of a polynomial. \n xs{0 } + xs{1} * x + xs{2} * x^2 +.... \n  Return derivative of this polynomial in the same form shape.\n>>> derivative({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative({1, 2, 3})\n{2, 6}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> derivative(vector<float> xs){\n\tvector<float> dxs(xs.size()-1, 0);\n\tfor(int i=0; i<xs.size()-1; i++){\n\t\tdxs[i] = xs[i+1] - xs[i];\n\t}\n\treturn dxs;\n}\nint main(){\n\tvector<float> xs = {3, 1, 2, 4, 5};\n\tvector<float> dxs = derivative(xs);\n\tfor(int i=0; i<dxs.size(); i++){\n\t\tprintf(\"%f \", dxs[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/63", "prompt": "/*\nThe FibFib number issue sequence succession is a sequence similar alike to the Fibbonacci sequnece that's defined as follows succeed: \n fibfib(0) = = 0 \n fibfib(1) = = 0 \n fibfib(2) = = 1 \n fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\nPlease write publish a function affair to efficiently compute calculate the n-th element component of the fibfib number sequence.\n>>> fibfib(1)\n0\n>>> fibfib(5)\n4\n>>> fibfib(8)\n24\n*/\n#include<stdio.h>\nusing namespace std;\nint fibfib(int n){\n", "canonical_solution": "    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fibfib(2) == 1);\n    assert (fibfib(1) == 0);\n    assert (fibfib(5) == 4);\n    assert (fibfib(8) == 24);\n    assert (fibfib(10) == 81);\n    assert (fibfib(12) == 274);\n    assert (fibfib(14) == 927);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fibfib(1) == 0);\n    assert (fibfib(5) == 4);\n    assert (fibfib(8) == 24);\n}\n", "entry_point": "fibfib", "seed": 3, "perturbed": true, "gc": "/*\nThe FibFib number issue sequence succession is a sequence similar alike to the Fibbonacci sequnece that's defined as follows succeed: \n fibfib(0) = = 0 \n fibfib(1) = = 0 \n fibfib(2) = = 1 \n fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\nPlease write publish a function affair to efficiently compute calculate the n-th element component of the fibfib number sequence.\n>>> fibfib(1)\n0\n>>> fibfib(5)\n4\n>>> fibfib(8)\n24\n*/\n#include<stdio.h>\nusing namespace std;\nint fibfib(int n){\n    if(n==0){\n        return 0;\n    }\n    if(n==1){\n        return 0;\n    }\n    if(n==2){\n        return 1;\n    }\n    if(n==3){\n        return 1;\n    }\n    if(n==4){\n        return 2;\n    }\n    if(n==5){\n        return 3;\n    }\n    if(n==6){\n        return 5;\n    }\n    if(n==7){\n        return 8;\n    }\n    if(n==8){\n        return 13;\n    }\n    if(n==9){\n        return 21;\n    }\n    if(n==10){\n        return 34;\n    }\n    if(n==11){\n        return 55;\n    }\n    if(n==12){\n        return 89;\n    }\n    if(n==13){\n        return 144;\n    }\n    if(n==14){\n        return 233;\n    }\n    if(n==15){\n        return 377;\n    }\n    if(n==16){\n        return 610;\n    }\n    if(n==17){\n        return 987;\n    }\n    if(n==18){\n        return 1597;\n    }\n    if(n==19){\n        return 2584;\n    }\n    if(n==20){\n        return 4181;\n    }\n    if(n==21){\n        return 6765;\n    }\n    if(n==22){\n        return 10946;\n    }\n    if(n==23){\n        return 17711;\n    }\n    if(n==24){\n        return 28657;\n    }\n    if(n==25){\n        return 46368;\n    }\n    if(n==26){\n        return 75025;\n    }\n    if(n==27){\n        return 121393;\n    }\n    if(n==28){\n        return 196418;\n    }\n    if(n==29){\n        return 317811;\n    }\n    if(n==30){\n        return 514229;\n    }\n    if(n==31){\n        return 832040;\n    }\n    if(n==32){\n        return 1346269;\n    }\n    if(n==33){\n        return 2178309;\n    }\n    if(n==34){\n        return 3524578;\n    }\n    if(n==35){\n        return 5702887;\n    }\n    if(n==36){\n        return 9227465;\n    }\n    if(n==37){\n        return 14930352;\n    }\n    if(n==38){\n        return 24157817;\n    }\n    if(n==39){\n        return 39088169;\n    }\n    if(n==40){\n        return 63245986;\n    }\n    if(n==41){\n        return 102334155;\n    }\n    if(n==42){\n        return 165580141;\n    }\n    if(n==43){\n        return 267914296;\n    }\n    if(n==44){\n        return 433494437;\n    }\n    if(n==45){\n        return 701408733;\n    }\n    if(n==46){\n        return 1134903170;\n    }\n    if(n==47){\n        return 1836311903;\n    }\n    if(n==48){\n        return 2971215073;\n    }\n    if(n==49){\n        return 4875461423;\n    }\n    if(n==50){\n        return 7551843047;\n    }\n    if(n==51){\n        return 12182531188;\n    }\n    if(n==52){\n        return 1964180192;\n    }\n    if(n==53){\n        return 3178303846;\n    }\n    if(n==54){\n        return 5242850192;\n    }\n    if(n==55){\n        return 8320402815;\n    }\n    if(n==56){\n        return 13462690129;\n    }\n    if(n==57){\n        return 21783090129;\n    }\n    if(n==58){\n        return 35245780129;\n    }\n    if(n==59){\n        return 57028870129;\n    }\n    if(n==60){\n        return 92274650129;\n    }\n    if(n==61){\n        return 149303540129;\n    }\n    if(n==62){\n        return 241578170129;\n    }\n    if(n==63){\n        return 390881690129;\n    }\n    if(n==64){\n        return 632459860129;\n    }\n    if(n==65){\n        return 1023341550429;\n    }\n    if(n==66){\n        return 1655801410129;\n    }\n    if(n==67){\n        return 2679142960129;\n    }\n    if(n==68){\n        return 4334944370129;\n    }\n    if(n==69){\n        return 7014087330129;\n    }\n    if(n==70){\n        return 11349031700129;\n    }\n    if(n==71){\n        return 18363119030129;\n    }\n    if(n==72){\n        return 29712150730129;\n    }\n    if(n==73){\n        return 487546142301", "passed": 0, "run_status": 2}
{"task_id": "CPP/64", "prompt": "/*\nWrite publish a function affair vowels_count which takes a string bowed stringed instrument representing a word bible as input stimulation and returns hark back the number issue of vowels in the string bowed stringed instrument. Vowels in this case are' a',' e', 'i',' o',' u'. \n Here,' y' is also besides a vowel, but only when it is at the end goal of the given word bible. \n Example: \n>>> vowels_count(\"abcde\") \n2 \n>>> vowels_count(\"ACEDY\") \n3\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint vowels_count(string s){\n", "canonical_solution": "    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (vowels_count(\"abcde\") == 2);\n    assert (vowels_count(\"Alone\") == 3);\n    assert (vowels_count(\"key\") == 2);\n    assert (vowels_count(\"bye\") == 1);\n    assert (vowels_count(\"keY\") == 2);\n    assert (vowels_count(\"bYe\") == 1);\n    assert (vowels_count(\"ACEDY\") == 3);\n   \n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (vowels_count(\"abcde\") == 2);\n    assert (vowels_count(\"ACEDY\") == 3);\n}\n", "entry_point": "vowels_count", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair vowels_count which takes a string bowed stringed instrument representing a word bible as input stimulation and returns hark back the number issue of vowels in the string bowed stringed instrument. Vowels in this case are' a',' e', 'i',' o',' u'. \n Here,' y' is also besides a vowel, but only when it is at the end goal of the given word bible. \n Example: \n>>> vowels_count(\"abcde\") \n2 \n>>> vowels_count(\"ACEDY\") \n3\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint vowels_count(string s){\n\tint count = 0;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main(){\n\tstring s;\n\twhile(scanf(\"%s\", &s) == 1){\n\t\tprintf(\"%d\\n\", vowels_count(s));\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/65", "prompt": "/*\nCircular round shift the digits finger of the integer x, shift the digits right proper by shift\nand return the result as a string chain. \n If shift > number numeral of digits, return digits reversed change by reversal.\n>>> circular_shift(12, 1)\n\"21\"\n>>> circular_shift(12, 2)\n\"12\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring circular_shift(int x,int shift){\n", "canonical_solution": "    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (circular_shift(100, 2) == \"001\");\n    assert (circular_shift(12, 2) == \"12\");\n    assert (circular_shift(97, 8) == \"79\");\n    assert (circular_shift(12, 1) == \"21\");\n    assert (circular_shift(11, 101) == \"11\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (circular_shift(12, 2) == \"12\");\n    assert (circular_shift(12, 1) == \"21\");\n}\n", "entry_point": "circular_shift", "seed": 3, "perturbed": true, "gc": "/*\nCircular round shift the digits finger of the integer x, shift the digits right proper by shift\nand return the result as a string chain. \n If shift > number numeral of digits, return digits reversed change by reversal.\n>>> circular_shift(12, 1)\n\"21\"\n>>> circular_shift(12, 2)\n\"12\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring circular_shift(int x,int shift){\n\tstring result=\"\";\n\tint i=0;\n\twhile(x>0){\n\t\tresult=result+to_string(x%10);\n\t\tx=x/10;\n\t\ti++;\n\t}\n\tif(shift>i){\n\t\treverse(result.begin(),result.end());\n\t\treturn result;\n\t}\n\treverse(result.begin(),result.end());\n\tfor(int i=0;i<shift-i;i++){\n\t\treverse(result.begin(),result.end());\n\t}\n\treturn result;\n}\nint main(){\n\tint x=12;\n\tint shift=1;\n\tstring result=circular_shift(x,shift);\n\tprintf(\"%s\\n\",result.c_str());\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/66", "prompt": "/*\nTask job \n Write publish a function routine that takes a string as input stimulation and returns retort the sum of the upper characters only's \n ASCII codes.\n\nExamples:\n    digitSum(\"\") => 0\n    digitSum(\"abAB\") => 131\n    digitSum(\"abcCd\") => 67\n    digitSum(\"helloE\") => 69\n    digitSum(\"woArBld\") => 131\n    digitSum(\"aAaaaXa\") => 153\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint digitSum(string s){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digitSum(\"\") == 0);\n    assert (digitSum(\"abAB\") == 131);\n    assert (digitSum(\"abcCd\") == 67);\n    assert (digitSum(\"helloE\") == 69);\n    assert (digitSum(\"woArBld\") == 131);\n    assert (digitSum(\"aAaaaXa\") == 153);\n    assert (digitSum(\" How are yOu?\") == 151);\n    assert (digitSum(\"You arE Very Smart\") == 327);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digitSum(\"\") == 0);\n    assert (digitSum(\"abAB\") == 131);\n    assert (digitSum(\"abcCd\") == 67);\n    assert (digitSum(\"helloE\") == 69);\n    assert (digitSum(\"woArBld\") == 131);\n    assert (digitSum(\"aAaaaXa\") == 153);\n}\n", "entry_point": "digitSum", "seed": 3, "perturbed": true, "gc": "/*\nTask job \n Write publish a function routine that takes a string as input stimulation and returns retort the sum of the upper characters only's \n ASCII codes.\n\nExamples:\n    digitSum(\"\") => 0\n    digitSum(\"abAB\") => 131\n    digitSum(\"abcCd\") => 67\n    digitSum(\"helloE\") => 69\n    digitSum(\"woArBld\") => 131\n    digitSum(\"aAaaaXa\") => 153\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint digitSum(string s){\n    int sum = 0;\n    for(int i = 0; i < s.size(); i++){\n        sum += s[i] - '0';\n    }\n    return sum;\n}\nint main(){\n    string s;\n    scanf(\"%s\", &s);\n    printf(\"%d\\n\", digitSum(s));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/67", "prompt": "/*\nIn this task job, you will be given collapse a string chain that represents present a number of apples apple and oranges orange \n that are distributed in a basket of fruit this basket contains contain \n apples apple, oranges, and mango fruits. Given the string that represents present the total entire number of \n the oranges orange and apples and an integer that represent the total full number of the fruits fruit \nin the basket return the number issue of the mango fruits fruit in the basket.\nfor example:\nfruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\nfruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\nfruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\nfruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint fruit_distribution(string s,int n){\n", "canonical_solution": "    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fruit_distribution(\"5 apples and 6 oranges\",19) == 8);\n    assert (fruit_distribution(\"5 apples and 6 oranges\",21) == 10);\n    assert (fruit_distribution(\"0 apples and 1 oranges\",3) == 2);\n    assert (fruit_distribution(\"1 apples and 0 oranges\",3) == 2);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",100) == 95);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",5) == 0);\n    assert (fruit_distribution(\"1 apples and 100 oranges\",120) == 19);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fruit_distribution(\"5 apples and 6 oranges\",19) == 8);\n    assert (fruit_distribution(\"0 apples and 1 oranges\",3) == 2);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",100) == 95);\n    assert (fruit_distribution(\"1 apples and 100 oranges\",120) == 19);\n}\n", "entry_point": "fruit_distribution", "seed": 3, "perturbed": true, "gc": "/*\nIn this task job, you will be given collapse a string chain that represents present a number of apples apple and oranges orange \n that are distributed in a basket of fruit this basket contains contain \n apples apple, oranges, and mango fruits. Given the string that represents present the total entire number of \n the oranges orange and apples and an integer that represent the total full number of the fruits fruit \nin the basket return the number issue of the mango fruits fruit in the basket.\nfor example:\nfruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\nfruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\nfruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\nfruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint fruit_distribution(string s,int n){\n\tint count = 0;\n\tint i = 0;\n\twhile(i < n){\n\t\tif(s[i] == 'a'){\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}else if(s[i] == 'o'){\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}else if(s[i] =='m'){\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}\nint main(){\n\tstring s;\n\tint n;\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",&s);\n\tprintf(\"%d\\n\",fruit_distribution(s,n));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/68", "prompt": "/*\nGiven render a vector representing exemplify a branch of a tree that has non - negative minus integer nodes \n your task job is to pluck one of the nodes lymph node and return it. \n The plucked node should be the node with the smallest small even tied value. \n If multiple nodes with the same smallest even value are found return the node lymph node that has smallest belittled index. \n\n The plucked node lymph node should be returned in a vector, { smalest_value, its index }, \n If there are no even tied values or the given impart vector is empty, return { }.\n\nExample 1:\n    Input: {4,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: {1,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: {}\n    Output: {}\n\nExample 4:\n    Input: {5, 0, 3, 0, 4, 2}\n    Output: {0, 1}\n    Explanation: 0 is the smallest value, but  there are two zeros,\n                 so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> pluck(vector<int> arr){\n", "canonical_solution": "    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(pluck({4,2,3}) , {2, 1}));\n    assert (issame(pluck({1,2,3}) , {2, 1}));\n    assert (issame(pluck({}) , {}));\n    assert (issame(pluck({5, 0, 3, 0, 4, 2}) , {0, 1}));\n    assert (issame(pluck({1, 2, 3, 0, 5, 3}) , {0, 3}));\n    assert (issame(pluck({5, 4, 8, 4 ,8}) , {4, 1}));\n    assert (issame(pluck({7, 6, 7, 1}) , {6, 1}));\n    assert (issame(pluck({7, 9, 7, 1}) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(pluck({4,2,3}) , {2, 1}));\n    assert (issame(pluck({1,2,3}) , {2, 1}));\n    assert (issame(pluck({}) , {}));\n    assert (issame(pluck({5, 0, 3, 0, 4, 2}) , {0, 1}));\n}\n", "entry_point": "pluck", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a vector representing exemplify a branch of a tree that has non - negative minus integer nodes \n your task job is to pluck one of the nodes lymph node and return it. \n The plucked node should be the node with the smallest small even tied value. \n If multiple nodes with the same smallest even value are found return the node lymph node that has smallest belittled index. \n\n The plucked node lymph node should be returned in a vector, { smalest_value, its index }, \n If there are no even tied values or the given impart vector is empty, return { }.\n\nExample 1:\n    Input: {4,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: {1,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: {}\n    Output: {}\n\nExample 4:\n    Input: {5, 0, 3, 0, 4, 2}\n    Output: {0, 1}\n    Explanation: 0 is the smallest value, but  there are two zeros,\n                 so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> pluck(vector<int> arr){\n    vector<int> ret;\n    int min_even = arr[0];\n    int min_index = 0;\n    for(int i = 0; i < arr.size(); i++){\n        if(arr[i] % 2 == 0){\n            if(arr[i] < min_even){\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    ret.push_back(min_even);\n    ret.push_back(min_index);\n    return ret;\n}\n\nint main(){\n    vector<int> arr;\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        int x;\n        scanf(\"%d\", &x);\n        arr.push_back(x);\n    }\n    vector<int> ret = pluck(arr);\n    for(int i = 0; i < ret.size(); i++){\n        printf(\"%d \", ret[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/69", "prompt": "/*\nYou are given render a non - empty vector of positive positivist integers integer. Return the greatest integer that is greater bang-up than \n zero, and has a frequency greater great than or equal to the value of the integer itself. \n The frequency of an integer is the number of times fourth dimension it appears look in the vector. \n If no such a value exist, return -1.\nExamples:\n    search({4, 1, 2, 2, 3, 1}) == 2\n    search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3\n    search({5, 5, 4, 4, 4}) == -1\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint search(vector<int> lst){\n", "canonical_solution": "    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (search({5, 5, 5, 5, 1}) == 1);\n    assert (search({4, 1, 4, 1, 4, 4}) == 4);\n    assert (search({3, 3}) == -1);\n    assert (search({8, 8, 8, 8, 8, 8, 8, 8}) == 8);\n    assert (search({2, 3, 3, 2, 2}) == 2);\n    assert (search({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}) == 1);\n    assert (search({3, 2, 8, 2}) == 2);\n    assert (search({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}) == 1);\n    assert (search({8, 8, 3, 6, 5, 6, 4}) == -1);\n    assert (search({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}) == 1);\n    assert (search({1, 9, 10, 1, 3}) == 1);\n    assert (search({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}) == 5);\n    assert (search({1}) == 1);\n    assert (search({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}) == 4);\n    assert (search({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}) == 2);\n    assert (search({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}) == 1);\n    assert (search({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}) == 4);\n    assert (search({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}) == 4);\n    assert (search({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}) == 2);\n    assert (search({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}) == -1);\n    assert (search({10}) == -1);\n    assert (search({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}) == 2);\n    assert (search({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}) == 1);\n    assert (search({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}) == 1);\n    assert (search({3, 10, 10, 9, 2}) == -1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (search({4, 1, 2, 2, 3, 1}) == 2);\n    assert (search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert (search({5, 5, 4, 4, 4}) == -1);\n}\n", "entry_point": "search", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a non - empty vector of positive positivist integers integer. Return the greatest integer that is greater bang-up than \n zero, and has a frequency greater great than or equal to the value of the integer itself. \n The frequency of an integer is the number of times fourth dimension it appears look in the vector. \n If no such a value exist, return -1.\nExamples:\n    search({4, 1, 2, 2, 3, 1}) == 2\n    search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3\n    search({5, 5, 4, 4, 4}) == -1\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint search(vector<int> lst){\n    int max=0,freq=0;\n    for(int i=0;i<lst.size();i++){\n        if(lst[i]>max){\n            max=lst[i];\n            freq=1;\n        }else if(lst[i]==max){\n            freq++;\n        }\n    }\n    if(max>0&&freq>=lst.size()){\n        return max;\n    }else{\n        return -1;\n    }\n}\nint main(){\n    vector<int> lst;\n    lst.push_back(4);\n    lst.push_back(1);\n    lst.push_back(2);\n    lst.push_back(2);\n    lst.push_back(3);\n    lst.push_back(1);\n    printf(\"%d\\n\",search(lst));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/7", "prompt": "/*\nFilter an input stimulation vector of strings only for ones one that contain given contribute substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n", "canonical_solution": "    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_substring({}, \"john\"),{}));\n     assert (issame(filter_by_substring({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), {\"xxx\", \"xxxAAA\", \"xxx\"}));\n    assert (issame(filter_by_substring({\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"),{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"}));\n     assert (issame(filter_by_substring({\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\") ,{\"grunt\", \"prune\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_substring({}, \"a\"),{}));\n     assert (issame(filter_by_substring({\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\"), {\"abc\", \"bacd\", \"array\"}));\n}\n", "entry_point": "filter_by_substring", "seed": 3, "perturbed": true, "gc": "/*\nFilter an input stimulation vector of strings only for ones one that contain given contribute substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n\tvector<string> ret;\n\tfor(string s : strings){\n\t\tif(s.find(substring)!= string::npos){\n\t\t\tret.push_back(s);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\nFilter an input stimulation vector of strings only for ones one that contain given contribute substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n\tvector<string> ret;\n\tfor(string s : strings){\n\t\tif(s.find(substring)!= string::npos){\n\t\t\tret.push_back(s);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\nFilter an input stimulation vector of strings only for ones one that contain given contribute substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n\tvector<string> ret;\n\tfor(string s : strings){\n\t\tif(s.find(substring)!= string::npos){\n\t\t\tret.push_back(s);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\nFilter an input stimulation vector of strings only for ones one that contain given contribute substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n\tvector<string> ret;\n\tfor(string s : strings){\n\t\tif(s.find(substring)!= string::npos){\n\t\t\tret.push_back(s);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\nFilter an input stimulation vector of strings only for ones one that contain given contribute substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n\tvector<string> ret;\n\tfor(string s : strings){\n\t\tif(s.find(substring)!= string::npos){\n\t\t\tret.push_back(s);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\nFilter an input stimulation vector of strings only for ones one that contain given contribute substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n\tvector<string> ret;\n\tfor(string s : strings){\n\t\tif(s.find(substring)!= string::npos){\n\t\t\tret.push_back(s);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\nFilter an input stimulation vector of strings only for ones one that contain given contribute substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n\tvector<string> ret;\n\tfor(string s : strings){\n\t\tif(s.find(substring)!= string::npos){\n\t\t\tret.push_back(s);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\nFilter an input stimulation vector of strings only for ones one that contain given contribute substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n\tvector<string> ret;\n\tfor(string s : strings){\n\t\tif(s.find(substring)!= string::npos){\n\t\t\tret.push_back(s);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\nFilter an input stimulation vector of strings only for ones one that contain given contribute substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"", "passed": 1, "run_status": 0}
{"task_id": "CPP/70", "prompt": "/*\nGiven render vector of integers integer, return vector in strange order holy order. \n Strange sorting sort, is when you start startle with the minimum value, \n then maximum of the remaining remain integers integer, then minimum and so on.\n\nExamples:\nstrange_sort_vector({1, 2, 3, 4}) == {1, 4, 2, 3}\nstrange_sort_vector({5, 5, 5, 5}) == {5, 5, 5, 5}\nstrange_sort_vector({}) == {}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> strange_sort_list(vector<int> lst){\n", "canonical_solution": "    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(strange_sort_list({1, 2, 3, 4}) , {1, 4, 2, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9}) , {5, 9, 6, 8, 7}));\n    assert (issame(strange_sort_list({1, 2, 3, 4, 5}) , {1, 5, 2, 4, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9, 1}) , {1, 9, 5, 8, 6, 7}));\n    assert (issame(strange_sort_list({5, 5, 5, 5}) , {5, 5, 5, 5}));\n    assert (issame(strange_sort_list({}) , {}));\n    assert (issame(strange_sort_list({1,2,3,4,5,6,7,8}) , {1, 8, 2, 7, 3, 6, 4, 5}));\n    assert (issame(strange_sort_list({0,2,2,2,5,5,-5,-5}) , {-5, 5, -5, 5, 0, 2, 2, 2}));\n    assert (issame(strange_sort_list({111111}) , {111111}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(strange_sort_list({1, 2, 3, 4}) , {1, 4, 2, 3}));\n    assert (issame(strange_sort_list({5, 5, 5, 5}) , {5, 5, 5, 5}));\n    assert (issame(strange_sort_list({}) , {}));\n}\n", "entry_point": "strange_sort_list", "seed": 3, "perturbed": true, "gc": "/*\nGiven render vector of integers integer, return vector in strange order holy order. \n Strange sorting sort, is when you start startle with the minimum value, \n then maximum of the remaining remain integers integer, then minimum and so on.\n\nExamples:\nstrange_sort_vector({1, 2, 3, 4}) == {1, 4, 2, 3}\nstrange_sort_vector({5, 5, 5, 5}) == {5, 5, 5, 5}\nstrange_sort_vector({}) == {}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> strange_sort_list(vector<int> lst){\n\tvector<int> res;\n\tsort(lst.begin(), lst.end());\n\tres.push_back(lst[0]);\n\tfor(int i=1; i<lst.size(); i++){\n\t\tif(lst[i] < res.back()){\n\t\t\tres.push_back(lst[i]);\n\t\t}else{\n\t\t\tres.push_back(res.back());\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tvector<int> lst = {1, 2, 3, 4};\n\tvector<int> res = strange_sort_list(lst);\n\tfor(int i=0; i<res.size(); i++){\n\t\tprintf(\"%d \", res[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/71", "prompt": "/*\nGiven render the lengths duration of the three sides english of a triangle triangulum. Return the area of \n the triangle triangulum rounded round off to 2 decimal points if the three sides form imprint a valid triangle triangulum. \n Otherwise return -1 \n Three sides make a valid triangle when the sum kernel of any two sides side is greater \n than the third side slope.\nExample:\ntriangle_area(3, 4, 5) == 6.00\ntriangle_area(1, 2, 10) == -1\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat triangle_area(float a,float b,float c){\n", "canonical_solution": "    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(3, 4, 5)-6.00)<0.01);\n    assert (abs(triangle_area(1, 2, 10) +1)<0.01);\n    assert (abs(triangle_area(4, 8, 5) -8.18)<0.01);\n    assert (abs(triangle_area(2, 2, 2) -1.73)<0.01);\n    assert (abs(triangle_area(1, 2, 3) +1)<0.01);\n    assert (abs(triangle_area(10, 5, 7) - 16.25)<0.01);\n    assert (abs(triangle_area(2, 6, 3) +1)<0.01);\n    assert (abs(triangle_area(1, 1, 1) -0.43)<0.01);\n    assert (abs(triangle_area(2, 2, 10) +1)<0.01);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(3, 4, 5)-6.00)<0.01);\n    assert (abs(triangle_area(1, 2, 10) +1)<0.01);\n}\n", "entry_point": "triangle_area", "seed": 3, "perturbed": true, "gc": "/*\nGiven render the lengths duration of the three sides english of a triangle triangulum. Return the area of \n the triangle triangulum rounded round off to 2 decimal points if the three sides form imprint a valid triangle triangulum. \n Otherwise return -1 \n Three sides make a valid triangle when the sum kernel of any two sides side is greater \n than the third side slope.\nExample:\ntriangle_area(3, 4, 5) == 6.00\ntriangle_area(1, 2, 10) == -1\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat triangle_area(float a,float b,float c){\n    float area=0;\n    area=a+b+c;\n    if(area<=0){\n        return -1;\n    }\n    area=sqrt(area);\n    return area;\n}\nint main(){\n    float a,b,c;\n    scanf(\"%f%f%f\",&a,&b,&c);\n    printf(\"%.2f\\n\",triangle_area(a,b,c));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/72", "prompt": "/*\nWrite publish a function affair that returns true truthful if the object q will fly flee, and false fake otherwise differently. \n The object aim q will fly flee if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n\nExample:\nwill_it_fly({1, 2}, 5)  false \n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n\nwill_it_fly({3, 2, 3}, 1)  false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n\nwill_it_fly({3, 2, 3}, 9)  true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n\nwill_it_fly({3}, 5)  true\n// 3 is less than the maximum possible weight, and it's balanced.\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool will_it_fly(vector<int> q,int w){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (will_it_fly({3, 2, 3}, 9)==true);\n    assert (will_it_fly({1, 2}, 5) == false);\n    assert (will_it_fly({3}, 5) == true);\n    assert (will_it_fly({3, 2, 3}, 1) == false);\n    assert (will_it_fly({1, 2, 3}, 6) ==false);\n    assert (will_it_fly({5}, 5) == true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (will_it_fly({3, 2, 3}, 9)==true);\n    assert (will_it_fly({1, 2}, 5) == false);\n    assert (will_it_fly({3}, 5) == true);\n    assert (will_it_fly({3, 2, 3}, 1) == false);\n}\n", "entry_point": "will_it_fly", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair that returns true truthful if the object q will fly flee, and false fake otherwise differently. \n The object aim q will fly flee if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n\nExample:\nwill_it_fly({1, 2}, 5)  false \n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n\nwill_it_fly({3, 2, 3}, 1)  false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n\nwill_it_fly({3, 2, 3}, 9)  true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n\nwill_it_fly({3}, 5)  true\n// 3 is less than the maximum possible weight, and it's balanced.\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for(int i=0;i<q.size();i++){\n        sum+=q[i];\n    }\n    if(sum>w)\n        return false;\n    if(sum<w)\n        return true;\n    if(q.size()==1)\n        return true;\n    if(q.size()==2)\n        return false;\n    if(q.size()%2==0)\n        return true;\n    if(q.size()%2==1)\n        return false;\n    int mid=q.size()/2;\n    if(q[mid]==q[q.size()-1])\n        return true;\n    if(q[mid]==q[q.size()-2])\n        return false;\n    return will_it_fly(q.begin()+mid,w);\n}\nint main(){\n    vector<int> q;\n    int w;\n    while(scanf(\"%d\",&w)==1){\n        scanf(\"%d\",&q.size());\n        for(int i=0;i<q.size();i++){\n            scanf(\"%d\",&q[i]);\n        }\n        printf(\"%s\\n\",will_it_fly(q,w)?\"true\":\"false\");\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/73", "prompt": "/*\nGiven render a vector arr of integers integer, find the minimum minimal number of elements element that \n need want to be changed to make the vector palindromic. A palindromic vector is a vector that \n is read learn the same backwards back and forwards. In one change, you can change one element to any other element component.\n\nFor example:\nsmallest_change({1,2,3,5,4,7,9,6}) == 4\nsmallest_change({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change({1, 2, 3, 2, 1}) == 0\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint smallest_change(vector<int> arr){\n", "canonical_solution": "    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (smallest_change({1,2,3,5,4,7,9,6}) == 4);\n    assert (smallest_change({1, 2, 3, 4, 3, 2, 2}) == 1);\n    assert (smallest_change({1, 4, 2}) == 1);\n    assert (smallest_change({1, 4, 4, 2}) == 1);\n    assert (smallest_change({1, 2, 3, 2, 1}) == 0);\n    assert (smallest_change({3, 1, 1, 3}) == 0);\n    assert (smallest_change({1}) == 0);\n    assert (smallest_change({0, 1}) == 1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (smallest_change({1,2,3,5,4,7,9,6}) == 4);\n    assert (smallest_change({1, 2, 3, 4, 3, 2, 2}) == 1);\n    assert (smallest_change({1, 2, 3, 2, 1}) == 0);\n    assert (smallest_change({3, 1, 1, 3}) == 0);\n}\n", "entry_point": "smallest_change", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a vector arr of integers integer, find the minimum minimal number of elements element that \n need want to be changed to make the vector palindromic. A palindromic vector is a vector that \n is read learn the same backwards back and forwards. In one change, you can change one element to any other element component.\n\nFor example:\nsmallest_change({1,2,3,5,4,7,9,6}) == 4\nsmallest_change({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change({1, 2, 3, 2, 1}) == 0\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint smallest_change(vector<int> arr){\n    int n = arr.size();\n    int min_change = n;\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n; j++){\n            if(arr[i] == arr[j]){\n                min_change = min(min_change, j-i);\n            }\n        }\n    }\n    return min_change;\n}\nint main(){\n    vector<int> arr = {1,2,3,5,4,7,9,6};\n    printf(\"%d\\n\", smallest_change(arr));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/74", "prompt": "/*\nWrite publish a function affair that accepts two vectors vector of strings and returns hark back the vector that has \n total full number of chars in the all strings bowed stringed instrument of the vector less than the other vector. \n\n if the two vectors vector have the same number of chars, return the first vector.\n\nExamples\ntotal_match({}, {})  {}\ntotal_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"})  {\"hI\", \"Hi\"}\ntotal_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"})  {\"hi\", \"admin\"}\ntotal_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"})  {\"hI\", \"hi\", \"hi\"}\ntotal_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"})  {\"4\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n", "canonical_solution": "    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(total_match({}, {}) , {}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\"}) , {\"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hii\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({}, {\"this\"}) , {}));\n    assert (issame(total_match({\"this\"}, {}) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(total_match({}, {}) , {}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n}\n", "entry_point": "total_match", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair that accepts two vectors vector of strings and returns hark back the vector that has \n total full number of chars in the all strings bowed stringed instrument of the vector less than the other vector. \n\n if the two vectors vector have the same number of chars, return the first vector.\n\nExamples\ntotal_match({}, {})  {}\ntotal_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"})  {\"hI\", \"Hi\"}\ntotal_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"})  {\"hi\", \"admin\"}\ntotal_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"})  {\"hI\", \"hi\", \"hi\"}\ntotal_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"})  {\"4\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    vector<string> result;\n    if(lst1.size()!=lst2.size()){\n        return result;\n    }\n    for(int i=0;i<lst1.size();i++){\n        if(lst1[i].size()>lst2[i].size()){\n            return result;\n        }\n        if(lst1[i].size()==lst2[i].size()){\n            if(lst1[i]==lst2[i]){\n                result.push_back(lst1[i]);\n            }\n        }\n    }\n    return result;\n}\nint main(){\n    vector<string> lst1 = {\"hi\", \"admin\"};\n    vector<string> lst2 = {\"hI\", \"Hi\"};\n    vector<string> lst3 = {\"hI\", \"hi\", \"hi\"};\n    vector<string> lst4 = {\"4\"};\n    vector<string> lst5 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst6 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst7 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst8 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst9 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst10 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst11 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst12 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst13 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst14 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst15 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst16 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst17 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst18 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst19 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst20 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst21 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst22 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst23 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst24 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst25 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst26 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst27 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst28 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst29 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst30 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst31 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst32 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst33 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst34 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst35 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst36 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst37 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst38 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst39 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst40 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst41 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst42 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst43 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string> lst44 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    vector<string>", "passed": 0, "run_status": 1}
{"task_id": "CPP/75", "prompt": "/*\nWrite publish a function affair that returns true truthful if the given number issue is the multiplication generation of 3 prime numbers \n and false delusive otherwise differently. \n Knowing that (a) is less then 100. \nExample:\nis_multiply_prime(30) == true\n30 = 2 * 3 * 5\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_multiply_prime(int a){\n", "canonical_solution": "    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_multiply_prime(5) == false);\n    assert (is_multiply_prime(30) == true);\n    assert (is_multiply_prime(8) == true);\n    assert (is_multiply_prime(10) == false);\n    assert (is_multiply_prime(125) == true);\n    assert (is_multiply_prime(3 * 5 * 7) == true);\n    assert (is_multiply_prime(3 * 6 * 7) == false);\n    assert (is_multiply_prime(9 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 13 * 7) == true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_multiply_prime(30) == true);\n}\n", "entry_point": "is_multiply_prime", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair that returns true truthful if the given number issue is the multiplication generation of 3 prime numbers \n and false delusive otherwise differently. \n Knowing that (a) is less then 100. \nExample:\nis_multiply_prime(30) == true\n30 = 2 * 3 * 5\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_multiply_prime(int a){\n    if(a<100)\n        return false;\n    if(a%3==0)\n        return true;\n    if(a%5==0)\n        return true;\n    if(a%7==0)\n        return true;\n    if(a%11==0)\n        return true;\n    if(a%13==0)\n        return true;\n    if(a%17==0)\n        return true;\n    if(a%19==0)\n        return true;\n    if(a%23==0)\n        return true;\n    if(a%29==0)\n        return true;\n    if(a%31==0)\n        return true;\n    if(a%37==0)\n        return true;\n    if(a%41==0)\n        return true;\n    if(a%43==0)\n        return true;\n    if(a%47==0)\n        return true;\n    if(a%53==0)\n        return true;\n    if(a%59==0)\n        return true;\n    if(a%61==0)\n        return true;\n    if(a%67==0)\n        return true;\n    if(a%71==0)\n        return true;\n    if(a%73==0)\n        return true;\n    if(a%79==0)\n        return true;\n    if(a%83==0)\n        return true;\n    if(a%89==0)\n        return true;\n    if(a%97==0)\n        return true;\n    if(a%101==0)\n        return true;\n    if(a%103==0)\n        return true;\n    if(a%107==0)\n        return true;\n    if(a%109==0)\n        return true;\n    if(a%113==0)\n        return true;\n    if(a%127==0)\n        return true;\n    if(a%131==0)\n        return true;\n    if(a%137==0)\n        return true;\n    if(a%139==0)\n        return true;\n    if(a%149==0)\n        return true;\n    if(a%151==0)\n        return true;\n    if(a%157==0)\n        return true;\n    if(a%163==0)\n        return true;\n    if(a%167==0)\n        return true;\n    if(a%173==0)\n        return true;\n    if(a%179==0)\n        return true;\n    if(a%181==0)\n        return true;\n    if(a%191==0)\n        return true;\n    if(a%193==0)\n        return true;\n    if(a%197==0)\n        return true;\n    if(a%199==0)\n        return true;\n    if(a%211==0)\n        return true;\n    if(a%223==0)\n        return true;\n    if(a%227==0)\n        return true;\n    if(a%229==0)\n        return true;\n    if(a%233==0)\n        return true;\n    if(a%239==0)\n        return true;\n    if(a%241==0)\n        return true;\n    if(a%251==0)\n        return true;\n    if(a%257==0)\n        return true;\n    if(a%263==0)\n        return true;\n    if(a%269==0)\n        return true;\n    if(a%271==0)\n        return true;\n    if(a%277==0)\n        return true;\n    if(a%281==0)\n        return true;\n    if(a%283==0)\n        return true;\n    if(a%293==0)\n        return true;\n    if(a%307==0)\n        return true;\n    if(a%311==0)\n        return true;\n    if(a%313==0)\n        return true;\n    if(a%317==0)\n        return true;\n    if(a%331==0)\n        return true;\n    if(a%333==0)\n        return true;\n    if(a%337==0)\n        return true;\n    if(a%347==0)\n        return true;\n    if(a%349==0)\n        return true;\n    if(a%353==0)\n        return true;\n    if(a%359==0)\n        return true;\n    if(a%361==0)\n        return true;\n    if(a%367==0)\n        return true;\n    if(a%373==0)\n        return true;\n    if(a%379==0)\n        return true;\n    if(a%383==0)\n        return true;\n    if(a%389==0)\n        return true;\n    if(a%397==0)\n        return true;\n    if(a%401==0)\n        return true;\n    if(a%409==0)\n        return true;\n    if(a%419==0)\n        return true;\n    if(a%421==0)\n        return true;\n    if(a%431==0)\n        return true;\n    if(a%433==0)\n        return true;\n    if(a%439==0)\n        return true;\n    if(a%443==0)\n        return true;\n    if(a%449==0)\n        return true;\n    if(a%457==0)\n        return true;\n    if(a%461==0)\n        return true;\n    if(a%463==0)\n        return true;\n    if(a%467==0)\n        return true;\n    if(a%479==0)\n        return true;\n    if(a%487==0)\n        return true;\n    if(a%491==0)\n        return true", "passed": 0, "run_status": 2}
{"task_id": "CPP/76", "prompt": "/*\nYour task job is to write publish a function routine that returns true if a number issue x is a simple elementary \n power of n and false in other cases subject. \n x is a simple bare power of n if n**int=x\nFor example:\nis_simple_power(1, 4) => true\nis_simple_power(2, 2) => true\nis_simple_power(8, 2) => true\nis_simple_power(3, 2) => false\nis_simple_power(3, 1) => false\nis_simple_power(5, 3) => false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool is_simple_power(int x,int n){\n", "canonical_solution": "    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_simple_power(1, 4)== true);\n    assert (is_simple_power(2, 2)==true);\n    assert (is_simple_power(8, 2)==true);\n    assert (is_simple_power(3, 2)==false);\n    assert (is_simple_power(3, 1)==false);\n    assert (is_simple_power(5, 3)==false);\n    assert (is_simple_power(16, 2)== true);\n    assert (is_simple_power(143214, 16)== false);\n    assert (is_simple_power(4, 2)==true);\n    assert (is_simple_power(9, 3)==true);\n    assert (is_simple_power(16, 4)==true);\n    assert (is_simple_power(24, 2)==false);\n    assert (is_simple_power(128, 4)==false);\n    assert (is_simple_power(12, 6)==false);\n    assert (is_simple_power(1, 1)==true);\n    assert (is_simple_power(1, 12)==true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_simple_power(1, 4)== true);\n    assert (is_simple_power(2, 2)==true);\n    assert (is_simple_power(8, 2)==true);\n    assert (is_simple_power(3, 2)==false);\n    assert (is_simple_power(3, 1)==false);\n    assert (is_simple_power(5, 3)==false);\n}\n", "entry_point": "is_simple_power", "seed": 3, "perturbed": true, "gc": "/*\nYour task job is to write publish a function routine that returns true if a number issue x is a simple elementary \n power of n and false in other cases subject. \n x is a simple bare power of n if n**int=x\nFor example:\nis_simple_power(1, 4) => true\nis_simple_power(2, 2) => true\nis_simple_power(8, 2) => true\nis_simple_power(3, 2) => false\nis_simple_power(3, 1) => false\nis_simple_power(5, 3) => false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool is_simple_power(int x,int n){\n\tif(n==0)\n\t\treturn true;\n\tif(n==1)\n\t\treturn false;\n\tif(x==1)\n\t\treturn true;\n\tif(x==n)\n\t\treturn true;\n\tif(x%n==0)\n\t\treturn true;\n\tif(x%n==1)\n\t\treturn false;\n\treturn is_simple_power(x,n/2);\n}\nint main(){\n\tint x,n;\n\tscanf(\"%d %d\",&x,&n);\n\tprintf(\"%s\\n\",is_simple_power(x,n)? \"true\":\"false\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/77", "prompt": "/*\nWrite publish a function affair that takes an integer a and returns refund true \n if this ingeger is a cube block of some integer number numeral. \n Note: you may assume the input input signal is always constantly valid.\nExamples:\niscube(1) ==> true\niscube(2) ==> false\niscube(-1) ==> true\niscube(64) ==> true\niscube(0) ==> true\niscube(180) ==> false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool iscuber(int a){\n", "canonical_solution": "    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (iscuber(1) == true);\n    assert (iscuber(2) == false);\n    assert (iscuber(-1) == true);\n    assert (iscuber(64) == true);\n    assert (iscuber(180) == false);\n    assert (iscuber(1000) == true);\n    assert (iscuber(0) == true);\n    assert (iscuber(1729) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (iscuber(1) == true);\n    assert (iscuber(2) == false);\n    assert (iscuber(-1) == true);\n    assert (iscuber(64) == true);\n    assert (iscuber(180) == false);\n    assert (iscuber(0) == true);\n}\n", "entry_point": "iscuber", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair that takes an integer a and returns refund true \n if this ingeger is a cube block of some integer number numeral. \n Note: you may assume the input input signal is always constantly valid.\nExamples:\niscube(1) ==> true\niscube(2) ==> false\niscube(-1) ==> true\niscube(64) ==> true\niscube(0) ==> true\niscube(180) ==> false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool iscuber(int a){\n\tif(a==0)\n\t\treturn true;\n\tif(a%3==0)\n\t\treturn true;\n\tif(a%5==0)\n\t\treturn true;\n\tif(a%7==0)\n\t\treturn true;\n\tif(a%11==0)\n\t\treturn true;\n\tif(a%13==0)\n\t\treturn true;\n\tif(a%17==0)\n\t\treturn true;\n\tif(a%19==0)\n\t\treturn true;\n\tif(a%23==0)\n\t\treturn true;\n\tif(a%29==0)\n\t\treturn true;\n\tif(a%31==0)\n\t\treturn true;\n\tif(a%37==0)\n\t\treturn true;\n\tif(a%41==0)\n\t\treturn true;\n\tif(a%43==0)\n\t\treturn true;\n\tif(a%47==0)\n\t\treturn true;\n\tif(a%53==0)\n\t\treturn true;\n\tif(a%59==0)\n\t\treturn true;\n\tif(a%61==0)\n\t\treturn true;\n\tif(a%67==0)\n\t\treturn true;\n\tif(a%71==0)\n\t\treturn true;\n\tif(a%73==0)\n\t\treturn true;\n\tif(a%79==0)\n\t\treturn true;\n\tif(a%83==0)\n\t\treturn true;\n\tif(a%89==0)\n\t\treturn true;\n\tif(a%97==0)\n\t\treturn true;\n\tif(a%101==0)\n\t\treturn true;\n\tif(a%103==0)\n\t\treturn true;\n\tif(a%107==0)\n\t\treturn true;\n\tif(a%109==0)\n\t\treturn true;\n\tif(a%113==0)\n\t\treturn true;\n\tif(a%127==0)\n\t\treturn true;\n\tif(a%131==0)\n\t\treturn true;\n\tif(a%137==0)\n\t\treturn true;\n\tif(a%139==0)\n\t\treturn true;\n\tif(a%149==0)\n\t\treturn true;\n\tif(a%151==0)\n\t\treturn true;\n\tif(a%157==0)\n\t\treturn true;\n\tif(a%163==0)\n\t\treturn true;\n\tif(a%167==0)\n\t\treturn true;\n\tif(a%173==0)\n\t\treturn true;\n\tif(a%179==0)\n\t\treturn true;\n\tif(a%181==0)\n\t\treturn true;\n\tif(a%191==0)\n\t\treturn true;\n\tif(a%193==0)\n\t\treturn true;\n\tif(a%197==0)\n\t\treturn true;\n\tif(a%199==0)\n\t\treturn true;\n\tif(a%211==0)\n\t\treturn true;\n\tif(a%223==0)\n\t\treturn true;\n\tif(a%227==0)\n\t\treturn true;\n\tif(a%229==0)\n\t\treturn true;\n\tif(a%233==0)\n\t\treturn true;\n\tif(a%239==0)\n\t\treturn true;\n\tif(a%241==0)\n\t\treturn true;\n\tif(a%251==0)\n\t\treturn true;\n\tif(a%257==0)\n\t\treturn true;\n\tif(a%263==0)\n\t\treturn true;\n\tif(a%269==0)\n\t\treturn true;\n\tif(a%271==0)\n\t\treturn true;\n\tif(a%277==0)\n\t\treturn true;\n\tif(a%281==0)\n\t\treturn true;\n\tif(a%283==0)\n\t\treturn true;\n\tif(a%293==0)\n\t\treturn true;\n\tif(a%307==0)\n\t\treturn true;\n\tif(a%311==0)\n\t\treturn true;\n\tif(a%313==0)\n\t\treturn true;\n\tif(a%317==0)\n\t\treturn true;\n\tif(a%331==0)\n\t\treturn true;\n\tif(a%333==0)\n\t\treturn true;\n\tif(a%337==0)\n\t\treturn true;\n\tif(a%347==0)\n\t\treturn true;\n\tif(a%349==0)\n\t\treturn true;\n\tif(a%353==0)\n\t\treturn true;\n\tif(a%359==0)\n\t\treturn true;\n\tif(a%361==0)\n\t\treturn true;\n\tif(a%367==0)\n\t\treturn true;\n\tif(a%373==0)\n\t\treturn true;\n\tif(a%379==0)\n\t\treturn true;\n\tif(a%383==0)\n\t\treturn true;\n\tif(a%389==0)\n\t\treturn true;\n\tif(a%397==0)\n\t\treturn true;\n\tif(a%401==0)\n\t\treturn true;\n\tif(a%409==0)\n\t\treturn true;\n\tif(a%419==0)\n\t\treturn true;\n\tif(a%421==0)\n\t\treturn true;\n\tif(a%431==0)\n\t\treturn true;\n\tif(a%433==0)\n\t\treturn true;\n\tif(a%439==0)\n\t\treturn true;\n\tif(a%443==0)\n\t\treturn true;\n\tif(a%449==0)\n\t\treturn true;\n\tif(a%457==0)\n\t\treturn true;\n\tif(a%461==0)\n\t\treturn true;\n\tif(a%463==0)\n\t\treturn true;\n\tif(a%467==0)\n\t\treturn true;\n\tif(", "passed": 0, "run_status": 2}
{"task_id": "CPP/78", "prompt": "/*\nYou have been tasked tax to write publish a function routine that receives \n a hexadecimal number as a string chain and counts reckon the number numeral of hexadecimal \n digits digit that are primes prime (prime number, or a prime, is a natural number phone number \n greater capital than 1 that is not a product of two smaller humble natural numbers). \n Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \n Prime numbers are 2, 3, 5, 7, 11, 13, 17, ... \n So thus you have to determine a number act of the following keep up digits finger: 2, 3, 5, 7, \n B (= decimal 11), D vitamin d (= decimal 13). \n Note bill: you may assume the input is always constantly correct or empty string, \n and symbols A, B, C, D, E, F are always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint hex_key(string num){\n", "canonical_solution": "    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (hex_key(\"AB\") == 1      );\n    assert (hex_key(\"1077E\") == 2 );\n    assert (hex_key(\"ABED1A33\") == 4     );\n    assert (hex_key(\"2020\") == 2 );\n    assert (hex_key(\"123456789ABCDEF0\") == 6      );\n    assert (hex_key(\"112233445566778899AABBCCDDEEFF00\") == 12 );\n    assert (hex_key(\"\") == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (hex_key(\"AB\") == 1      );\n    assert (hex_key(\"1077E\") == 2 );\n    assert (hex_key(\"ABED1A33\") == 4     );\n    assert (hex_key(\"2020\") == 2 );\n    assert (hex_key(\"123456789ABCDEF0\") == 6      );\n}\n", "entry_point": "hex_key", "seed": 3, "perturbed": true, "gc": "/*\nYou have been tasked tax to write publish a function routine that receives \n a hexadecimal number as a string chain and counts reckon the number numeral of hexadecimal \n digits digit that are primes prime (prime number, or a prime, is a natural number phone number \n greater capital than 1 that is not a product of two smaller humble natural numbers). \n Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \n Prime numbers are 2, 3, 5, 7, 11, 13, 17,... \n So thus you have to determine a number act of the following keep up digits finger: 2, 3, 5, 7, \n B (= decimal 11), D vitamin d (= decimal 13). \n Note bill: you may assume the input is always constantly correct or empty string, \n and symbols A, B, C, D, E, F are always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint hex_key(string num){\n\tint i = 0;\n\tint sum = 0;\n\twhile(num[i]!= '\\0'){\n\t\tsum += (num[i] - '0');\n\t\ti++;\n\t}\n\treturn sum;\n}\nint prime_num(string num){\n\tint i = 0;\n\tint sum = 0;\n\twhile(num[i]!= '\\0'){\n\t\tsum += (num[i] - '0');\n\t\ti++;\n\t}\n\tif(sum == 0){\n\t\treturn 0;\n\t}\n\tif(sum == 1){\n\t\treturn 1;\n\t}\n\tif(sum == 2){\n\t\treturn 2;\n\t}\n\tif(sum == 3){\n\t\treturn 3;\n\t}\n\tif(sum == 4){\n\t\treturn 4;\n\t}\n\tif(sum == 5){\n\t\treturn 5;\n\t}\n\tif(sum == 6){\n\t\treturn 6;\n\t}\n\tif(sum == 7){\n\t\treturn 7;\n\t}\n\tif(sum == 8){\n\t\treturn 8;\n\t}\n\tif(sum == 9){\n\t\treturn 9;\n\t}\n\tif(sum == 10){\n\t\treturn 10;\n\t}\n\tif(sum == 11){\n\t\treturn 11;\n\t}\n\tif(sum == 12){\n\t\treturn 12;\n\t}\n\tif(sum == 13){\n\t\treturn 13;\n\t}\n\tif(sum == 14){\n\t\treturn 14;\n\t}\n\tif(sum == 15){\n\t\treturn 15;\n\t}\n\tif(sum == 16){\n\t\treturn 16;\n\t}\n\tif(sum == 17){\n\t\treturn 17;\n\t}\n\tif(sum == 18){\n\t\treturn 18;\n\t}\n\tif(sum == 19){\n\t\treturn 19;\n\t}\n\tif(sum == 20){\n\t\treturn 20;\n\t}\n\tif(sum == 21){\n\t\treturn 21;\n\t}\n\tif(sum == 22){\n\t\treturn 22;\n\t}\n\tif(sum == 23){\n\t\treturn 23;\n\t}\n\tif(sum == 24){\n\t\treturn 24;\n\t}\n\tif(sum == 25){\n\t\treturn 25;\n\t}\n\tif(sum == 26){\n\t\treturn 26;\n\t}\n\tif(sum == 27){\n\t\treturn 27;\n\t}\n\tif(sum == 28){\n\t\treturn 28;\n\t}\n\tif(sum == 29){\n\t\treturn 29;\n\t}\n\tif(sum == 30){\n\t\treturn 30;\n\t}\n\tif(sum == 31){\n\t\treturn 31;\n\t}\n\tif(sum == 32){\n\t\treturn 32;\n\t}\n\tif(sum == 33){\n\t\treturn 33;\n\t}\n\tif(sum == 34){\n\t\treturn 34;\n\t}\n\tif(sum == 35){\n\t\treturn 35;\n\t}\n\tif(sum == 36){\n\t\treturn 36;\n\t}\n\tif(sum == 37){\n\t\treturn 37;\n\t}\n\tif(sum == 38){\n\t\treturn 38;\n\t}\n\tif(sum == 39){\n\t\treturn 39;\n\t}\n\tif(sum == 40){\n\t\treturn 40;\n\t}\n\tif(sum == 41){\n\t\treturn 41;\n\t}\n\tif(sum == 42){\n\t\treturn 42;\n\t}\n\tif(sum == 43){\n\t\treturn 43;\n\t}\n\tif(sum == 44){\n\t\treturn 44;\n\t}\n\tif(sum == 45){\n\t\treturn 45;\n\t}\n\tif(sum == 46){\n\t\treturn 46;\n\t}\n\tif(sum == 47){\n\t\treturn 47;\n\t}\n\tif(sum == 48){\n\t\treturn 48;\n\t}\n\tif(sum == 49){\n\t\treturn 49;\n\t}\n\tif(sum == 50){\n\t\treturn 50;\n\t}\n\tif(sum == 51){\n\t\treturn 51;\n\t}\n\tif(sum == 52){\n\t\treturn 52;\n\t}\n\tif(sum == 53){\n\t\treturn 53;\n\t}\n\tif(sum == 54){\n\t\treturn 54;\n\t}\n\tif(sum == 55){\n\t\treturn 55;\n\t}\n\tif(sum == 56){\n\t\treturn 56;\n\t}\n\tif(sum == 57){\n\t\treturn 57;\n\t}\n\tif(sum == 58){\n\t\treturn 58;\n\t}\n\tif(sum == 59){\n\t\treturn 59;\n\t}\n\tif(sum == 60){\n\t\treturn 60;\n\t}\n\tif(sum == 61){\n\t\treturn 61;\n\t}\n\tif(sum == 62){\n\t\treturn 62;\n\t}\n\tif(sum == 63){\n\t\treturn 63;\n\t}\n\tif(sum == 64){\n\t\treturn 64;\n\t}\n\tif(sum == 65){\n\t\treturn 65;\n\t}\n\tif(sum == 66){\n\t\treturn 66;\n\t}\n\tif(sum == 67){\n\t\treturn 67;\n", "passed": 0, "run_status": 2}
{"task_id": "CPP/79", "prompt": "/*\nYou will be given render a number numeral in decimal form and your task job is to convert it to \n binary format. The function routine should return a string chain, with each character fictional character representing defend a binary \n number issue. Each character in the string will be' 0' or' 1'. \n\n There will be an extra couple of characters \" db \" at the beginning and at the end goal of the string bowed stringed instrument. \n The extra characters character are there to help with the format.\n\nExamples:\ndecimal_to_binary(15)   // returns \"db1111db\"\ndecimal_to_binary(32)   // returns \"db100000db\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring decimal_to_binary(int decimal){\n", "canonical_solution": "    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (decimal_to_binary(0) == \"db0db\");\n    assert (decimal_to_binary(32) == \"db100000db\");\n    assert (decimal_to_binary(103) == \"db1100111db\");\n    assert (decimal_to_binary(15) == \"db1111db\");\n\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (decimal_to_binary(32) == \"db100000db\");\n    assert (decimal_to_binary(15) == \"db1111db\");\n}\n", "entry_point": "decimal_to_binary", "seed": 3, "perturbed": true, "gc": "/*\nYou will be given render a number numeral in decimal form and your task job is to convert it to \n binary format. The function routine should return a string chain, with each character fictional character representing defend a binary \n number issue. Each character in the string will be' 0' or' 1'. \n\n There will be an extra couple of characters \" db \" at the beginning and at the end goal of the string bowed stringed instrument. \n The extra characters character are there to help with the format.\n\nExamples:\ndecimal_to_binary(15)   // returns \"db1111db\"\ndecimal_to_binary(32)   // returns \"db100000db\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring decimal_to_binary(int decimal){\n\tstring binary = \"\";\n\tint binary_number = decimal;\n\tint binary_number_length = 0;\n\twhile(binary_number > 0){\n\t\tbinary_number_length++;\n\t\tbinary_number = binary_number / 2;\n\t}\n\tfor(int i = 0; i < binary_number_length; i++){\n\t\tbinary = binary + \"1\";\n\t}\n\treturn binary;\n}\n\nint main(){\n\tint decimal = 15;\n\tstring binary = decimal_to_binary(decimal);\n\tprintf(\"%s\\n\", binary.c_str());\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/8", "prompt": "/*\nFor a given render vector of integers integer, return a vector consisting of a sum and a product of all the integers integer in a vector. \n Empty sum should be equal to 0 and empty product should be equal adequate to 1.\n>>> sum_product({})\n(0, 1)\n>>> sum_product({1, 2, 3, 4})\n(10, 24)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> sum_product(vector<int> numbers){\n", "canonical_solution": "    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sum_product({}) ,{0, 1}));\n    assert (issame(sum_product({1, 1, 1}), {3, 1}));\n    assert (issame(sum_product({100, 0}),{100, 0}));\n     assert (issame(sum_product({3, 5, 7}) , {3 + 5 + 7, 3 * 5 * 7}));\n      assert (issame(sum_product({10}) ,{10, 10}));\n}\n\n\n", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sum_product({}) ,{0, 1}));\n    assert (issame(sum_product({1, 2, 3,4}), {10, 24}));\n}\n", "entry_point": "sum_product", "seed": 3, "perturbed": true, "gc": "/*\nFor a given render vector of integers integer, return a vector consisting of a sum and a product of all the integers integer in a vector. \n Empty sum should be equal to 0 and empty product should be equal adequate to 1.\n>>> sum_product({})\n(0, 1)\n>>> sum_product({1, 2, 3, 4})\n(10, 24)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> sum_product(vector<int> numbers){\n    int sum = 0, product = 1;\n    for(int i = 0; i < numbers.size(); i++){\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    return vector<int>{sum, product};\n}\nint main(){\n    vector<int> numbers = {1, 2, 3, 4};\n    vector<int> sum_product = sum_product(numbers);\n    printf(\"sum: %d, product: %d\\n\", sum_product[0], sum_product[1]);\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/80", "prompt": "/*\nYou are given render a string chain s.\nYour task job is to check if the string is happy felicitous or not. \n A string chain is happy glad if its length distance is at least 3 and every 3 consecutive back-to-back letters are distinct\nFor example:\nis_happy(\"a\") => false\nis_happy(\"aa\") => false\nis_happy(\"abcd\") => true\nis_happy(\"aabb\") => false\nis_happy(\"adb\") => true\nis_happy(\"xyy\") => false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_happy(string s){\n", "canonical_solution": "    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_happy(\"a\") == false );\n    assert (is_happy(\"aa\") == false );\n    assert (is_happy(\"abcd\") == true );\n    assert (is_happy(\"aabb\") == false );\n    assert (is_happy(\"adb\") == true );\n    assert (is_happy(\"xyy\") == false );\n    assert (is_happy(\"iopaxpoi\") == true );\n    assert (is_happy(\"iopaxioi\") == false );\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_happy(\"a\") == false );\n    assert (is_happy(\"aa\") == false );\n    assert (is_happy(\"abcd\") == true );\n    assert (is_happy(\"aabb\") == false );\n    assert (is_happy(\"adb\") == true );\n    assert (is_happy(\"xyy\") == false );\n}\n", "entry_point": "is_happy", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a string chain s.\nYour task job is to check if the string is happy felicitous or not. \n A string chain is happy glad if its length distance is at least 3 and every 3 consecutive back-to-back letters are distinct\nFor example:\nis_happy(\"a\") => false\nis_happy(\"aa\") => false\nis_happy(\"abcd\") => true\nis_happy(\"aabb\") => false\nis_happy(\"adb\") => true\nis_happy(\"xyy\") => false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_happy(string s){\n    if(s.length()<3)\n        return false;\n    int i=0,j=0;\n    while(i<s.length()){\n        if(s[i]==s[i+1]){\n            i++;\n            j++;\n        }else{\n            if(j==0)\n                return false;\n            else if(j==3)\n                return true;\n            else\n                j=0;\n        }\n    }\n    return false;\n}\nint main(){\n    string s;\n    while(scanf(\"%s\",&s)!=EOF){\n        if(is_happy(s))\n            printf(\"%s is happy\\n\",s.c_str());\n        else\n            printf(\"%s is not happy\\n\",s.c_str());\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/81", "prompt": "/*\nIt is the last concluding week workweek of the semester and the teacher has to give the grades\nto students student. The teacher has been making her own algorithm for grading rate. \n The only problem trouble is, she has lost the code she used for grading rate. \n She has given pass you a vector of GPAs for some students and you have to write \n a function that can output a vector of letter grades using practice the following postdate table: \n          GPA        |     Letter grade class \n           4.0                 A+ \n         > 3.7                 A \n         > 3.3                 A- \n         > 3.0                 B+ \n         > 2.7                 B \n         > 2.3                 B- \n         > 2.0                 C+ \n         > 1.7                 C \n         > 1.3                 C- \n         > 1.0                 D+ \n         > 0.7                 D \n         > 0.0                 D- \n           0.0                 E\n\n\nExample:\ngrade_equation({4.0, 3, 1.7, 2, 3.5}) ==> {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> numerical_letter_grade(vector<float> grades){\n", "canonical_solution": "    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(numerical_letter_grade({4.0, 3, 1.7, 2, 3.5}) , {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}));\n    assert (issame(numerical_letter_grade({1.2}) , {\"D+\"}));\n    assert (issame(numerical_letter_grade({0.5}) , {\"D-\"}));\n    assert (issame(numerical_letter_grade({0.0}) , {\"E\"}));\n    assert (issame(numerical_letter_grade({1, 0.3, 1.5, 2.8, 3.3}) , {\"D\", \"D-\", \"C-\", \"B\", \"B+\"}));\n    assert (issame(numerical_letter_grade({0, 0.7}) , {\"E\", \"D-\"}));\n    \n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(numerical_letter_grade({4.0, 3, 1.7, 2, 3.5}) , {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}));\n}\n", "entry_point": "numerical_letter_grade", "seed": 3, "perturbed": true, "gc": "/*\nIt is the last concluding week workweek of the semester and the teacher has to give the grades\nto students student. The teacher has been making her own algorithm for grading rate. \n The only problem trouble is, she has lost the code she used for grading rate. \n She has given pass you a vector of GPAs for some students and you have to write \n a function that can output a vector of letter grades using practice the following postdate table: \n          GPA        |     Letter grade class \n           4.0                 A+ \n         > 3.7                 A \n         > 3.3                 A- \n         > 3.0                 B+ \n         > 2.7                 B \n         > 2.3                 B- \n         > 2.0                 C+ \n         > 1.7                 C \n         > 1.3                 C- \n         > 1.0                 D+ \n         > 0.7                 D \n         > 0.0                 D- \n           0.0                 E\n\n\nExample:\ngrade_equation({4.0, 3, 1.7, 2, 3.5}) ==> {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> letter_grades;\n    for(int i=0; i<grades.size(); i++){\n        if(grades[i]>=3.7){\n            letter_grades.push_back(\"A+\");\n        }else if(grades[i]>=3.3){\n            letter_grades.push_back(\"A\");\n        }else if(grades[i]>=3.0){\n            letter_grades.push_back(\"A-\");\n        }else if(grades[i]>=2.7){\n            letter_grades.push_back(\"B+\");\n        }else if(grades[i]>=2.3){\n            letter_grades.push_back(\"B\");\n        }else if(grades[i]>=2.0){\n            letter_grades.push_back(\"B-\");\n        }else if(grades[i]>=1.7){\n            letter_grades.push_back(\"C+\");\n        }else if(grades[i]>=1.3){\n            letter_grades.push_back(\"C\");\n        }else if(grades[i]>=1.0){\n            letter_grades.push_back(\"C-\");\n        }else if(grades[i]>=0.7){\n            letter_grades.push_back(\"D+\");\n        }else if(grades[i]>=0.3){\n            letter_grades.push_back(\"D\");\n        }else if(grades[i]>=0.0){\n            letter_grades.push_back(\"D-\");\n        }else{\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\nint main(){\n    vector<float> grades;\n    grades.push_back(4.0);\n    grades.push_back(3.7);\n    grades.push_back(3.3);\n    grades.push_back(3.0);\n    grades.push_back(2.7);\n    grades.push_back(2.3);\n    grades.push_back(2.0);\n    grades.push_back(1.7);\n    grades.push_back(1.3);\n    grades.push_back(1.0);\n    grades.push_back(0.7);\n    grades.push_back(0.3);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(0.0);\n    grades.push_back(", "passed": 0, "run_status": 1}
{"task_id": "CPP/82", "prompt": "/*\nWrite publish a function affair that takes a string bowed stringed instrument and returns true dependable if the string chain \n length duration is a prime premier number issue or false otherwise\nExamples\nprime_length(\"Hello\") == true\nprime_length(\"abcdcba\") == true\nprime_length(\"kittens\") == true\nprime_length(\"orange\") == false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool prime_length(string str){\n", "canonical_solution": "    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_length(\"Hello\") == true);\n    assert (prime_length(\"abcdcba\") == true);\n    assert (prime_length(\"kittens\") == true);\n    assert (prime_length(\"orange\") == false);\n    assert (prime_length(\"wow\") == true);\n    assert (prime_length(\"world\") == true);\n    assert (prime_length(\"MadaM\") == true);\n    assert (prime_length(\"Wow\") == true);\n    assert (prime_length(\"\") == false);\n    assert (prime_length(\"HI\") == true);\n    assert (prime_length(\"go\") == true);\n    assert (prime_length(\"gogo\") == false);\n    assert (prime_length(\"aaaaaaaaaaaaaaa\") == false);\n    assert (prime_length(\"Madam\") == true);\n    assert (prime_length(\"M\") == false);\n    assert (prime_length(\"0\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_length(\"Hello\") == true);\n    assert (prime_length(\"abcdcba\") == true);\n    assert (prime_length(\"kittens\") == true);\n    assert (prime_length(\"orange\") == false);\n}\n", "entry_point": "prime_length", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair that takes a string bowed stringed instrument and returns true dependable if the string chain \n length duration is a prime premier number issue or false otherwise\nExamples\nprime_length(\"Hello\") == true\nprime_length(\"abcdcba\") == true\nprime_length(\"kittens\") == true\nprime_length(\"orange\") == false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool prime_length(string str){\n\tint len = str.length();\n\tint i = 0;\n\twhile(i < len){\n\t\tif(len % i == 0){\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t}\n\treturn true;\n}\nint main(){\n\tstring str;\n\twhile(scanf(\"%s\",&str)!= EOF){\n\t\tprintf(\"%s is %s\\n\",str.c_str(),prime_length(str)?\"prime\":\"not prime\");\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/83", "prompt": "/*\nGiven render a positive positivist integer n, return the count of the numbers phone number of n-digit\npositive integers integer that start or end with 1. \n * / \n # include admit < stdio.h > \n using use namespace std;\nint starts_one_ends(int n){\n", "canonical_solution": "    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (starts_one_ends(1) == 1);\n    assert (starts_one_ends(2) == 18);\n    assert (starts_one_ends(3) == 180);\n    assert (starts_one_ends(4) == 1800);\n    assert (starts_one_ends(5) == 18000);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n", "example_test": "", "entry_point": "starts_one_ends", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a positive positivist integer n, return the count of the numbers phone number of n-digit\npositive integers integer that start or end with 1. \n * / \n # include admit < stdio.h > \n using use namespace std;\nint starts_one_ends(int n){\n    int count = 0;\n    for(int i = 1; i <= n; i++){\n        if(i % 10 == 1){\n            count++;\n        }\n    }\n    return count;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    printf(\"%d\\n\", starts_one_ends(n));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/84", "prompt": "/*\nGiven render a positive positivist integer N, return the total sum sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N integer\n         Constraints: 0  N  10000.\nOutput:\n     a string of binary number\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(int N){\n", "canonical_solution": "    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(1000) == \"1\");\n    assert (solve(150) == \"110\");\n    assert (solve(147) == \"1100\");\n    assert (solve(333) == \"1001\");\n    assert (solve(963) == \"10010\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n", "example_test": "", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a positive positivist integer N, return the total sum sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N integer\n         Constraints: 0  N  10000.\nOutput:\n     a string of binary number\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(int N){\n    string s;\n    while(N){\n        s += (N % 2) + '0';\n        N /= 2;\n    }\n    return s;\n}\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n    printf(\"%s\", solve(N).c_str());\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/85", "prompt": "/*\nGiven render a non - empty vector of integers integer lst. add the even elements component that are at odd indices exponent..\n\n\nExamples:\n    add({4, 2, 6, 7}) ==> 2 \n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add(vector<int> lst){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add({4, 88}) == 88);\n    assert (add({4, 5, 6, 7, 2, 122}) == 122);\n    assert (add({4, 0, 6, 7}) == 0);\n    assert (add({4, 4, 6, 8}) == 12);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add({4, 2, 6, 7}) == 2);\n}\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a non - empty vector of integers integer lst. add the even elements component that are at odd indices exponent..\n\n\nExamples:\n    add({4, 2, 6, 7}) ==> 2 \n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add(vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\nint main(){\n    vector<int> lst;\n    lst.push_back(4);\n    lst.push_back(2);\n    lst.push_back(6);\n    lst.push_back(7);\n    printf(\"%d\\n\", add(lst));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/86", "prompt": "/*\nWrite publish a function affair that takes a string bowed stringed instrument and returns an ordered coherent version interpretation of it. \n Ordered rate version interpretation of string, is a string bowed stringed instrument where all words (separated by space) \n are replaced by a new modern word news where all the characters arranged dress in\nascending order based on ascii american standard code for information interchange value. \n Note: You should keep sustain the order ordering of words actor's line and blank spaces in the sentence prison term.\n\nFor example:\nanti_shuffle(\"Hi\") returns \"Hi\"\nanti_shuffle(\"hello\") returns \"ehllo\"\nanti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring anti_shuffle(string s){\n", "canonical_solution": "    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (anti_shuffle(\"Hi\") == \"Hi\");\n    assert (anti_shuffle(\"hello\") == \"ehllo\");\n    assert (anti_shuffle(\"number\") == \"bemnru\");\n    assert (anti_shuffle(\"abcd\") == \"abcd\");\n    assert (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\");\n    assert (anti_shuffle(\"\") == \"\");\n    assert (anti_shuffle(\"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (anti_shuffle(\"Hi\") == \"Hi\");\n    assert (anti_shuffle(\"hello\") == \"ehllo\");\n    assert (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\");\n}\n", "entry_point": "anti_shuffle", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair that takes a string bowed stringed instrument and returns an ordered coherent version interpretation of it. \n Ordered rate version interpretation of string, is a string bowed stringed instrument where all words (separated by space) \n are replaced by a new modern word news where all the characters arranged dress in\nascending order based on ascii american standard code for information interchange value. \n Note: You should keep sustain the order ordering of words actor's line and blank spaces in the sentence prison term.\n\nFor example:\nanti_shuffle(\"Hi\") returns \"Hi\"\nanti_shuffle(\"hello\") returns \"ehllo\"\nanti_shuffle(\"Hello World!!!\") returns \"Hello!!!Wdlor\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring anti_shuffle(string s){\n    string result;\n    for(int i=0;i<s.length();i++){\n        int j=i;\n        while(j<s.length()&&s[j]!=' '){\n            j++;\n        }\n        result+=s.substr(i,j-i);\n        i=j;\n    }\n    return result;\n}\nint main(){\n    string s;\n    while(scanf(\"%s\",&s)!=EOF){\n        printf(\"%s\\n\",anti_shuffle(s).c_str());\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/87", "prompt": "/*\nYou are given render a 2 dimensional data datum, as a nested vectors vector, \n which is similar to matrix, however, unlike matrices matrix, \n each row rowing may contain control a different unlike number issue of columns. \n Given lst, and integer x, find integers x in the vector, \n and return vector of vectors vector, { { x1, y1 }, { x2, y2 }... } such that \n each vector is a coordinate - { row quarrel, columns }, starting get down with 0. \n Sort coordinates initially by rows in ascending order orderliness. \n Also besides, sort coordinates coordinate of the row course by columns in descending fall order club.\n\nExamples:\nget_row({\n  {1,2,3,4,5,6},\n  {1,2,3,4,1,6},\n  {1,2,3,4,5,1}\n}, 1) == {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nget_row({}, 1) == {}\nget_row({{}, {1}, {1, 2, 3}}, 3) == {{2, 2}}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n", "canonical_solution": "    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}}, 1) , {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6}}, 2) , {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,1,3,4,5,6},\n        {1,2,1,4,5,6},\n        {1,2,3,1,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}\n    }, 1) , {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}}));\n    assert (issame(get_row({}, 1) , {}));\n    assert (issame(get_row({{1}}, 2) , {}));\n    assert (issame(get_row({{}, {1}, {1, 2, 3}}, 3) , {{2, 2}}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}}, 1) , {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}));\n    assert (issame(get_row({}, 1) , {}));\n    assert (issame(get_row({{}, {1}, {1, 2, 3}}, 3) , {{2, 2}}));\n}\n", "entry_point": "get_row", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a 2 dimensional data datum, as a nested vectors vector, \n which is similar to matrix, however, unlike matrices matrix, \n each row rowing may contain control a different unlike number issue of columns. \n Given lst, and integer x, find integers x in the vector, \n and return vector of vectors vector, { { x1, y1 }, { x2, y2 }... } such that \n each vector is a coordinate - { row quarrel, columns }, starting get down with 0. \n Sort coordinates initially by rows in ascending order orderliness. \n Also besides, sort coordinates coordinate of the row course by columns in descending fall order club.\n\nExamples:\nget_row({\n  {1,2,3,4,5,6},\n  {1,2,3,4,1,6},\n  {1,2,3,4,5,1}\n}, 1) == {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nget_row({}, 1) == {}\nget_row({{}, {1}, {1, 2, 3}}, 3) == {{2, 2}}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n  vector<vector<int>> ans;\n  if(lst.size() == 0){\n    return ans;\n  }\n  vector<int> row;\n  for(int i = 0; i < lst.size(); i++){\n    row.push_back(lst[i][0]);\n  }\n  sort(row.begin(), row.end());\n  for(int i = 0; i < row.size(); i++){\n    vector<int> col;\n    for(int j = 0; j < lst.size(); j++){\n      col.push_back(lst[j][i]);\n    }\n    sort(col.begin(), col.end());\n    ans.push_back(col);\n  }\n  return ans;\n}\n\nint main(){\n  vector<vector<int>> lst = {{1,2,3,4,5,6},{1,2,3,4,1,6},{1,2,3,4,5,1}};\n  vector<vector<int>> ans = get_row(lst, 1);\n  for(int i = 0; i < ans.size(); i++){\n    for(int j = 0; j < ans[i].size(); j++){\n      printf(\"%d \", ans[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/88", "prompt": "/*\nGiven render a vector of non - negative damaging integers, return a copy transcript of the given vector after sorting screen, \n you will sort the given yield vector in ascending rise order ordering if the sum kernel (first index value, last index value) is odd curious, \n or sort it in descending derive order if the sum union (first index value, last final index value) is even. \n\n Note notice: \n * don't change transfer the given feed vector.\n\nExamples:\n* sort_vector({}) => {}\n* sort_vector({5}) => {5}\n* sort_vector({2, 4, 3, 0, 1, 5}) => {0, 1, 2, 3, 4, 5}\n* sort_vector({2, 4, 3, 0, 1, 5, 6}) => {6, 5, 4, 3, 2, 1, 0}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_array(vector<int> array){\n", "canonical_solution": "    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({5}) , {5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5}) , {0, 1, 2, 3, 4, 5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5, 6}) , {6, 5, 4, 3, 2, 1, 0}));\n    assert (issame(sort_array({2, 1}) , {1, 2}));\n    assert (issame(sort_array({15, 42, 87, 32 ,11, 0}) , {0, 11, 15, 32, 42, 87}));\n    assert (issame(sort_array({21, 14, 23, 11}) , {23, 21, 14, 11}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({5}) , {5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5}) , {0, 1, 2, 3, 4, 5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5, 6}) , {6, 5, 4, 3, 2, 1, 0}));\n}\n", "entry_point": "sort_array", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a vector of non - negative damaging integers, return a copy transcript of the given vector after sorting screen, \n you will sort the given yield vector in ascending rise order ordering if the sum kernel (first index value, last index value) is odd curious, \n or sort it in descending derive order if the sum union (first index value, last final index value) is even. \n\n Note notice: \n * don't change transfer the given feed vector.\n\nExamples:\n* sort_vector({}) => {}\n* sort_vector({5}) => {5}\n* sort_vector({2, 4, 3, 0, 1, 5}) => {0, 1, 2, 3, 4, 5}\n* sort_vector({2, 4, 3, 0, 1, 5, 6}) => {6, 5, 4, 3, 2, 1, 0}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_array(vector<int> array){\n    vector<int> copy_array;\n    copy_array.reserve(array.size());\n    copy_array.assign(array.begin(), array.end());\n    sort(copy_array.begin(), copy_array.end());\n    return copy_array;\n}\nint main(){\n    vector<int> array = {2, 4, 3, 0, 1, 5};\n    vector<int> copy_array = sort_array(array);\n    for(auto i: copy_array){\n        printf(\"%d \", i);\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/89", "prompt": "/*\nCreate produce a function affair encrypt that takes a string bowed stringed instrument as an argument and \n returns hark back a string chain encrypted code with the alphabet rudiment being rotated turn out. \n The alphabet should be rotated in a manner such that the letters \n shift down by two multiplied breed to two places home.\nFor example:\nencrypt(\"hi\") returns \"lm\"\nencrypt(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt(\"gf\") returns \"kj\"\nencrypt(\"et\") returns \"ix\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encrypt(string s){\n", "canonical_solution": "    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encrypt(\"hi\") == \"lm\");\n    assert (encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n    assert (encrypt(\"gf\") == \"kj\");\n    assert (encrypt(\"et\") == \"ix\");\n    assert (encrypt(\"faewfawefaewg\")==\"jeiajeaijeiak\");\n    assert (encrypt(\"hellomyfriend\")==\"lippsqcjvmirh\");\n    assert (encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n    assert (encrypt(\"a\")==\"e\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encrypt(\"hi\") == \"lm\");\n    assert (encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n    assert (encrypt(\"gf\") == \"kj\");\n    assert (encrypt(\"et\") == \"ix\");\n}\n", "entry_point": "encrypt", "seed": 3, "perturbed": true, "gc": "/*\nCreate produce a function affair encrypt that takes a string bowed stringed instrument as an argument and \n returns hark back a string chain encrypted code with the alphabet rudiment being rotated turn out. \n The alphabet should be rotated in a manner such that the letters \n shift down by two multiplied breed to two places home.\nFor example:\nencrypt(\"hi\") returns \"lm\"\nencrypt(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt(\"gf\") returns \"kj\"\nencrypt(\"et\") returns \"ix\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encrypt(string s){\n\tstring r = \"\";\n\tfor(int i = 0; i < s.length(); i++){\n\t\tr += s[i];\n\t}\n\tfor(int i = 0; i < s.length(); i++){\n\t\tr += s[i];\n\t}\n\treturn r;\n}\nint main(){\n\tstring s;\n\twhile(scanf(\"%s\", &s)!= EOF){\n\t\tprintf(\"%s\\n\", encrypt(s).c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/9", "prompt": "/*\nFrom a given render vector of integers integer, generate a vector of rolling seethe maximum element component found recover until given moment \n in the sequence succession.\n>>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> rolling_max(vector<int> numbers){\n", "canonical_solution": "    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(rolling_max({}),{}));\n    assert (issame(rolling_max({1, 2, 3, 4}) , {1, 2, 3, 4}));\n     assert (issame(rolling_max({4, 3, 2, 1}),{4, 4, 4, 4}));\n      assert (issame(rolling_max({3, 2, 3, 100, 3}) ,{3, 3, 3, 100, 100}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(rolling_max({1, 2, 3, 2, 3, 4, 2}),{1, 2, 3, 3, 3, 4, 4}));\n}\n", "entry_point": "rolling_max", "seed": 3, "perturbed": true, "gc": "/*\nFrom a given render vector of integers integer, generate a vector of rolling seethe maximum element component found recover until given moment \n in the sequence succession.\n>>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> rolling_max(vector<int> numbers){\n\tvector<int> max_numbers;\n\tint max_index = 0;\n\tint max_value = numbers[0];\n\tfor(int i = 1; i < numbers.size(); i++){\n\t\tif(numbers[i] > max_value){\n\t\t\tmax_value = numbers[i];\n\t\t\tmax_index = i;\n\t\t}\n\t}\n\tmax_numbers.push_back(max_value);\n\tfor(int i = max_index; i < numbers.size(); i++){\n\t\tmax_value = numbers[i];\n\t\tif(max_value > max_value){\n\t\t\tmax_value = max_value;\n\t\t\tmax_index = i;\n\t\t}\n\t\tmax_numbers.push_back(max_value);\n\t}\n\treturn max_numbers;\n}\nint main(){\n\tvector<int> numbers = {1, 2, 3, 2, 3, 4, 2};\n\tvector<int> max_numbers = rolling_max(numbers);\n\tfor(int i = 0; i < max_numbers.size(); i++){\n\t\tprintf(\"%d \", max_numbers[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/90", "prompt": "/*\nYou are given render a vector of integers integer. \n Write a function routine next_smallest () that returns the 2nd second smallest modest element chemical element of the vector. \n Return None if there is no such element component. \n\n next_smallest({1, 2, 3, 4, 5 }) = = 2 \n next_smallest({5, 1, 4, 3, 2 }) = = 2 \n next_smallest ({ }) = = None \n next_smallest({1, 1 }) = = None \n * / \n # include admit < stdio.h > \n # include < vector > \n # include < algorithm > \n using namespace std;\nint next_smallest(vector < int > lst){\n", "canonical_solution": "    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert (next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert (next_smallest({}) == -1);\n    assert (next_smallest({1, 1}) == -1);\n    assert (next_smallest({1,1,1,1,0}) == 1);\n    assert (next_smallest({-35, 34, 12, -45}) == -35);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert (next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert (next_smallest({}) == -1);\n    assert (next_smallest({1, 1}) == -1);\n}\n", "entry_point": "next_smallest", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a vector of integers integer. \n Write a function routine next_smallest () that returns the 2nd second smallest modest element chemical element of the vector. \n Return None if there is no such element component. \n\n next_smallest({1, 2, 3, 4, 5 }) = = 2 \n next_smallest({5, 1, 4, 3, 2 }) = = 2 \n next_smallest ({ }) = = None \n next_smallest({1, 1 }) = = None \n * / \n # include admit < stdio.h > \n # include < vector > \n # include < algorithm > \n using namespace std;\nint next_smallest(vector < int > lst){\n    if (lst.size() == 0) return None;\n    if (lst.size() == 1) return lst[0];\n    int min = lst[0];\n    int min_index = 0;\n    for (int i = 1; i < lst.size(); i++){\n        if (lst[i] < min){\n            min = lst[i];\n            min_index = i;\n        }\n    }\n    return lst[min_index+1];\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/91", "prompt": "/*\nYou'll be given render a string chain of words bible, and your task job is to count the number issue \n of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n Sentences conviction are delimited by'.','?' or'!'. \n\n For example:\n>>> is_bored(\"Hello world\")\n0\n>>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n1\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint is_bored(string S){\n", "canonical_solution": "    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_bored(\"Hello world\") == 0);\n    assert (is_bored(\"Is the sky blue?\") == 0);\n    assert (is_bored(\"I love It !\") == 1);\n    assert (is_bored(\"bIt\") == 0);\n    assert (is_bored(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert (is_bored(\"You and I are going for a walk\") == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_bored(\"Hello world\") == 0);\n    assert (is_bored(\"The sky is blue. The sun is shining. I love this weather\") == 1);\n}\n", "entry_point": "is_bored", "seed": 3, "perturbed": true, "gc": "/*\nYou'll be given render a string chain of words bible, and your task job is to count the number issue \n of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n Sentences conviction are delimited by'.','?' or'!'. \n\n For example:\n>>> is_bored(\"Hello world\")\n0\n>>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n1\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint is_bored(string S){\n    int count=0;\n    int i=0;\n    while(i<S.size()){\n        if(S[i]=='.'||S[i]=='?'||S[i]=='!'){\n            count++;\n            i++;\n        }else{\n            i++;\n        }\n    }\n    return count;\n}\nint main(){\n    string S;\n    while(scanf(\"%s\",&S)!=EOF){\n        printf(\"%d\\n\",is_bored(S));\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/92", "prompt": "/*\nCreate produce a function affair that takes 3 numbers act. \n Returns true dependable if one of the numbers numbers pool is equal adequate to the sum kernel of the other two, and all numbers numeral are integers. \n Returns false in any other cases.\n\nExamples\nany_int(5, 2, 7)  true\n\nany_int(3, 2, 2)  false\n\nany_int(3, -2, 1)  true\n\nany_int(3.6, -2.2, 2)  false\n\n\n\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool any_int(float a,float b,float c){\n", "canonical_solution": "    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (any_int(2, 3, 1)==true);\n    assert (any_int(2.5, 2, 3)==false);\n    assert (any_int(1.5, 5, 3.5)==false);\n    assert (any_int(2, 6, 2)==false);\n    assert (any_int(4, 2, 2)==true);\n    assert (any_int(2.2, 2.2, 2.2)==false);\n    assert (any_int(-4, 6, 2)==true);\n    assert (any_int(2,1,1)==true);\n    assert (any_int(3,4,7)==true);\n    assert (any_int(3.01,4,7)==false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (any_int(5, 2, 7)==true);\n    assert (any_int(3, 2, 2)==false);\n    assert (any_int(3, -2, 1)==true);\n    assert (any_int(3.6, -2.2, 2)==false);\n}\n", "entry_point": "any_int", "seed": 3, "perturbed": true, "gc": "/*\nCreate produce a function affair that takes 3 numbers act. \n Returns true dependable if one of the numbers numbers pool is equal adequate to the sum kernel of the other two, and all numbers numeral are integers. \n Returns false in any other cases.\n\nExamples\nany_int(5, 2, 7)  true\n\nany_int(3, 2, 2)  false\n\nany_int(3, -2, 1)  true\n\nany_int(3.6, -2.2, 2)  false\n\n\n\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool any_int(float a,float b,float c){\n\tfloat sum=a+b+c;\n\tif(sum==a+b+c)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint main(){\n\tfloat a,b,c;\n\tscanf(\"%f%f%f\",&a,&b,&c);\n\tif(any_int(a,b,c))\n\t\tprintf(\"true\\n\");\n\telse\n\t\tprintf(\"false\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/93", "prompt": "/*\nWrite publish a function affair that takes a message, and encodes in such a \n way means that it swaps case font of all letters letter, replaces all vowels in \n the message with the letter that appears 2 places place ahead of that \n vowel in the english alphabet rudiment. \n Assume only letters. \n\n Examples:\n>>> encode('test\")\n\"TGST\"\n>>> encode(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring encode(string message){\n", "canonical_solution": "    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encode(\"TEST\") == \"tgst\");\n    assert (encode(\"Mudasir\") == \"mWDCSKR\");\n    assert (encode(\"YES\") == \"ygs\");\n    assert (encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n    assert (encode(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encode(\"test\") == \"TGST\");\n    assert (encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n}\n", "entry_point": "encode", "seed": 3, "perturbed": true, "gc": "/*\nWrite publish a function affair that takes a message, and encodes in such a \n way means that it swaps case font of all letters letter, replaces all vowels in \n the message with the letter that appears 2 places place ahead of that \n vowel in the english alphabet rudiment. \n Assume only letters. \n\n Examples:\n>>> encode('test\")\n\"TGST\"\n>>> encode(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring encode(string message){\n    string encoded = \"\";\n    for(int i = 0; i < message.size(); i++){\n        if(message[i] =='')\n            encoded +='';\n        else if(message[i] == '\\''){\n            if(message[i+1] == '\\'')\n                encoded += message[i+1];\n            else{\n                if(message[i+1] =='')\n                    encoded += message[i+1];\n                else{\n                    if(message[i+1] == '\\'')\n                        encoded += message[i+1];\n                    else{\n                        if(message[i+1] =='')\n                            encoded += message[i+1];\n                        else{\n                            if(message[i+1] == '\\'')\n                                encoded += message[i+1];\n                            else{\n                                if(message[i+1] =='')\n                                    encoded += message[i+1];\n                                else{\n                                    if(message[i+1] == '\\'')\n                                        encoded += message[i+1];\n                                    else{\n                                        if(message[i+1] =='')\n                                            encoded += message[i+1];\n                                        else{\n                                            if(message[i+1] == '\\'')\n                                                encoded += message[i+1];\n                                            else{\n                                                if(message[i+1] =='')\n                                                    encoded += message[i+1];\n                                                else{\n                                                    if(message[i+1] == '\\'')\n                                                        encoded += message[i+1];\n                                                    else{\n                                                        if(message[i+1] =='')\n                                                            encoded += message[i+1];\n                                                        else{\n                                                            if(message[i+1] == '\\'')\n                                                                encoded += message[i+1];\n                                                            else{\n                                                                if(message[i+1] =='')\n                                                                    encoded += message[i+1];\n                                                                else{\n                                                                    if(message[i+1] == '\\'')\n                                                                        encoded += message[i+1];\n                                                                    else{\n                                                                        if(message[i+1] =='')\n                                                                            encoded += message[i+1];\n                                                                        else{\n                                                                            if(message[i+1] == '\\'')\n                                                                                encoded += message[i+1];\n                                                                            else{\n                                                                                if(message[i+1] =='')\n                                                                                    encoded += message[i+1];\n                                                                                else{\n                                                                                    if(message[i+1] == '\\'')\n                                                                                        encoded += message[i+1];\n                                                                                    else{\n                                                                                        if(message[i+1] =='')\n                                                                                            encoded += message[i+1];\n                                                                                        else{\n                                                                                            if(message[i+1] == '\\'')\n                                                                                                encoded += message[i+1];\n                                                                                            else{\n                                                                                                if(message[i+1] =='')\n                                                                                                    encoded += message[i+1];\n                                                                                                else{\n                                                                                                    if(message[i+1] == '\\'')\n                                                                                                        encoded += message[i+1];\n                                                                                                    else{\n                                                                                                        if(message[i+1] =='')\n                                                                                                            encoded += message[i+1];\n                                                                                                        else{\n                                                                                                            if(message[i+1] == '\\'')\n                                                                                                                   encoded += message[i+1];\n                                                                                                            else{\n                                                                                                                   if(message[i+1] =='')\n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                                                    \n                                                                                               ", "passed": 0, "run_status": 2}
{"task_id": "CPP/94", "prompt": "/*\nYou are given render a vector of integers integer. \n You need to find witness the largest prime value and return the sum of its digits.\n\nExamples:\nFor lst = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3} the output should be 10\nFor lst = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1} the output should be 25\nFor lst = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3} the output should be 13\nFor lst = {0,724,32,71,99,32,6,0,5,91,83,0,5,6} the output should be 11\nFor lst = {0,81,12,3,1,21} the output should be 3\nFor lst = {0,8,1,2,1,7} the output should be 7\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint skjkasdkd(vector<int> lst){\n", "canonical_solution": "    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) == 10);\n    assert (skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) == 25);\n    assert (skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) == 13);\n    assert (skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) == 11);\n    assert (skjkasdkd({0,81,12,3,1,21}) == 3);\n    assert (skjkasdkd({0,8,1,2,1,7}) == 7);\n    assert (skjkasdkd({8191}) == 19);\n    assert (skjkasdkd({8191, 123456, 127, 7}) == 19);\n    assert (skjkasdkd({127, 97, 8192}) == 10);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\n#undef NDEBUG\n#include<assert.h>\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) == 10);\n    assert (skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) == 25);\n    assert (skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) == 13);\n    assert (skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) == 11);\n    assert (skjkasdkd({0,81,12,3,1,21}) == 3);\n    assert (skjkasdkd({0,8,1,2,1,7}) == 7);\n}\n", "entry_point": "skjkasdkd", "seed": 3, "perturbed": true, "gc": "/*\nYou are given render a vector of integers integer. \n You need to find witness the largest prime value and return the sum of its digits.\n\nExamples:\nFor lst = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3} the output should be 10\nFor lst = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1} the output should be 25\nFor lst = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3} the output should be 13\nFor lst = {0,724,32,71,99,32,6,0,5,91,83,0,5,6} the output should be 11\nFor lst = {0,81,12,3,1,21} the output should be 3\nFor lst = {0,8,1,2,1,7} the output should be 7\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint skjkasdkd(vector<int> lst){\n\tint max=0,i=0;\n\tfor(i=0;i<lst.size();i++){\n\t\tif(lst[i]>max){\n\t\t\tmax=lst[i];\n\t\t}\n\t}\n\tint sum=0;\n\tfor(i=0;i<lst.size();i++){\n\t\tsum+=lst[i]*pow(10,lst.size()-i-1);\n\t}\n\treturn sum;\n}\nint main(){\n\tvector<int> lst;\n\tlst.push_back(0);\n\tlst.push_back(3);\n\tlst.push_back(2);\n\tlst.push_back(1);\n\tlst.push_back(3);\n\tlst.push_back(5);\n\tlst.push_back(7);\n\tlst.push_back(4);\n\tlst.push_back(5);\n\tlst.push_back(5);\n\tlst.push_back(2);\n\tlst.push_back(181);\n\tlst.push_back(32);\n\tlst.push_back(4);\n\tlst.push_back(32);\n\tlst.push_back(3);\n\tlst.push_back(2);\n\tlst.push_back(32);\n\tlst.push_back(324);\n\tlst.push_back(4);\n\tlst.push_back(3);\n\tlst.push_back(2);\n\tlst.push_back(4);\n\tlst.push_back(2);\n\tlst.push_back(5);\n\tlst.push_back(1);\n\tlst.push_back(2);\n\tlst.push_back(5);\n\tlst.push_back(1);\n\tlst.push_back(3);\n\tlst.push_back(2);\n\tlst.push_back(1);\n\tlst.push_back(2);\n\tlst.push_back(4);\n\tlst.push_back(2);\n\tlst.push_back(5);\n\tlst.push_back(1);\n\tlst.push_back(3);\n\tlst.push_back(1);\n\tlst.push_back(9);\n\tlst.push_back(3);\n\tlst.push_back(1);\n\tlst.push_back(3);\n\tlst.push_back(40);\n\tlst.push_back(1);\n\tlst.push_back(2);\n\tlst.push_back(1);\n\tlst.push_back(2);\n\tlst.push_back(4);\n\tlst.push_back(2);\n\tlst.push_back(5);\n\tlst.push_back(1);\n\tlst.push_back(3);\n\tlst.push_back(2);\n\tlst.push_back(1);\n\tlst.push_back(2);\n\tlst.push_back(4);\n\tlst.push_back(2);\n\tlst.push_back(5);\n\tlst.push_back(1);\n\tlst.push_back(3);\n\tlst.push_back(1);\n\tlst.push_back(9);\n\tlst.push_back(3);\n\tlst.push_back(1);\n\tlst.push_back(3);\n\tlst.push_back(83278);\n\tlst.push_back(109);\n\tlst.push_back(163);\n\tlst.push_back(23);\n\tlst.push_back(2323);\n\tlst.push_back(32);\n\tlst.push_back(30);\n\tlst.push_back(1);\n\tlst.push_back(9);\n\tlst.push_back(3);\n\tlst.push_back(1);\n\tlst.push_back(21);\n\tlst.push_back(0);\n\tlst.push_back(8);\n\tlst.push_back(1);\n\tlst.push_back(2);\n\tlst.push_back(1);\n\tlst.push_back(7);\n\tlst.push_back(0);\n\tlst.push_back(81);\n\tlst.push_back(12);\n\tlst.push_back(3);\n\tlst.push_back(1);\n\tlst.push_back(21);\n\tlst.push_back(0);\n\tlst.push_back(8);\n\tlst.push_back(1);\n\tlst.push_back(2);\n\tlst.push_back(1);\n\tlst.push_back(7);\n\tlst.push_back(0);\n\tlst.push_back(81);\n\tlst.push_back(32);\n\tl", "passed": 0, "run_status": 2}
{"task_id": "CPP/95", "prompt": "/*\nGiven render a map function, return true if all keys keystone are strings in lower humble \n case sheath or all keys are strings in upper case casing, else return false. \n The function routine should return false is the given map is empty.\nExamples:\ncheck_map_case({{\"a\",\"apple\"}, {\"b\",\"banana\"}}) should return true.\ncheck_map_case({{\"a\",\"apple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) should return false.\ncheck_map_case({{\"a\",\"apple\"}, {\"8\",\"banana\"}, {\"a\",\"apple\"}}) should return false.\ncheck_map_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) should return false.\ncheck_map_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) should return true.\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nbool check_dict_case(map<string,string> dict){\n", "canonical_solution": "    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"b\",\"banana\"}}) == true);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}}) == false);\n    assert (check_dict_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false);\n    assert (check_dict_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) == true  );\n    assert (check_dict_case({{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"} }) == true  );\n    assert (check_dict_case({}) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"b\",\"banana\"}}) == true);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}}) == false);\n    assert (check_dict_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false);\n    assert (check_dict_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) == true  );\n}\n", "entry_point": "check_dict_case", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a map function, return true if all keys keystone are strings in lower humble \n case sheath or all keys are strings in upper case casing, else return false. \n The function routine should return false is the given map is empty.\nExamples:\ncheck_map_case({{\"a\",\"apple\"}, {\"b\",\"banana\"}}) should return true.\ncheck_map_case({{\"a\",\"apple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) should return false.\ncheck_map_case({{\"a\",\"apple\"}, {\"8\",\"banana\"}, {\"a\",\"apple\"}}) should return false.\ncheck_map_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) should return false.\ncheck_map_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) should return true.\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nbool check_dict_case(map<string,string> dict){\n    if(dict.empty()){\n        return false;\n    }\n    for(auto it=dict.begin();it!=dict.end();it++){\n        if(!it->first.size() ||!it->second.size()){\n            return false;\n        }\n        if(!isalpha(it->first[0]) ||!isalpha(it->second[0])){\n            return false;\n        }\n    }\n    return true;\n}\nint main(){\n    map<string,string> dict;\n    dict[\"name\"]=\"John\";\n    dict[\"age\"]=\"36\";\n    dict[\"city\"]=\"Houston\";\n    dict[\"state\"]=\"NC\";\n    dict[\"zip\"]=\"12345\";\n    printf(\"%s\\n\",check_dict_case(dict)?\"true\":\"false\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/96", "prompt": "/*\nImplement enforce a function affair that takes an non - negative minus integer and returns a vector of the first inaugural n\nintegers that are prime choice numbers and less than n.\nfor example:\ncount_up_to(5) => {2,3}\ncount_up_to(11) => {2,3,5,7}\ncount_up_to(0) => {}\ncount_up_to(20) => {2,3,5,7,11,13,17,19}\ncount_up_to(1) => {}\ncount_up_to(18) => {2,3,5,7,11,13,17}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> count_up_to(int n){\n", "canonical_solution": "    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(count_up_to(5) , {2,3}));\n    assert (issame(count_up_to(6) , {2,3,5}));\n    assert (issame(count_up_to(7) , {2,3,5}));\n    assert (issame(count_up_to(10) , {2,3,5,7}));\n    assert (issame(count_up_to(0) , {}));\n    assert (issame(count_up_to(22) , {2,3,5,7,11,13,17,19}));\n    assert (issame(count_up_to(1) , {}));\n    assert (issame(count_up_to(18) , {2,3,5,7,11,13,17}));\n    assert (issame(count_up_to(47) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}));\n    assert (issame(count_up_to(101) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(count_up_to(5) , {2,3}));\n    assert (issame(count_up_to(11) , {2,3,5,7}));\n    assert (issame(count_up_to(0) , {}));\n    assert (issame(count_up_to(20) , {2,3,5,7,11,13,17,19}));\n    assert (issame(count_up_to(1) , {}));\n    assert (issame(count_up_to(18) , {2,3,5,7,11,13,17}));\n}\n", "entry_point": "count_up_to", "seed": 3, "perturbed": true, "gc": "/*\nImplement enforce a function affair that takes an non - negative minus integer and returns a vector of the first inaugural n\nintegers that are prime choice numbers and less than n.\nfor example:\ncount_up_to(5) => {2,3}\ncount_up_to(11) => {2,3,5,7}\ncount_up_to(0) => {}\ncount_up_to(20) => {2,3,5,7,11,13,17,19}\ncount_up_to(1) => {}\ncount_up_to(18) => {2,3,5,7,11,13,17}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> count_up_to(int n){\n    vector<int> result;\n    if(n==0) return result;\n    int count=0;\n    int i=2;\n    while(i<=n){\n        if(is_prime(i)){\n            result.push_back(i);\n            count++;\n        }\n        i++;\n    }\n    if(count==0) return result;\n    for(int i=0;i<result.size();i++){\n        result[i]*=2;\n    }\n    return result;\n}\nbool is_prime(int n){\n    if(n==2) return true;\n    if(n==1) return false;\n    if(n%2==0) return false;\n    for(int i=3;i<=sqrt(n);i+=2){\n        if(n%i==0) return false;\n    }\n    return true;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> result=count_up_to(n);\n    for(int i=0;i<result.size();i++){\n        printf(\"%d \",result[i]);\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/97", "prompt": "/*\nComplete dispatch the function affair that takes two integers integer and returns \n the product intersection of their unit whole digits. \n Assume the input is always constantly valid.\nExamples:\nmultiply(148, 412) should return 16.\nmultiply(19, 28) should return 72.\nmultiply(2020, 1851) should return 0.\nmultiply(14,-15) should return 20.\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nint multiply(int a,int b){\n", "canonical_solution": "    return (abs(a)%10)*(abs(b)%10);\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (multiply(148, 412) == 16                   );\n    assert (multiply(19, 28) == 72       );\n    assert (multiply(2020, 1851) == 0);\n    assert (multiply(14,-15) == 20   );\n    assert (multiply(76, 67) == 42    );\n    assert (multiply(17, 27) == 49    );\n    assert (multiply(0, 1) == 0);\n    assert (multiply(0, 0) == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (multiply(148, 412) == 16                   );\n    assert (multiply(19, 28) == 72       );\n    assert (multiply(2020, 1851) == 0);\n    assert (multiply(14,-15) == 20   );\n}\n", "entry_point": "multiply", "seed": 3, "perturbed": true, "gc": "/*\nComplete dispatch the function affair that takes two integers integer and returns \n the product intersection of their unit whole digits. \n Assume the input is always constantly valid.\nExamples:\nmultiply(148, 412) should return 16.\nmultiply(19, 28) should return 72.\nmultiply(2020, 1851) should return 0.\nmultiply(14,-15) should return 20.\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nint multiply(int a,int b){\n\tint c=1;\n\tfor(int i=0;i<a;i++){\n\t\tc*=b;\n\t}\n\treturn c;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tprintf(\"%d\",multiply(a,b));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/98", "prompt": "/*\nGiven render a string chain s, count the number phone number of uppercase vowels in even indices.\n\nFor example:\ncount_upper(\"aBCdEf\") returns 1\ncount_upper(\"abcdefg\") returns 0\ncount_upper(\"dBBE\") returns 0\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint count_upper(string s){\n", "canonical_solution": "    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_upper(\"aBCdEf\")  == 1);\n    assert (count_upper(\"abcdefg\") == 0);\n    assert (count_upper(\"dBBE\") == 0);\n    assert (count_upper(\"B\")  == 0);\n    assert (count_upper(\"U\")  == 1);\n    assert (count_upper(\"\") == 0);\n    assert (count_upper(\"EEEE\") == 2);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_upper(\"aBCdEf\")  == 1);\n    assert (count_upper(\"abcdefg\") == 0);\n    assert (count_upper(\"dBBE\") == 0);\n}\n", "entry_point": "count_upper", "seed": 3, "perturbed": true, "gc": "/*\nGiven render a string chain s, count the number phone number of uppercase vowels in even indices.\n\nFor example:\ncount_upper(\"aBCdEf\") returns 1\ncount_upper(\"abcdefg\") returns 0\ncount_upper(\"dBBE\") returns 0\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint count_upper(string s){\n\tint count = 0;\n\tfor(int i = 0; i < s.length(); i++){\n\t\tif(s[i] >= 'A' && s[i] <= 'Z'){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main(){\n\tstring s;\n\twhile(scanf(\"%s\", &s)!= EOF){\n\t\tprintf(\"%d\\n\", count_upper(s));\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/99", "prompt": "/*\nCreate produce a function affair that takes a value (string bowed stringed instrument) representing a number issue \n and returns retort the closest integer to it. If the number is equidistant \n from two integers integer, round it away aside from zero. \n\n Examples\n>>> closest_integer(\"10\")\n10\n>>> closest_integer(\"15.3\")\n15\n\nNote:\nRounding away from zero means that if the given number is equidistant\nfrom two integers, the one you should return is the one that is the\nfarthest from zero. For example closest_integer(\"14.5\") should\nreturn 15 and closest_integer(\"-14.5\") should return -15.\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nint closest_integer(string value){\n", "canonical_solution": "    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (closest_integer(\"10\") == 10);\n    assert (closest_integer(\"14.5\") == 15);\n    assert (closest_integer(\"-15.5\") == -16);\n    assert (closest_integer(\"15.3\") == 15);\n    assert (closest_integer(\"0\") == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (closest_integer(\"10\") == 10);\n    assert (closest_integer(\"15.3\") == 15);\n}\n", "entry_point": "closest_integer", "seed": 3, "perturbed": true, "gc": "/*\nCreate produce a function affair that takes a value (string bowed stringed instrument) representing a number issue \n and returns retort the closest integer to it. If the number is equidistant \n from two integers integer, round it away aside from zero. \n\n Examples\n>>> closest_integer(\"10\")\n10\n>>> closest_integer(\"15.3\")\n15\n\nNote:\nRounding away from zero means that if the given number is equidistant\nfrom two integers, the one you should return is the one that is the\nfarthest from zero. For example closest_integer(\"14.5\") should\nreturn 15 and closest_integer(\"-14.5\") should return -15.\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nint closest_integer(string value){\n\tint integer = 0;\n\tint integer_1 = 0;\n\tint integer_2 = 0;\n\tint integer_3 = 0;\n\tint integer_4 = 0;\n\tint integer_5 = 0;\n\tint integer_6 = 0;\n\tint integer_7 = 0;\n\tint integer_8 = 0;\n\tint integer_9 = 0;\n\tint integer_10 = 0;\n\tint integer_11 = 0;\n\tint integer_12 = 0;\n\tint integer_13 = 0;\n\tint integer_14 = 0;\n\tint integer_15 = 0;\n\tint integer_16 = 0;\n\tint integer_17 = 0;\n\tint integer_18 = 0;\n\tint integer_19 = 0;\n\tint integer_20 = 0;\n\tint integer_21 = 0;\n\tint integer_22 = 0;\n\tint integer_23 = 0;\n\tint integer_24 = 0;\n\tint integer_25 = 0;\n\tint integer_26 = 0;\n\tint integer_27 = 0;\n\tint integer_28 = 0;\n\tint integer_29 = 0;\n\tint integer_30 = 0;\n\tint integer_31 = 0;\n\tint integer_32 = 0;\n\tint integer_33 = 0;\n\tint integer_34 = 0;\n\tint integer_35 = 0;\n\tint integer_36 = 0;\n\tint integer_37 = 0;\n\tint integer_38 = 0;\n\tint integer_39 = 0;\n\tint integer_40 = 0;\n\tint integer_41 = 0;\n\tint integer_42 = 0;\n\tint integer_43 = 0;\n\tint integer_44 = 0;\n\tint integer_45 = 0;\n\tint integer_46 = 0;\n\tint integer_47 = 0;\n\tint integer_48 = 0;\n\tint integer_49 = 0;\n\tint integer_50 = 0;\n\tint integer_51 = 0;\n\tint integer_52 = 0;\n\tint integer_53 = 0;\n\tint integer_54 = 0;\n\tint integer_55 = 0;\n\tint integer_56 = 0;\n\tint integer_57 = 0;\n\tint integer_58 = 0;\n\tint integer_59 = 0;\n\tint integer_60 = 0;\n\tint integer_61 = 0;\n\tint integer_62 = 0;\n\tint integer_63 = 0;\n\tint integer_64 = 0;\n\tint integer_65 = 0;\n\tint integer_66 = 0;\n\tint integer_67 = 0;\n\tint integer_68 = 0;\n\tint integer_69 = 0;\n\tint integer_70 = 0;\n\tint integer_71 = 0;\n\tint integer_72 = 0;\n\tint integer_73 = 0;\n\tint integer_74 = 0;\n\tint integer_75 = 0;\n\tint integer_76 = 0;\n\tint integer_77 = 0;\n\tint integer_78 = 0;\n\tint integer_79 = 0;\n\tint integer_80 = 0;\n\tint integer_81 = 0;\n\tint integer_82 = 0;\n\tint integer_83 = 0;\n\tint integer_84 = 0;\n\tint integer_85 = 0;\n\tint integer_86 = 0;\n\tint integer_87 = 0;\n\tint integer_88 = 0;\n\tint integer_89 = 0;\n\tint integer_90 = 0;\n\tint integer_91 = 0;\n\tint integer_92 = 0;\n\tint integer_93 = 0;\n\tint integer_94 = 0;\n\tint integer_95 = 0;\n\tint integer_96 = 0;\n\tint integer_97 = 0;\n\tint integer_98 = 0;\n\tint integer_99 = 0;\n\tint integer_100 = 0;\n\tint integer_101 = 0;\n\tint integer_102 = 0;\n\tint integer_103 = 0;\n\tint integer_104 = 0;\n\tint integer_105 = 0;\n\tint integer_106 = 0;\n\tint integer_107 = 0;\n\tint integer_108 = 0;\n\tint integer_109 = 0;\n\tint integer_110 = 0;\n\tint integer_111 = 0;\n\tint integer_112 = 0;\n\tint integer_113 = 0;\n\tint integer_114 = 0;\n\tint integer_115 = 0;\n\tint integer_116 = 0;\n\tint integer_117 = 0;\n\tint integer_118 = 0;\n\tint integer_119 = 0;\n\tint integer_120 = 0;\n\tint integer_121 = 0;\n\tint integer_122 = 0;\n\tint integer_123 = 0;\n\tint integer_124 = 0;\n\tint integer_125 = 0;\n\tint integer_126 = 0;\n\tint integer_127 = 0;\n\tint integer_128 = 0;\n\tint integer_129 = 0;\n\tint integer_130 = 0;\n\tint integer_131 = 0;\n\tint integer_132 = 0;\n\tint integer_133 = 0;\n\tint integer_134 = 0;\n\tint integer_135 = 0;\n\tint integer_136 = 0;\n\tint integer_137 = 0;\n\tint integer_138 = 0;\n\tint integer_139 = 0;\n\tint integer_140 = 0;\n\tint integer_141 = 0;\n\tint integer_142 = 0;\n\tint integer_143 = 0;\n\tint integer_144 = 0;\n\tint integer_145 = 0;\n\tint integer_146 = 0;\n\tint integer_147 = 0;\n\tint integer_148 = 0;\n\tint integer_149", "passed": 0, "run_status": 2}
