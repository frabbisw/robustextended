{"task_id": "JavaScript/0", "prompt": "/* crack if in given list of numbers, are any two numbers closer to each early than \n   give threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 2, "perturbed": true, "gc": "/* crack if in given list of numbers, are any two numbers closer to each early than \n   give threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const min = sortedNumbers[0];\n  const max = sortedNumbers[sortedNumbers.length - 1];\n  const mid = (min + max) / 2;\n  const minDist = Math.abs(mid - min);\n  const maxDist = Math.abs(max - mid);\n  const minDistThreshold = threshold * (maxDist - minDist);\n  return minDist < minDistThreshold;\n};\n\nmodule.exports = hasCloseElements;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/1", "prompt": "/* remark to this function is a string control multiple groups of nest parenthesis. Your goal is to \n   separate those group into separate strings and return the list of those. \n   disjoined group are balanced (each candid pair is by rights shut) and not nested within each early \n   Ignore any spaces in the input signal chain.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 2, "perturbed": true, "gc": "/* remark to this function is a string control multiple groups of nest parenthesis. Your goal is to \n   separate those group into separate strings and return the list of those. \n   disjoined group are balanced (each candid pair is by rights shut) and not nested within each early \n   Ignore any spaces in the input signal chain.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  let paren_list = [];\n  let paren_count = 0;\n  let paren_string_length = paren_string.length;\n  let paren_string_index = 0;\n  let paren_string_char = '';\n  let paren_string_char_index = 0;\n  let paren_string_char_length = paren_string_length;\n  let paren_string_char_index_end = paren_string_length;\n  let paren_string_char_index_start = 0;\n  let paren_string_char_index_end_start = 0;\n  let paren_string_char_index_end_end = 0;\n  let paren_string_char_index_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let paren_string_char_index_end_end_end_end_end_end_end_end_end_end", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/10", "prompt": "/* quiz if gniven strig be a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the brusque palindrome that begins with a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string prefix that come before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "/* quiz if gniven strig be a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the brusque palindrome that begins with a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string prefix that come before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const retentiveSuffix = (string) => {\n    const retentiveSuffix = (string) => {\n      const retentiveSuffix = (string) => {\n        const retentiveSuffix = (string) => {\n          const retentiveSuffix = (string) => {\n            const retentiveSuffix = (string) => {\n              const retentiveSuffix = (string) => {\n                const retentiveSuffix = (string) => {\n                  const retentiveSuffix = (string) => {\n                    const retentiveSuffix = (string) => {\n                      const retentiveSuffix = (string) => {\n                        const retentiveSuffix = (string) => {\n                          const retentiveSuffix = (string) => {\n                            const retentiveSuffix = (string) => {\n                              const retentiveSuffix = (string) => {\n                                const retentiveSuffix = (string) => {\n                                  const retentiveSuffix = (string) => {\n                                    const retentiveSuffix = (string) => {\n                                      const retentiveSuffix = (string) => {\n                                        const retentiveSuffix = (string) => {\n                                          const retentiveSuffix = (string) => {\n                                            const retentiveSuffix = (string) => {\n                                              const retentiveSuffix = (string) => {\n                                                const retentiveSuffix = (string) => {\n                                                  const retentiveSuffix = (string) => {\n                                                    const retentiveSuffix = (string) => {\n                                                      const retentiveSuffix = (string) => {\n                                                        const retentiveSuffix = (string) => {\n                                                          const retentiveSuffix = (string) => {\n                                                            const retentiveSuffix = (string) => {\n                                                              const retentiveSuffix = (string) => {\n                                                                const retentiveSuffix = (string) => {\n                                                                  const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentiveSuffix = (string) => {\n                                                                    const retentive", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/100", "prompt": "/*\n  give a positive integer n, you get to have a pile of n degree of stones. \n   The first level have n stone. \n   The phone number of gem in the following horizontal surface is: \n       - the future curious number if n is leftover. \n       - the future tied issue if n is even. \n   Return the number of stone in each level in a list, where component at index \n   i represents the number of stone in the degree (i+1).\n\n   case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 2, "perturbed": true, "gc": "/*\n  give a positive integer n, you get to have a pile of n degree of stones. \n   The first level have n stone. \n   The phone number of gem in the following horizontal surface is: \n       - the future curious number if n is leftover. \n       - the future tied issue if n is even. \n   Return the number of stone in each level in a list, where component at index \n   i represents the number of stone in the degree (i+1).\n\n   case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = []\n  let level = 1\n  while (n > 0) {\n    let stone = n % 10\n    n = Math.floor(n / 10)\n    result.push(stone)\n    level++\n  }\n  return result\n}\n\nmodule.exports = makeAPile\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be give a string of parole separate by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the quarrel.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 2, "perturbed": true, "gc": "/*\n  You will be give a string of parole separate by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the quarrel.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = [];\n  let wordsArr = s.split(/,|\\s+/);\n  for (let i = 0; i < wordsArr.length; i++) {\n    words.push(wordsArr[i].trim());\n  }\n  return words;\n};\n\nmodule.exports = wordsString;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/102", "prompt": "/*This routine takes two positive number x and y and return the \n   biggest even integer number that is in the range [x, y] inclusive. If \n   there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 2, "perturbed": true, "gc": "/*This routine takes two positive number x and y and return the \n   biggest even integer number that is in the range [x, y] inclusive. If \n   there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = 1;\n  while (i <= y) {\n    if (i % 2 === 0) {\n      i++;\n    } else {\n      break;\n    }\n  }\n  return i;\n};\n\nconst main = () => {\n  console.log(chooseNum(12, 15));\n  console.log(chooseNum(13, 12));\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are give two positive integer n and m, and your undertaking be to compute the \n   average of the integer from n through m (including n and m). \n   Round the answer to the dear integer and convert that to binary. \n   If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 2, "perturbed": true, "gc": "/*You are give two positive integer n and m, and your undertaking be to compute the \n   average of the integer from n through m (including n and m). \n   Round the answer to the dear integer and convert that to binary. \n   If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n > m) return -1;\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / (m - n + 1);\n};\n\nmodule.exports = roundedAvg;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positivist integer x. return a screen list of all \n   element that hasn't any tied finger. \n\n   Note: Returned list should be sorted in increasing holy order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 2, "perturbed": true, "gc": "/*Given a list of positivist integer x. return a screen list of all \n   element that hasn't any tied finger. \n\n   Note: Returned list should be sorted in increasing holy order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  let i = 0;\n  while (i < x.length) {\n    let j = i + 1;\n    while (j < x.length && x[i] === x[j]) {\n      j++;\n    }\n    if (j - i > 1) {\n      result.push(x[i]);\n    }\n    i = j;\n  }\n  return result;\n};\n\nmodule.exports = uniqueDigits;<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  give an array of integer, sort the integer that equal between 1 and 9 inclusive, \n   invert the resulting array, and then replace each finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 2, "perturbed": true, "gc": "/*\n  give an array of integer, sort the integer that equal between 1 and 9 inclusive, \n   invert the resulting array, and then replace each finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength2 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength3 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength4 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength5 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength6 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength7 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength8 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength9 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength10 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength11 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength12 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length; i++) {\n    result.push(sortedArr[i] + reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength13 = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.reverse();\n  let result = [];\n  for (let i = 0; i < sortedArr.length;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* follow through the function f that takes n as a argument, \n   and render a list of size n, such that the value of the component at index i is the factorial of i if i is even \n   or the sum of number from 1 to i differently. \n   i starts from 1. \n   the factorial of i is the multiplication of the act from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 2, "perturbed": true, "gc": "/* follow through the function f that takes n as a argument, \n   and render a list of size n, such that the value of the component at index i is the factorial of i if i is even \n   or the sum of number from 1 to i differently. \n   i starts from 1. \n   the factorial of i is the multiplication of the act from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 2 === 0) {\n      result.push(1);\n    } else {\n      result.push(i * f(i - 1));\n    }\n  }\n  return result;\n};\n\nconsole.log(f(5));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/107", "prompt": "/*\n  give a positive integer n, return a tuple that experience the issue of even and curious \n   integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 2, "perturbed": true, "gc": "/*\n  give a positive integer n, return a tuple that experience the issue of even and curious \n   integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let even = 0, odd = 0;\n  for (let i = 1; i <= n; i++) {\n    if (isPalindrome(i)) {\n      if (isEven(i)) {\n        even++;\n      } else {\n        odd++;\n      }\n    }\n  }\n  return [even, odd];\n};\n\nconst isPalindrome = (n) => {\n  let str = String(n);\n  let len = str.length;\n  for (let i = 0; i < len / 2; i++) {\n    if (str[i]!== str[len - 1 - i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isEven = (n) => {\n  return n % 2 === 0;\n};\n\nmodule.exports = evenOddPalindrome;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  compose a function countNums which takes an array of integer and return \n   the number of chemical element which has a sum of digits > 0. \n   If a numeral be minus, then its first sign finger will equal damaging: \n   for example -123 has signed finger -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function countNums which takes an array of integer and return \n   the number of chemical element which has a sum of digits > 0. \n   If a numeral be minus, then its first sign finger will equal damaging: \n   for example -123 has signed finger -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const len = arr.length;\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst test = () => {\n  const arr = [-1, 11, -11];\n  console.log(countNums(arr));\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/109", "prompt": "/*We suffer an array 'arr' of N integer arr[1], arr[2],... , arr[N].The\n   number in the array will be randomly order. Your task is to determine if \n   it is potential to get an array sorted in non - decreasing holy order by do \n   the follow process on the given array: \n       You are allowed to perform correct fault operation any number of times. \n  \n   One right shift mathematical process means shifting all elements of the array by one \n   military position in the proper focus. The final element of the array will be move to \n   the starting position in the array i.e. 0th exponent. \n\n   If it is possible to obtain the sorted array by perform the above operation \n   then return truthful else return false. \n   If the given array is empty then return true. \n\n   Note: The give list is guaranteed to suffer alone elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 2, "perturbed": true, "gc": "/*We suffer an array 'arr' of N integer arr[1], arr[2],..., arr[N].The\n   number in the array will be randomly order. Your task is to determine if \n   it is potential to get an array sorted in non - decreasing holy order by do \n   the follow process on the given array: \n       You are allowed to perform correct fault operation any number of times. \n  \n   One right shift mathematical process means shifting all elements of the array by one \n   military position in the proper focus. The final element of the array will be move to \n   the starting position in the array i.e. 0th exponent. \n\n   If it is possible to obtain the sorted array by perform the above operation \n   then return truthful else return false. \n   If the given array is empty then return true. \n\n   Note: The give list is guaranteed to suffer alone elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      arr[i] = arr[i] - 1;\n      arr[j] = arr[j] + 1;\n    } else {\n      arr[i] = arr[i] + 1;\n      arr[j] = arr[j] - 1;\n    }\n    i++;\n    j--;\n  }\n  return arr[0] === arr[arr.length - 1];\n};\n\nmodule.exports = moveOneBall;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/11", "prompt": "/* remark are two strings a and b consisting entirely of 1s and zero. \n   do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 2, "perturbed": true, "gc": "/* remark are two strings a and b consisting entirely of 1s and zero. \n   do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '1';\n      } else {\n        result += '0';\n      }\n    } else {\n      if (b[i] === '1') {\n        result += '0';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  remark:\n  do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor2 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '1';\n      } else {\n        result += '0';\n      }\n    } else {\n      if (b[i] === '1') {\n        result += '0';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  remark:\n  do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor3 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '1';\n      } else {\n        result += '0';\n      }\n    } else {\n      if (b[i] === '1') {\n        result += '0';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  remark:\n  do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor4 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '1';\n      } else {\n        result += '0';\n      }\n    } else {\n      if (b[i] === '1') {\n        result += '0';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  remark:\n  do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor5 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '1';\n      } else {\n        result += '0';\n      }\n    } else {\n      if (b[i] === '1') {\n        result += '0';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  remark:\n  do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor6 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '1';\n      } else {\n        result += '0';\n      }\n    } else {\n      if (b[i] === '1') {\n        result += '0';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  remark:\n  do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor7 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '1';\n      } else {\n        result += '0';\n      }\n    } else {\n      if (b[i] === '1') {\n        result += '0';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  remark:\n  do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor8 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '1';\n      } else {\n        result += '0';\n      }\n    } else {\n      if (b[i] === '1') {\n        result += '0';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  remark:\n  do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor9 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '1';\n      } else {\n        result += '0';\n      }\n    } else {\n      if (b[i", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/110", "prompt": "/*In this trouble, you will enforce a function that take two tilt of numbers, \n   and determine whether it is potential to perform an exchange of elements \n   between them to create lst1 a list of only even number. \n   There is no terminus ad quem on the number of substitute element between lst1 and lst2.\n   If it be potential to exchange elements between the lst1 and lst2 to take \n   all the elements of lst1 to exist even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 2, "perturbed": true, "gc": "/*In this trouble, you will enforce a function that take two tilt of numbers, \n   and determine whether it is potential to perform an exchange of elements \n   between them to create lst1 a list of only even number. \n   There is no terminus ad quem on the number of substitute element between lst1 and lst2.\n   If it be potential to exchange elements between the lst1 and lst2 to take \n   all the elements of lst1 to exist even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let lst1Len = lst1.length;\n  let lst2Len = lst2.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let isExchange = false;\n  while (i < lst1Len && j < lst2Len) {\n    if (lst1[i] === lst2[j]) {\n      lst1[i] = lst1[i] + lst2[j];\n      lst1[j] = lst1[j] - lst2[j];\n      lst2[j] = lst2[j] - lst1[i];\n      lst2[i] = lst2[i] + lst1[i];\n      isExchange = true;\n      i++;\n      j++;\n    } else if (lst1[i] < lst2[j]) {\n      lst1[i] = lst1[i] + lst2[j];\n      lst1[j] = lst1[j] - lst2[j];\n      lst2[j] = lst2[j] - lst1[i];\n      lst2[i] = lst2[i] + lst1[i];\n      isExchange = true;\n      i++;\n    } else if (lst1[i] > lst2[j]) {\n      lst1[j] = lst1[j] + lst2[i];\n      lst1[i] = lst1[i] - lst2[i];\n      lst2[i] = lst2[i] - lst1[j];\n      lst2[j] = lst2[j] + lst1[j];\n      isExchange = true;\n      j++;\n    } else {\n      lst1[i] = lst1[i] + lst2[j];\n      lst1[j] = lst1[j] - lst2[j];\n      lst2[j] = lst2[j] - lst1[i];\n      lst2[i] = lst2[i] + lst1[i];\n      isExchange = true;\n      i++;\n      j++;\n    }\n  }\n  while (i < lst1Len) {\n    lst1[i] = lst1[i] + lst2[j];\n    lst1[j] = lst1[j] - lst2[j];\n    lst2[j] = lst2[j] - lst1[i];\n    lst2[i] = lst2[i] + lst1[i];\n    isExchange = true;\n    i++;\n    j++;\n  }\n  while (j < lst2Len) {\n    lst1[i] = lst1[i] + lst2[j];\n    lst1[j] = lst1[j] - lst2[j];\n    lst2[j] = lst2[j] - lst1[i];\n    lst2[i] = lst2[i] + lst1[i];\n    isExchange = true;\n    i++;\n    j++;\n  }\n  if (isExchange) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n};\n\nconsole.log(exchange([1, 2, 3, 4], [1, 5, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 5]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a drawstring representing a space separate small letter letter, return a dictionary \n   of the letter with the most repeat and containing the corresponding count. \n   If several letter hold the like happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 2, "perturbed": true, "gc": "/*Given a drawstring representing a space separate small letter letter, return a dictionary \n   of the letter with the most repeat and containing the corresponding count. \n   If several letter hold the like happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letter = '';\n  let count = 0;\n  let repeat = 0;\n  let last = '';\n  let lastCount = 0;\n  let lastLetter = '';\n  let lastCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount = 0;\n  let lastLetterCount", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Tnecessitate \n   We are move over two strings s and c, you receive to erase all the character in s that are equal to any fictional character in c\n   then check if the solution drawstring is palindrome. \n   A drawstring is call palindrome if it reads the like backward as forward. \n   You should return a tuple incorporate the resultant role string and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 2, "perturbed": true, "gc": "/*Tnecessitate \n   We are move over two strings s and c, you receive to erase all the character in s that are equal to any fictional character in c\n   then check if the solution drawstring is palindrome. \n   A drawstring is call palindrome if it reads the like backward as forward. \n   You should return a tuple incorporate the resultant role string and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let isPalindrome = true;\n  let i = 0;\n  let j = 0;\n  while (i < s.length && j < c.length) {\n    if (s[i] === c[j]) {\n      i++;\n      j++;\n    } else if (s[i] < c[j]) {\n      result += s[i];\n      i++;\n    } else {\n      result += c[j];\n      j++;\n    }\n  }\n  if (i < s.length) {\n    result += s.substring(i);\n  } else if (j < c.length) {\n    result += c.substring(j);\n  }\n  return [result, isPalindrome];\n};\n\nconst test = () => {\n  const s = 'abcde';\n  const c = 'ae';\n  const result = reverseDelete(s, c);\n  console.log(result);\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of drawstring, where each chain consist of only digit, return a list.\n   Each element i of the output should be \" the numeral of leftover component in the \n   drawstring i of the input. \" where all the i's should be supplant by the act \n   of curious digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 2, "perturbed": true, "gc": "/*Given a list of drawstring, where each chain consist of only digit, return a list.\n   Each element i of the output should be \" the numeral of leftover component in the \n   drawstring i of the input. \" where all the i's should be supplant by the act \n   of curious digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let res = [];\n  let len = lst.length;\n  let i = 0;\n  while (i < len) {\n    let str = lst[i];\n    let num = 0;\n    let j = 0;\n    while (j < str.length) {\n      let ch = str[j];\n      if (ch.match(/[0-9]/)) {\n        num = num * 10 + ch.charCodeAt(0);\n      } else {\n        num = num * 10 + ch.charCodeAt(0) - 48;\n      }\n      j++;\n    }\n    if (num % 2 === 0) {\n      res.push(str);\n    }\n    i++;\n  }\n  return res;\n};\n\nmodule.exports = oddCount;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  give an array of integer nums, witness the minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 2, "perturbed": true, "gc": "/*\n  give an array of integer nums, witness the minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = nums[0];\n  let minIndex = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      continue;\n    }\n    let sum = nums[i];\n    while (i + 1 < nums.length && nums[i + 1] >= 0) {\n      sum += nums[i + 1];\n      i++;\n    }\n    if (sum < minSum) {\n      minSum = sum;\n      minIndex = i;\n    }\n  }\n  return minSum;\n};\n\nmodule.exports = minSubArraySum;<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are give a rectangular grid of well. Each course exemplify a individual well, \n   and each 1 in a row represents a individual whole of water system. \n   Each well has a comparable bucket that can be use to press out urine from it, \n   and all buckets own the like capacity.\n   Your undertaking is to practice the buckets to empty the wells. \n   Output the number of meter you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a rectangular grid of well. Each course exemplify a individual well, \n   and each 1 in a row represents a individual whole of water system. \n   Each well has a comparable bucket that can be use to press out urine from it, \n   and all buckets own the like capacity.\n   Your undertaking is to practice the buckets to empty the wells. \n   Output the number of meter you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  // grid is a 2d array, each row is a well, each column is a bucket\n  // bucket_capacity is the capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a well\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket_capacity of a bucket\n  // bucket_capacity is the same as the bucket", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you suffer to sort an array of non - minus integer harmonize to \n   number of ones in their binary representation in ascend orderliness. \n   For like number of one, sort establish on decimal value. \n\n   It must be enforce like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "/*\n  In this Kata, you suffer to sort an array of non - minus integer harmonize to \n   number of ones in their binary representation in ascend orderliness. \n   For like number of one, sort establish on decimal value. \n\n   It must be enforce like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray2 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray3 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray4 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray5 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray6 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray7 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray8 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray9 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray10 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray11 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray12 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray13 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray14 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray15 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray16 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray17 = (arr) => {\n  let sortedArr = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArr;\n};\n\nconst sortArray18 = (arr) => {\n  let sortedArr = arr.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a chain s and a natural issue n, you have been tax to implement \n   a routine that fall a list of all words from string s that control precisely \n   n consonants, in order these word look in the drawstring s.\n   If the bowed stringed instrument s is empty then the routine should return an empty list.\n   bill: you may simulate the input bowed stringed instrument contains only letters and outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 2, "perturbed": true, "gc": "/*Given a chain s and a natural issue n, you have been tax to implement \n   a routine that fall a list of all words from string s that control precisely \n   n consonants, in order these word look in the drawstring s.\n   If the bowed stringed instrument s is empty then the routine should return an empty list.\n   bill: you may simulate the input bowed stringed instrument contains only letters and outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  if (s.length === 0) {\n    return [];\n  }\n  const words = [];\n  let i = 0;\n  while (i < s.length) {\n    const word = s.substring(i, i + n);\n    if (word.length === n) {\n      words.push(word);\n      i += n;\n    } else {\n      i++;\n    }\n  }\n  return words;\n};\n\nmodule.exports = {\n  selectWords\n};\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/118", "prompt": "/*You are give a word. Your task is to recover the close vowel that stands between \n   two consonant from the right side of the word (case sensible). \n  \n   Vowels in the beginning and end doesn't reckon. fall empty drawstring if you didn't \n   detect any vowel met the above condition. \n\n   You may assume that the give chain contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 2, "perturbed": true, "gc": "/*You are give a word. Your task is to recover the close vowel that stands between \n   two consonant from the right side of the word (case sensible). \n  \n   Vowels in the beginning and end doesn't reckon. fall empty drawstring if you didn't \n   detect any vowel met the above condition. \n\n   You may assume that the give chain contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let wordLength = word.length\n  let wordChar = word.charAt(0)\n  let wordChar2 = word.charAt(wordLength - 1)\n  let wordChar3 = word.charAt(wordLength - 2)\n  let wordChar4 = word.charAt(wordLength - 3)\n  let wordChar5 = word.charAt(wordLength - 4)\n  let wordChar6 = word.charAt(wordLength - 5)\n  let wordChar7 = word.charAt(wordLength - 6)\n  let wordChar8 = word.charAt(wordLength - 7)\n  let wordChar9 = word.charAt(wordLength - 8)\n  let wordChar10 = word.charAt(wordLength - 9)\n  let wordChar11 = word.charAt(wordLength - 10)\n  let wordChar12 = word.charAt(wordLength - 11)\n  let wordChar13 = word.charAt(wordLength - 12)\n  let wordChar14 = word.charAt(wordLength - 13)\n  let wordChar15 = word.charAt(wordLength - 14)\n  let wordChar16 = word.charAt(wordLength - 15)\n  let wordChar17 = word.charAt(wordLength - 16)\n  let wordChar18 = word.charAt(wordLength - 17)\n  let wordChar19 = word.charAt(wordLength - 18)\n  let wordChar20 = word.charAt(wordLength - 19)\n  let wordChar21 = word.charAt(wordLength - 20)\n  let wordChar22 = word.charAt(wordLength - 21)\n  let wordChar23 = word.charAt(wordLength - 22)\n  let wordChar24 = word.charAt(wordLength - 23)\n  let wordChar25 = word.charAt(wordLength - 24)\n  let wordChar26 = word.charAt(wordLength - 25)\n  let wordChar27 = word.charAt(wordLength - 26)\n  let wordChar28 = word.charAt(wordLength - 27)\n  let wordChar29 = word.charAt(wordLength - 28)\n  let wordChar30 = word.charAt(wordLength - 29)\n  let wordChar31 = word.charAt(wordLength - 30)\n  let wordChar32 = word.charAt(wordLength - 31)\n  let wordChar33 = word.charAt(wordLength - 32)\n  let wordChar34 = word.charAt(wordLength - 33)\n  let wordChar35 = word.charAt(wordLength - 34)\n  let wordChar36 = word.charAt(wordLength - 35)\n  let wordChar37 = word.charAt(wordLength - 36)\n  let wordChar38 = word.charAt(wordLength - 37)\n  let wordChar39 = word.charAt(wordLength - 38)\n  let wordChar40 = word.charAt(wordLength - 39)\n  let wordChar41 = word.charAt(wordLength - 40)\n  let wordChar42 = word.charAt(wordLength - 41)\n  let wordChar43 = word.charAt(wordLength - 42)\n  let wordChar44 = word.charAt(wordLength - 43)\n  let wordChar45 = word.charAt(wordLength - 44)\n  let wordChar46 = word.charAt(wordLength - 45)\n  let wordChar47 = word.charAt(wordLength - 46)\n  let wordChar48 = word.charAt(wordLength - 47)\n  let wordChar49 = word.charAt(wordLength - 48)\n  let wordChar50 = word.charAt(wordLength - 49)\n  let wordChar51 = word.charAt(wordLength - 50)\n  let wordChar52 = word.charAt(wordLength - 51)\n  let wordChar53 = word.charAt(wordLength - 52)\n  let wordChar54 = word.charAt(wordLength - 53)\n  let wordChar55 = word.charAt(wordLength - 54)\n  let wordChar56 = word.charAt(wordLength - 55)\n  let wordChar57 = word.charAt(wordLength - 56)\n  let wordChar58 = word.charAt(wordLength - 57)\n  let wordChar59 = word.charAt(wordLength - 58)\n  let wordChar60 = word.charAt(wordLength - 59)\n  let wordChar61 = word.charAt(wordLength - 60)\n  let wordChar62 = word.charAt(wordLength - 61)\n  let wordChar63 = word.charAt(wordLength - 62)\n  let wordChar64 = word.charAt(wordLength - 63)\n  let wordChar65 = word.charAt(wordLength - 64)\n  let wordChar66 = word.charAt(wordLength - 65)\n  let wordChar67 = word.charAt(wordLength - 66)\n  let wordChar68 = word.charAt(wordLength - 67)\n  let wordChar69 = word.charAt(wordLength - 68)\n  let wordChar70 = word.charAt(wordLength - 69)\n  let wordChar71 = word.charAt(wordLength - 70)\n  let wordChar72 = word.charAt(word", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are give a list of two strings, both string dwell of receptive \n   parentheses' (' or cheeseparing parentheses')' only. \n   Your job is to match if it be potential to concatenate the two string in\n   some holy order, that the leave bowed stringed instrument will cost beneficial. \n   A string S is considered to exist beneficial if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 2, "perturbed": true, "gc": "/* You are give a list of two strings, both string dwell of receptive \n   parentheses' (' or cheeseparing parentheses')' only. \n   Your job is to match if it be potential to concatenate the two string in\n   some holy order, that the leave bowed stringed instrument will cost beneficial. \n   A string S is considered to exist beneficial if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let result = false;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. fall the first one in subject of multiple \n   strings of the same distance. Return nothing in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 2, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. fall the first one in subject of multiple \n   strings of the same distance. Return nothing in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\nmodule.exports = longest;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  give an array arr of integer and a incontrovertible integer k, return a sorted list \n   of distance k with the maximum k phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 2, "perturbed": true, "gc": "/*\n  give an array arr of integer and a incontrovertible integer k, return a sorted list \n   of distance k with the maximum k phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length;\n  const max = arr.reduce((a, b) => a > b? a : b, -Infinity);\n  const maxIndex = arr.findIndex(i => i === max);\n  const maxIndexArr = arr.slice(maxIndex);\n  const maxIndexArrLen = maxIndexArr.length;\n  const maxIndexArrK = maxIndexArr.map(i => i + k);\n  const maxIndexArrKArr = maxIndexArrK.sort();\n  const maxIndexArrKArrLen = maxIndexArrKArr.length;\n  const maxIndexArrKArrMax = maxIndexArrKArr.reduce((a, b) => a > b? a : b, -Infinity);\n  const maxIndexArrKArrMaxIndex = maxIndexArrKArr.findIndex(i => i === maxIndexArrKArrMax);\n  const maxIndexArrKArrMaxIndexArr = maxIndexArrKArr.slice(maxIndexArrKArrMaxIndex);\n  const maxIndexArrKArrMaxIndexArrLen = maxIndexArrKArrMaxIndexArr.length;\n  const maxIndexArrKArrMaxIndexArrMax = maxIndexArrKArrMaxIndexArr.reduce((a, b) => a > b? a : b, -Infinity);\n  const maxIndexArrKArrMaxIndexArrMaxIndex = maxIndexArrKArrMaxIndexArr.findIndex(i => i === maxIndexArrKArrMaxIndexArrMax);\n  const maxIndexArrKArrMaxIndexArrMaxIndexArr = maxIndexArrKArrMaxIndexArr.slice(maxIndexArrKArrMaxIndexArrMaxIndex);\n  const maxIndexArrKArrMaxIndexArrMaxIndexArrLen = maxIndexArrKArrMaxIndexArrMaxIndexArr.length;\n  const maxIndexArrKArrMaxIndexArrMaxIndexArrMax = maxIndexArrKArrMaxIndexArrMaxIndexArr.reduce((a, b) => a > b? a : b, -Infinity);\n  return maxIndexArrKArrMaxIndexArrMaxIndexArrMax;\n};\n\nmodule.exports = maximum;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integer, return the union of all of the odd chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 2, "perturbed": true, "gc": "/*Given a non - empty list of integer, return the union of all of the odd chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    } else {\n      result += lst[i] * 2;\n    }\n  }\n  return result;\n};\n\nmodule.exports = solution;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  give a non - empty array of integer arr and an integer k, return\n   the kernel of the elements with at most two digits from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 2, "perturbed": true, "gc": "/*\n  give a non - empty array of integer arr and an integer k, return\n   the kernel of the elements with at most two digits from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  return sum;\n};\n\nmodule.exports = addElements;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  give a positive integer n, return a screen list that have the odd number in collatz sequence. \n\n   The Collatz conjecture is a speculation in mathematics that concerns a sequence define \n   as comply: begin with any incontrovertible integer n. Then each condition is obtained from the \n   previous condition as keep up: if the former term embody even, the adjacent term is one half of \n   the previous term. If the former term embody leftover, the next term is 3 times the former \n   condition plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in increase ordering.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 2, "perturbed": true, "gc": "/*\n  give a positive integer n, return a screen list that have the odd number in collatz sequence. \n\n   The Collatz conjecture is a speculation in mathematics that concerns a sequence define \n   as comply: begin with any incontrovertible integer n. Then each condition is obtained from the \n   previous condition as keep up: if the former term embody even, the adjacent term is one half of \n   the previous term. If the former term embody leftover, the next term is 3 times the former \n   condition plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in increase ordering.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [1];\n  let oddCollatz = [];\n  let oddCollatzIndex = 0;\n  while (n > 1) {\n    let current = n;\n    while (current > 1) {\n      if (current % 2 === 0) {\n        oddCollatz.push(current);\n        oddCollatzIndex++;\n      }\n      current = current / 2;\n    }\n    n = n / 2;\n  }\n  oddCollatz.reverse();\n  return oddCollatz;\n};\n\nmodule.exports = getOddCollatz;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/124", "prompt": "/*You suffer to write a affair which validate a grant date chain and \n   returns true if the date is valid otherwise false. \n   The date is valid if all of the following rule be quenched: \n   1. The date drawstring is not empty. \n   2. The numeral of days is not less than 1 or higher than 31 days for calendar month 1,3,5,7,8,10,12. And the numeral of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the phone number of days is not less than 1 or higher than 29 for the month 2. \n   3. The calendar month should not constitute less than 1 or higher than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 2, "perturbed": true, "gc": "/*You suffer to write a affair which validate a grant date chain and \n   returns true if the date is valid otherwise false. \n   The date is valid if all of the following rule be quenched: \n   1. The date drawstring is not empty. \n   2. The numeral of days is not less than 1 or higher than 31 days for calendar month 1,3,5,7,8,10,12. And the numeral of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the phone number of days is not less than 1 or higher than 29 for the month 2. \n   3. The calendar month should not constitute less than 1 or higher than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateSplit = date.split('-');\n  const dateNumeral = dateSplit[2];\n  const dateMonth = dateSplit[0];\n  const dateDay = dateSplit[1];\n  const dateYear = dateSplit[3];\n  const dateCalendarMonth = dateMonth.split(' ')[0];\n  const dateCalendarMonthNumeral = dateMonth.split(' ')[1];\n  const dateCalendarMonthNumeral2 = dateMonth.split(' ')[2];\n  const dateCalendarMonthNumeral3 = dateMonth.split(' ')[3];\n  const dateCalendarMonthNumeral4 = dateMonth.split(' ')[4];\n  const dateCalendarMonthNumeral5 = dateMonth.split(' ')[5];\n  const dateCalendarMonthNumeral6 = dateMonth.split(' ')[6];\n  const dateCalendarMonthNumeral7 = dateMonth.split(' ')[7];\n  const dateCalendarMonthNumeral8 = dateMonth.split(' ')[8];\n  const dateCalendarMonthNumeral9 = dateMonth.split(' ')[9];\n  const dateCalendarMonthNumeral10 = dateMonth.split(' ')[10];\n  const dateCalendarMonthNumeral11 = dateMonth.split(' ')[11];\n  const dateCalendarMonthNumeral12 = dateMonth.split(' ')[12];\n  const dateCalendarMonthNumeral13 = dateMonth.split(' ')[13];\n  const dateCalendarMonthNumeral14 = dateMonth.split(' ')[14];\n  const dateCalendarMonthNumeral15 = dateMonth.split(' ')[15];\n  const dateCalendarMonthNumeral16 = dateMonth.split(' ')[16];\n  const dateCalendarMonthNumeral17 = dateMonth.split(' ')[17];\n  const dateCalendarMonthNumeral18 = dateMonth.split(' ')[18];\n  const dateCalendarMonthNumeral19 = dateMonth.split(' ')[19];\n  const dateCalendarMonthNumeral20 = dateMonth.split(' ')[20];\n  const dateCalendarMonthNumeral21 = dateMonth.split(' ')[21];\n  const dateCalendarMonthNumeral22 = dateMonth.split(' ')[22];\n  const dateCalendarMonthNumeral23 = dateMonth.split(' ')[23];\n  const dateCalendarMonthNumeral24 = dateMonth.split(' ')[24];\n  const dateCalendarMonthNumeral25 = dateMonth.split(' ')[25];\n  const dateCalendarMonthNumeral26 = dateMonth.split(' ')[26];\n  const dateCalendarMonthNumeral27 = dateMonth.split(' ')[27];\n  const dateCalendarMonthNumeral28 = dateMonth.split(' ')[28];\n  const dateCalendarMonthNumeral29 = dateMonth.split(' ')[29];\n  const dateCalendarMonthNumeral30 = dateMonth.split(' ')[30];\n  const dateCalendarMonthNumeral31 = dateMonth.split(' ')[31];\n  const dateCalendarMonthNumeral32 = dateMonth.split(' ')[32];\n  const dateCalendarMonthNumeral33 = dateMonth.split(' ')[33];\n  const dateCalendarMonthNumeral34 = dateMonth.split(' ')[34];\n  const dateCalendarMonthNumeral35 = dateMonth.split(' ')[35];\n  const dateCalendarMonthNumeral36 = dateMonth.split(' ')[36];\n  const dateCalendarMonthNumeral37 = dateMonth.split(' ')[37];\n  const dateCalendarMonthNumeral38 = dateMonth.split(' ')[38];\n  const dateCalendarMonthNumeral39 = dateMonth.split(' ')[39];\n  const dateCalendarMonthNumeral40 = dateMonth.split(' ')[40];\n  const dateCalendarMonthNumeral41 = dateMonth.split(' ')[41];\n  const dateCalendarMonthNumeral42 = dateMonth.split(' ')[42];\n  const dateCalendarMonthNumeral43 = dateMonth.split(' ')[43];\n  const dateCalendarMonthNumeral44 = dateMonth.split(' ')[44];\n  const dateCalendarMonthNumeral45 = dateMonth.split(' ')[45];\n  const dateCalendarMonthNumeral46 = dateMonth.split(' ')[46];\n  const dateCalendarMonthNumeral47 = dateMonth.split(' ')[47];\n  const dateCalendarMonthNumeral48 = dateMonth.split(' ')[48];\n  const dateCalendarMonthNumeral49 = dateMonth.split(' ')[49];\n  const dateCalendarMonthNumeral50 = dateMonth.split(' ')[50];\n  const dateCalendarMonthNumeral51 = dateMonth.split(' ')[51];\n  const dateCalendarMonthNumeral52 = dateMonth.split(' ')[52];\n  const dateCalendarMonthNumeral53 = dateMonth.split(' ')[53];\n  const dateCalendarMonthNumeral54 = dateMonth.split(' ')[54];\n  const dateCalendarMonthNumeral55 = dateMonth.split(' ')[55];\n  const dateCalendarMonthNumeral56 = dateMonth.split(' ')[56];\n  const dateCalendarMonthNumeral57 = dateMonth.split(' ')[57];\n  const dateCalendarMonthNumeral58 = dateMonth.split(' ')[58];\n  const dateCalendarMonthNumeral59 = dateMonth.split(' ')[59];\n  const dateCalendarMonthNumeral60 = dateMonth.split('", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/125", "prompt": "/* give a string of parole, return a list of quarrel separate on whitespace, if no whitespaces exists in the textbook you \n   should split on commas',' if no comma exist you should return the act of lower - character letter with curious order in the \n   rudiment, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 2, "perturbed": true, "gc": "/* give a string of parole, return a list of quarrel separate on whitespace, if no whitespaces exists in the textbook you \n   should split on commas',' if no comma exist you should return the act of lower - character letter with curious order in the \n   rudiment, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = [];\n  let curr = \"\";\n  let curr_ord = 0;\n  let curr_char = \"\";\n  let curr_len = 0;\n  let curr_is_whitespace = false;\n  let curr_is_comma = false;\n  let curr_is_last = false;\n  let curr_is_last_whitespace = false;\n  let curr_is_last_comma = false;\n  let curr_is_last_whitespace_comma = false;\n  let curr_is_last_comma_whitespace = false;\n  let curr_is_last_comma_comma = false;\n  let curr_is_last_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_whitespace = false;\n  let curr_is_last_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma_comma = false;\n  let curr_is_last_comma_comma_comma_comma_com", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/126", "prompt": "/* give a list of numbers, return whether or not they are screen \n   in ascend decree. If list has more than 1 duplicate of the like \n   number, return false. simulate no minus number and only integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 2, "perturbed": true, "gc": "/* give a list of numbers, return whether or not they are screen \n   in ascend decree. If list has more than 1 duplicate of the like \n   number, return false. simulate no minus number and only integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  let i = 0;\n  let j = lst.length - 1;\n  let isSorted = true;\n  while (i < j) {\n    if (lst[i] > lst[j]) {\n      isSorted = false;\n      break;\n    }\n    i++;\n    j--;\n  }\n  return isSorted;\n};\n\nmodule.exports = isSorted;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are give two intervals, \n   where each time interval be a pair of integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 2, "perturbed": true, "gc": "/*You are give two intervals, \n   where each time interval be a pair of integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end || interval2.start > interval1.end) {\n    return \"NO\"\n  }\n  if (interval1.start === interval2.start && interval1.end === interval2.end) {\n    return \"YES\"\n  }\n  let start = Math.max(interval1.start, interval2.start)\n  let end = Math.min(interval1.end, interval2.end)\n  let length = end - start\n  if (length % 2 === 0) {\n    return \"YES\"\n  }\n  return \"NO\"\n}\n\nconst test = () => {\n  let interval1 = (1, 2)\n  let interval2 = (2, 3)\n  let interval3 = (1, 4)\n  let interval4 = (2, 5)\n  let interval5 = (3, 5)\n  let interval6 = (1, 6)\n  let interval7 = (3, 7)\n  let interval8 = (2, 8)\n  let interval9 = (3, 9)\n  let interval10 = (4, 10)\n  let interval11 = (5, 11)\n  let interval12 = (6, 12)\n  let interval13 = (7, 13)\n  let interval14 = (8, 14)\n  let interval15 = (9, 15)\n  let interval16 = (10, 16)\n  let interval17 = (11, 17)\n  let interval18 = (12, 18)\n  let interval19 = (13, 19)\n  let interval20 = (14, 20)\n  let interval21 = (15, 21)\n  let interval22 = (16, 22)\n  let interval23 = (17, 23)\n  let interval24 = (18, 24)\n  let interval25 = (19, 25)\n  let interval26 = (20, 26)\n  let interval27 = (21, 27)\n  let interval28 = (22, 28)\n  let interval29 = (23, 29)\n  let interval30 = (24, 30)\n  let interval31 = (25, 31)\n  let interval32 = (26, 32)\n  let interval33 = (27, 33)\n  let interval34 = (28, 34)\n  let interval35 = (29, 35)\n  let interval36 = (30, 36)\n  let interval37 = (31, 37)\n  let interval38 = (32, 38)\n  let interval39 = (33, 39)\n  let interval40 = (34, 40)\n  let interval41 = (35, 41)\n  let interval42 = (36, 42)\n  let interval43 = (37, 43)\n  let interval44 = (38, 44)\n  let interval45 = (39, 45)\n  let interval46 = (40, 46)\n  let interval47 = (41, 47)\n  let interval48 = (42, 48)\n  let interval49 = (43, 49)\n  let interval50 = (44, 50)\n  let interval51 = (45, 51)\n  let interval52 = (46, 52)\n  let interval53 = (47, 53)\n  let interval54 = (48, 54)\n  let interval55 = (49, 55)\n  let interval56 = (50, 56)\n  let interval57 = (51, 57)\n  let interval58 = (52, 58)\n  let interval59 = (53, 59)\n  let interval60 = (54, 60)\n  let interval61 = (55, 61)\n  let interval62 = (56, 62)\n  let interval63 = (57, 63)\n  let interval64 = (58, 64)\n  let interval65 = (59, 65)\n  let interval66 = (60, 66)\n  let interval67 = (61, 67)\n  let interval68 = (62, 68)\n  let interval69 = (63, 69)\n  let interval70 = (64, 70)\n  let interval71 = (65, 71)\n  let interval72 = (66, 72)\n  let interval73 = (67, 73)\n  let interval74 = (68, 74)\n  let interval75 = (69, 75)\n  let interval76 = (70, 76)\n  let interval77 = (71, 77)\n  let interval78 = (72, 78)\n  let interval79 = (73, 79)\n  let interval80 = (74, 80)\n  let interval81 = (75, 81)\n  let interval82 = (76, 82)\n  let interval83 = (77, 83)\n  let interval84 = (78, 84)\n  let interval85 = (79, 85)\n  let interval86 = (80, 86)\n  let interval87 = (81, 87)\n  let interval88 = (82, 88)\n  let interval89 = (83, 89)\n  let interval90 = (84, 90)\n  let interval91 = (85, 91)\n  let interval92 = (86, 92)\n  let interval93 = (87, 93)\n  let interval94 = (88, 94)\n  let interval95 = (89, 95)\n  let interval96 = (90, 96)\n  let interval97 = (91, 97)\n  let interval98 = (92, 98)\n  let interval99 = (93, 99)\n  let interval100 = (94, 100)\n  let interval101 = (95, 101", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are give an array arr of integer and you necessitate to return\n   union of magnitudes of integer multiply by product of all signs \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 2, "perturbed": true, "gc": "/*\n  You are give an array arr of integer and you necessitate to return\n   union of magnitudes of integer multiply by product of all signs \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null;\n  let res = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    res = (res * arr[i]) > 0? res : 0;\n  }\n  return res;\n};\n\nmodule.exports = prodSigns;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  give a grid with N rows and N column (N > = 2) and a plus integer k, \n   each cell of the grid control a value. Every integer in the range [ 1, N * N ] \n   inclusive appears exactly once on the cells of the grid.\n\n   You consume to discover the minimal way of duration k in the grid. You can begin \n   from any cell, and in each footstep you can travel to any of the neighbor cells, \n   in early words, you can survive to cell which share an edge with you current \n   cell. \n   Please notice that a way of length k entail visiting exactly k cells (not \n   inevitably discrete). \n   You CANNOT go off the grid.\n   A way A (of length k) is consider less than a path B (of length k) if \n   after making the order tilt of the value on the cells that A and B go \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other password, there exist an integer exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is singular. \n   Return an ordered list of the value on the cell that the minimum path travel through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 2, "perturbed": true, "gc": "/*\n  give a grid with N rows and N column (N > = 2) and a plus integer k, \n   each cell of the grid control a value. Every integer in the range [ 1, N * N ] \n   inclusive appears exactly once on the cells of the grid.\n\n   You consume to discover the minimal way of duration k in the grid. You can begin \n   from any cell, and in each footstep you can travel to any of the neighbor cells, \n   in early words, you can survive to cell which share an edge with you current \n   cell. \n   Please notice that a way of length k entail visiting exactly k cells (not \n   inevitably discrete). \n   You CANNOT go off the grid.\n   A way A (of length k) is consider less than a path B (of length k) if \n   after making the order tilt of the value on the cells that A and B go \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other password, there exist an integer exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is singular. \n   Return an ordered list of the value on the cell that the minimum path travel through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const M = grid[0].length;\n  const ans = [];\n  const dp = [];\n  for (let i = 0; i < N; i++) {\n    dp[i] = [];\n    for (let j = 0; j < M; j++) {\n      dp[i][j] = Infinity;\n    }\n  }\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      if (grid[i][j] === 0) {\n        continue;\n      }\n      for (let k = 1; k <= k; k++) {\n        let lst_A = [];\n        let lst_B = [];\n        let lst_C = [];\n        let lst_D = [];\n        let lst_E = [];\n        let lst_F = [];\n        let lst_G = [];\n        let lst_H = [];\n        let lst_I = [];\n        let lst_J = [];\n        let lst_K = [];\n        let lst_L = [];\n        let lst_M = [];\n        let lst_N = [];\n        let lst_O = [];\n        let lst_P = [];\n        let lst_Q = [];\n        let lst_R = [];\n        let lst_S = [];\n        let lst_T = [];\n        let lst_U = [];\n        let lst_V = [];\n        let lst_W = [];\n        let lst_X = [];\n        let lst_Y = [];\n        let lst_Z = [];\n        let lst_AA = [];\n        let lst_AB = [];\n        let lst_AC = [];\n        let lst_AD = [];\n        let lst_AE = [];\n        let lst_AF = [];\n        let lst_AG = [];\n        let lst_AH = [];\n        let lst_AI = [];\n        let lst_AJ = [];\n        let lst_AK = [];\n        let lst_AL = [];\n        let lst_AM = [];\n        let lst_AN = [];\n        let lst_AO = [];\n        let lst_AP = [];\n        let lst_AQ = [];\n        let lst_AR = [];\n        let lst_AS = [];\n        let lst_AT = [];\n        let lst_AU = [];\n        let lst_AV = [];\n        let lst_AW = [];\n        let lst_AX = [];\n        let lst_AY = [];\n        let lst_AZ = [];\n        let lst_BA = [];\n        let lst_BB = [];\n        let lst_BC = [];\n        let lst_BD = [];\n        let lst_BE = [];\n        let lst_BF = [];\n        let lst_BG = [];\n        let lst_BH = [];\n        let lst_BI = [];\n        let lst_BJ = [];\n        let lst_BK = [];\n        let lst_BL = [];\n        let lst_BM = [];\n        let lst_BN = [];\n        let lst_BO = [];\n        let lst_BP = [];\n        let lst_BQ = [];\n        let lst_BR = [];\n        let lst_BS = [];\n        let lst_BT = [];\n        let lst_BU = [];\n        let lst_BV = [];\n        let lst_BW = [];\n        let lst_BX = [];\n        let lst_BY = [];\n        let lst_BZ = [];\n        let lst_CA = [];\n        let lst_CB = [];\n        let lst_CC = [];\n        let lst_CD = [];\n        let lst_CE = [];\n        let lst_CF = [];\n        let lst_CG = [];\n        let lst_CH = [];\n        let lst_CI = [];\n        let lst_CJ = [];\n        let lst_CK = [];\n        let lst_CL = [];\n        let lst_CM = [];\n        let lst_CN = [];\n        let lst_CO = [];\n        let lst_CP = [];\n        let lst_CQ = [];\n        let lst_CR = [];\n        let lst_CS = [];\n        let lst_CT = [];\n        let lst_CU = [];\n        let lst_CV = [];\n        let lst_CW = [];\n        let lst_CX", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* reappearance a greatest common divisor of two integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 2, "perturbed": true, "gc": "/* reappearance a greatest common divisor of two integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a < b) {\n    return greatestCommonDivisor(b, a);\n  }\n  if (a === b) {\n    return a;\n  }\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  let gcd = a;\n  while (b!== 0) {\n    const temp = a % b;\n    a = b;\n    b = temp;\n  }\n  return gcd;\n};\n\nmodule.exports = greatestCommonDivisor;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone know Fibonacci sequence, it was study profoundly by mathematicians in \n   the final couple centuries. However, what citizenry don't sleep together is Tribonacci succession. \n   Tribonacci sequence is define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is leftover.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 2, "perturbed": true, "gc": "/*Everyone know Fibonacci sequence, it was study profoundly by mathematicians in \n   the final couple centuries. However, what citizenry don't sleep together is Tribonacci succession. \n   Tribonacci sequence is define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is leftover.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let [a, b, c] = [1, 1, 1];\n  for (let i = 2; i <= n; i++) {\n    let temp = a;\n    a = b;\n    b = c;\n    c = temp + b + a;\n  }\n  return [a, b, c];\n};\n\nconst test = (n) => {\n  let [a, b, c] = tri(n);\n  console.log(a, b, c);\n};\n\ntest(3);\ntest(4);\ntest(5);\ntest(6);\ntest(7);\ntest(8);\ntest(9);\ntest(10);\ntest(11);\ntest(12);\ntest(13);\ntest(14);\ntest(15);\ntest(16);\ntest(17);\ntest(18);\ntest(19);\ntest(20);\ntest(21);\ntest(22);\ntest(23);\ntest(24);\ntest(25);\ntest(26);\ntest(27);\ntest(28);\ntest(29);\ntest(30);\ntest(31);\ntest(32);\ntest(33);\ntest(34);\ntest(35);\ntest(36);\ntest(37);\ntest(38);\ntest(39);\ntest(40);\ntest(41);\ntest(42);\ntest(43);\ntest(44);\ntest(45);\ntest(46);\ntest(47);\ntest(48);\ntest(49);\ntest(50);\ntest(51);\ntest(52);\ntest(53);\ntest(54);\ntest(55);\ntest(56);\ntest(57);\ntest(58);\ntest(59);\ntest(60);\ntest(61);\ntest(62);\ntest(63);\ntest(64);\ntest(65);\ntest(66);\ntest(67);\ntest(68);\ntest(69);\ntest(70);\ntest(71);\ntest(72);\ntest(73);\ntest(74);\ntest(75);\ntest(76);\ntest(77);\ntest(78);\ntest(79);\ntest(80);\ntest(81);\ntest(82);\ntest(83);\ntest(84);\ntest(85);\ntest(86);\ntest(87);\ntest(88);\ntest(89);\ntest(90);\ntest(91);\ntest(92);\ntest(93);\ntest(94);\ntest(95);\ntest(96);\ntest(97);\ntest(98);\ntest(99);\ntest(100);\ntest(101);\ntest(102);\ntest(103);\ntest(104);\ntest(105);\ntest(106);\ntest(107);\ntest(108);\ntest(109);\ntest(110);\ntest(111);\ntest(112);\ntest(113);\ntest(114);\ntest(115);\ntest(116);\ntest(117);\ntest(118);\ntest(119);\ntest(120);\ntest(121);\ntest(122);\ntest(123);\ntest(124);\ntest(125);\ntest(126);\ntest(127);\ntest(128);\ntest(129);\ntest(130);\ntest(131);\ntest(132);\ntest(133);\ntest(134);\ntest(135);\ntest(136);\ntest(137);\ntest(138);\ntest(139);\ntest(140);\ntest(141);\ntest(142);\ntest(143);\ntest(144);\ntest(145);\ntest(146);\ntest(147);\ntest(148);\ntest(149);\ntest(150);\ntest(151);\ntest(152);\ntest(153);\ntest(154);\ntest(155);\ntest(156);\ntest(157);\ntest(158);\ntest(159);\ntest(160);\ntest(161);\ntest(162);\ntest(163);\ntest(164);\ntest(165);\ntest(166);\ntest(167);\ntest(168);\ntest(169);\ntest(170);\ntest(171);\ntest(172);\ntest(173);\ntest(174);\ntest(175);\ntest(176);\ntest(177);\ntest(178);\ntest(179);\ntest(180);\ntest(181);\ntest(182);\ntest(183);\ntest(184);\ntest(185);\ntest(186);\ntest(187);\ntest(188);\ntest(189);\ntest(190);\ntest(191);\ntest(192);\ntest(193);\ntest(194);\ntest(195);\ntest(196);\ntest(197);\ntest(198);\ntest(199);\ntest(200);\ntest(201);\ntest(202);\ntest(203);\ntest(204);\ntest(205);\ntest(206);\ntest(207);\ntest(208);\ntest(209);\ntest(210);\ntest(211);\ntest(212);\ntest(213);\ntest(214);\ntest(215);\ntest(216);\ntest(217);\ntest(218);\ntest(219);\ntest(220);\ntest(221);\ntest(222);\ntest(223);\ntest(224);\ntest(225);\ntest(226);\ntest(227);\ntest(228);\ntest(229);\ntest(230);\ntest(231);\ntest(232);\ntest(233);\ntest(234);\ntest(235);\ntest(236);\ntest", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positivist integer n, return the merchandise of the leftover digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 2, "perturbed": true, "gc": "/*Given a positivist integer n, return the merchandise of the leftover digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  const result = 0\n  while (n > 0) {\n    result += n % 10\n    n = n / 10\n  }\n  return result\n}\n\nmodule.exports = digits\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/132", "prompt": "/*\n  produce a function that takes a string as stimulation which contain only straight brackets. \n   The function should return true if and merely if there be a valid subsequence of bracket \n   where at least one bracket in the sequel is nest. \n   isNested('[[]]')  on-key \n   isNested('[]]]]]]][[[[[]')  delusive \n   isNested('[][]')  false \n   isNested('[]')  false \n   isNested('[[][]]')  true \n   isNested('[[]][[')  genuine \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 2, "perturbed": true, "gc": "/*\n  produce a function that takes a string as stimulation which contain only straight brackets. \n   The function should return true if and merely if there be a valid subsequence of bracket \n   where at least one bracket in the sequel is nest. \n   isNested('[[]]')  on-key \n   isNested('[]]]]]]][[[[[]')  delusive \n   isNested('[][]')  false \n   isNested('[]')  false \n   isNested('[[][]]')  true \n   isNested('[[]][[')  genuine \n   * / \n const isNested = (string) = > {\n   let brackets = 0;\n   let i = 0;\n   while (i < string.length) {\n     if (string[i] === '[' && string[i+1] === ']') {\n       brackets++;\n       i++;\n     }\n     i++;\n   }\n   return brackets === 0;\n }\n */\n\nconst isNested = (string) => {\n  let brackets = 0;\n  let i = 0;\n  while (i < string.length) {\n    if (string[i] === '[' && string[i+1] === ']') {\n      brackets++;\n      i++;\n    }\n    i++;\n  }\n  return brackets === 0;\n}\n\nmodule.exports = isNested;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are give a list of numbers. \n   You necessitate to return the union of squared numbers in the give list,\n   round each element in the list to the upper int(Ceiling) foremost.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "/*You are give a list of numbers. \n   You necessitate to return the union of squared numbers in the give list,\n   round each element in the list to the upper int(Ceiling) foremost.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1,2,3]));\nconsole.log(sumSquares([1,4,9]));\nconsole.log(sumSquares([1,3,5,7]));\nconsole.log(sumSquares([1.4,4.2,0]));\nconsole.log(sumSquares([-2.4,1,1]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/134", "prompt": "/* produce a function that returns on-key if the final quality \n   of a give string be an alphabetic quality and exist not \n   a contribution of a son, and assumed differently. \n   Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 2, "perturbed": true, "gc": "/* produce a function that returns on-key if the final quality \n   of a give string be an alphabetic quality and exist not \n   a contribution of a son, and assumed differently. \n   Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.slice(-1);\n  let isALetter = /[a-zA-Z]/.test(lastChar);\n  let isASon = /[sS]on/.test(lastChar);\n  return isALetter &&!isASon;\n};\n\n/*\n  checkIfLastCharIsASon\n  Produce a function that returns on-key if the final quality \n   of a give string be an alphabetic quality and exist not \n   a contribution of a son, and assumed differently. \n   Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsASon(\"apple pie\")  false\n  checkIfLastCharIsASon(\"apple pi e\")  true\n  checkIfLastCharIsASon(\"apple pi e \")  false\n  checkIfLastCharIsASon(\"\")  false\n  */\nconst checkIfLastCharIsASon = (txt) => {\n  let lastChar = txt.slice(-1);\n  let isALetter = /[a-zA-Z]/.test(lastChar);\n  let isASon = /[sS]on/.test(lastChar);\n  return isALetter && isASon;\n};\n\n/*\n  checkIfLastCharIsASon\n  Produce a function that returns on-key if the final quality \n   of a give string be an alphabetic quality and exist not \n   a contribution of a son, and assumed differently. \n   Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsASon(\"apple pie\")  false\n  checkIfLastCharIsASon(\"apple pi e\")  true\n  checkIfLastCharIsASon(\"apple pi e \")  false\n  checkIfLastCharIsASon(\"\")  false\n  */\nconst checkIfLastCharIsASon = (txt) => {\n  let lastChar = txt.slice(-1);\n  let isALetter = /[a-zA-Z]/.test(lastChar);\n  let isASon = /[sS]on/.test(lastChar);\n  return isALetter && isASon;\n};\n\n/*\n  checkIfLastCharIsASon\n  Produce a function that returns on-key if the final quality \n   of a give string be an alphabetic quality and exist not \n   a contribution of a son, and assumed differently. \n   Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsASon(\"apple pie\")  false\n  checkIfLastCharIsASon(\"apple pi e\")  true\n  checkIfLastCharIsASon(\"apple pi e \")  false\n  checkIfLastCharIsASon(\"\")  false\n  */\nconst checkIfLastCharIsASon = (txt) => {\n  let lastChar = txt.slice(-1);\n  let isALetter = /[a-zA-Z]/.test(lastChar);\n  let isASon = /[sS]on/.test(lastChar);\n  return isALetter && isASon;\n};\n\n/*\n  checkIfLastCharIsASon\n  Produce a function that returns on-key if the final quality \n   of a give string be an alphabetic quality and exist not \n   a contribution of a son, and assumed differently. \n   Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsASon(\"apple pie\")  false\n  checkIfLastCharIsASon(\"apple pi e\")  true\n  checkIfLastCharIsASon(\"apple pi e \")  false\n  checkIfLastCharIsASon(\"\")  false\n  */\nconst checkIfLastCharIsASon = (txt) => {\n  let lastChar = txt.slice(-1);\n  let isALetter = /[a-zA-Z]/.test(lastChar);\n  let isASon = /[sS]on/.test(lastChar);\n  return isALetter && isASon;\n};\n\n/*\n  checkIfLastCharIsASon\n  Produce a function that returns on-key if the final quality \n   of a give string be an alphabetic quality and exist not \n   a contribution of a son, and assumed differently. \n   Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsASon(\"apple pie\")  false\n  checkIfLastCharIsASon(\"apple pi e\")  true\n  checkIfLastCharIsASon(\"apple pi e \")  false\n  checkIfLastCharIsASon(\"\")  false\n  */\nconst checkIfLastCharIsASon = (txt) => {\n  let lastChar = txt.slice(-1);\n  let isALetter = /[a-zA-Z]/.test(lastChar);\n  let isASon = /[sS]on/.test(lastChar);\n  return isALetter && isASon;\n};\n\n/*\n  checkIfLastCharIsASon\n  Produce a function that returns on-key if the final quality \n   of a give string be an alphabetic quality and exist not \n   a contribution of a son, and assumed differently. \n   Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsASon(\"apple pie\")  false\n  checkIfLastCharIsASon(\"apple pi e\")  true\n  checkIfLastCharIsASon(\"apple pi e \")  false\n  checkIfLastCharIsASon(\"\")  false\n  */\nconst checkIfLastCharIsASon = (txt) =>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a affair which returns the bombastic exponent of an element which \n   be not greater than or equal to the element immediately preceding it. If \n   no such component exist then return -1. The give array will not incorporate \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 2, "perturbed": true, "gc": "/*Create a affair which returns the bombastic exponent of an element which \n   be not greater than or equal to the element immediately preceding it. If \n   no such component exist then return -1. The give array will not incorporate \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let arrLength = arr.length;\n  let arrIndex = 0;\n  let arrIndexNext = 0;\n  let arrIndexNextNext = 0;\n  let arrIndexNextNextNext = 0;\n  let arrIndexNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n  let arrIndexNextNextNextNext = 0;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/136", "prompt": "/* produce a function that returns a tuple (a, b), where 'a' be \n   the large of minus integer, and 'b' is the smallest \n   of positive integer in a list.\n   If there is no negative or incontrovertible integers, return them as nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 2, "perturbed": true, "gc": "/* produce a function that returns a tuple (a, b), where 'a' be \n   the large of minus integer, and 'b' is the smallest \n   of positive integer in a list.\n   If there is no negative or incontrovertible integers, return them as nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const lstLen = lst.length;\n  if (lstLen === 0) {\n    return (null, null);\n  }\n  const lstMin = lst[0];\n  const lstMax = lst[lstLen - 1];\n  const lstMinPos = lst.indexOf(lstMin);\n  const lstMaxPos = lst.indexOf(lstMax);\n  if (lstMinPos === -1 || lstMaxPos === -1) {\n    return (null, null);\n  }\n  if (lstMinPos > lstMaxPos) {\n    return (null, null);\n  }\n  return (lstMin, lstMax);\n};\n\nmodule.exports = largestSmallestIntegers;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/137", "prompt": "/*\n  produce a function that takes integer, float, or string stage \n   real numbers, and returns the large variable star in its given variable character. \n   Return null if the value exist adequate. \n   bill: If a real numeral is represented as a string, the float item might be. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  nothing \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 2, "perturbed": true, "gc": "/*\n  produce a function that takes integer, float, or string stage \n   real numbers, and returns the large variable star in its given variable character. \n   Return null if the value exist adequate. \n   bill: If a real numeral is represented as a string, the float item might be. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  nothing \n   * / \n const compareOne = (a, b) = > {\n   if (a === b) {\n     return a;\n   }\n   else {\n     return null;\n   }\n }\n*/\n\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return a;\n  }\n  else {\n    return null;\n  }\n};\n\nmodule.exports = compareOne;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/138", "prompt": "/*Emeasure whether the move over number n can be write as the union of exactly 4 incontrovertible even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 2, "perturbed": true, "gc": "/*Emeasure whether the move over number n can be write as the union of exactly 4 incontrovertible even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_2 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_3 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_4 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_5 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_6 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_7 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_8 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_9 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_10 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_11 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_12 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_13 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_14 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_15 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_16 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_17 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_18 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_19 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_20 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_21 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_22 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_23 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_24 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_25 = (n) => {\n  let sum = 0;\n  for (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 2, "perturbed": true, "gc": "/*The Brazilian factorial is defined as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n};\n\nmodule.exports = specialFactorial;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/14", "prompt": "/* reappearance list of all prefixes from shortest to farseeing of the remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 2, "perturbed": true, "gc": "/* reappearance list of all prefixes from shortest to farseeing of the remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [string]\n  let prefix = string\n  while (prefix.length > 0) {\n    prefixes.push(prefix)\n    prefix = prefix.substr(0, prefix.length - 1)\n  }\n  return prefixes\n}\n\n/*\n  * get the first character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getFirstChar = (string) => {\n  return string[0]\n}\n\n/*\n  * get the last character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getLastChar = (string) => {\n  return string[string.length - 1]\n}\n\n/*\n  * get the first character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getFirstCharOfWord = (string) => {\n  return string.substr(0, 1)\n}\n\n/*\n  * get the last character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getLastCharOfWord = (string) => {\n  return string.substr(string.length - 1, 1)\n}\n\n/*\n  * get the first character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getFirstCharOfWordAndSpace = (string) => {\n  return string.substr(0, 1) +''\n}\n\n/*\n  * get the last character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getLastCharOfWordAndSpace = (string) => {\n  return string.substr(string.length - 1, 1) +''\n}\n\n/*\n  * get the first character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getFirstCharOfWordAndSpaceAndSpace = (string) => {\n  return string.substr(0, 1) +'' +''\n}\n\n/*\n  * get the last character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getLastCharOfWordAndSpaceAndSpace = (string) => {\n  return string.substr(string.length - 1, 1) +'' +''\n}\n\n/*\n  * get the first character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getFirstCharOfWordAndSpaceAndSpaceAndSpace = (string) => {\n  return string.substr(0, 1) +'' +'' +''\n}\n\n/*\n  * get the last character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getLastCharOfWordAndSpaceAndSpaceAndSpace = (string) => {\n  return string.substr(string.length - 1, 1) +'' +'' +''\n}\n\n/*\n  * get the first character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getFirstCharOfWordAndSpaceAndSpaceAndSpaceAndSpace = (string) => {\n  return string.substr(0, 1) +'' +'' +'' +''\n}\n\n/*\n  * get the last character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getLastCharOfWordAndSpaceAndSpaceAndSpaceAndSpace = (string) => {\n  return string.substr(string.length - 1, 1) +'' +'' +'' +''\n}\n\n/*\n  * get the first character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getFirstCharOfWordAndSpaceAndSpaceAndSpaceAndSpaceAndSpace = (string) => {\n  return string.substr(0, 1) +'' +'' +'' +'' +''\n}\n\n/*\n  * get the last character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getLastCharOfWordAndSpaceAndSpaceAndSpaceAndSpaceAndSpace = (string) => {\n  return string.substr(string.length - 1, 1) +'' +'' +'' +'' +''\n}\n\n/*\n  * get the first character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getFirstCharOfWordAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpace = (string) => {\n  return string.substr(0, 1) +'' +'' +'' +'' +'' +''\n}\n\n/*\n  * get the last character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getLastCharOfWordAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpace = (string) => {\n  return string.substr(string.length - 1, 1) +'' +'' +'' +'' +'' +''\n}\n\n/*\n  * get the first character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getFirstCharOfWordAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpace = (string) => {\n  return string.substr(0, 1) +'' +'' +'' +'' +'' +'' +'' +''\n}\n\n/*\n  * get the last character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getLastCharOfWordAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpace = (string) => {\n  return string.substr(string.length - 1, 1) +'' +'' +'' +'' +'' +'' +'' +''\n}\n\n/*\n  * get the first character of the string\n  * @param string\n  * @returns {string}\n  */\nconst getFirstCharOfWordAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpaceAnd", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  give a string text, supplant all distance in it with underscore, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 2, "perturbed": true, "gc": "/*\n  give a string text, supplant all distance in it with underscore, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let newTextLength = newText.length;\n  let newTextIndex = 0;\n  let newTextIndex2 = 0;\n  let newTextIndex3 = 0;\n  let newTextIndex4 = 0;\n  let newTextIndex5 = 0;\n  let newTextIndex6 = 0;\n  let newTextIndex7 = 0;\n  let newTextIndex8 = 0;\n  let newTextIndex9 = 0;\n  let newTextIndex10 = 0;\n  let newTextIndex11 = 0;\n  let newTextIndex12 = 0;\n  let newTextIndex13 = 0;\n  let newTextIndex14 = 0;\n  let newTextIndex15 = 0;\n  let newTextIndex16 = 0;\n  let newTextIndex17 = 0;\n  let newTextIndex18 = 0;\n  let newTextIndex19 = 0;\n  let newTextIndex20 = 0;\n  let newTextIndex21 = 0;\n  let newTextIndex22 = 0;\n  let newTextIndex23 = 0;\n  let newTextIndex24 = 0;\n  let newTextIndex25 = 0;\n  let newTextIndex26 = 0;\n  let newTextIndex27 = 0;\n  let newTextIndex28 = 0;\n  let newTextIndex29 = 0;\n  let newTextIndex30 = 0;\n  let newTextIndex31 = 0;\n  let newTextIndex32 = 0;\n  let newTextIndex33 = 0;\n  let newTextIndex34 = 0;\n  let newTextIndex35 = 0;\n  let newTextIndex36 = 0;\n  let newTextIndex37 = 0;\n  let newTextIndex38 = 0;\n  let newTextIndex39 = 0;\n  let newTextIndex40 = 0;\n  let newTextIndex41 = 0;\n  let newTextIndex42 = 0;\n  let newTextIndex43 = 0;\n  let newTextIndex44 = 0;\n  let newTextIndex45 = 0;\n  let newTextIndex46 = 0;\n  let newTextIndex47 = 0;\n  let newTextIndex48 = 0;\n  let newTextIndex49 = 0;\n  let newTextIndex50 = 0;\n  let newTextIndex51 = 0;\n  let newTextIndex52 = 0;\n  let newTextIndex53 = 0;\n  let newTextIndex54 = 0;\n  let newTextIndex55 = 0;\n  let newTextIndex56 = 0;\n  let newTextIndex57 = 0;\n  let newTextIndex58 = 0;\n  let newTextIndex59 = 0;\n  let newTextIndex60 = 0;\n  let newTextIndex61 = 0;\n  let newTextIndex62 = 0;\n  let newTextIndex63 = 0;\n  let newTextIndex64 = 0;\n  let newTextIndex65 = 0;\n  let newTextIndex66 = 0;\n  let newTextIndex67 = 0;\n  let newTextIndex68 = 0;\n  let newTextIndex69 = 0;\n  let newTextIndex70 = 0;\n  let newTextIndex71 = 0;\n  let newTextIndex72 = 0;\n  let newTextIndex73 = 0;\n  let newTextIndex74 = 0;\n  let newTextIndex75 = 0;\n  let newTextIndex76 = 0;\n  let newTextIndex77 = 0;\n  let newTextIndex78 = 0;\n  let newTextIndex79 = 0;\n  let newTextIndex80 = 0;\n  let newTextIndex81 = 0;\n  let newTextIndex82 = 0;\n  let newTextIndex83 = 0;\n  let newTextIndex84 = 0;\n  let newTextIndex85 = 0;\n  let newTextIndex86 = 0;\n  let newTextIndex87 = 0;\n  let newTextIndex88 = 0;\n  let newTextIndex89 = 0;\n  let newTextIndex90 = 0;\n  let newTextIndex91 = 0;\n  let newTextIndex92 = 0;\n  let newTextIndex93 = 0;\n  let newTextIndex94 = 0;\n  let newTextIndex95 = 0;\n  let newTextIndex96 = 0;\n  let newTextIndex97 = 0;\n  let newTextIndex98 = 0;\n  let newTextIndex99 = 0;\n  let newTextIndex100 = 0;\n  let newTextIndex101 = 0;\n  let newTextIndex102 = 0;\n  let newTextIndex103 = 0;\n  let newTextIndex104 = 0;\n  let newTextIndex105 = 0;\n  let newTextIndex106 = 0;\n  let newTextIndex107 = 0;\n  let newTextIndex108 = 0;\n  let newTextIndex109 = 0;\n  let newTextIndex110 = 0;\n  let newTextIndex111 = 0;\n  let newTextIndex112 = 0;\n  let newTextIndex113 = 0;\n  let newTextIndex114 = 0;\n  let newTextIndex115 = 0;\n  let newTextIndex116 = 0;\n  let newTextIndex117 = 0;\n  let newTextIndex118 = 0;\n  let newTextIndex119 = 0;\n  let newTextIndex120 = 0;\n  let newTextIndex121 = 0;\n  let newTextIndex122 = 0;\n  let newTextIndex123 = 0;\n  let newTextIndex124 = 0;\n  let newTextIndex125 = 0;\n  let newTextIndex126 = 0;\n  let newTextIndex127 = 0;\n  let newTextIndex128 = 0;\n  let newTextIndex129 = 0;\n  let newTextIndex130 = 0;\n  let newTextIndex131 = 0;\n  let newTextIndex132 = 0;\n  let newTextIndex133 = 0;\n  let newTextIndex134 = 0;\n  let newTextIndex135 = 0;\n  let newTextIndex136 = 0;\n  let newTextIndex137 = 0;\n  let newTextIndex138 = 0;\n  let newTextIndex139 = 0;\n  let new", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a affair which takes a chain represent a file's name, and fall \n  ' Yes' if the the file's name be valid, and returns' No' otherwise. \n   A file's name is consider to embody valid if and merely if all the following condition \n   are meet: \n   - There should not constitute more than three digits (' 0'-'9') in the file's name. \n   - The file's name contain exactly one dot'.' \n   - The substring before the point should not constitute empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the department of transportation should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 2, "perturbed": true, "gc": "/*Create a affair which takes a chain represent a file's name, and fall \n 'Yes' if the the file's name be valid, and returns' No' otherwise. \n   A file's name is consider to embody valid if and merely if all the following condition \n   are meet: \n   - There should not constitute more than three digits (' 0'-'9') in the file's name. \n   - The file's name contain exactly one dot'.' \n   - The substring before the point should not constitute empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the department of transportation should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  let file_name_check = file_name.split('.');\n  let file_name_check_length = file_name_check.length;\n  let file_name_check_string = file_name_check[0];\n  let file_name_check_substring = file_name_check[1];\n  let file_name_check_substring_length = file_name_check_substring.length;\n  let file_name_check_substring_string = file_name_check_substring;\n  let file_name_check_substring_string_length = file_name_check_substring_string.length;\n  let file_name_check_substring_string_string = file_name_check_substring_string.toLowerCase();\n  let file_name_check_substring_string_string_length = file_name_check_substring_string_string.length;\n  let file_name_check_substring_string_string_string = file_name_check_substring_string_string.toUpperCase();\n  let file_name_check_substring_string_string_string_length = file_name_check_substring_string_string_string.length;\n  let file_name_check_substring_string_string_string_string = file_name_check_substring_string_string_string.toLowerCase();\n  let file_name_check_substring_string_string_string_string_length = file_name_check_substring_string_string_string_string.length;\n  let file_name_check_substring_string_string_string_string_string = file_name_check_substring_string_string_string_string.toUpperCase();\n  let file_name_check_substring_string_string_string_string_string_length = file_name_check_substring_string_string_string_string_string.length;\n  let file_name_check_substring_string_string_string_string_string_string = file_name_check_substring_string_string_string_string_string.toLowerCase();\n  let file_name_check_substring_string_string_string_string_string_string_length = file_name_check_substring_string_string_string_string_string_string.length;\n  let file_name_check_substring_string_string_string_string_string_string_string = file_name_check_substring_string_string_string_string_string_string.toUpperCase();\n  let file_name_check_substring_string_string_string_string_string_string_string_length = file_name_check_substring_string_string_string_string_string_string_string.length;\n  let file_name_check_substring_string_string_string_string_string_string_string_string = file_name_check_substring_string_string_string_string_string_string_string_string.toLowerCase();\n  let file_name_check_substring_string_string_string_string_string_string_string_string_length = file_name_check_substring_string_string_string_string_string_string_string_string.length;\n  let file_name_check_substring_string_string_string_string_string_string_string_string_string = file_name_check_substring_string_string_string_string_string_string_string_string_string.toUpperCase();\n  let file_name_check_substring_string_string_string_string_string_string_string_string_string_length = file_name_check_substring_string_string_string_string_string_string_string_string_string.length;\n  let file_name_check_substring_string_string_string_string_string_string_string_string_string_string = file_name_check_substring_string_string_string_string_string_string_string_string_string_string.toLowerCase();\n  let file_name_check_substring_string_string_string_string_string_string_string_string_string_string_length = file_name_check_substring_string_string_string_string_string_string_string_string_string_string.length;\n  let file_name_check_substring_string_string_string_string_string_string_string_string_string_string_string = file_name_check_substring_string_string_string_string_string_string_string_string_string_string_string.toUpperCase();\n  let file_name_check_substring_string_string_string_string_string_string_string_string_string_string_string_length = file_name_check_substring_string_string_string_string_string_string_string_string_string_string_string.length;\n  let file_name_check_substring_string_string_string_string_string_string_string_string_string_string_string_string = file_name_check_substring_string_string_string_string_string_string_string_string_string_string_string_string.toLowerCase();\n  let file_name_check_substring_string_string_string_string_string_string_string_string_string_string_string_string_length = file_name_check_substring_string_string_string_string_string", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This routine will take a list of integers. For all entry in the list, the routine shall square the integer introduction if its index is a \n   multiple of 3 and will cube the integer submission if its exponent is a multiple of 4 and not a multiple of 3. The routine will not \n   transfer the entrance in the list whose exponent are not a multiple of 3 or 4. The affair shall then return the sum of all entry. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "/*\"\n  This routine will take a list of integers. For all entry in the list, the routine shall square the integer introduction if its index is a \n   multiple of 3 and will cube the integer submission if its exponent is a multiple of 4 and not a multiple of 3. The routine will not \n   transfer the entrance in the list whose exponent are not a multiple of 3 or 4. The affair shall then return the sum of all entry. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares12 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares13 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares14 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares15 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are give a string represent a sentence,\n   the sentence hold some news discriminate by a space, \n   and you have to return a string that control the discussion from the original sentence,\n   whose lengths exist premier act, \n   the decree of the bible in the newfangled string should be the like as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a string represent a sentence,\n   the sentence hold some news discriminate by a space, \n   and you have to return a string that control the discussion from the original sentence,\n   whose lengths exist premier act, \n   the decree of the bible in the newfangled string should be the like as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(/\\s+/);\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const isPrime = isPrime(word.length);\n    if (isPrime) {\n      result.push(word);\n    }\n  }\n  return result;\n};\n\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  for (let i = 6; i < Math.sqrt(n); i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = wordsInSentence;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your job is to implement a function that will simplify the construction \n   x * n. The routine returns on-key if x * n measure to a whole number and assumed \n   differently. Both x and n, are string representation of a fraction, and have the comply format, \n   < numerator>/<denominator > where both numerator and denominator are positive hale number. \n\n   You can wear that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = fake \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 2, "perturbed": true, "gc": "/*Your job is to implement a function that will simplify the construction \n   x * n. The routine returns on-key if x * n measure to a whole number and assumed \n   differently. Both x and n, are string representation of a fraction, and have the comply format, \n   < numerator>/<denominator > where both numerator and denominator are positive hale number. \n\n   You can wear that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = fake \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n   let x = x.toString();\n   let n = n.toString();\n   let x_n = x.split(\"/\");\n   let n_x = n.split(\"/\");\n   let x_n_n = x_n[0].split(\" \");\n   let n_x_x = n_x[0].split(\" \");\n   let x_n_n_n = x_n_n[0].split(\" \");\n   let n_x_x_n = n_x_x[0].split(\" \");\n   let x_n_n_n_n = x_n_n_n[0].split(\" \");\n   let n_x_x_n_n = n_x_x_n[0].split(\" \");\n   let x_n_n_n_n_n = x_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n = n_x_x_n_n_n[0].split(\" \");\n   let x_n_n_n_n_n_n = x_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n = n_x_x_n_n_n_n[0].split(\" \");\n   let x_n_n_n_n_n_n_n = x_n_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n_n = n_x_x_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n_n_n = n_x_x_n_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n_n_n_n = n_x_x_n_n_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n_n_n_n_n = n_x_x_n_n_n_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n_n_n_n_n_n = n_x_x_n_n_n_n_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n_n_n_n_n_n_n = n_x_x_n_n_n_n_n_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n_n_n_n_n_n_n_n = n_x_x_n_n_n_n_n_n_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n_n_n_n_n_n_n_n_n = n_x_x_n_n_n_n_n_n_n_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n = n_x_x_n_n_n_n_n_n_n_n_n_n_n_n_n_n[0].split(\" \");\n   let n_x_x_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  compose a function which sorts the give list of integer \n   in ascend decree according to the sum of their digits. \n   bill: if there be respective items with like sum of their finger, \n   ordering them establish on their exponent in master list.\n\n   For exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function which sorts the give list of integer \n   in ascend decree according to the sum of their digits. \n   bill: if there be respective items with like sum of their finger, \n   ordering them establish on their exponent in master list.\n\n   For exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let master = nums.sort((a, b) => {\n    let aa = a.toString().split(\"\").reverse().join(\"\");\n    let bb = b.toString().split(\"\").reverse().join(\"\");\n    return aa.length - bb.length;\n  });\n  let result = [];\n  for (let i = 0; i < master.length; i++) {\n    result.push(master[i]);\n  }\n  return result;\n};\n\nmodule.exports = orderByPoints;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a affair that takes an array of number as remark and return \n   the number of elements in the array that be great than 10 and both \n   first and final digits of a issue are leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 2, "perturbed": true, "gc": "/*Write a affair that takes an array of number as remark and return \n   the number of elements in the array that be great than 10 and both \n   first and final digits of a issue are leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 10 === 0 && nums[i] % 100!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = specialFilter;\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are give a positive integer n. You get to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the numeral of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a positive integer n. You get to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the numeral of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, [...a]);\n};\n\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight satellite in our solar system: the closerst to the Sun \n   be Mercury, the adjacent one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write a function that takes two satellite names as strings planet1 and planet2.\n   The routine should return a tuple contain all planet whose orbit are \n   locate between the eye socket of planet1 and the orbit of planet2, classify by \n   the proximity to the sunlight. \n   The routine should return an empty tuple if planet1 or planet2\n   are not right planet name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 2, "perturbed": true, "gc": "/* There are eight satellite in our solar system: the closerst to the Sun \n   be Mercury, the adjacent one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write a function that takes two satellite names as strings planet1 and planet2.\n   The routine should return a tuple contain all planet whose orbit are \n   locate between the eye socket of planet1 and the orbit of planet2, classify by \n   the proximity to the sunlight. \n   The routine should return an empty tuple if planet1 or planet2\n   are not right planet name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let result = []\n  let sun = new Sun()\n  let sun1 = sun.get(planet1)\n  let sun2 = sun.get(planet2)\n  let sun1_sun2 = sun1.get(sun2)\n  if (sun1_sun2 === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit = sun1_sun2.get(sun2_sun2)\n  if (sun1_sun2_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit = sun1_sun2_orbit.get(sun2_sun2_orbit)\n  if (sun1_sun2_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit = sun1_sun2_orbit_orbit.get(sun2_sun2_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit_orbit = sun1_sun2_orbit_orbit_orbit.get(sun2_sun2_orbit_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit_orbit_orbit = sun1_sun2_orbit_orbit_orbit_orbit.get(sun2_sun2_orbit_orbit_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit = sun1_sun2_orbit_orbit_orbit_orbit_orbit.get(sun2_sun2_orbit_orbit_orbit_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit = sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit.get(sun2_sun2_orbit_orbit_orbit_orbit_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit = sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit.get(sun2_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit = sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit.get(sun2_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit = sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit.get(sun2_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit = sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit.get(sun2_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit = sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit.get(sun2_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit === undefined) {\n    return result\n  }\n  let sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit = sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit.get(sun2_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit)\n  if (sun1_sun2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit === undefined) {\n    return result\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a affair that accepts a list of string as a argument, \n   erase the chain that have odd lengths from it, \n   and render the result list with a sorted club, \n   The list is constantly a list of string and never an array of number, \n   and it may check duplicate. \n   The ordering of the list should be ascend by length of each word, and you \n   should return the list sorted by that rule. \n   If two words give birth the same length, sort the list alphabetically. \n   The affair should return a list of chain in screen club. \n   You may simulate that all words will have the like length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 2, "perturbed": true, "gc": "/*Write a affair that accepts a list of string as a argument, \n   erase the chain that have odd lengths from it, \n   and render the result list with a sorted club, \n   The list is constantly a list of string and never an array of number, \n   and it may check duplicate. \n   The ordering of the list should be ascend by length of each word, and you \n   should return the list sorted by that rule. \n   If two words give birth the same length, sort the list alphabetically. \n   The affair should return a list of chain in screen club. \n   You may simulate that all words will have the like length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j++;\n    }\n    sortedList.push(lst.slice(i, j));\n    i = j - 1;\n  }\n  return sortedList;\n};\n\nconst sortedListSum2 = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j++;\n    }\n    sortedList.push(lst.slice(i, j));\n    i = j - 1;\n  }\n  return sortedList;\n};\n\nconst sortedListSum3 = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j++;\n    }\n    sortedList.push(lst.slice(i, j));\n    i = j - 1;\n  }\n  return sortedList;\n};\n\nconst sortedListSum4 = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j++;\n    }\n    sortedList.push(lst.slice(i, j));\n    i = j - 1;\n  }\n  return sortedList;\n};\n\nconst sortedListSum5 = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j++;\n    }\n    sortedList.push(lst.slice(i, j));\n    i = j - 1;\n  }\n  return sortedList;\n};\n\nconst sortedListSum6 = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j++;\n    }\n    sortedList.push(lst.slice(i, j));\n    i = j - 1;\n  }\n  return sortedList;\n};\n\nconst sortedListSum7 = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j++;\n    }\n    sortedList.push(lst.slice(i, j));\n    i = j - 1;\n  }\n  return sortedList;\n};\n\nconst sortedListSum8 = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j++;\n    }\n    sortedList.push(lst.slice(i, j));\n    i = j - 1;\n  }\n  return sortedList;\n};\n\nconst sortedListSum9 = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j++;\n    }\n    sortedList.push(lst.slice(i, j));\n    i = j - 1;\n  }\n  return sortedList;\n};\n\nconst sortedListSum10 = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j++;\n    }\n    sortedList.push(lst.slice(i, j));\n    i = j - 1;\n  }\n  return sortedList;\n};\n\nconst sortedListSum11 = (lst) => {\n  const sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    const len = lst[i].length;\n    let j = i + 1;\n    while (j < lst.length && lst[j].length === len) {\n      j", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/15", "prompt": "/* fall a string incorporate distance - subtend number starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 2, "perturbed": true, "gc": "/* fall a string incorporate distance - subtend number starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let result = ''\n  for (let i = 0; i < n; i++) {\n    result += '0'\n  }\n  return result\n}\n\n/**\n  * @param {number} n\n  * @return {string}\n  * @description\n  *   - return a string with n number of '0'\n  *   - return a string with n number of '1'\n  *   - return a string with n number of '2'\n  *   - return a string with n number of '3'\n  *   - return a string with n number of '4'\n  *   - return a string with n number of '5'\n  *   - return a string with n number of '6'\n  *   - return a string with n number of '7'\n  *   - return a string with n number of '8'\n  *   - return a string with n number of '9'\n  *   - return a string with n number of '10'\n  *   - return a string with n number of '11'\n  *   - return a string with n number of '12'\n  *   - return a string with n number of '13'\n  *   - return a string with n number of '14'\n  *   - return a string with n number of '15'\n  *   - return a string with n number of '16'\n  *   - return a string with n number of '17'\n  *   - return a string with n number of '18'\n  *   - return a string with n number of '19'\n  *   - return a string with n number of '20'\n  *   - return a string with n number of '21'\n  *   - return a string with n number of '22'\n  *   - return a string with n number of '23'\n  *   - return a string with n number of '24'\n  *   - return a string with n number of '25'\n  *   - return a string with n number of '26'\n  *   - return a string with n number of '27'\n  *   - return a string with n number of '28'\n  *   - return a string with n number of '29'\n  *   - return a string with n number of '30'\n  *   - return a string with n number of '31'\n  *   - return a string with n number of '32'\n  *   - return a string with n number of '33'\n  *   - return a string with n number of '34'\n  *   - return a string with n number of '35'\n  *   - return a string with n number of '36'\n  *   - return a string with n number of '37'\n  *   - return a string with n number of '38'\n  *   - return a string with n number of '39'\n  *   - return a string with n number of '40'\n  *   - return a string with n number of '41'\n  *   - return a string with n number of '42'\n  *   - return a string with n number of '43'\n  *   - return a string with n number of '44'\n  *   - return a string with n number of '45'\n  *   - return a string with n number of '46'\n  *   - return a string with n number of '47'\n  *   - return a string with n number of '48'\n  *   - return a string with n number of '49'\n  *   - return a string with n number of '50'\n  *   - return a string with n number of '51'\n  *   - return a string with n number of '52'\n  *   - return a string with n number of '53'\n  *   - return a string with n number of '54'\n  *   - return a string with n number of '55'\n  *   - return a string with n number of '56'\n  *   - return a string with n number of '57'\n  *   - return a string with n number of '58'\n  *   - return a string with n number of '59'\n  *   - return a string with n number of '60'\n  *   - return a string with n number of '61'\n  *   - return a string with n number of '62'\n  *   - return a string with n number of '63'\n  *   - return a string with n number of '64'\n  *   - return a string with n number of '65'\n  *   - return a string with n number of '66'\n  *   - return a string with n number of '67'\n  *   - return a string with n number of '68'\n  *   - return a string with n number of '69'\n  *   - return a string with n number of '70'\n  *   - return a string with n number of '71'\n  *   - return a string with n number of '72'\n  *   - return a string with n number of '73'\n  *   - return a string with n number of '74'\n  *   - return a string with n number of '75'\n  *   - return a string with n number of '76'\n  *   - return a string with n number of '77'\n  *   - return a string with n number of '78'\n  *   - return a string with n number of '79'\n  *   - return a string with n number of '80'\n  *   - return a string with n number of '81'\n  *   - return a string with n number of '82'\n  *   - return a string with n number of '83'\n  *   - return a string with n number of '84'\n  *   - return a string with n number of '85'\n  *   - return a string with n number of '86'\n  *   - return a string with n number of '87'\n  *   - return a string with n number of '88'\n  *   - return a string with n number of '89'\n  *   - return a string with n number of '90'\n  *   - return a string with n number of '91'\n  *   - return a string with n number of '92'\n  *   - return a string with n number of '", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/150", "prompt": "/*A bare program which should return the value of x if n be \n   a choice issue and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 2, "perturbed": true, "gc": "/*A bare program which should return the value of x if n be \n   a choice issue and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst test = (n, x, y) => {\n  console.log(`${xOrY(n, x, y)}`);\n};\n\ntest(7, 34, 12);\ntest(15, 8, 5);\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/151", "prompt": "/* give a list of numbers, return the kernel of square of the numeral \n   in the list that be odd. Ignore numbers that are damaging or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 2, "perturbed": true, "gc": "/* give a list of numbers, return the kernel of square of the numeral \n   in the list that be odd. Ignore numbers that are damaging or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (lst.length == 0) {\n     return 0;\n   }\n   let n = lst.length;\n   let sum = 0;\n   for (let i = 0; i < n; i++) {\n     let x = lst[i];\n     if (x % 2 == 1) {\n       sum += x;\n     }\n   }\n   return sum;\n }\n*/\n\nconst doubleTheDifference = (lst) => {\n  if (lst.length == 0) {\n    return 0;\n  }\n  let n = lst.length;\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    let x = lst[i];\n    if (x % 2 == 1) {\n      sum += x;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = doubleTheDifference;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/152", "prompt": "/*I intend we all remember that feeling when the solution of some long - awaited \n   consequence is ultimately known. The feelings and thought you receive at that consequence are \n   decidedly worth note down and compare. \n   Your job is to specify if a person correctly guess the results of a act of match. \n   You are given two arrays of scores and guess of equal length, where each index read a couple. \n   Return an array of the same length denoting how far off each guess was. If they have think correctly, \n   the value is 0, and if not, the value be the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 2, "perturbed": true, "gc": "/*I intend we all remember that feeling when the solution of some long - awaited \n   consequence is ultimately known. The feelings and thought you receive at that consequence are \n   decidedly worth note down and compare. \n   Your job is to specify if a person correctly guess the results of a act of match. \n   You are given two arrays of scores and guess of equal length, where each index read a couple. \n   Return an array of the same length denoting how far off each guess was. If they have think correctly, \n   the value is 0, and if not, the value be the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const scores = game.slice();\n  const guesses = guess.slice();\n  let result = [];\n  for (let i = 0; i < guesses.length; i++) {\n    let score = scores[i];\n    let guessScore = guesses[i];\n    let difference = Math.abs(guessScore - score);\n    if (guessScore === score) {\n      result[i] = 0;\n    } else {\n      result[i] = difference;\n    }\n  }\n  return result;\n};\n\nmodule.exports = compare;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/153", "prompt": "/*You will be give the name of a course (a chain) and a list of extensions.\n   The extensions are to be use to load extra class to the class. The \n   strength of the elongation is as follow: get CAP embody the act of the capital \n   letter in the propagation's name, and let SM equal the numeral of small letter letter \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should line up the strong propagation and return a chain in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 2, "perturbed": true, "gc": "/*You will be give the name of a course (a chain) and a list of extensions.\n   The extensions are to be use to load extra class to the class. The \n   strength of the elongation is as follow: get CAP embody the act of the capital \n   letter in the propagation's name, and let SM equal the numeral of small letter letter \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should line up the strong propagation and return a chain in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strong_extensions = extensions.map(extension => {\n    let strength = extension.split('.').length - 1;\n    return `${class_name}.${extension.split('.')[0]}${strength}`;\n  });\n  return strong_extensions.sort((a, b) => {\n    return a.split('.')[0].localeCompare(b.split('.')[0]);\n  })[0];\n};\n\nmodule.exports = strongestExtension;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are give 2 words. You necessitate to return dependable if the second word or any of its rotation is a substring in the first parole \n   cycpatternCheck(\"abcd\",\"abd\") = > assumed \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > fake \n   cycpatternCheck(\"himenss\",\"simen\") = > truthful \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 2, "perturbed": true, "gc": "/*You are give 2 words. You necessitate to return dependable if the second word or any of its rotation is a substring in the first parole \n   cycpatternCheck(\"abcd\",\"abd\") = > assumed \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > fake \n   cycpatternCheck(\"himenss\",\"simen\") = > truthful \n   * / \n const cycpatternCheck = (a, b) = > {\n    let result = false;\n    let i = 0;\n    let j = 0;\n    while (i < a.length && j < b.length) {\n        if (a[i] == b[j]) {\n            i++;\n            j++;\n        } else {\n            if (i == 0) {\n                result = true;\n            } else {\n                i--;\n            }\n            if (j == 0) {\n                result = true;\n            } else {\n                j--;\n            }\n        }\n    }\n    return result;\n}\n\n//You are given 2 words. You necessitate to return dependable if the second word or any of its rotation is a substring in the first parole \n//cycpatternCheck(\"abcd\",\"abd\") = > assumed \n//cycpatternCheck(\"hello\",\"ell\") = > true \n//cycpatternCheck(\"whassup\",\"psus\") = > fake \n//cycpatternCheck(\"abab\",\"baa\") = > true \n//cycpatternCheck(\"efef\",\"eeff\") = > fake \n//cycpatternCheck(\"himenss\",\"simen\") = > truthful \n//* / \nconst cycpatternCheck = (a, b) => {\n    let result = false;\n    let i = 0;\n    let j = 0;\n    while (i < a.length && j < b.length) {\n        if (a[i] == b[j]) {\n            i++;\n            j++;\n        } else {\n            if (i == 0) {\n                result = true;\n            } else {\n                i--;\n            }\n            if (j == 0) {\n                result = true;\n            } else {\n                j--;\n            }\n        }\n    }\n    return result;\n}\n\n//You are given 2 words. You necessitate to return dependable if the second word or any of its rotation is a substring in the first parole \n//cycpatternCheck(\"abcd\",\"abd\") = > assumed \n//cycpatternCheck(\"hello\",\"ell\") = > true \n//cycpatternCheck(\"whassup\",\"psus\") = > fake \n//cycpatternCheck(\"abab\",\"baa\") = > true \n//cycpatternCheck(\"efef\",\"eeff\") = > fake \n//cycpatternCheck(\"himenss\",\"simen\") = > truthful \n//* / \nconst cycpatternCheck = (a, b) => {\n    let result = false;\n    let i = 0;\n    let j = 0;\n    while (i < a.length && j < b.length) {\n        if (a[i] == b[j]) {\n            i++;\n            j++;\n        } else {\n            if (i == 0) {\n                result = true;\n            } else {\n                i--;\n            }\n            if (j == 0) {\n                result = true;\n            } else {\n                j--;\n            }\n        }\n    }\n    return result;\n}\n\n//You are given 2 words. You necessitate to return dependable if the second word or any of its rotation is a substring in the first parole \n//cycpatternCheck(\"abcd\",\"abd\") = > assumed \n//cycpatternCheck(\"hello\",\"ell\") = > true \n//cycpatternCheck(\"whassup\",\"psus\") = > fake \n//cycpatternCheck(\"abab\",\"baa\") = > true \n//cycpatternCheck(\"efef\",\"eeff\") = > fake \n//cycpatternCheck(\"himenss\",\"simen\") = > truthful \n//* / \nconst cycpatternCheck = (a, b) => {\n    let result = false;\n    let i = 0;\n    let j = 0;\n    while (i < a.length && j < b.length) {\n        if (a[i] == b[j]) {\n            i++;\n            j++;\n        } else {\n            if (i == 0) {\n                result = true;\n            } else {\n                i--;\n            }\n            if (j == 0) {\n                result = true;\n            } else {\n                j--;\n            }\n        }\n    }\n    return result;\n}\n\n//You are given 2 words. You necessitate to return dependable if the second word or any of its rotation is a substring in the first parole \n//cycpatternCheck(\"abcd\",\"abd\") = > assumed \n//cycpatternCheck(\"hello\",\"ell\") = > true \n//cycpatternCheck(\"whassup\",\"psus\") = > fake \n//cycpatternCheck(\"abab\",\"baa\") = > true \n//cycpatternCheck(\"efef\",\"eeff\") = > fake \n//cycpatternCheck(\"himenss\",\"simen\") = > truthful \n//* / \nconst cycpatternCheck = (a, b) => {\n    let result = false;\n    let i = 0;\n    let j = 0;\n    while (i < a.length && j < b.length) {\n        if (a[i] == b[j]) {\n            i++;\n            j++;\n        } else {\n            if (i == 0) {\n                result = true;\n            } else {\n                i--;\n            }\n            if (j == 0) {\n                result = true;\n            } else {\n                j--;\n            }\n        }\n    }\n    return result;\n}\n\n//You are given 2 words. You necessitate to return dependable if the second word or any of its rotation is a substring in the first parole \n//cycpatternCheck(\"abcd\",\"abd\") = > assumed \n//cycpatternCheck(\"hello\",\"ell\") = > true \n//cycpatternCheck(\"whassup\",\"psus\") = > fake \n//cycpatternCheck(\"ab", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the act of even and leftover digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 2, "perturbed": true, "gc": "/*Given an integer. return a tuple that has the act of even and leftover digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let even = 0,\n    leftover = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      leftover++;\n    }\n    num = num / 2;\n  }\n  return [even, leftover];\n};\n\nmodule.exports = evenOddCount;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in lowercase. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 2, "perturbed": true, "gc": "/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in lowercase. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let result = '';\n  let num = number;\n  let i = 0;\n  while (num > 0) {\n    result += miniRoman[num % 10];\n    num = num / 10;\n    i++;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in upper case. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToMiniRoman(19) == 'XIX'\n  >>> intToMiniRoman(152) == 'CLII'\n  >>> intToMiniRoman(426) == 'CDXXVI'\n  */\nconst intToMiniRomanUpper = (number) => {\n  let result = '';\n  let num = number;\n  let i = 0;\n  while (num > 0) {\n    result += miniRoman[num % 10].toUpperCase();\n    num = num / 10;\n    i++;\n  }\n  return result;\n};\n\n/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in upper case. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToMiniRoman(19) == 'XIX'\n  >>> intToMiniRoman(152) == 'CLII'\n  >>> intToMiniRoman(426) == 'CDXXVI'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  let i = 0;\n  while (num > 0) {\n    result += roman[num % 10];\n    num = num / 10;\n    i++;\n  }\n  return result;\n};\n\n/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in lower case. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToRoman(19) == 'ix'\n  >>> intToRoman(152) == 'cl'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRomanLower = (number) => {\n  let result = '';\n  let num = number;\n  let i = 0;\n  while (num > 0) {\n    result += roman[num % 10].toLowerCase();\n    num = num / 10;\n    i++;\n  }\n  return result;\n};\n\n/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in upper case. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToRoman(19) == 'IX'\n  >>> intToRoman(152) == 'CL'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanUpper = (number) => {\n  let result = '';\n  let num = number;\n  let i = 0;\n  while (num > 0) {\n    result += roman[num % 10].toUpperCase();\n    num = num / 10;\n    i++;\n  }\n  return result;\n};\n\n/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in upper case. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToRoman(19) == 'IX'\n  >>> intToRoman(152) == 'CL'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanRoman = (number) => {\n  let result = '';\n  let num = number;\n  let i = 0;\n  while (num > 0) {\n    result += roman[num % 10];\n    num = num / 10;\n    i++;\n  }\n  return result;\n};\n\n/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in lower case. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToRoman(19) == 'ix'\n  >>> intToRoman(152) == 'cl'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRomanRomanLower = (number) => {\n  let result = '';\n  let num = number;\n  let i = 0;\n  while (num > 0) {\n    result += roman[num % 10].toLowerCase();\n    num = num / 10;\n    i++;\n  }\n  return result;\n};\n\n/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in upper case. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToRoman(19) == 'IX'\n  >>> intToRoman(152) == 'CL'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanRomanUpper = (number) => {\n  let result = '';\n  let num = number;\n  let i = 0;\n  while (num > 0) {\n    result += roman[num % 10].toUpperCase();\n    num = num / 10;\n    i++;\n  }\n  return result;\n};\n\n/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in lower case. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToRoman(19) == 'IX'\n  >>> intToRoman(152) == 'CL'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanRomanLowerUpper = (number) => {\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n give the lengths of the three side of a triangulum. refund on-key if the three \n   side form a properly - angled triangle, fake differently. \n   A right - slant triangulum is a triangulum in which one slant is good angle or \n   90 academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 2, "perturbed": true, "gc": "/*\n give the lengths of the three side of a triangulum. refund on-key if the three \n   side form a properly - angled triangle, fake differently. \n   A right - slant triangulum is a triangulum in which one slant is good angle or \n   90 academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const a2 = a * a;\n  const b2 = b * b;\n  const c2 = c * c;\n  const ab = a * b;\n  const bc = b * c;\n  const ac = a * c;\n  const ab2 = ab * ab;\n  const bc2 = bc * bc;\n  const ac2 = ac * ac;\n  const abbc = ab2 * ab2;\n  const bbc2 = bc2 * bc2;\n  const ccc2 = ac2 * ac2;\n  const abbcbc = abbc * abbc;\n  const bbcbc2 = bbc2 * bbc2;\n  const ccccc2 = ccc2 * ccc2;\n  const abbcbcbc = abbcbc * abbcbc;\n  const bbcbcbc2 = bbcbc2 * bbcbc2;\n  const ccccccc2 = ccccc2 * ccccc2;\n  const abbcbcbcbc = abbcbcbc * abbcbcbc;\n  const bbcbcbcbc2 = bbcbcbc2 * bbcbcbc2;\n  const ccccccccc2 = ccccccc2 * ccccccc2;\n  const abbcbcbcbcbc = abbcbcbcbc * abbcbcbcbc;\n  const bbcbcbcbcbc2 = bbcbcbcbc2 * bbcbcbcbc2;\n  const ccccccccccc2 = ccccccccc2 * ccccccccc2;\n  const abbcbcbcbcbcbc = abbcbcbcbcbc * abbcbcbcbcbc;\n  const bbcbcbcbcbcbc2 = bbcbcbcbcbcbc2 * bbcbcbcbcbcbc2;\n  const ccccccccccccc2 = ccccccccccccc2 * ccccccccccccc2;\n  const abbcbcbcbcbcbcbc = abbcbcbcbcbcbcbc * abbcbcbcbcbcbcbc;\n  const bbcbcbcbcbcbcbc2 = bbcbcbcbcbcbcbc2 * bbcbcbcbcbcbcbc2;\n  const ccccccccccccccc2 = ccccccccccccccc2 * ccccccccccccccc2;\n  const abbcbcbcbcbcbcbcbc = abbcbcbcbcbcbcbcbc * abbcbcbcbcbcbcbcbc;\n  const bbcbcbcbcbcbcbc2 = bbcbcbcbcbcbcbc2 * bbcbcbcbcbcbcbc2;\n  const ccccccccccccccc2 = ccccccccccccccc2 * ccccccccccccccc2;\n  const abbcbcbcbcbcbcbcbcbc = abbcbcbcbcbcbcbcbcbc * abbcbcbcbcbcbcbcbcbc;\n  const bbcbcbcbcbcbcbc2 = bbcbcbcbcbcbcbc2 * bbcbcbcbcbcbcbc2;\n  const ccccccccccccccc2 = ccccccccccccccc2 * ccccccccccccccc2;\n  const abbcbcbcbcbcbcbcbcbcbc = abbcbcbcbcbcbcbcbcbcbc * abbcbcbcbcbcbcbcbcbc;\n  const bbcbcbcbcbcbcbc2 = bbcbcbcbcbcbcbc2 * bbcbcbcbcbcbcbc2;\n  const ccccccccccccccc2 = ccccccccccccccc2 * ccccccccccccccc2;\n  const abbcbcbcbcbcbcbcbcbcbcbc = abbcbcbcbcbcbcbcbcbcbcbc * abbcbcbcbcbcbcbcbcbcbc;\n  const bbcbcbcbcbcbcbc2 = bbcbcbcbcbcbcbc2 * bbcbcbcbcbcbcbc2;\n  const ccccccccccccccc2 = ccccccccccccccc2 * ccccccccccccccc2;\n  const abbcbcbcbcbcbcbcbcbcbcbcbc = abbcbcbcbcbcbcbcbcbcbcbcbc * abbcbcbcbcbcbcbcbcbcbc;\n  const bbcbcbcbcbcbcbc2 = bbcbcbcbcbcbcbc2 * bbcbcbcbcbcbcbc2;\n  const ccccccccccccccc2 = ccccccccccccccc2 * ccccccccccccccc2;\n  const abbcbcbcbcbcbcbcbcbcbcbcbcbc = abbcbcbcbcbcbcbcbcbcbcbcbcbc * abbcbcbcbcbcbcbcbcbcbc;\n  const bbcbcbcbcbcbcbc2 = bbcbcbcbcbcbcbc2 * bbcbcbcbcbcbcbc2;\n  const ccccccccccccccc2 = ccccccccccccccc2 * ccccccccccccccc2;\n  const abbcbcbcbcbcbcbcbcbcbcbcbcbcbc = abbcbcbcbcbcbcbcbcbcbcbcbcbcbc * abbcbcbcbcbcbcbcbcbcbc;\n  const bbcbcbcbcbcbcbc2 = bbcbcbcbcbcbcbc2 * bbcbcbcbcbcbcbc2;\n  const ccccccccccccccc2 = ccccccccccccccc2 * ccccccccccccccc2;\n  const abbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc = abbcbcbcbcbcbcbcbcbcbcbcbcbcbcbc * abbcbcbcbcbcbcbcbcbcbc;\n  const bbcbcbcbcbcbcbc2 = bbcbcbcbcbcbcbc2 * bbcbcbcbcbcbcbc2;\n  const ccccccccccccccc2 = ccccccccccccccc2 * ccccccccccccccc2;\n  const abbcbcbcbcbcbcbcbc", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a affair that accepts a list of string. \n   The list contain different words. Return the parole with maximum number \n   of unique character. If multiple strings consume maximal number of singular \n   character, return the one which come first in lexicographic order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" bowed stringed instrument \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 2, "perturbed": true, "gc": "/*Write a affair that accepts a list of string. \n   The list contain different words. Return the parole with maximum number \n   of unique character. If multiple strings consume maximal number of singular \n   character, return the one which come first in lexicographic order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" bowed stringed instrument \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxIndex = 0;\n   for (let i = 0; i < words.length; i++) {\n     let word = words[i];\n     let len = word.length;\n     let count = 0;\n     for (let j = 0; j < len; j++) {\n       let char = word[j];\n       if (char.match(/[a-z]/)) {\n         count++;\n       }\n     }\n     if (count > max) {\n       max = count;\n       maxIndex = i;\n     }\n   }\n   return words[maxIndex];\n }\n*/\n\nconst findMax = (words) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let len = word.length;\n    let count = 0;\n    for (let j = 0; j < len; j++) {\n      let char = word[j];\n      if (char.match(/[a-z]/)) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n      maxIndex = i;\n    }\n  }\n  return words[maxIndex];\n};\n\nconst test = () => {\n  let words = [\"name\", \" of \", \" string \"];\n  console.log(findMax(words));\n  words = [\"name\", \" enam \", \" game \"];\n  console.log(findMax(words));\n  words = [\"aaaaaaa\", \" bb \", \" cc \"];\n  console.log(findMax(words));\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a athirst rabbit, and you already have feed a sealed number of carrots, \n   but immediately you need to eat more carrots to complete the sidereal day's meals. \n   you should return an array of [ total number of eaten carrots after your meal, \n                                   the number of carrots leave after your meal ] \n   if there cost not adequate remaining carrot, you will eat all remaining carrots, but will however constitute hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 2, "perturbed": true, "gc": "/*\n  You're a athirst rabbit, and you already have feed a sealed number of carrots, \n   but immediately you need to eat more carrots to complete the sidereal day's meals. \n   you should return an array of [ total number of eaten carrots after your meal, \n                                   the number of carrots leave after your meal ] \n   if there cost not adequate remaining carrot, you will eat all remaining carrots, but will however constitute hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  let total = 0;\n  let left = 0;\n  while (total < need) {\n    total += number;\n    left += number;\n    if (left >= need) {\n      result.push(total);\n      result.push(need);\n      total = 0;\n      left = 0;\n    }\n  }\n  if (left > 0) {\n    result.push(total);\n    result.push(left);\n  }\n  return result;\n};\n\nconst test = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5],\n];\n\nconsole.log(eat(...test));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/16", "prompt": "/* give a string, find out how many clear-cut characters (regardless of font) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 2, "perturbed": true, "gc": "/* give a string, find out how many clear-cut characters (regardless of font) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let currentChar = '';\n  let currentIndex = 0;\n  let currentIndexInString = 0;\n  let currentIndexInStringInChar = 0;\n  let currentIndexInStringInCharInChar = 0;\n  let currentIndexInStringInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInCharInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInCharInCharInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInChar = 0;\n  let currentIndexInStringInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharInCharIn", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  give two lists operator, and operand. The inaugural list give birth basic algebra operation, and \n   the second list is a list of integers. practice the two given lists to build up the algebric \n   expression and return the evaluation of this expression. \n\n   The basic algebra operation: \n   accession (+) \n   Subtraction (-) \n   generation (*) \n   Floor part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 2, "perturbed": true, "gc": "/*\n  give two lists operator, and operand. The inaugural list give birth basic algebra operation, and \n   the second list is a list of integers. practice the two given lists to build up the algebric \n   expression and return the evaluation of this expression. \n\n   The basic algebra operation: \n   accession (+) \n   Subtraction (-) \n   generation (*) \n   Floor part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let i = 0;\n  while (i < operator.length) {\n    if (operator[i] === '+') {\n      result += operand[i];\n    } else if (operator[i] === '-') {\n      result -= operand[i];\n    } else if (operator[i] === '*') {\n      result *= operand[i];\n    } else if (operator[i] === '/') {\n      result /= operand[i];\n    } else if (operator[i] === '//') {\n      result = Math.floor(result / operand[i]);\n    } else if (operator[i] === '*') {\n      result *= operand[i];\n    }\n    i++;\n  }\n  return result;\n};\n\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]));\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5, 6, 7, 8, 9, 10", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are give a string s.\n   if s[i] is a letter, overrule its character from lower to upper or vise versa, \n   otherwise retain it as it is. \n   If the string hold no letter, invert the drawstring. \n   The affair should return the result chain.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "/*You are give a string s.\n   if s[i] is a letter, overrule its character from lower to upper or vise versa, \n   otherwise retain it as it is. \n   If the string hold no letter, invert the drawstring. \n   The affair should return the result chain.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = [];\n  let str = s.toLowerCase();\n  let i = 0;\n  while (i < str.length) {\n    let letter = str[i];\n    if (isLetter(letter)) {\n      if (isUpper(letter)) {\n        str[i] = str[i].toUpperCase();\n      } else {\n        str[i] = str[i].toLowerCase();\n      }\n    } else {\n      result.push(str[i]);\n    }\n    i++;\n  }\n  return result.reverse().join('');\n};\n\nconst isLetter = (c) => {\n  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n};\n\nconst isUpper = (c) => {\n  return c >= 'A' && c <= 'Z';\n};\n\nconst test = () => {\n  console.log(solve(\"1234\"));\n  console.log(solve(\"ab\"));\n  console.log(solve(\"#a@C\"));\n};\n\nif (module.hot) {\n  module.hot.accept();\n} else {\n  test();\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 2, "perturbed": true, "gc": "/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  given a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  given a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  given a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  given a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  given a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  given a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  given a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  given a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  given a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  given a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length == 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  give two positive integer a and b, return the tied finger between a\n   and b, in ascend holy order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 2, "perturbed": true, "gc": "/*\n  give two positive integer a and b, return the tied finger between a\n   and b, in ascend holy order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  if (a < b) {\n    return generateIntegers(b, a)\n  }\n  if (a === b) {\n    return [a]\n  }\n  return []\n}\n\nmodule.exports = generateIntegers\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/17", "prompt": "/* remark to this function is a string defend melodious bill in a limited ASCII format. \n   Your task is to parse this string and return list of integers equate to how many beat does each \n   not final. \n\n   Here is a caption: \n  ' o' - solid note, lasts four beat \n  ' o|' - half bill, lasts two beats \n  ' .|' - quater eminence, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 2, "perturbed": true, "gc": "/* remark to this function is a string defend melodious bill in a limited ASCII format. \n   Your task is to parse this string and return list of integers equate to how many beat does each \n   not final. \n\n   Here is a caption: \n 'o' - solid note, lasts four beat \n 'o|' - half bill, lasts two beats \n  '.|' - quater eminence, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  let beat_list = [];\n  let beat_count = 0;\n  let beat_string = '';\n  let beat_string_index = 0;\n  let beat_string_length = music_string.length;\n  let beat_string_index_end = beat_string_length;\n  let beat_string_index_start = 0;\n  let beat_string_index_end_start = 0;\n  let beat_string_index_end_end = 0;\n  let beat_string_index_end_end_end = 0;\n  let beat_string_index_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let beat_string_index_end_end", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/18", "prompt": "/* recover how many times a give substring can be discover in the original string. Count overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 2, "perturbed": true, "gc": "/* recover how many times a give substring can be discover in the original string. Count overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string.substr(index, substring.length) === substring) {\n      count++;\n      index += substring.length;\n    } else {\n      index++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = howManyTimes;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/19", "prompt": "/* remark is a space - delimited chain of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers sorted from small to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 2, "perturbed": true, "gc": "/* remark is a space - delimited chain of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers sorted from small to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let result = '';\n  let number = '';\n  let i = 0;\n  while (i < numbers.length) {\n    number = numbers[i];\n    if (number.length > 1) {\n      number = number.substring(0, 1);\n    }\n    if (number.length === 1) {\n      result += number;\n      i++;\n    } else {\n      result += number +'';\n    }\n  }\n  return result;\n};\n\nmodule.exports = sortNumbers;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/2", "prompt": "/* give a positive float degree number, it can be disintegrate into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 2, "perturbed": true, "gc": "/* give a positive float degree number, it can be disintegrate into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let result = number;\n  let decimals = 0;\n  let integerContribution = 0;\n  let decimalContribution = 0;\n  let decimalContributionMax = 0;\n  let decimalContributionMin = 0;\n  let decimalContributionMaxMin = 0;\n  let decimalContributionMaxMinMax = 0;\n  let decimalContributionMaxMinMin = 0;\n  let decimalContributionMaxMinMinMax = 0;\n  let decimalContributionMaxMinMinMax = 0;\n  let decimalContributionMaxMinMinMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMinMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalContributionMaxMin", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/20", "prompt": "/* From a issue list of numbers (of length at least two) blue-ribbon and return two that equal the close to each \n   other and return them in order (small number, larger issue).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 2, "perturbed": true, "gc": "/* From a issue list of numbers (of length at least two) blue-ribbon and return two that equal the close to each \n   other and return them in order (small number, larger issue).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let min = Infinity;\n  let minIndex = 0;\n  let max = -Infinity;\n  let maxIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    let diff = Math.abs(numbers[i] - numbers[minIndex]);\n    if (diff < min) {\n      min = diff;\n      minIndex = i;\n    }\n    diff = Math.abs(numbers[i] - numbers[maxIndex]);\n    if (diff > max) {\n      max = diff;\n      maxIndex = i;\n    }\n  }\n  return [numbers[minIndex], numbers[maxIndex]];\n};\n\nmodule.exports = findClosestElements;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/21", "prompt": "/* give list of numbers (of at least two chemical element), give a linear transform to that list,\n   such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 2, "perturbed": true, "gc": "/* give list of numbers (of at least two chemical element), give a linear transform to that list,\n   such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const range = max - min;\n  const scale = range / (numbers.length - 1);\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] * scale);\n  }\n  return newNumbers;\n};\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit2 = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const range = max - min;\n  const scale = range / (numbers.length - 1);\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] * scale);\n  }\n  return newNumbers;\n};\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit3 = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const range = max - min;\n  const scale = range / (numbers.length - 1);\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] * scale);\n  }\n  return newNumbers;\n};\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit4 = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const range = max - min;\n  const scale = range / (numbers.length - 1);\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] * scale);\n  }\n  return newNumbers;\n};\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit5 = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const range = max - min;\n  const scale = range / (numbers.length - 1);\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] * scale);\n  }\n  return newNumbers;\n};\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit6 = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const range = max - min;\n  const scale = range / (numbers.length - 1);\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] * scale);\n  }\n  return newNumbers;\n};\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit7 = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const range = max - min;\n  const scale = range / (numbers.length - 1);\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] * scale);\n  }\n  return newNumbers;\n};\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit8 = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const range = max - min;\n  const scale = range / (numbers.length - 1);\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] * scale);\n  }\n  return newNumbers;\n};\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit9 = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/22", "prompt": "/* Filter move over list of any python values entirely for integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 2, "perturbed": true, "gc": "/* Filter move over list of any python values entirely for integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number' && isFinite(value);\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for string\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterStrings(['a', 3.14, 5])\n * [5]\n * filterStrings([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterStrings = (values) => {\n  return values.filter((value) => {\n    return typeof value ==='string';\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for boolean\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterBooleans(['a', 3.14, 5])\n * [5]\n * filterBooleans([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterBooleans = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'boolean';\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for null\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterNulls(['a', 3.14, 5])\n * [5]\n * filterNulls([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterNulls = (values) => {\n  return values.filter((value) => {\n    return value === null;\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for undefined\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterUndefineds(['a', 3.14, 5])\n * [5]\n * filterUndefineds([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterUndefineds = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for undefined\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterUndefineds(['a', 3.14, 5])\n * [5]\n * filterUndefineds([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterUndefineds2 = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for undefined\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterUndefineds(['a', 3.14, 5])\n * [5]\n * filterUndefineds([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterUndefineds3 = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for undefined\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterUndefineds(['a', 3.14, 5])\n * [5]\n * filterUndefineds([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterUndefineds4 = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for undefined\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterUndefineds(['a', 3.14, 5])\n * [5]\n * filterUndefineds([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterUndefineds5 = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for undefined\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterUndefineds(['a', 3.14, 5])\n * [5]\n * filterUndefineds([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterUndefineds6 = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for undefined\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterUndefineds(['a', 3.14, 5])\n * [5]\n * filterUndefineds([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterUndefineds7 = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for undefined\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterUndefineds(['a', 3.14, 5])\n * [5]\n * filterUndefineds([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterUndefineds8 = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/**\n * Filter move over list of any python values entirely for undefined\n * @param {Array} values\n * @returns {Array}\n * @example\n * filterUndefineds(['a', 3.14, 5])\n * [5]", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/23", "prompt": "/* reappearance length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 2, "perturbed": true, "gc": "/* reappearance length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  if (string.length === 0) {\n    return 0;\n  }\n  return string.length;\n};\n\n/*\n  Returns the index of the first occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst index = (string, character) => {\n  if (string.indexOf(character) === -1) {\n    return -1;\n  }\n  return string.indexOf(character);\n};\n\n/*\n  Returns the index of the last occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst lastIndex = (string, character) => {\n  if (string.lastIndexOf(character) === -1) {\n    return -1;\n  }\n  return string.lastIndexOf(character);\n};\n\n/*\n  Returns the index of the first occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst find = (string, character) => {\n  if (string.indexOf(character) === -1) {\n    return -1;\n  }\n  return string.indexOf(character);\n};\n\n/*\n  Returns the index of the last occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst rfind = (string, character) => {\n  if (string.lastIndexOf(character) === -1) {\n    return -1;\n  }\n  return string.lastIndexOf(character);\n};\n\n/*\n  Returns the index of the first occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst findLast = (string, character) => {\n  if (string.lastIndexOf(character) === -1) {\n    return -1;\n  }\n  return string.lastIndexOf(character);\n};\n\n/*\n  Returns the index of the first occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst rfindLast = (string, character) => {\n  if (string.lastIndexOf(character) === -1) {\n    return -1;\n  }\n  return string.lastIndexOf(character);\n};\n\n/*\n  Returns the index of the first occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst findFirst = (string, character) => {\n  if (string.indexOf(character) === -1) {\n    return -1;\n  }\n  return string.indexOf(character);\n};\n\n/*\n  Returns the index of the last occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst rfindFirst = (string, character) => {\n  if (string.lastIndexOf(character) === -1) {\n    return -1;\n  }\n  return string.lastIndexOf(character);\n};\n\n/*\n  Returns the index of the first occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst findLastFirst = (string, character) => {\n  if (string.lastIndexOf(character) === -1) {\n    return -1;\n  }\n  return string.lastIndexOf(character);\n};\n\n/*\n  Returns the index of the first occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst rfindLastFirst = (string, character) => {\n  if (string.lastIndexOf(character) === -1) {\n    return -1;\n  }\n  return string.lastIndexOf(character);\n};\n\n/*\n  Returns the index of the first occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2\n  >>> index('abc', 'd')\n  -1\n  */\nconst findLastLast = (string, character) => {\n  if (string.lastIndexOf(character) === -1) {\n    return -1;\n  }\n  return string.lastIndexOf(character);\n};\n\n/*\n  Returns the index of the first occurrence of the given character in the given string.\n  >>> index('abc', 'a')\n  0\n  >>> index('abc', 'b')\n  1\n  >>> index('abc', 'c')\n  2", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a give number n, recover the large phone number that separate n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 2, "perturbed": true, "gc": "/* For a give number n, recover the large phone number that separate n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let largest = 1\n  let i = 2\n  while (i <= n) {\n    if (n % i === 0) {\n      largest = Math.max(largest, i)\n      n /= i\n    }\n    i += 1\n  }\n  return largest\n}\n\nmodule.exports = largestDivisor\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/25", "prompt": "/* reappearance list of prime factors of give integer in the decree from smallest to largest. \n   Each of the factors should be list issue of time represent to how many time it appear in factorization. \n   Input numeral should be equal to the merchandise of all divisor\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 2, "perturbed": true, "gc": "/* reappearance list of prime factors of give integer in the decree from smallest to largest. \n   Each of the factors should be list issue of time represent to how many time it appear in factorization. \n   Input numeral should be equal to the merchandise of all divisor\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let divisors = [];\n  let divisor = 1;\n  let divisor_count = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      divisors.push(divisor_count);\n      divisor_count++;\n    }\n    divisor++;\n  }\n  return factors;\n};\n\nconst prime_factors = (n) => {\n  let factors = [];\n  let divisors = [];\n  let divisor = 2;\n  let divisor_count = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      divisors.push(divisor_count);\n      divisor_count++;\n    }\n    divisor++;\n  }\n  return factors;\n};\n\nconst prime_factors_list = (n) => {\n  let factors = [];\n  let divisors = [];\n  let divisor = 2;\n  let divisor_count = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      divisors.push(divisor_count);\n      divisor_count++;\n    }\n    divisor++;\n  }\n  return factors;\n};\n\nconst prime_factors_list_of_time = (n) => {\n  let factors = [];\n  let divisors = [];\n  let divisor = 2;\n  let divisor_count = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      divisors.push(divisor_count);\n      divisor_count++;\n    }\n    divisor++;\n  }\n  return factors;\n};\n\nconst prime_factors_list_of_time_with_divisor = (n) => {\n  let factors = [];\n  let divisors = [];\n  let divisor = 2;\n  let divisor_count = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      divisors.push(divisor_count);\n      divisor_count++;\n    }\n    divisor++;\n  }\n  return factors;\n};\n\nconst prime_factors_list_of_time_with_divisor_and_divisor_count = (n) => {\n  let factors = [];\n  let divisors = [];\n  let divisor = 2;\n  let divisor_count = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      divisors.push(divisor_count);\n      divisor_count++;\n    }\n    divisor++;\n  }\n  return factors;\n};\n\nconst prime_factors_list_of_time_with_divisor_and_divisor_count_and_divisor_count = (n) => {\n  let factors = [];\n  let divisors = [];\n  let divisor = 2;\n  let divisor_count = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      divisors.push(divisor_count);\n      divisor_count++;\n    }\n    divisor++;\n  }\n  return factors;\n};\n\nconst prime_factors_list_of_time_with_divisor_and_divisor_count_and_divisor_count_and_divisor_count = (n) => {\n  let factors = [];\n  let divisors = [];\n  let divisor = 2;\n  let divisor_count = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      divisors.push(divisor_count);\n      divisor_count++;\n    }\n    divisor++;\n  }\n  return factors;\n};\n\nconst prime_factors_list_of_time_with_divisor_and_divisor_count_and_divisor_count_and_divisor_count_and_divisor_count = (n) => {\n  let factors = [];\n  let divisors = [];\n  let divisor = 2;\n  let divisor_count = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      divisors.push(divisor_count);\n      divisor_count++;\n    }\n    divisor++;\n  }\n  return factors;\n};\n\nconst prime_factors_list_of_time_with_divisor_and_divisor_count_and_divisor_count_and_divisor_count_and_divisor_count_and_divisor_count = (n) => {\n  let factors = [];\n  let divisors = [];\n  let divisor = 2;\n  let divisor_count = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      divisors.push(divisor_count);\n      divisor_count++;\n    }\n    divisor++;\n  }\n  return factors;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integer, absent all elements that happen more than once. \n   Keep decree of elements left the same as in the stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 2, "perturbed": true, "gc": "/* From a list of integer, absent all elements that happen more than once. \n   Keep decree of elements left the same as in the stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let result = [];\n  while (i < numbers.length) {\n    if (j < k) {\n      result.push(numbers[i]);\n      i++;\n    } else {\n      result.push(numbers[i]);\n      j++;\n    }\n    k++;\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]!== undefined) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting2 = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]!== undefined) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting3 = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]!== undefined) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting4 = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]!== undefined) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting5 = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]!== undefined) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting6 = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]!== undefined) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting7 = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]!== undefined) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting8 = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]!== undefined) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting9 = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]!== undefined) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting10 = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]!== undefined) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  From a list of integer, remove all elements that are not in the list.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/27", "prompt": "/* For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 2, "perturbed": true, "gc": "/* For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase3 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase4 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase5 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase6 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase7 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase8 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase9 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase10 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase11 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] >= 'a' && result[i] <= 'z') {\n      result[i] = result[i] - 32;\n    }\n  }\n  return result;\n};\n\n/*\n  For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase12 = (string) => {\n  let result = string.toLowerCase();\n  for (let i = 0; i < result", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a individual string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 2, "perturbed": true, "gc": "/* Concatenate list of strings into a individual string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Convert a string to a list of strings\n  >>> list('a b c')\n  ['a', 'b', 'c']\n  */\nconst list = (str) => {\n  return str.split('');\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to a string\n  >>> join(['a', 'b', 'c'])\n  'abc'\n  */\nconst join = (strings) => {\n  return concatenate(strings);\n};\n\n/*\n  Convert a list of strings to", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/29", "prompt": "/* Filter an remark list of strings only for ones that begin with a give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 2, "perturbed": true, "gc": "/* Filter an remark list of strings only for ones that begin with a give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  const prefixes = strings.map(s => s.toLowerCase());\n  const prefixesLen = prefixes.length;\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (prefixes.indexOf(strings[i].toLowerCase()) === -1) {\n      continue;\n    }\n    if (prefixesLen === 1) {\n      result.push(strings[i]);\n    } else {\n      result.push(strings[i]);\n    }\n  }\n  return result;\n};\n\nmodule.exports = {\n  filterByPrefix,\n};\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/3", "prompt": "/* You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account fallls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 2, "perturbed": true, "gc": "/* You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account fallls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account falls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero2 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account falls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero3 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account falls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero4 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account falls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero5 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account falls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero6 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account falls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero7 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account falls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero8 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account falls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero9 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account falls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero10 = (operations) => {\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return merely positive number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 2, "perturbed": true, "gc": "/*Return merely positive number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/**\n  Return the largest number in the list.\n  >>> getLargest([-1, 2, -4, 5, 6])\n  6\n  >>> getLargest([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst getLargest = (l) => {\n  let result = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > result) {\n      result = l[i];\n    }\n  }\n  return result;\n};\n\n/**\n  Return the smallest number in the list.\n  >>> getSmallest([-1, 2, -4, 5, 6])\n  -1\n  >>> getSmallest([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst getSmallest = (l) => {\n  let result = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < result) {\n      result = l[i];\n    }\n  }\n  return result;\n};\n\n/**\n  Return the median of the list.\n  >>> getMedian([-1, 2, -4, 5, 6])\n  2\n  >>> getMedian([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst getMedian = (l) => {\n  let result = getLargest(l);\n  let middle = l.length / 2;\n  let left = l.slice(0, middle);\n  let right = l.slice(middle);\n  let leftSmallest = getSmallest(left);\n  let rightSmallest = getSmallest(right);\n  if (leftSmallest > rightSmallest) {\n    result = rightSmallest;\n  } else {\n    result = leftSmallest;\n  }\n  return result;\n};\n\n/**\n  Return the mean of the list.\n  >>> getMean([-1, 2, -4, 5, 6])\n  -1.5\n  >>> getMean([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -1.5\n  */\nconst getMean = (l) => {\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    result += l[i];\n  }\n  return result / l.length;\n};\n\n/**\n  Return the standard deviation of the list.\n  >>> getStandardDeviation([-1, 2, -4, 5, 6])\n  1.5811388300841898\n  >>> getStandardDeviation([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.5811388300841898\n  */\nconst getStandardDeviation = (l) => {\n  let mean = getMean(l);\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    result += Math.pow(l[i] - mean, 2);\n  }\n  result = Math.sqrt(result / l.length);\n  return result;\n};\n\n/**\n  Return the variance of the list.\n  >>> getVariance([-1, 2, -4, 5, 6])\n  0.0\n  >>> getVariance([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  0.0\n  */\nconst getVariance = (l) => {\n  let mean = getMean(l);\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    result += Math.pow(l[i] - mean, 2);\n  }\n  result = result / l.length;\n  result = result - mean * mean;\n  return result;\n};\n\n/**\n  Return the standard error of the list.\n  >>> getStandardError([-1, 2, -4, 5, 6])\n  0.0\n  >>> getStandardError([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  0.0\n  */\nconst getStandardError = (l) => {\n  let mean = getMean(l);\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    result += Math.pow(l[i] - mean, 2);\n  }\n  result = Math.sqrt(result / l.length);\n  result = result / Math.sqrt(l.length);\n  return result;\n};\n\n/**\n  Return the standard error of the list.\n  >>> getStandardError([-1, 2, -4, 5, 6])\n  0.0\n  >>> getStandardError([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  0.0\n  */\nconst getStandardErrorOfMean = (l) => {\n  let mean = getMean(l);\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    result += Math.pow(l[i] - mean, 2);\n  }\n  result = Math.sqrt(result / l.length);\n  result = result / Math.sqrt(l.length);\n  return result;\n};\n\nmodule.exports = {\n  getPositive,\n  getLargest,\n  getSmallest", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/31", "prompt": "/*Return genuine if a given issue be prime, and assumed otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 2, "perturbed": true, "gc": "/*Return genuine if a given issue be prime, and assumed otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nmodule.exports = isPrime;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at detail x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficient of a polynomial. \n   findZero discover x such that poly(x) = 0. \n   findZero returns merely only zero point, even if there are many. \n   furthermore, findZero entirely subscribe list xs receive even issue of coefficient \n   and big non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 2, "perturbed": true, "gc": "/*\n  Evaluates polynomial with coefficients xs at detail x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficient of a polynomial. \n   findZero discover x such that poly(x) = 0. \n   findZero returns merely only zero point, even if there are many. \n   furthermore, findZero entirely subscribe list xs receive even issue of coefficient \n   and big non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let xs_length = xs.length;\n  let xs_sum = 0;\n  let xs_sum_squared = 0;\n  let xs_sum_squared_squared = 0;\n  let xs_sum_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared = 0;\n  let xs_sum_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_squared_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/33", "prompt": "/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n   to the value of the corresponding indicies of l, but screen.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 2, "perturbed": true, "gc": "/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n   to the value of the corresponding indicies of l, but screen.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 3 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird2 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 3 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird3 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 3 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird4 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 3 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird5 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 3 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird6 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 3 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird7 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 3 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n  >>> sortThird([", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return screen unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 2, "perturbed": true, "gc": "/*Return screen unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let i = 0;\n  let result = [];\n  while (i < l.length) {\n    if (result.indexOf(l[i]) === -1) {\n      result.push(l[i]);\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst first = (l) => {\n  return l[0];\n};\n\n/*\n  Return the last element of a list\n  >>> last([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  123\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  5\n  */\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n/*\n  Return the first element of a list\n  >>> first([5, 3, 5, 2, 3,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximal element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 2, "perturbed": true, "gc": "/*Return maximal element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*Return the sum of all elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sum = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return the product of all elements in the list.\n  >>> product([1, 2, 3])\n  6\n  >>> product([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst product = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product;\n};\n\n/*Return the average of all elements in the list.\n  >>> average([1, 2, 3])\n  2\n  >>> average([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -2.5\n  */\nconst average = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum / l.length;\n};\n\n/*Return the median of all elements in the list.\n  >>> median([1, 2, 3])\n  2\n  >>> median([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst median = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let middle = Math.floor(l.length / 2);\n  return sorted[middle];\n};\n\n/*Return the mode of all elements in the list.\n  >>> mode([1, 2, 3])\n  1\n  >>> mode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst mode = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let max = sorted[0];\n  let count = 1;\n  for (let i = 1; i < sorted.length; i++) {\n    if (sorted[i] === max) {\n      count++;\n    } else {\n      count = 1;\n      max = sorted[i];\n    }\n  }\n  return max;\n};\n\n/*Return the median of all elements in the list.\n  >>> median([1, 2, 3])\n  2\n  >>> median([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst median = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let middle = Math.floor(l.length / 2);\n  return sorted[middle];\n};\n\n/*Return the mode of all elements in the list.\n  >>> mode([1, 2, 3])\n  1\n  >>> mode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst mode = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let max = sorted[0];\n  let count = 1;\n  for (let i = 1; i < sorted.length; i++) {\n    if (sorted[i] === max) {\n      count++;\n    } else {\n      count = 1;\n      max = sorted[i];\n    }\n  }\n  return max;\n};\n\n/*Return the median of all elements in the list.\n  >>> median([1, 2, 3])\n  2\n  >>> median([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst median = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let middle = Math.floor(l.length / 2);\n  return sorted[middle];\n};\n\n/*Return the mode of all elements in the list.\n  >>> mode([1, 2, 3])\n  1\n  >>> mode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst mode = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let max = sorted[0];\n  let count = 1;\n  for (let i = 1; i < sorted.length; i++) {\n    if (sorted[i] === max) {\n      count++;\n    } else {\n      count = 1;\n      max = sorted[i];\n    }\n  }\n  return max;\n};\n\n/*Return the median of all elements in the list.\n  >>> median([1, 2, 3])\n  2\n  >>> median([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst median = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let middle = Math.floor(l.length / 2);\n  return sorted[middle];\n};\n\n/*Return the mode of all elements in the list.\n  >>> mode([1, 2, 3])\n  1\n  >>> mode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst mode = (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/36", "prompt": "/*Return the numeral of times the finger 7 appear in integers less than n which cost divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 2, "perturbed": true, "gc": "/*Return the numeral of times the finger 7 appear in integers less than n which cost divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      result += 1;\n    } else if (i % 11 === 0) {\n      result += 2;\n    } else {\n      result += i;\n    }\n  }\n  return result;\n};\n\nmodule.exports = fizzBuzz;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/37", "prompt": "/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 2, "perturbed": true, "gc": "/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    let j = i + 1;\n    while (j < l.length && l[i] === l[j]) {\n      j++;\n    }\n    l2.push(l[i]);\n    i = j;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the odd indicies are equal \n   to the value of the odd indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [3, 5, 6, 4]\n  */\nconst sortOdd = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    let j = i + 1;\n    while (j < l.length && l[i] === l[j]) {\n      j++;\n    }\n    l2.push(l[i]);\n    i = j;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 5, 6, 4]\n  */\nconst sortEvenOdd = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    let j = i + 1;\n    while (j < l.length && l[i] === l[j]) {\n      j++;\n    }\n    l2.push(l[i]);\n    i = j;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 5, 6, 4]\n  */\nconst sortOddOdd = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    let j = i + 1;\n    while (j < l.length && l[i] === l[j]) {\n      j++;\n    }\n    l2.push(l[i]);\n    i = j;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 5, 6, 4]\n  */\nconst sortOddOddOdd = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    let j = i + 1;\n    while (j < l.length && l[i] === l[j]) {\n      j++;\n    }\n    l2.push(l[i]);\n    i = j;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 5, 6, 4]\n  */\nconst sortOddOddOddOdd = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    let j = i + 1;\n    while (j < l.length && l[i] === l[j]) {\n      j++;\n    }\n    l2.push(l[i]);\n    i = j;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 5, 6, 4]\n  */\nconst sortEvenOddOddOdd = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    let j = i + 1;\n    while (j < l.length && l[i] === l[j]) {\n      j++;\n    }\n    l2.push(l[i]);\n    i = j;\n  }\n  return l2;\n};\n\n/*\n  This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  return key encoded bowed stringed instrument by cycle groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   drive as remark drawstring encoded with encode_cyclic routine. tax return decode string. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 2, "perturbed": true, "gc": "/*\n  return key encoded bowed stringed instrument by cycle groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   drive as remark drawstring encoded with encode_cyclic routine. tax return decode string. \n   * / \n const decodeCyclic = (s) = > {\n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length == 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n*/\n\n// / \nconst encode_cyclic = (s) = > {\n  volt-ampere groups = [ ], groups2 = [ ]; \n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  } \n  for (const group of groups) { \n    if (group.length == 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  } \n  return groups2.join('');\n}\n\n// / \nconst decode_cyclic = (s) = > {\n  volt-ampere groups = [ ], groups2 = [ ]; \n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  } \n  for (const group of groups) { \n    if (group.length == 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  } \n  return groups2.join('');\n}\n\n// / \nconst encode_cyclic_2 = (s) = > {\n  volt-ampere groups = [ ], groups2 = [ ]; \n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  } \n  for (const group of groups) { \n    if (group.length == 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  } \n  return groups2.join('');\n}\n\n// / \nconst decode_cyclic_2 = (s) = > {\n  volt-ampere groups = [ ], groups2 = [ ]; \n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  } \n  for (const group of groups) { \n    if (group.length == 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  } \n  return groups2.join('');\n}\n\n// / \nconst encode_cyclic_3 = (s) = > {\n  volt-ampere groups = [ ], groups2 = [ ]; \n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  } \n  for (const group of groups) { \n    if (group.length == 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  } \n  return groups2.join('');\n}\n\n// / \nconst decode_cyclic_3 = (s) = > {\n  volt-ampere groups = [ ], groups2 = [ ]; \n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  } \n  for (const group of groups) { \n    if (group.length == 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  } \n  return groups2.join('');\n}\n\n// / \nconst encode_cyclic_4 = (s) = > {\n  volt-ampere groups = [ ], groups2 = [ ]; \n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  } \n  for (const group of groups) { \n    if (group.length == 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 2, "perturbed": true, "gc": "/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let fib = 1;\n  let fibNext = 2;\n  while (fibNext <= n) {\n    fib = fibNext;\n    fibNext = fibNext + fib;\n  }\n  return fib;\n};\n\n/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib2 = (n) => {\n  let fib = 1;\n  let fibNext = 2;\n  while (fibNext <= n) {\n    fib = fibNext;\n    fibNext = fibNext + fib;\n  }\n  return fibNext;\n};\n\n/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib3 = (n) => {\n  let fib = 1;\n  let fibNext = 2;\n  while (fibNext <= n) {\n    fib = fibNext;\n    fibNext = fibNext + fib;\n  }\n  return fibNext;\n};\n\n/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib4 = (n) => {\n  let fib = 1;\n  let fibNext = 2;\n  while (fibNext <= n) {\n    fib = fibNext;\n    fibNext = fibNext + fib;\n  }\n  return fibNext;\n};\n\n/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib5 = (n) => {\n  let fib = 1;\n  let fibNext = 2;\n  while (fibNext <= n) {\n    fib = fibNext;\n    fibNext = fibNext + fib;\n  }\n  return fibNext;\n};\n\n/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib6 = (n) => {\n  let fib = 1;\n  let fibNext = 2;\n  while (fibNext <= n) {\n    fib = fibNext;\n    fibNext = fibNext + fib;\n  }\n  return fibNext;\n};\n\n/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib7 = (n) => {\n  let fib = 1;\n  let fibNext = 2;\n  while (fibNext <= n) {\n    fib = fibNext;\n    fibNext = fibNext + fib;\n  }\n  return fibNext;\n};\n\n/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib8 = (n) => {\n  let fib = 1;\n  let fibNext = 2;\n  while (fibNext <= n) {\n    fib = fibNext;\n    fibNext = fibNext + fib;\n  }\n  return fibNext;\n};\n\n/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib9 = (n) => {\n  let fib = 1;\n  let fibNext = 2;\n  while (fibNext <= n) {\n    fib = fibNext;\n    fibNext = fibNext + fib;\n  }\n  return fibNext;\n};\n\n/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib10 = (n) => {\n  let fib = 1;\n  let fibNext = 2;\n  while (fibNext <= n) {", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a give list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the median absolute deviation between each \n   element and a centerpoint (mean in this font ): \n   MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 2, "perturbed": true, "gc": "/* For a give list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the median absolute deviation between each \n   element and a centerpoint (mean in this font ): \n   MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let mean = 0.0;\n  let median = 0.0;\n  let MAD = 0.0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let sum = 0.0;\n  let sumSquares = 0.0;\n  let sumSquares2 = 0.0;\n  let sumSquares3 = 0.0;\n  let sumSquares4 = 0.0;\n  let sumSquares5 = 0.0;\n  let sumSquares6 = 0.0;\n  let sumSquares7 = 0.0;\n  let sumSquares8 = 0.0;\n  let sumSquares9 = 0.0;\n  let sumSquares10 = 0.0;\n  let sumSquares11 = 0.0;\n  let sumSquares12 = 0.0;\n  let sumSquares13 = 0.0;\n  let sumSquares14 = 0.0;\n  let sumSquares15 = 0.0;\n  let sumSquares16 = 0.0;\n  let sumSquares17 = 0.0;\n  let sumSquares18 = 0.0;\n  let sumSquares19 = 0.0;\n  let sumSquares20 = 0.0;\n  let sumSquares21 = 0.0;\n  let sumSquares22 = 0.0;\n  let sumSquares23 = 0.0;\n  let sumSquares24 = 0.0;\n  let sumSquares25 = 0.0;\n  let sumSquares26 = 0.0;\n  let sumSquares27 = 0.0;\n  let sumSquares28 = 0.0;\n  let sumSquares29 = 0.0;\n  let sumSquares30 = 0.0;\n  let sumSquares31 = 0.0;\n  let sumSquares32 = 0.0;\n  let sumSquares33 = 0.0;\n  let sumSquares34 = 0.0;\n  let sumSquares35 = 0.0;\n  let sumSquares36 = 0.0;\n  let sumSquares37 = 0.0;\n  let sumSquares38 = 0.0;\n  let sumSquares39 = 0.0;\n  let sumSquares40 = 0.0;\n  let sumSquares41 = 0.0;\n  let sumSquares42 = 0.0;\n  let sumSquares43 = 0.0;\n  let sumSquares44 = 0.0;\n  let sumSquares45 = 0.0;\n  let sumSquares46 = 0.0;\n  let sumSquares47 = 0.0;\n  let sumSquares48 = 0.0;\n  let sumSquares49 = 0.0;\n  let sumSquares50 = 0.0;\n  let sumSquares51 = 0.0;\n  let sumSquares52 = 0.0;\n  let sumSquares53 = 0.0;\n  let sumSquares54 = 0.0;\n  let sumSquares55 = 0.0;\n  let sumSquares56 = 0.0;\n  let sumSquares57 = 0.0;\n  let sumSquares58 = 0.0;\n  let sumSquares59 = 0.0;\n  let sumSquares60 = 0.0;\n  let sumSquares61 = 0.0;\n  let sumSquares62 = 0.0;\n  let sumSquares63 = 0.0;\n  let sumSquares64 = 0.0;\n  let sumSquares65 = 0.0;\n  let sumSquares66 = 0.0;\n  let sumSquares67 = 0.0;\n  let sumSquares68 = 0.0;\n  let sumSquares69 = 0.0;\n  let sumSquares70 = 0.0;\n  let sumSquares71 = 0.0;\n  let sumSquares72 = 0.0;\n  let sumSquares73 = 0.0;\n  let sumSquares74 = 0.0;\n  let sumSquares75 = 0.0;\n  let sumSquares76 = 0.0;\n  let sumSquares77 = 0.0;\n  let sumSquares78 = 0.0;\n  let sumSquares79 = 0.0;\n  let sumSquares80 = 0.0;\n  let sumSquares81 = 0.0;\n  let sumSquares82 = 0.0;\n  let sumSquares83 = 0.0;\n  let sumSquares84 = 0.0;\n  let sumSquares85 = 0.0;\n  let sumSquares86 = 0.0;\n  let sumSquares87 = 0.0;\n  let sumSquares88 = 0.0;\n  let sumSquares89 = 0.0;\n  let sumSquares90 = 0.0;\n  let sumSquares91 = 0.0;\n  let sumSquares92 = 0.0;\n  let sumSquares93 = 0.0;\n  let sumSquares94 = 0.0;\n  let sumSquares95 = 0.0;\n  let sumSquares96 = 0.0;\n  let sumSquares97 = 0.0;\n  let sumSquares98 = 0.0;\n  let sumSquares99 = 0.0;\n  let sumSquares100 = 0.0;\n  let sumSquares101 = 0.0;\n  let sumSquares102 = 0.0;\n  let sumSquares103 = 0.0;\n  let sumSquares104 = 0.0;\n  let sumSquares105 = 0.0;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 2, "perturbed": true, "gc": "/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero2 = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero3 = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero4 = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero5 = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero6 = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumTo", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  think a road that's a absolutely square boundlessly long credit line. \n   n cars are driving left to justly;   simultaneously, a different set of n car \n   are drive correct to leave.    The two set of car start out being very far from \n   each early.   All cars move in the same speed.   Two cars are say to collide \n   when a car that's moving entrust to proper strike a car that's moving right to leave. \n   However, the cars are boundlessly sturdy and hard; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This affair output the issue of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 2, "perturbed": true, "gc": "/*\n  think a road that's a absolutely square boundlessly long credit line. \n   n cars are driving left to justly;   simultaneously, a different set of n car \n   are drive correct to leave.    The two set of car start out being very far from \n   each early.   All cars move in the same speed.   Two cars are say to collide \n   when a car that's moving entrust to proper strike a car that's moving right to leave. \n   However, the cars are boundlessly sturdy and hard; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This affair output the issue of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n  let {\n    carRaceCollision: {\n      [i] = > {\n        let {\n          [j] = > {\n            let {\n              [k] = > {\n                let {\n                  [l] = > {\n                    let {\n                      [m] = > {\n                        let {\n                          [n] = > {\n                            let {\n                              [o] = > {\n                                let {\n                                  [p] = > {\n                                    let {\n                                      [q] = > {\n                                        let {\n                                          [r] = > {\n                                            let {\n                                              [s] = > {\n                                                let {\n                                                  [t] = > {\n                                                    let {\n                                                      [u] = > {\n                                                        let {\n                                                          [v] = > {\n                                                            let {\n                                                              [w] = > {\n                                                              let {\n                                                                [x] = > {\n                                                                  let {\n                                                                    [y] = > {\n                                                                      let {\n                                                                        [z] = > {\n                                                                          let {\n                                                                            [A] = > {\n                                                                              let {\n                                                                                [B] = > {\n                                                                                  let {\n                                                                                    [C] = > {\n                                                                                      let {\n                                                                                        [D] = > {\n                                                                                          let {\n                                                                                            [E] = > {\n                                                                                            \tlet {\n                                                                                            \t  [F] = > {\n                                                                                            \t\tlet {\n                                                                                            \t\t  [G] = > {\n                                                                                            \t\t    let {\n                                                                                            \t\t      [H] = > {\n                                                                                            \t\t        let {\n                                                                                            \t\t      \tlet {\n                                                                                            \t\t        \tlet {\n                                                                                            \t\t          \tlet {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n                                                                                            \t\t          \t  let {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 2, "perturbed": true, "gc": "/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let res = [];\n  while (i < j) {\n    res.push(l[i]);\n    i++;\n    res.push(l[j]);\n    j--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList2 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let res = [];\n  while (i < j) {\n    res.push(l[i]);\n    res.push(l[j]);\n    i++;\n    j--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList3 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let res = [];\n  while (i < j) {\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    i++;\n    j--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList4 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let res = [];\n  while (i < j) {\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    i++;\n    j--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList5 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let res = [];\n  while (i < j) {\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    res.push(l[j]);\n    i++;\n    j--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList6 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let res = [];\n  while (i < j) {\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    res.push(l[j]);\n    i++;\n    j--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList7 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let res = [];\n  while (i < j) {\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    res.push(l[j]);\n    i++;\n    j--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList8 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let res = [];\n  while (i < j) {\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    res.push(l[j]);\n    res.push(l[i]);\n    res.push(l[j]);\n    ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero take a list of integers as an input signal. \n   it render dependable if there be two distinct elements in the list that \n   sum to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 2, "perturbed": true, "gc": "/*\n  pairsSumToZero take a list of integers as an input signal. \n   it render dependable if there be two distinct elements in the list that \n   sum to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0);\n  return sum === 0;\n};\n\nmodule.exports = pairsSumToZero;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numeric base of input issue x to base.\n   return drawstring theatrical performance after the conversion. \n   base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 2, "perturbed": true, "gc": "/*Change numeric base of input issue x to base.\n   return drawstring theatrical performance after the conversion. \n   base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase2 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase3 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase4 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase5 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase6 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase7 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase8 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase9 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase10 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase11 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase12 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase13 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\nconst changeBase14 = (x, base) => {\n  let result = ''\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  Change numeric base of input issue x to base.\n  return drawstring theatrical performance after the conversion. \n  base numbers are less than 10.\n  */\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given duration of a side and gamey return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "/*Given duration of a side and gamey return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  if (a < 0) {\n    throw new Error('a must be positive');\n  }\n  if (h < 0) {\n    throw new Error('h must be positive');\n  }\n  return Math.sqrt(a * h);\n};\n\nmodule.exports = triangleArea;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 phone number sequence is a sequence exchangeable to the Fibbonacci sequnece that's defined as surveil: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a function to efficiently compute the n-th chemical element of the fib4 number succession.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 2, "perturbed": true, "gc": "/*The Fib4 phone number sequence is a sequence exchangeable to the Fibbonacci sequnece that's defined as surveil: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a function to efficiently compute the n-th chemical element of the fib4 number succession.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n === 3) {\n    return 0;\n  }\n  if (n === 4) {\n    return 2;\n  }\n  if (n === 5) {\n    return 4;\n  }\n  if (n === 6) {\n    return 8;\n  }\n  if (n === 7) {\n    return 14;\n  }\n  if (n === 8) {\n    return 20;\n  }\n  if (n === 9) {\n    return 28;\n  }\n  if (n === 10) {\n    return 36;\n  }\n  if (n === 11) {\n    return 44;\n  }\n  if (n === 12) {\n    return 52;\n  }\n  if (n === 13) {\n    return 60;\n  }\n  if (n === 14) {\n    return 68;\n  }\n  if (n === 15) {\n    return 76;\n  }\n  if (n === 16) {\n    return 84;\n  }\n  if (n === 17) {\n    return 92;\n  }\n  if (n === 18) {\n    return 100;\n  }\n  if (n === 19) {\n    return 108;\n  }\n  if (n === 20) {\n    return 116;\n  }\n  if (n === 21) {\n    return 124;\n  }\n  if (n === 22) {\n    return 132;\n  }\n  if (n === 23) {\n    return 140;\n  }\n  if (n === 24) {\n    return 148;\n  }\n  if (n === 25) {\n    return 156;\n  }\n  if (n === 26) {\n    return 164;\n  }\n  if (n === 27) {\n    return 172;\n  }\n  if (n === 28) {\n    return 180;\n  }\n  if (n === 29) {\n    return 188;\n  }\n  if (n === 30) {\n    return 196;\n  }\n  if (n === 31) {\n    return 204;\n  }\n  if (n === 32) {\n    return 212;\n  }\n  if (n === 33) {\n    return 220;\n  }\n  if (n === 34) {\n    return 228;\n  }\n  if (n === 35) {\n    return 236;\n  }\n  if (n === 36) {\n    return 244;\n  }\n  if (n === 37) {\n    return 252;\n  }\n  if (n === 38) {\n    return 260;\n  }\n  if (n === 39) {\n    return 268;\n  }\n  if (n === 40) {\n    return 276;\n  }\n  if (n === 41) {\n    return 284;\n  }\n  if (n === 42) {\n    return 292;\n  }\n  if (n === 43) {\n    return 300;\n  }\n  if (n === 44) {\n    return 308;\n  }\n  if (n === 45) {\n    return 316;\n  }\n  if (n === 46) {\n    return 324;\n  }\n  if (n === 47) {\n    return 332;\n  }\n  if (n === 48) {\n    return 340;\n  }\n  if (n === 49) {\n    return 348;\n  }\n  if (n === 50) {\n    return 356;\n  }\n  if (n === 51) {\n    return 364;\n  }\n  if (n === 52) {\n    return 372;\n  }\n  if (n === 53) {\n    return 380;\n  }\n  if (n === 54) {\n    return 388;\n  }\n  if (n === 55) {\n    return 396;\n  }\n  if (n === 56) {\n    return 404;\n  }\n  if (n === 57) {\n    return 412;\n  }\n  if (n === 58) {\n    return 420;\n  }\n  if (n === 59) {\n    return 428;\n  }\n  if (n === 60) {\n    return 436;\n  }\n  if (n === 61) {\n    return 444;\n  }\n  if (n === 62) {\n    return 452;\n  }\n  if (n === 63) {\n    return 460;\n  }\n  if (n === 64) {\n    return 468;\n  }\n  if (n === 65) {\n    return 476;\n  }\n  if (n === 66) {\n    return 484;\n  }\n  if (n === 67) {\n    return 492;\n  }\n  if (n === 68) {\n    return 500;\n  }\n  if (n === 69) {\n    return 508;\n  }\n  if (n === 70) {\n    return 516;\n  }\n  if (n === 71) {\n    return 524;\n  }\n  if (n === 72) {\n    return 532;\n  }\n  if (n === 73) {\n    return 540;\n  }\n  if (n === 74) {\n    return 548;\n  }\n  if (n === 75) {\n    return 556;\n  }\n  if (n === 76) {\n    return 564;\n  }\n  if (n === 77) {\n    return 572;\n  }\n  if (n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/47", "prompt": "/*Return median of element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 2, "perturbed": true, "gc": "/*Return median of element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    throw new Error('Empty list');\n  }\n  const middle = l.length / 2;\n  if (l.length % 2 === 0) {\n    return (l[middle - 1] + l[middle]) / 2;\n  } else {\n    return l[middle];\n  }\n};\n\nmodule.exports = median;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  check if given bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "/*\n  check if given bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  if (text.length === 0) {\n    return true;\n  }\n  let first = text[0];\n  let last = text[text.length - 1];\n  if (first!== last) {\n    return false;\n  }\n  let middle = text.substr(1, text.length - 2);\n  return isPalindrome(middle);\n};\n\nmodule.exports = isPalindrome;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 2, "perturbed": true, "gc": "/*Return 2^n modulo p (be mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || n >= p) throw new Error('n must be less than p')\n  if (n === 0) return 1\n  if (n === 1) return 0\n  if (n === p) return 1\n  if (n % 2 === 0) return modp(n - 1, p)\n  return modp(n - 1, p) + 1\n}\n\nmodule.exports = modp\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a phone number 'delimeter' between every two consecutive elements of stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 2, "perturbed": true, "gc": "/* Insert a phone number 'delimeter' between every two consecutive elements of stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  if (numbers.length === 0) {\n    return [];\n  }\n\n  let result = [];\n  let current = numbers[0];\n  let next = numbers[1];\n  let i = 0;\n\n  while (i < numbers.length - 1) {\n    result.push(current);\n    current = next;\n    next = numbers[++i];\n  }\n\n  result.push(current);\n\n  return result.map(number => number + delimeter);\n};\n\nexport default intersperse;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/50", "prompt": "/*\n  return key encoded bowed stringed instrument by shift every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   drive as remark drawstring encoded with encode_shift routine. return decode string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 2, "perturbed": true, "gc": "/*\n  return key encoded bowed stringed instrument by shift every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   drive as remark drawstring encoded with encode_shift routine. return decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   return key encoded bowed stringed instrument by shift every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   drive as remark drawstring encoded with encode_shift routine. return decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   return key encoded bowed stringed instrument by shift every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   drive as remark drawstring encoded with encode_shift routine. return decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   return key encoded bowed stringed instrument by shift every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   drive as remark drawstring encoded with encode_shift routine. return decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   return key encoded bowed stringed instrument by shift every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   drive as remark drawstring encoded with encode_shift routine. return decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   return key encoded bowed stringed instrument by shift every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   drive as remark drawstring encoded with encode_shift routine. return decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   return key encoded bowed stringed instrument by shift every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   drive as remark drawstring encoded with encode_shift routine. return decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 2, "perturbed": true, "gc": "/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  if (text.length === 0) {\n    return text;\n  }\n\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let newText = text.replace(/[aeiou]/g, '');\n\n  for (let i = 0; i < vowels.length; i++) {\n    newText = newText.replace(new RegExp(`[${vowels[i]}]`, 'g'), '');\n  }\n\n  return newText;\n};\n\nmodule.exports = removeVowels;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return genuine if all numbers in the list l are below brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 2, "perturbed": true, "gc": "/*Return genuine if all numbers in the list l are below brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/*Return true if all numbers in the list l are above brink t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(n => n > t);\n};\n\n/*Return true if all numbers in the list l are between brink t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold = (l, t) => {\n  return l.every(n => n >= t && n < t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold2 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold3 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold4 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold5 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold6 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold7 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold8 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold9 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold10 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold11 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold12 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold13 = (l, t) => {\n  return l.every(n => n >= t && n <= t + 1);\n};\n\n/*Return true if all numbers in the list l are between t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst betweenThreshold14 = (l, t) => {\n  return l.every(n => n >=", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "/*Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add2 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add3 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add4 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add5 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add6 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add7 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add8 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add9 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add10 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add11 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add12 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add13 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add14 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add15 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add16 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add17 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add18 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add19 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add20 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add21 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add22 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add23 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add24 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add25 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add26 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/54", "prompt": "/*\n  crack if two words have the like quality.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 2, "perturbed": true, "gc": "/*\n  crack if two words have the like quality.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars2 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars3 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars4 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars5 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars6 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars7 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars8 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars9 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars10 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars11 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars12 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars13 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars14 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 2, "perturbed": true, "gc": "/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return n;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib2 = (n) => {\n  if (n < 2) return n;\n  return fib2(n - 1) + fib2(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib3 = (n) => {\n  if (n < 2) return n;\n  return fib3(n - 1) + fib3(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib4 = (n) => {\n  if (n < 2) return n;\n  return fib4(n - 1) + fib4(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib5 = (n) => {\n  if (n < 2) return n;\n  return fib5(n - 1) + fib5(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib6 = (n) => {\n  if (n < 2) return n;\n  return fib6(n - 1) + fib6(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib7 = (n) => {\n  if (n < 2) return n;\n  return fib7(n - 1) + fib7(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib8 = (n) => {\n  if (n < 2) return n;\n  return fib8(n - 1) + fib8(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib9 = (n) => {\n  if (n < 2) return n;\n  return fib9(n - 1) + fib9(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib10 = (n) => {\n  if (n < 2) return n;\n  return fib10(n - 1) + fib10(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib11 = (n) => {\n  if (n < 2) return n;\n  return fib11(n - 1) + fib11(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib12 = (n) => {\n  if (n < 2) return n;\n  return fib12(n - 1) + fib12(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib13 = (n) => {\n  if (n < 2) return n;\n  return fib13(n - 1) + fib13(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib14 = (n) => {\n  if (n < 2) return n;\n  return fib14(n - 1) + fib14(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib15 = (n) => {\n  if (n < 2) return n;\n  return fib15(n - 1) + fib15(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib16 = (n) => {\n  if (n < 2) return n;\n  return fib16(n - 1) + fib16(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib17 = (n) => {\n  if (n < 2) return n;\n  return fib17(n - 1) + fib17(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib18 = (n) => {\n  if (n <", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a drawstring of \" < \" and \" > \". \n   return false if every opening bracket give birth a comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "/* brackets is a drawstring of \" < \" and \" > \". \n   return false if every opening bracket give birth a comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  while (bracketIndex < brackets.length) {\n    if (bracket === \"<\") {\n      bracketCount++;\n    } else if (bracket === \">\") {\n      if (bracketCount === 0) {\n        return false;\n      }\n      bracketCount--;\n    }\n    bracket = brackets[++bracketIndex];\n  }\n  return true;\n};\n\nconst getBracketing = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  while (bracketIndex < brackets.length) {\n    if (bracket === \"<\") {\n      bracketCount++;\n    } else if (bracket === \">\") {\n      if (bracketCount === 0) {\n        return false;\n      }\n      bracketCount--;\n    }\n    bracket = brackets[++bracketIndex];\n  }\n  return brackets.slice(0, bracketIndex);\n};\n\nconst getBracketingCount = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  while (bracketIndex < brackets.length) {\n    if (bracket === \"<\") {\n      bracketCount++;\n    } else if (bracket === \">\") {\n      if (bracketCount === 0) {\n        return false;\n      }\n      bracketCount--;\n    }\n    bracket = brackets[++bracketIndex];\n  }\n  return bracketCount;\n};\n\nconst getBracketingIndex = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  while (bracketIndex < brackets.length) {\n    if (bracket === \"<\") {\n      bracketCount++;\n    } else if (bracket === \">\") {\n      if (bracketCount === 0) {\n        return false;\n      }\n      bracketCount--;\n    }\n    bracket = brackets[++bracketIndex];\n  }\n  return bracketIndex;\n};\n\nconst getBracketingIndexes = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  while (bracketIndex < brackets.length) {\n    if (bracket === \"<\") {\n      bracketCount++;\n    } else if (bracket === \">\") {\n      if (bracketCount === 0) {\n        return false;\n      }\n      bracketCount--;\n    }\n    bracket = brackets[++bracketIndex];\n  }\n  return brackets.slice(0, bracketIndex);\n};\n\nconst getBracketingIndexesCount = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  while (bracketIndex < brackets.length) {\n    if (bracket === \"<\") {\n      bracketCount++;\n    } else if (bracket === \">\") {\n      if (bracketCount === 0) {\n        return false;\n      }\n      bracketCount--;\n    }\n    bracket = brackets[++bracketIndex];\n  }\n  return bracketCount;\n};\n\nconst getBracketingIndexesCounts = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  while (bracketIndex < brackets.length) {\n    if (bracket === \"<\") {\n      bracketCount++;\n    } else if (bracket === \">\") {\n      if (bracketCount === 0) {\n        return false;\n      }\n      bracketCount--;\n    }\n    bracket = brackets[++bracketIndex];\n  }\n  return brackets.slice(0, bracketIndex);\n};\n\nconst getBracketingIndexesCountsCount = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  while (bracketIndex < brackets.length) {\n    if (bracket === \"<\") {\n      bracketCount++;\n    } else if (bracket === \">\") {\n      if (bracketCount === 0) {\n        return false;\n      }\n      bracketCount--;\n    }\n    bracket = brackets[++bracketIndex];\n  }\n  return bracketCount;\n};\n\nconst getBracketingIndexesCountsCount = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  while (bracketIndex < brackets.length) {\n    if (bracket === \"<\") {\n      bracketCount++;\n    } else if (bracket === \">\") {\n      if (bracketCount === 0) {\n        return false;\n      }\n      bracketCount--;\n    }\n    bracket = brackets[++bracketIndex];\n  }\n  return brackets.slice(0, bracketIndex);\n};\n\nconst getBracketingIndexesCountsCounts = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  while (bracketIndex < brackets.length) {\n    if (bracket === \"<\") {\n      bracketCount++;\n    } else if (bracket === \">\") {\n      if (bracketCount === 0) {\n        return false;\n      }\n      bracketCount--;\n    }\n    bracket = brackets[++bracketIndex];\n  }\n  return brackets.slice(0, bracketIndex);\n};\n\nconst getBracketingIndexesCountsCountsCount = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return genuine is list elements are monotonically increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 2, "perturbed": true, "gc": "/*Return genuine is list elements are monotonically increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    }\n    if (l[i] < l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nmodule.exports = monotonic;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return screen unique common chemical element for two tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 2, "perturbed": true, "gc": "/*Return screen unique common chemical element for two tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1_length = l1.length;\n  const l2_length = l2.length;\n  if (l1_length!== l2_length) {\n    return [];\n  }\n  const common_length = l1_length;\n  const common_array = new Array(common_length);\n  for (let i = 0; i < common_length; i++) {\n    common_array[i] = l1[i] === l2[i]? l1[i] : null;\n  }\n  return common_array;\n};\n\nexport default common;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest premier factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 2, "perturbed": true, "gc": "/*Return the largest premier factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      n = n / i;\n      i++;\n    }\n  }\n  return i;\n};\n\nmodule.exports = largestPrimeFactor;\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/6", "prompt": "/* remark to this function is a string defend multiple group for nested parenthesis separated by spaces. \n   For each of the group, output the deep grade of nesting of parentheses. \n   E.g. (() ()) has maximal two levels of nest while (( ()) ) receive three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 2, "perturbed": true, "gc": "/* remark to this function is a string defend multiple group for nested parenthesis separated by spaces. \n   For each of the group, output the deep grade of nesting of parentheses. \n   E.g. (() ()) has maximal two levels of nest while (( ()) ) receive three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let result = [];\n  let stack = [];\n  let current_level = 0;\n  let current_paren_level = 0;\n  let current_paren_index = 0;\n  let current_paren_string = '';\n  let current_paren_string_length = 0;\n  let current_paren_string_index = 0;\n  let current_paren_string_length_index = 0;\n  let current_paren_string_length_index_max = 0;\n  let current_paren_string_length_index_min = 0;\n  let current_paren_string_length_index_max_max = 0;\n  let current_paren_string_length_index_min_min = 0;\n  let current_paren_string_length_index_min_max = 0;\n  let current_paren_string_length_index_min_min_max = 0;\n  let current_paren_string_length_index_min_min_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max_max_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max = 0;\n  let current_paren_string_length_index_min_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a routine that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 2, "perturbed": true, "gc": "/*sumToN is a routine that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\nmodule.exports = sumToN;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a drawstring of \" (\" and \") \". \n   return true if every opening bracket give birth a comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "/* brackets is a drawstring of \" (\" and \") \". \n   return true if every opening bracket give birth a comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let bracketing = false;\n  let bracket = \"\";\n  let i = 0;\n  while (i < brackets.length) {\n    if (brackets[i] === \"(\") {\n      bracketing = true;\n      bracket = \"(\";\n    } else if (brackets[i] === \")\") {\n      bracketing = false;\n      bracket = \")\";\n    }\n    i++;\n  }\n  return bracketing;\n};\n\nconst getBrackets = (text) => {\n  let brackets = [];\n  let bracket = \"\";\n  let i = 0;\n  while (i < text.length) {\n    if (text[i] === \"(\") {\n      brackets.push(bracket);\n      bracket = \"(\";\n    } else if (text[i] === \")\") {\n      brackets.push(bracket);\n      bracket = \")\";\n    }\n    i++;\n  }\n  return brackets;\n};\n\nconst getBracketing = (text) => {\n  let brackets = [];\n  let bracket = \"\";\n  let i = 0;\n  while (i < text.length) {\n    if (text[i] === \"(\") {\n      brackets.push(bracket);\n      bracket = \"(\";\n    } else if (text[i] === \")\") {\n      brackets.push(bracket);\n      bracket = \")\";\n    }\n    i++;\n  }\n  return brackets;\n};\n\nconst getBracketingCount = (text) => {\n  let brackets = getBrackets(text);\n  let bracketingCount = 0;\n  for (let i = 0; i < brackets.length; i++) {\n    if (correctBracketing(brackets[i])) {\n      bracketingCount++;\n    }\n  }\n  return bracketingCount;\n};\n\nconst getBracketingPercentage = (text) => {\n  let brackets = getBrackets(text);\n  let bracketingPercentage = 0;\n  for (let i = 0; i < brackets.length; i++) {\n    if (correctBracketing(brackets[i])) {\n      bracketingPercentage++;\n    }\n  }\n  return bracketingPercentage / brackets.length;\n};\n\nconst getBracketingPercentageCount = (text) => {\n  let brackets = getBrackets(text);\n  let bracketingPercentageCount = 0;\n  for (let i = 0; i < brackets.length; i++) {\n    if (correctBracketing(brackets[i])) {\n      bracketingPercentageCount++;\n    }\n  }\n  return bracketingPercentageCount;\n};\n\nconst getBracketingPercentageCounts = (text) => {\n  let brackets = getBrackets(text);\n  let bracketingPercentageCounts = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if (correctBracketing(brackets[i])) {\n      bracketingPercentageCounts.push(bracketingPercentageCount);\n    }\n  }\n  return bracketingPercentageCounts;\n};\n\nconst getBracketingPercentageCountsPercentages = (text) => {\n  let brackets = getBrackets(text);\n  let bracketingPercentageCounts = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if (correctBracketing(brackets[i])) {\n      bracketingPercentageCounts.push(bracketingPercentageCount);\n    }\n  }\n  let bracketingPercentageCountsPercentages = [];\n  for (let i = 0; i < bracketingPercentageCounts.length; i++) {\n    bracketingPercentageCountsPercentages.push(bracketingPercentageCounts[i] / brackets.length);\n  }\n  return bracketingPercentageCountsPercentages;\n};\n\nconst getBracketingPercentageCountsPercentagesPercentages = (text) => {\n  let brackets = getBrackets(text);\n  let bracketingPercentageCounts = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if (correctBracketing(brackets[i])) {\n      bracketingPercentageCounts.push(bracketingPercentageCount);\n    }\n  }\n  let bracketingPercentageCountsPercentages = [];\n  for (let i = 0; i < bracketingPercentageCounts.length; i++) {\n    bracketingPercentageCountsPercentages.push(bracketingPercentageCounts[i] / brackets.length);\n  }\n  return bracketingPercentageCountsPercentages;\n};\n\nconst getBracketingPercentageCountsPercentagesPercentagesPercentages = (text) => {\n  let brackets = getBrackets(text);\n  let bracketingPercentageCounts = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if (correctBracketing(brackets[i])) {\n      bracketingPercentageCounts.push(bracketingPercentageCount);\n    }\n  }\n  let bracketingPercentageCountsPercentages = [];\n  for (let i = 0; i < bracketingPercentageCounts.length; i++) {\n    bracketingPercentageCountsPercentages.push(bracketingPercentageCounts[i] / brackets.length);\n  }\n  let bracketingPercentageCountsPercentagesPercentages = [];\n  for (let i = 0; i < bracketingPercentageCountsPercentages.length; i++) {\n    bracketingPercentageCountsPercentagesPercentages.push(bracketingPercentageCountsPercentages[i] / brackets.length);\n  }\n  return bracketingPercentageCountsPercentagesPercentages;\n};\n\nmodule.exports = {\n  getBracketing,\n  getBracketingCount,\n  getBracketingPercentage,\n  getBracketingPercentageCount,\n  getBracketingPercentage", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs stage coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    recurrence derivative of this polynomial in the same human body.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 2, "perturbed": true, "gc": "/* xs stage coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    recurrence derivative of this polynomial in the same human body.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let xs2 = xs.slice(0);\n  let xs1 = xs2.slice(0);\n  let xs0 = xs1.slice(0);\n  let xs1_2 = xs1.slice(0);\n  let xs0_2 = xs0.slice(0);\n  let xs1_1 = xs1.slice(0);\n  let xs0_1 = xs0.slice(0);\n  let xs0_0 = xs0.slice(0);\n  let xs1_0 = xs1.slice(0);\n  let xs0_0_0 = xs0_0.slice(0);\n  let xs1_0_0 = xs1_0.slice(0);\n  let xs0_0_0_0 = xs0_0_0.slice(0);\n  let xs1_0_0_0 = xs1_0_0.slice(0);\n  let xs0_0_0_0_0 = xs0_0_0_0.slice(0);\n  let xs1_0_0_0_0 = xs1_0_0_0.slice(0);\n  let xs0_0_0_0_0_0 = xs0_0_0_0_0.slice(0);\n  let xs1_0_0_0_0_0 = xs1_0_0_0_0.slice(0);\n  let xs0_0_0_0_0_0_0 = xs0_0_0_0_0_0.slice(0);\n  let xs1_0_0_0_0_0_0 = xs1_0_0_0_0_0.slice(0);\n  let xs0_0_0_0_0_0_0_0 = xs0_0_0_0_0_0_0.slice(0);\n  let xs1_0_0_0_0_0_0_0_0 = xs1_0_0_0_0_0_0_0.slice(0);\n  let xs0_0_0_0_0_0_0_0_0_0 = xs0_0_0_0_0_0_0_0_0.slice(0);\n  let xs1_0_0_0_0_0_0_0_0_0_0 = xs1_0_0_0_0_0_0_0_0_0.slice(0);\n  let xs0_0_0_0_0_0_0_0_0_0_0_0 = xs0_0_0_0_0_0_0_0_0_0_0.slice(0);\n  let xs1_0_0_0_0_0_0_0_0_0_0_0_0 = xs1_0_0_0_0_0_0_0_0_0_0_0.slice(0);\n  let xs0_0_0_0_0_0_0_0_0_0_0_0_0_0 = xs0_0_0_0_0_0_0_0_0_0_0_0_0.slice(0);\n  let xs1_0_0_0_0_0_0_0_0_0_0_0_0_0_0 = xs1_0_0_0_0_0_0_0_0_0_0_0_0_0.slice(0);\n  let xs0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0 = xs0_0_0_0_0_0_0_0_0_0_0_0_0_0_0.slice(0);\n  let xs1_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0 = xs1_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0.slice(0);\n  let xs0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0 = xs0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0.slice(0);\n  let xs1_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0 = xs1_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0.slice(0);\n  let xs0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0 = xs0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0.slice(0);\n  let xs1_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0 = xs1_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib phone number sequence is a sequence exchangeable to the Fibbonacci sequnece that's defined as surveil: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a function to efficiently compute the n-th chemical element of the fibfib number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 2, "perturbed": true, "gc": "/*The FibFib phone number sequence is a sequence exchangeable to the Fibbonacci sequnece that's defined as surveil: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a function to efficiently compute the n-th chemical element of the fibfib number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 0) {\n    throw new Error('fibfib: n must be positive');\n  }\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 0;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  if (n === 3) {\n    return 1;\n  }\n  if (n === 4) {\n    return 2;\n  }\n  if (n === 5) {\n    return 3;\n  }\n  if (n === 6) {\n    return 5;\n  }\n  if (n === 7) {\n    return 8;\n  }\n  if (n === 8) {\n    return 13;\n  }\n  if (n === 9) {\n    return 21;\n  }\n  if (n === 10) {\n    return 34;\n  }\n  if (n === 11) {\n    return 55;\n  }\n  if (n === 12) {\n    return 89;\n  }\n  if (n === 13) {\n    return 144;\n  }\n  if (n === 14) {\n    return 233;\n  }\n  if (n === 15) {\n    return 377;\n  }\n  if (n === 16) {\n    return 610;\n  }\n  if (n === 17) {\n    return 987;\n  }\n  if (n === 18) {\n    return 1597;\n  }\n  if (n === 19) {\n    return 2584;\n  }\n  if (n === 20) {\n    return 4181;\n  }\n  if (n === 21) {\n    return 6765;\n  }\n  if (n === 22) {\n    return 10946;\n  }\n  if (n === 23) {\n    return 17711;\n  }\n  if (n === 24) {\n    return 28657;\n  }\n  if (n === 25) {\n    return 46368;\n  }\n  if (n === 26) {\n    return 75025;\n  }\n  if (n === 27) {\n    return 121393;\n  }\n  if (n === 28) {\n    return 196418;\n  }\n  if (n === 29) {\n    return 317811;\n  }\n  if (n === 30) {\n    return 514229;\n  }\n  if (n === 31) {\n    return 832040;\n  }\n  if (n === 32) {\n    return 1346269;\n  }\n  if (n === 33) {\n    return 2178309;\n  }\n  if (n === 34) {\n    return 3524578;\n  }\n  if (n === 35) {\n    return 5702887;\n  }\n  if (n === 36) {\n    return 9227465;\n  }\n  if (n === 37) {\n    return 14930352;\n  }\n  if (n === 38) {\n    return 24157817;\n  }\n  if (n === 39) {\n    return 39088169;\n  }\n  if (n === 40) {\n    return 63245929;\n  }\n  if (n === 41) {\n    return 102334155;\n  }\n  if (n === 42) {\n    return 165580141;\n  }\n  if (n === 43) {\n    return 267914296;\n  }\n  if (n === 44) {\n    return 433494437;\n  }\n  if (n === 45) {\n    return 701408733;\n  }\n  if (n === 46) {\n    return 1134903170;\n  }\n  if (n === 47) {\n    return 1836311903;\n  }\n  if (n === 48) {\n    return 2978090515;\n  }\n  if (n === 49) {\n    return 4875460145;\n  }\n  if (n === 50) {\n    return 7551842045;\n  }\n  if (n === 51) {\n    return 12243985185;\n  }\n  if (n === 52) {\n    return 18661538455;\n  }\n  if (n === 53) {\n    return 29780951535;\n  }\n  if (n === 54) {\n    return 48754601455;\n  }\n  if (n === 55) {\n    return 75518420455;\n  }\n  if (n === 56) {\n    return 122439851855;\n  }\n  if (n === 57) {\n    return 186615384555;\n  }\n  if (n === 58) {\n    return 297809515355;\n  }\n  if (n === 59) {\n    return 487546014555;\n  }\n  if (n === 60) {\n    return 755184204555;\n  }\n  if (n === 61) {\n    return 1224398518555;\n  }\n  if (n === 62) {\n    return 1866153845555;\n  }\n  if (n === 63) {\n    return 2978095153555;\n  }\n  if (n === 64) {\n    return 4875460145555;\n  }\n  if (n === 65) {\n    return 7551842045555;\n  }\n  if (n === 66) {\n    return 12243985185555;\n  }\n  if (n === 67) {\n    return 18661538455555;\n  }\n  if (n === 68) {\n    return 29780951535555;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a affair vowelsCount which takes a chain represent \n   a word as stimulation and returns the number of vowels in the string. \n   vowel in this casing are' a',' einsteinium',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but merely when it is at the conclusion of the give news. \n\n   case:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 2, "perturbed": true, "gc": "/*Write a affair vowelsCount which takes a chain represent \n   a word as stimulation and returns the number of vowels in the string. \n   vowel in this casing are' a',' einsteinium',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but merely when it is at the conclusion of the give news. \n\n   case:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let vowelsCount = 0;\n  let vowels = \"aeiouy\";\n  let", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digit of the integer x, shift the digit correct by shift\n   and return the result as a chain. \n   If shift > number of digits, return digits overrule.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 2, "perturbed": true, "gc": "/*Circular shift the digit of the integer x, shift the digit correct by shift\n   and return the result as a chain. \n   If shift > number of digits, return digits overrule.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = ''\n  let i = 0\n  while (i < x.length) {\n    result += x[i]\n    i += 1\n    if (i < x.length) {\n      result += x[i]\n    }\n    i += shift\n  }\n  return result\n}\n\nmodule.exports = circularShift\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/66", "prompt": "/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 2, "perturbed": true, "gc": "/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n//TODO:\n//  - add a function that takes a string and returns the sum of the upper character only\n//  - add a function that takes a string and returns the sum of the lower character only\n//  - add a function that takes a string and returns the sum of the lower and upper character only\n//  - add a function that takes a string and returns the sum of the upper and lower character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper and lower character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper and lower and upper and lower character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper and lower and upper and lower and upper and lower character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper and lower and upper and lower and upper and lower and upper and lower character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower character only\n//  - add a function that takes a string and returns the sum of the upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and upper and lower and", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this job, you will be given a string that defend a issue of apples and orange \n   that are distributed in a basket of fruit this basket contains \n   apples, orange, and mango fruits. give the drawstring that represent the entire numeral of \n   the oranges and apples and an integer that stage the total act of the fruits \n   in the basket return the number of the mango fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apple and 3 orange \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 2, "perturbed": true, "gc": "/*\n  In this job, you will be given a string that defend a issue of apples and orange \n   that are distributed in a basket of fruit this basket contains \n   apples, orange, and mango fruits. give the drawstring that represent the entire numeral of \n   the oranges and apples and an integer that stage the total act of the fruits \n   in the basket return the number of the mango fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apple and 3 orange \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n  let num = 0;\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] == 'a') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] == 'o') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] =='m') {\n      num = num + 1;\n      count = count + 1;\n    }\n    i = i + 1;\n  }\n  return num * count;\n}\n*/\n\nconst fruitDistribution = (s, n) => {\n  let num = 0;\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] == 'a') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] == 'o') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] =='m') {\n      num = num + 1;\n      count = count + 1;\n    }\n    i = i + 1;\n  }\n  return num * count;\n}\n\nconst fruitDistribution2 = (s, n) => {\n  let num = 0;\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] == 'a') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] == 'o') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] =='m') {\n      num = num + 1;\n      count = count + 1;\n    }\n    i = i + 1;\n  }\n  return num * count;\n}\n\nconst fruitDistribution3 = (s, n) => {\n  let num = 0;\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] == 'a') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] == 'o') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] =='m') {\n      num = num + 1;\n      count = count + 1;\n    }\n    i = i + 1;\n  }\n  return num * count;\n}\n\nconst fruitDistribution4 = (s, n) => {\n  let num = 0;\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] == 'a') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] == 'o') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] =='m') {\n      num = num + 1;\n      count = count + 1;\n    }\n    i = i + 1;\n  }\n  return num * count;\n}\n\nconst fruitDistribution5 = (s, n) => {\n  let num = 0;\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] == 'a') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] == 'o') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] =='m') {\n      num = num + 1;\n      count = count + 1;\n    }\n    i = i + 1;\n  }\n  return num * count;\n}\n\nconst fruitDistribution6 = (s, n) => {\n  let num = 0;\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] == 'a') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] == 'o') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] =='m') {\n      num = num + 1;\n      count = count + 1;\n    }\n    i = i + 1;\n  }\n  return num * count;\n}\n\nconst fruitDistribution7 = (s, n) => {\n  let num = 0;\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] == 'a') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] == 'o') {\n      num = num + 1;\n      count = count + 1;\n    }\n    if (s[i] =='m') {\n      num = num + 1;\n      count = count + 1;\n    }\n    i = i + 1;\n  }\n  return num * count;\n}\n\nconst fruitDistribution8 = (s, n) => {\n  let num = 0;\n  let count = 0;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" give an array represent a arm of a tree that has non - negative integer node \n   your task is to pluck one of the nodes and return it. \n   The plucked node should embody the lymph node with the smallest tied value. \n   If multiple node with the same minor tied value are find return the lymph node that has modest index. \n\n   The plucked lymph node should be returned in a list, [ smalest_value, its index ], \n   If there be no tied values or the give array equal empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 2, "perturbed": true, "gc": "/*\n  \" give an array represent a arm of a tree that has non - negative integer node \n   your task is to pluck one of the nodes and return it. \n   The plucked node should embody the lymph node with the smallest tied value. \n   If multiple node with the same minor tied value are find return the lymph node that has modest index. \n\n   The plucked lymph node should be returned in a list, [ smalest_value, its index ], \n   If there be no tied values or the give array equal empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  if (arr.length === 0) return [];\n  let result = [];\n  let min = arr[0];\n  let min_index = 0;\n  let i = 1;\n  while (i < arr.length) {\n    if (arr[i] < min) {\n      min = arr[i];\n      min_index = i;\n    }\n    i++;\n  }\n  result.push(min);\n  result.push(min_index);\n  return result;\n};\n\nmodule.exports = pluck;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are give a non - empty list of positivist integers. come back the greatest integer that be greater than \n   zero, and has a frequency greater than or adequate to the value of the integer itself. \n   The frequency of an integer is the numeral of time it appear in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a non - empty list of positivist integers. come back the greatest integer that be greater than \n   zero, and has a frequency greater than or adequate to the value of the integer itself. \n   The frequency of an integer is the numeral of time it appear in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = -1\n  let maxFreq = 0\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i]\n    if (freq > maxFreq) {\n      max = i\n      maxFreq = freq\n    }\n  }\n  return max\n}\n\nmodule.exports = search\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an remark list of strings only for ones that check give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 2, "perturbed": true, "gc": "/* Filter an remark list of strings only for ones that check give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an array of strings by a given substring\n  * @param {Array} strings - Array of strings to filter\n  * @param {String} substring - Substring to filter by\n  * @returns {Array} - Filtered array of strings\n  * @example\n  * filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  * // => ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring2 = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an array of strings by a given substring\n  * @param {Array} strings - Array of strings to filter\n  * @param {String} substring - Substring to filter by\n  * @returns {Array} - Filtered array of strings\n  * @example\n  * filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  * // => ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring3 = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an array of strings by a given substring\n  * @param {Array} strings - Array of strings to filter\n  * @param {String} substring - Substring to filter by\n  * @returns {Array} - Filtered array of strings\n  * @example\n  * filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  * // => ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring4 = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an array of strings by a given substring\n  * @param {Array} strings - Array of strings to filter\n  * @param {String} substring - Substring to filter by\n  * @returns {Array} - Filtered array of strings\n  * @example\n  * filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  * // => ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring5 = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an array of strings by a given substring\n  * @param {Array} strings - Array of strings to filter\n  * @param {String} substring - Substring to filter by\n  * @returns {Array} - Filtered array of strings\n  * @example\n  * filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  * // => ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring6 = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an array of strings by a given substring\n  * @param {Array} strings - Array of strings to filter\n  * @param {String} substring - Substring to filter by\n  * @returns {Array} - Filtered array of strings\n  * @example\n  * filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  * // => ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring7 = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an array of strings by a given substring\n  * @param {Array} strings - Array of strings to filter\n  * @param {String} substring - Substring to filter by\n  * @returns {Array} - Filtered array of strings\n  * @example\n  * filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  * // => ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring8 = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an array of strings by a given substring\n  * @param {Array} strings - Array of strings to filter\n  * @param {String} substring - Substring to filter by\n  * @returns {Array} - Filtered array of strings\n  * @example\n  * filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  * // => ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring9 = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an array of strings by a given substring\n  * @param {Array} strings - Array of strings to filter\n  * @param {String", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  give list of integers, return list in foreign decree. \n   foreign sorting, is when you originate with the minimum value, \n   then maximum of the persist integer, then minimum and thus on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 2, "perturbed": true, "gc": "/*\n  give list of integers, return list in foreign decree. \n   foreign sorting, is when you originate with the minimum value, \n   then maximum of the persist integer, then minimum and thus on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let result = []\n  let min = lst[0]\n  let max = lst[0]\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === min) {\n      result.push(max)\n    } else if (lst[i] === max) {\n      result.push(min)\n    } else {\n      result.push(lst[i])\n    }\n  }\n  return result\n}\n\nmodule.exports = strangeSortList\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/71", "prompt": "/*\n  give the lengths of the three side of a triangulum. refund the area of \n   the triangulum polish to 2 decimal points if the three side form a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangulum when the kernel of any two sides be great \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "/*\n  give the lengths of the three side of a triangulum. refund the area of \n   the triangulum polish to 2 decimal points if the three side form a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangulum when the kernel of any two sides be great \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let area = 0;\n  let ab = a - b;\n  let bc = b - c;\n  let ac = a - c;\n  let abbc = ab * ab;\n  let bcbc = bc * bc;\n  let acac = ac * ac;\n  let abbcbc = abbc * bc;\n  let abcac = abbc * ac;\n  let abcbcbc = abbcbc * bc;\n  let abcacbc = abcac * bc;\n  let abcacac = abcac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n  let abcacac = abcacac * ac;\n  let abcacbc = abcacbc * bc;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  compose a function that returns on-key if the aim q will vanish, and assumed otherwise. \n   The object q will fly if it's balanced (it is a palindromic list) and the union of its element be less than or equal the maximal potential system of weights w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function that returns on-key if the aim q will vanish, and assumed otherwise. \n   The object q will fly if it's balanced (it is a palindromic list) and the union of its element be less than or equal the maximal potential system of weights w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length === 0) {\n    return true;\n  }\n  let max = q.reduce((a, b) => a + b, 0);\n  if (max > w) {\n    return false;\n  }\n  let isBalanced = true;\n  for (let i = 0; i < q.length; i++) {\n    if (q[i]!== q[q.length - i - 1]) {\n      isBalanced = false;\n      break;\n    }\n  }\n  if (isBalanced) {\n    return true;\n  }\n  return false;\n};\n\nmodule.exports = willItFly;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  give an array arr of integer, witness the minimal number of chemical element that \n   need to be changed to make the array palindromic. A palindromic array is an array that \n   is learn the same backward and ahead. In one variety, you can switch one chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 2, "perturbed": true, "gc": "/*\n  give an array arr of integer, witness the minimal number of chemical element that \n   need to be changed to make the array palindromic. A palindromic array is an array that \n   is learn the same backward and ahead. In one variety, you can switch one chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = arr.length;\n  let change = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i];\n    arr[i] = arr[arr.length - i - 1];\n    arr[arr.length - i - 1] = temp;\n    let temp2 = arr.length - i - 1;\n    let temp3 = arr.length - i - 2;\n    let temp4 = arr.length - i - 3;\n    let temp5 = arr.length - i - 4;\n    let temp6 = arr.length - i - 5;\n    let temp7 = arr.length - i - 6;\n    let temp8 = arr.length - i - 7;\n    let temp9 = arr.length - i - 8;\n    let temp10 = arr.length - i - 9;\n    let temp11 = arr.length - i - 10;\n    let temp12 = arr.length - i - 11;\n    let temp13 = arr.length - i - 12;\n    let temp14 = arr.length - i - 13;\n    let temp15 = arr.length - i - 14;\n    let temp16 = arr.length - i - 15;\n    let temp17 = arr.length - i - 16;\n    let temp18 = arr.length - i - 17;\n    let temp19 = arr.length - i - 18;\n    let temp20 = arr.length - i - 19;\n    let temp21 = arr.length - i - 20;\n    let temp22 = arr.length - i - 21;\n    let temp23 = arr.length - i - 22;\n    let temp24 = arr.length - i - 23;\n    let temp25 = arr.length - i - 24;\n    let temp26 = arr.length - i - 25;\n    let temp27 = arr.length - i - 26;\n    let temp28 = arr.length - i - 27;\n    let temp29 = arr.length - i - 28;\n    let temp30 = arr.length - i - 29;\n    let temp31 = arr.length - i - 30;\n    let temp32 = arr.length - i - 31;\n    let temp33 = arr.length - i - 32;\n    let temp34 = arr.length - i - 33;\n    let temp35 = arr.length - i - 34;\n    let temp36 = arr.length - i - 35;\n    let temp37 = arr.length - i - 36;\n    let temp38 = arr.length - i - 37;\n    let temp39 = arr.length - i - 38;\n    let temp40 = arr.length - i - 39;\n    let temp41 = arr.length - i - 40;\n    let temp42 = arr.length - i - 41;\n    let temp43 = arr.length - i - 42;\n    let temp44 = arr.length - i - 43;\n    let temp45 = arr.length - i - 44;\n    let temp46 = arr.length - i - 45;\n    let temp47 = arr.length - i - 46;\n    let temp48 = arr.length - i - 47;\n    let temp49 = arr.length - i - 48;\n    let temp50 = arr.length - i - 49;\n    let temp51 = arr.length - i - 50;\n    let temp52 = arr.length - i - 51;\n    let temp53 = arr.length - i - 52;\n    let temp54 = arr.length - i - 53;\n    let temp55 = arr.length - i - 54;\n    let temp56 = arr.length - i - 55;\n    let temp57 = arr.length - i - 56;\n    let temp58 = arr.length - i - 57;\n    let temp59 = arr.length - i - 58;\n    let temp60 = arr.length - i - 59;\n    let temp61 = arr.length - i - 60;\n    let temp62 = arr.length - i - 61;\n    let temp63 = arr.length - i - 62;\n    let temp64 = arr.length - i - 63;\n    let temp65 = arr.length - i - 64;\n    let temp66 = arr.length - i - 65;\n    let temp67 = arr.length - i - 66;\n    let temp68 = arr.length - i - 67;\n    let temp69 = arr.length - i - 68;\n    let temp70 = arr.length - i - 69;\n    let temp71 = arr.length - i - 70;\n    let temp72 = arr.length - i - 71;\n    let temp73 = arr.length - i - 72;\n    let temp74 = arr.length - i - 73;\n    let temp75 = arr.length - i - 74;\n    let temp76 = arr.length - i - 75;\n    let temp77 = arr.length - i - 76;\n    let temp78 = arr.length - i - 77;\n    let temp79 = arr.length - i - 78;\n    let temp80 = arr.length - i - 79;\n    let temp81 = arr.length - i - 80;\n    let temp82 = arr.length - i - 81;\n    let temp83 = arr.length - i - 82;\n    let temp84 = arr.length - i - 83;\n    let temp85 = arr.length - i - 84;\n    let temp86 = arr.length - i - 85;\n    let temp87 = arr.length - i - 86;\n    let temp88 = arr.length - i - 87;\n    let temp89 = arr.length - i - 88;\n    let temp90 = arr.length - i - 89;\n    let temp91 = arr.length - i - 90;\n    let temp92 = arr.length - i - 91;\n    let temp93 = arr.length - i - 92;\n    let temp94 = arr.length - i - 93;\n    let temp95 = arr", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  compose a function that accepts two tilt of string and return the list that has \n   entire number of chars in the all chain of the list less than the other list.\n\n   if the two lists consume the like number of charwoman, return the inaugural list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function that accepts two tilt of string and return the list that has \n   entire number of chars in the all chain of the list less than the other list.\n\n   if the two lists consume the like number of charwoman, return the inaugural list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return [];\n  }\n  const result = [];\n  const lst1Len = lst1.length;\n  const lst2Len = lst2.length;\n  let i = 0;\n  while (i < lst1Len && i < lst2Len) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i]);\n      i++;\n    } else if (lst1[i] < lst2[i]) {\n      i++;\n    } else {\n      result.push(lst2[i]);\n      i = 0;\n    }\n  }\n  if (i === lst1Len) {\n    result.push(lst1[i]);\n  } else if (i === lst2Len) {\n    result.push(lst2[i]);\n  }\n  return result;\n};\n\nmodule.exports = totalMatch;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that come back dependable if the grant issue cost the multiplication of 3 prime number \n   and assumed otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 2, "perturbed": true, "gc": "/*Write a function that come back dependable if the grant issue cost the multiplication of 3 prime number \n   and assumed otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime2 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime3 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime4 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime5 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime6 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime7 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime8 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime9 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime10 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime11 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime12 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime13 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime14 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime15 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime16 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime17 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime18 = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime19 = (a", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your job is to write a function that retort on-key if a number x be a simple \n   power of n and false in other case. \n   x is a dim-witted power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 2, "perturbed": true, "gc": "/*Your job is to write a function that retort on-key if a number x be a simple \n   power of n and false in other case. \n   x is a dim-witted power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 1) {\n    return true;\n  }\n  if (x === n) {\n    return true;\n  }\n  if (x % n === 0) {\n    return false;\n  }\n  return isSimplePower(x, n);\n};\n\nconsole.log(isSimplePower(1, 4));\nconsole.log(isSimplePower(2, 2));\nconsole.log(isSimplePower(8, 2));\nconsole.log(isSimplePower(3, 2));\nconsole.log(isSimplePower(3, 1));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(3, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  return a % 3 === 0 && a % 4 === 0 && a % 5 === 0 && a % 6 === 0 && a % 7 === 0 && a % 8 === 0 && a % 9 === 0 && a % 10 === 0 && a % 11 === 0 && a % 12 === 0 && a % 13 === 0 && a % 14 === 0 && a % 15 === 0 && a % 16 === 0 && a % 17 === 0 && a % 18 === 0 && a % 19 === 0 && a % 20 === 0 && a % 21 === 0 && a % 22 === 0 && a % 23 === 0 && a % 24 === 0 && a % 25 === 0 && a % 26 === 0 && a % 27 === 0 && a % 28 === 0 && a % 29 === 0 && a % 30 === 0 && a % 31 === 0 && a % 32 === 0 && a % 33 === 0 && a % 34 === 0 && a % 35 === 0 && a % 36 === 0 && a % 37 === 0 && a % 38 === 0 && a % 39 === 0 && a % 40 === 0 && a % 41 === 0 && a % 42 === 0 && a % 43 === 0 && a % 44 === 0 && a % 45 === 0 && a % 46 === 0 && a % 47 === 0 && a % 48 === 0 && a % 49 === 0 && a % 50 === 0 && a % 51 === 0 && a % 52 === 0 && a % 53 === 0 && a % 54 === 0 && a % 55 === 0 && a % 56 === 0 && a % 57 === 0 && a % 58 === 0 && a % 59 === 0 && a % 60 === 0 && a % 61 === 0 && a % 62 === 0 && a % 63 === 0 && a % 64 === 0;\n};\n\nconst iscube2 = (a) => {\n  return a % 3 === 0 && a % 4 === 0 && a % 5 === 0 && a % 6 === 0 && a % 7 === 0 && a % 8 === 0 && a % 9 === 0 && a % 10 === 0 && a % 11 === 0 && a % 12 === 0 && a % 13 === 0 && a % 14 === 0 && a % 15 === 0 && a % 16 === 0 && a % 17 === 0 && a % 18 === 0 && a % 19 === 0 && a % 20 === 0 && a % 21 === 0 && a % 22 === 0 && a % 23 === 0 && a % 24 === 0 && a % 25 === 0 && a % 26 === 0 && a % 27 === 0 && a % 28 === 0 && a % 29 === 0 && a % 30 === 0 && a % 31 === 0 && a % 32 === 0 && a % 33 === 0 && a % 34 === 0 && a % 35 === 0 && a % 36 === 0 && a % 37 === 0 && a % 38 === 0 && a % 39 === 0 && a % 40 === 0 && a % 41 === 0 && a % 42 === 0 && a % 43 === 0 && a % 44 === 0 && a % 45 === 0 && a % 46 === 0 && a % 47 === 0 && a % 48 === 0 && a % 49 === 0 && a % 50 === 0 && a % 51 === 0 && a % 52 === 0 && a % 53 === 0 && a % 54 === 0 && a % 55 === 0 && a % 56 === 0 && a % 57 === 0 && a % 58 === 0 && a % 59 === 0 && a % 60 === 0 && a % 61 === 0 && a % 62 === 0 && a % 63 === 0 && a % 64 === 0;\n};\n\nconst iscube3 = (a) => {\n  return a % 3 === 0 && a % 4 === 0 && a % 5 === 0 && a % 6 === 0 && a % 7 === 0 && a % 8 === 0 && a % 9 === 0 && a % 10 === 0 && a % 11 === 0 && a % 12 === 0 && a % 13 === 0 && a % 14 === 0 && a % 15 === 0 && a % 16 === 0 && a % 17 === 0 && a % 18 === 0 && a % 19 === 0 && a % 20 === 0 && a % 21 === 0 && a % 22 === 0 && a % 23 === 0 && a % 24 === 0 && a % 25 === 0 && a % 26 === 0 && a % 27 === 0 && a % 28 === 0 && a % 29 === 0 && a % 30 === 0 && a % 31 === 0 && a % 32 === 0 && a % 33 === 0 && a % 34 === 0 && a % 35 === 0 && a % 36 === 0 && a % 37 === 0 && a % 38 === 0 && a % 39 === 0 && a % 40 === 0 && a % 41 === 0 && a % 42 === 0 && a % 43 === 0 && a % 44 === 0 && a % 45 === 0 && a % 46 === 0 && a % 47 === 0 && a % 48 === 0 && a % 49 === 0 && a % 50 === 0 && a % 51 === 0 && a % 52 === 0 && a % 53 === 0 && a % 54 === 0 && a % 55 === 0 && a % 56 === 0 && a % 57 === 0 && a % 58 === 0 && a % 59 === 0 && a % 60 === 0 && a % 61 === 0 && a % 62 === 0 && a % 63 === 0 && a % 64 === 0;\n};\n\nconst iscube4 = (a) => {\n  return a % 3 === 0 && a % 4 === 0 && a % 5 === 0 && a % 6 === 0 && a % 7 === 0 && a % 8 === 0 && a % 9 === 0 && a % 10 === 0 && a % 11 === 0 && a % 12 === 0 && a % 13 === 0 && a % 14 === 0 && a % 15 === 0 && a % 16 === 0 && a % 17 === 0 && a % 18 === 0 && a % 19 === 0 && a % 20 === 0 && a % 21 === 0 && a % 22 === 0 && a % 23 === 0 && a % 24 === 0 && a % 25 === 0 && a % 26 === 0 && a % 27 === 0 && a % 28 === 0 && a % 29 === 0 && a % 30 === 0 && a % 31 === 0 && a % 32 === 0 && a % 33 === 0 && a % 34 === 0 && a % 35 === 0 && a % 36 === 0 && a % 37 === 0 && a % 38 === 0 && a % 39 === 0 && a % 40 === 0 && a % 41 === 0 && a % 42 === 0 && a % 43 ===", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tax to write a function that receive \n   a hexadecimal phone number as a chain and counts the number of hexadecimal \n   digit that be primes (flower number=== or a prime=== is a natural issue \n   capital than 1 that exist not a merchandise of two little lifelike numbers). \n   Hexadecimal digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   thus you have to decide a number of the following digits: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== vitamin d (= decimal 13). \n   bill: you may assume the remark is always correct or empty string=== \n   and symbols A===B===C===D===E===F be always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 2, "perturbed": true, "gc": "/*You have been tax to write a function that receive \n   a hexadecimal phone number as a chain and counts the number of hexadecimal \n   digit that be primes (flower number=== or a prime=== is a natural issue \n   capital than 1 that exist not a merchandise of two little lifelike numbers). \n   Hexadecimal digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   thus you have to decide a number of the following digits: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== vitamin d (= decimal 13). \n   bill: you may assume the remark is always correct or empty string=== \n   and symbols A===B===C===D===E===F be always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let hexKey = 0;\n  let i = 0;\n  let len = num.length;\n  while (i < len) {\n    hexKey += parseInt(num[i], 10);\n    i++;\n  }\n  return hexKey;\n};\n\nconst prime = (num) => {\n  let prime = 0;\n  let i = 0;\n  let len = num.length;\n  while (i < len) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      prime += 1;\n    }\n    i++;\n  }\n  return prime;\n};\n\nconst getPrime = (num) => {\n  let prime = 0;\n  let i = 0;\n  let len = num.length;\n  while (i < len) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      prime += 1;\n    }\n    i++;\n  }\n  return prime;\n};\n\nconst getDigit = (num) => {\n  let digit = 0;\n  let i = 0;\n  let len = num.length;\n  while (i < len) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      digit += 1;\n    }\n    i++;\n  }\n  return digit;\n};\n\nconst getDigitPrime = (num) => {\n  let digit = 0;\n  let i = 0;\n  let len = num.length;\n  while (i < len) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      digit += 1;\n    }\n    i++;\n  }\n  return digit;\n};\n\nconst getDigitPrime2 = (num) => {\n  let digit = 0;\n  let i = 0;\n  let len = num.length;\n  while (i < len) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      digit += 1;\n    }\n    i++;\n  }\n  return digit;\n};\n\nconst getDigitPrime3 = (num) => {\n  let digit = 0;\n  let i = 0;\n  let len = num.length;\n  while (i < len) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      digit += 1;\n    }\n    i++;\n  }\n  return digit;\n};\n\nconst getDigitPrime4 = (num) => {\n  let digit = 0;\n  let i = 0;\n  let len = num.length;\n  while (i < len) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      digit += 1;\n    }\n    i++;\n  }\n  return digit;\n};\n\nconst getDigitPrime5 = (num) => {\n  let digit = 0;\n  let i = 0;\n  let len = num.length;\n  while (i < len) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      digit += 1;\n    }\n    i++;\n  }\n  return digit;\n};\n\nconst getDigitPrime6 = (num) => {\n  let digit = 0;\n  let i = 0;\n  let len = num.length;\n  while (i < len) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      digit += 1;\n    }\n    i++;\n  }\n  return digit;\n};\n\nconst getDigitPrime7 = (num) => {\n  let digit = 0;\n  let i = 0;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be give a number in decimal kind and your job equal to commute it to \n   binary format. The function should return a bowed stringed instrument, with each character representing a binary \n   number. Each quality in the bowed stringed instrument will embody' 0' or' 1'. \n\n   There will cost an extra couple of quality' db' at the beginning and at the goal of the drawstring. \n   The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 2, "perturbed": true, "gc": "/*You will be give a number in decimal kind and your job equal to commute it to \n   binary format. The function should return a bowed stringed instrument, with each character representing a binary \n   number. Each quality in the bowed stringed instrument will embody' 0' or' 1'. \n\n   There will cost an extra couple of quality' db' at the beginning and at the goal of the drawstring. \n   The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = \"\";\n  let binaryString = \"\";\n  let binaryStringLength = 0;\n  let binaryStringLength2 = 0;\n  let binaryStringLength3 = 0;\n  let binaryStringLength4 = 0;\n  let binaryStringLength5 = 0;\n  let binaryStringLength6 = 0;\n  let binaryStringLength7 = 0;\n  let binaryStringLength8 = 0;\n  let binaryStringLength9 = 0;\n  let binaryStringLength10 = 0;\n  let binaryStringLength11 = 0;\n  let binaryStringLength12 = 0;\n  let binaryStringLength13 = 0;\n  let binaryStringLength14 = 0;\n  let binaryStringLength15 = 0;\n  let binaryStringLength16 = 0;\n  let binaryStringLength17 = 0;\n  let binaryStringLength18 = 0;\n  let binaryStringLength19 = 0;\n  let binaryStringLength20 = 0;\n  let binaryStringLength21 = 0;\n  let binaryStringLength22 = 0;\n  let binaryStringLength23 = 0;\n  let binaryStringLength24 = 0;\n  let binaryStringLength25 = 0;\n  let binaryStringLength26 = 0;\n  let binaryStringLength27 = 0;\n  let binaryStringLength28 = 0;\n  let binaryStringLength29 = 0;\n  let binaryStringLength30 = 0;\n  let binaryStringLength31 = 0;\n  let binaryStringLength32 = 0;\n  let binaryStringLength33 = 0;\n  let binaryStringLength34 = 0;\n  let binaryStringLength35 = 0;\n  let binaryStringLength36 = 0;\n  let binaryStringLength37 = 0;\n  let binaryStringLength38 = 0;\n  let binaryStringLength39 = 0;\n  let binaryStringLength40 = 0;\n  let binaryStringLength41 = 0;\n  let binaryStringLength42 = 0;\n  let binaryStringLength43 = 0;\n  let binaryStringLength44 = 0;\n  let binaryStringLength45 = 0;\n  let binaryStringLength46 = 0;\n  let binaryStringLength47 = 0;\n  let binaryStringLength48 = 0;\n  let binaryStringLength49 = 0;\n  let binaryStringLength50 = 0;\n  let binaryStringLength51 = 0;\n  let binaryStringLength52 = 0;\n  let binaryStringLength53 = 0;\n  let binaryStringLength54 = 0;\n  let binaryStringLength55 = 0;\n  let binaryStringLength56 = 0;\n  let binaryStringLength57 = 0;\n  let binaryStringLength58 = 0;\n  let binaryStringLength59 = 0;\n  let binaryStringLength60 = 0;\n  let binaryStringLength61 = 0;\n  let binaryStringLength62 = 0;\n  let binaryStringLength63 = 0;\n  let binaryStringLength64 = 0;\n  let binaryStringLength65 = 0;\n  let binaryStringLength66 = 0;\n  let binaryStringLength67 = 0;\n  let binaryStringLength68 = 0;\n  let binaryStringLength69 = 0;\n  let binaryStringLength70 = 0;\n  let binaryStringLength71 = 0;\n  let binaryStringLength72 = 0;\n  let binaryStringLength73 = 0;\n  let binaryStringLength74 = 0;\n  let binaryStringLength75 = 0;\n  let binaryStringLength76 = 0;\n  let binaryStringLength77 = 0;\n  let binaryStringLength78 = 0;\n  let binaryStringLength79 = 0;\n  let binaryStringLength80 = 0;\n  let binaryStringLength81 = 0;\n  let binaryStringLength82 = 0;\n  let binaryStringLength83 = 0;\n  let binaryStringLength84 = 0;\n  let binaryStringLength85 = 0;\n  let binaryStringLength86 = 0;\n  let binaryStringLength87 = 0;\n  let binaryStringLength88 = 0;\n  let binaryStringLength89 = 0;\n  let binaryStringLength90 = 0;\n  let binaryStringLength91 = 0;\n  let binaryStringLength92 = 0;\n  let binaryStringLength93 = 0;\n  let binaryStringLength94 = 0;\n  let binaryStringLength95 = 0;\n  let binaryStringLength96 = 0;\n  let binaryStringLength97 = 0;\n  let binaryStringLength98 = 0;\n  let binaryStringLength99 = 0;\n  let binaryStringLength100 = 0;\n  let binaryStringLength101 = 0;\n  let binaryStringLength102 = 0;\n  let binaryStringLength103 = 0;\n  let binaryStringLength104 = 0;\n  let binaryStringLength105 = 0;\n  let binaryStringLength106 = 0;\n  let binaryStringLength107 = 0;\n  let binaryStringLength108 = 0;\n  let binaryStringLength109 = 0;\n  let binaryStringLength110 = 0;\n  let binaryStringLength111 = 0;\n  let binaryStringLength112 = 0;\n  let binaryStringLength113 = 0;\n  let binaryStringLength114 = 0;\n  let binaryStringLength115 = 0;\n  let binaryStringLength116 = 0;\n  let binaryStringLength117 = 0;\n  let binaryStringLength118 = 0;\n  let binaryStringLength119 = 0;\n  let binaryStringLength120 = 0;\n  let binaryStringLength121 = 0;\n  let binaryStringLength122 = 0;\n  let binaryStringLength123 = 0;\n  let binaryStringLength124 = 0;\n  let binaryStringLength125 = 0;\n  let binaryStringLength126 = 0;\n  let binaryStringLength127 = 0;\n  let binaryStringLength128 = 0;\n  let binaryStringLength129 = 0;\n  let binaryStringLength130 = 0;\n  let binaryStringLength131 = 0;\n  let binaryStringLength132 = 0;\n  let binaryStringLength133 = 0;\n  let binaryStringLength134 = 0;\n  let binaryStringLength135 = 0;\n  let binaryStringLength136 = 0;\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a give list of integers, return a tuple dwell of a union and a intersection of all the integer in a list.\n   Empty sum should be equal to 0 and empty product should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 2, "perturbed": true, "gc": "/* For a give list of integers, return a tuple dwell of a union and a intersection of all the integer in a list.\n   Empty sum should be equal to 0 and empty product should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0, product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\nconst test = () => {\n  const numbers = [1, 2, 3, 4];\n  const int = 10;\n  const result = sumProduct(numbers, int);\n  console.log(`sumProduct(numbers, ${int}) = ${result}`);\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/80", "prompt": "/*You are give a string s.\n   Your undertaking is to control if the drawstring is glad or not. \n   A bowed stringed instrument is happy if its length be at least 3 and every 3 consecutive letter are discrete\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 2, "perturbed": true, "gc": "/*You are give a string s.\n   Your undertaking is to control if the drawstring is glad or not. \n   A bowed stringed instrument is happy if its length be at least 3 and every 3 consecutive letter are discrete\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  let isHappy = true;\n  let index = 0;\n  let prev = s[0];\n  for (let i = 1; i < s.length; i++) {\n    if (s[i] === prev) {\n      index++;\n      if (index === 3) {\n        isHappy = true;\n      }\n    } else {\n      index = 0;\n    }\n    prev = s[i];\n  }\n  return isHappy;\n};\n\nmodule.exports = isHappy;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/81", "prompt": "/*Ithymine is the last workweek of the semester and the teacher suffer to contribute the grades\n   to students. The teacher has been making her own algorithm for grading. \n   The alone trouble is, she has lost the code she used for grade. \n   She has give you a list of grade point average for some students and you take to write \n   a function that can output a list of letter grades use the following table: \n            GPA        |     Letter grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 coke \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 five hundred \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 2, "perturbed": true, "gc": "/*Ithymine is the last workweek of the semester and the teacher suffer to contribute the grades\n   to students. The teacher has been making her own algorithm for grading. \n   The alone trouble is, she has lost the code she used for grade. \n   She has give you a list of grade point average for some students and you take to write \n   a function that can output a list of letter grades use the following table: \n            GPA        |     Letter grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 coke \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 five hundred \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrade = (grade) => {\n    if (grade >= 3.7) {\n      return 'A+';\n    } else if (grade >= 3.3) {\n      return 'A';\n    } else if (grade >= 3.0) {\n      return 'A-';\n    } else if (grade >= 2.7) {\n      return 'B+';\n    } else if (grade >= 2.3) {\n      return 'B';\n    } else if (grade >= 2.0) {\n      return 'B-';\n    } else if (grade >= 1.7) {\n      return 'C+';\n    } else if (grade >= 1.3) {\n      return 'C';\n    } else if (grade >= 1.0) {\n      return 'C-';\n    } else if (grade >= 0.7) {\n      return 'D+';\n    } else if (grade >= 0.3) {\n      return 'D';\n    } else {\n      return 'D-';\n    }\n  };\n  return grades.map(grade => letterGrade(grade));\n};\n\nmodule.exports = numericalLetterGrade;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a affair that takes a string and retort on-key if the string\n   length be a prime number or false differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 2, "perturbed": true, "gc": "/*Write a affair that takes a string and retort on-key if the string\n   length be a prime number or false differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  if (string.length < 3) {\n    return false;\n  }\n  const prime = true;\n  for (let i = 2; i < string.length; i++) {\n    if (string.length % i === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = primeLength;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/83", "prompt": "/*\n  give a positive integer n, return the count of the number of n-digit\n   positive integer that originate or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 2, "perturbed": true, "gc": "/*\n  give a positive integer n, return the count of the number of n-digit\n   positive integer that originate or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n   if (i === 1 || i === n) {\n    count++;\n   }\n  }\n  return count;\n }\n*/\n\nfunction startsOneEnds(n) {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n}\n\nmodule.exports = startsOneEnds;<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positivist integer N, return the entire union of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "/*Given a positivist integer N, return the entire union of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const digits = [...new Set(N.toString().split(''))];\n  const binary = digits.map((digit) => {\n    return digit === '0'? '0' : '1';\n  });\n  return binary.join('');\n};\n\nmodule.exports = solve;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integer lst. add the tied element that be at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "/*Given a non - empty list of integer lst. add the tied element that be at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    }\n  }\n  return sum\n}\n\nconst add2 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add3 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add4 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add5 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add6 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add7 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add8 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add9 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add10 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add11 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add12 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add13 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add14 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add15 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add16 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add17 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n      sum += lst[i] * 2\n    }\n  }\n  return sum\n}\n\nconst add18 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i]\n    } else {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/86", "prompt": "/*\n  compose a function that takes a chain and reelect an ordered interpretation of it. \n   Ordered version of string, is a chain where all words (separated by distance) \n   are replaced by a modern parole where all the characters stage in\n   ascending order establish on american standard code for information interchange value. \n   bill: You should keep the order of words and blank outer space in the conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function that takes a chain and reelect an ordered interpretation of it. \n   Ordered version of string, is a chain where all words (separated by distance) \n   are replaced by a modern parole where all the characters stage in\n   ascending order establish on american standard code for information interchange value. \n   bill: You should keep the order of words and blank outer space in the conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let result = ''\n  let words = s.split(' ')\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are give a 2 dimensional datum, as a cuddle tilt, \n   which is exchangeable to matrix, however, unlike matrices, \n   each rowing may check a unlike number of column. \n   give lst, and integer x, find oneself integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (course, column), start with 0. \n   Sort coordinates initially by rows in ascending orderliness. \n   Also, sort coordinates of the row by column in condescend holy order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a 2 dimensional datum, as a cuddle tilt, \n   which is exchangeable to matrix, however, unlike matrices, \n   each rowing may check a unlike number of column. \n   give lst, and integer x, find oneself integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (course, column), start with 0. \n   Sort coordinates initially by rows in ascending orderliness. \n   Also, sort coordinates of the row by column in condescend holy order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const sorted = lst.sort((a, b) => a[1] - b[1]);\n  const sortedByColumn = sorted.sort((a, b) => a[0] - b[0]);\n  const result = [];\n  for (let i = 0; i < sortedByColumn.length; i++) {\n    if (sortedByColumn[i][0] === x) {\n      result.push([sortedByColumn[i][1], i]);\n    }\n  }\n  return result;\n};\n\nconst getColumn = (lst, y) => {\n  const sorted = lst.sort((a, b) => a[1] - b[1]);\n  const sortedByRow = sorted.sort((a, b) => a[0] - b[0]);\n  const result = [];\n  for (let i = 0; i < sortedByRow.length; i++) {\n    if (sortedByRow[i][1] === y) {\n      result.push([sortedByRow[i][0], i]);\n    }\n  }\n  return result;\n};\n\nconst getColumns = (lst, y) => {\n  const sorted = lst.sort((a, b) => a[1] - b[1]);\n  const sortedByRow = sorted.sort((a, b) => a[0] - b[0]);\n  const result = [];\n  for (let i = 0; i < sortedByRow.length; i++) {\n    if (sortedByRow[i][1] === y) {\n      result.push([sortedByRow[i][0], i]);\n    }\n  }\n  return result;\n};\n\nconst getRows = (lst, x) => {\n  const sorted = lst.sort((a, b) => a[1] - b[1]);\n  const sortedByColumn = sorted.sort((a, b) => a[0] - b[0]);\n  const result = [];\n  for (let i = 0; i < sortedByColumn.length; i++) {\n    if (sortedByColumn[i][0] === x) {\n      result.push([sortedByColumn[i][1], i]);\n    }\n  }\n  return result;\n};\n\nconst getRowsByColumn = (lst, x) => {\n  const sorted = lst.sort((a, b) => a[1] - b[1]);\n  const sortedByColumn = sorted.sort((a, b) => a[0] - b[0]);\n  const result = [];\n  for (let i = 0; i < sortedByColumn.length; i++) {\n    if (sortedByColumn[i][0] === x) {\n      result.push([sortedByColumn[i][1], i]);\n    }\n  }\n  return result;\n};\n\nconst getRowsByRow = (lst, y) => {\n  const sorted = lst.sort((a, b) => a[1] - b[1]);\n  const sortedByRow = sorted.sort((a, b) => a[0] - b[0]);\n  const result = [];\n  for (let i = 0; i < sortedByRow.length; i++) {\n    if (sortedByRow[i][1] === y) {\n      result.push([sortedByRow[i][0], i]);\n    }\n  }\n  return result;\n};\n\nconst getRowsByRowAndColumn = (lst, y, x) => {\n  const sorted = lst.sort((a, b) => a[1] - b[1]);\n  const sortedByRow = sorted.sort((a, b) => a[0] - b[0]);\n  const sortedByColumn = sorted.sort((a, b) => a[1] - b[1]);\n  const result = [];\n  for (let i = 0; i < sortedByRow.length; i++) {\n    if (sortedByRow[i][1] === y) {\n      result.push([sortedByRow[i][0], i]);\n    }\n  }\n  for (let i = 0; i < sortedByColumn.length; i++) {\n    if (sortedByColumn[i][0] === x) {\n      result.push([sortedByColumn[i][1], i]);\n    }\n  }\n  return result;\n};\n\nconst getColumnsByRow = (lst, y) => {\n  const sorted = lst.sort((a, b) => a[1] - b[1]);\n  const sortedByRow = sorted.sort((a, b) => a[0] - b[0]);\n  const result = [];\n  for (let i = 0; i < sortedByRow.length; i++) {\n    if (sortedByRow[i][1] === y) {\n      result.push([sortedByRow[i][0], i]);\n    }\n  }\n  return result;\n};\n\nconst getColumnsByRowAndColumn = (lst, y, x) => {\n  const sorted = lst.sort((a, b) => a[1] - b[1]);\n  const sortedByRow = sorted.sort((a, b) => a[0] - b[0]);\n  const sortedByColumn =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  give an array of non - damaging integer, return a copy of the give array after screen, \n   you will sort the given array in ascend decree if the sum (beginning exponent value, final exponent value) is curious, \n   or sort it in descending ordering if the kernel (first index value, last index value) cost even. \n\n   Note: \n   * don't change the give array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "/*\n  give an array of non - damaging integer, return a copy of the give array after screen, \n   you will sort the given array in ascend decree if the sum (beginning exponent value, final exponent value) is curious, \n   or sort it in descending ordering if the kernel (first index value, last index value) cost even. \n\n   Note: \n   * don't change the give array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  if (array.length === 0) {\n    return array;\n  }\n  let newArray = array.slice();\n  let sortedArray = newArray.sort((a, b) => {\n    let sum = a + b;\n    if (sum % 2 === 0) {\n      return sum;\n    } else {\n      return sum * -1;\n    }\n  });\n  return sortedArray;\n};\n\nmodule.exports = sortArray;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a affair encrypt that takes a chain as an argumentation and \n   returns a chain encrypted with the alphabet being rotated. \n   The rudiment should be rotated in a manner such that the letters \n   careen down by two multiply to two space.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 2, "perturbed": true, "gc": "/*Create a affair encrypt that takes a chain as an argumentation and \n   returns a chain encrypted with the alphabet being rotated. \n   The rudiment should be rotated in a manner such that the letters \n   careen down by two multiply to two space.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let result = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s1 = 0;\n  let s2 = 0;\n  let s3 = 0;\n  let s4 = 0;\n  let s5 = 0;\n  let s6 = 0;\n  let s7 = 0;\n  let s8 = 0;\n  let s9 = 0;\n  let s10 = 0;\n  let s11 = 0;\n  let s12 = 0;\n  let s13 = 0;\n  let s14 = 0;\n  let s15 = 0;\n  let s16 = 0;\n  let s17 = 0;\n  let s18 = 0;\n  let s19 = 0;\n  let s20 = 0;\n  let s21 = 0;\n  let s22 = 0;\n  let s23 = 0;\n  let s24 = 0;\n  let s25 = 0;\n  let s26 = 0;\n  let s27 = 0;\n  let s28 = 0;\n  let s29 = 0;\n  let s30 = 0;\n  let s31 = 0;\n  let s32 = 0;\n  let s33 = 0;\n  let s34 = 0;\n  let s35 = 0;\n  let s36 = 0;\n  let s37 = 0;\n  let s38 = 0;\n  let s39 = 0;\n  let s40 = 0;\n  let s41 = 0;\n  let s42 = 0;\n  let s43 = 0;\n  let s44 = 0;\n  let s45 = 0;\n  let s46 = 0;\n  let s47 = 0;\n  let s48 = 0;\n  let s49 = 0;\n  let s50 = 0;\n  let s51 = 0;\n  let s52 = 0;\n  let s53 = 0;\n  let s54 = 0;\n  let s55 = 0;\n  let s56 = 0;\n  let s57 = 0;\n  let s58 = 0;\n  let s59 = 0;\n  let s60 = 0;\n  let s61 = 0;\n  let s62 = 0;\n  let s63 = 0;\n  let s64 = 0;\n  let s65 = 0;\n  let s66 = 0;\n  let s67 = 0;\n  let s68 = 0;\n  let s69 = 0;\n  let s70 = 0;\n  let s71 = 0;\n  let s72 = 0;\n  let s73 = 0;\n  let s74 = 0;\n  let s75 = 0;\n  let s76 = 0;\n  let s77 = 0;\n  let s78 = 0;\n  let s79 = 0;\n  let s80 = 0;\n  let s81 = 0;\n  let s82 = 0;\n  let s83 = 0;\n  let s84 = 0;\n  let s85 = 0;\n  let s86 = 0;\n  let s87 = 0;\n  let s88 = 0;\n  let s89 = 0;\n  let s90 = 0;\n  let s91 = 0;\n  let s92 = 0;\n  let s93 = 0;\n  let s94 = 0;\n  let s95 = 0;\n  let s96 = 0;\n  let s97 = 0;\n  let s98 = 0;\n  let s99 = 0;\n  let s100 = 0;\n  let s101 = 0;\n  let s102 = 0;\n  let s103 = 0;\n  let s104 = 0;\n  let s105 = 0;\n  let s106 = 0;\n  let s107 = 0;\n  let s108 = 0;\n  let s109 = 0;\n  let s110 = 0;\n  let s111 = 0;\n  let s112 = 0;\n  let s113 = 0;\n  let s114 = 0;\n  let s115 = 0;\n  let s116 = 0;\n  let s117 = 0;\n  let s118 = 0;\n  let s119 = 0;\n  let s120 = 0;\n  let s121 = 0;\n  let s122 = 0;\n  let s123 = 0;\n  let s124 = 0;\n  let s125 = 0;\n  let s126 = 0;\n  let s127 = 0;\n  let s128 = 0;\n  let s129 = 0;\n  let s130 = 0;\n  let s131 = 0;\n  let s132 = 0;\n  let s133 = 0;\n  let s134 = 0;\n  let s135 = 0;\n  let s136 = 0;\n  let s137 = 0;\n  let s138 = 0;\n  let s139 = 0;\n  let s140 = 0;\n  let s141 = 0;\n  let s142 = 0;\n  let s143 = 0;\n  let s144 = 0;\n  let s145 = 0;\n  let s146 = 0;\n  let s147 = 0;\n  let s148 = 0;\n  let s149 = 0;\n  let s150 = 0;\n  let s151 = 0;\n  let s152 = 0;\n  let s153 = 0;\n  let s154 = 0;\n  let s155 = 0;\n  let s156 = 0;\n  let s157 = 0;\n  let s158 = 0;\n  let s159 = 0;\n  let s160 = 0;\n  let s161 = 0;\n  let s162 = 0;\n  let s163 = 0;\n  let s164 = 0;\n  let s165 = 0;\n  let s166 = 0;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a give list of integers, render a list of roll maximal element find until given here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 2, "perturbed": true, "gc": "/* From a give list of integers, render a list of roll maximal element find until given here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = numbers[0];\n  let result = [];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result = [max];\n    } else if (numbers[i] === max) {\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/*\n  From a give list of integers, render a list of roll minimal element find until given here and now \n   in the succession.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 2, 2, 1]\n  */\nconst rollingMin = (numbers) => {\n  let min = numbers[0];\n  let result = [];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n      result = [min];\n    } else if (numbers[i] === min) {\n      result.push(min);\n    }\n  }\n  return result;\n};\n\n/*\n  From a give list of integers, render a list of roll maximal element find until given here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax2 = (numbers) => {\n  let max = numbers[0];\n  let result = [];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result = [max];\n    } else if (numbers[i] === max) {\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/*\n  From a give list of integers, render a list of roll minimal element find until given here and now \n   in the succession.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 2, 2, 1]\n  */\nconst rollingMin2 = (numbers) => {\n  let min = numbers[0];\n  let result = [];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n      result = [min];\n    } else if (numbers[i] === min) {\n      result.push(min);\n    }\n  }\n  return result;\n};\n\n/*\n  From a give list of integers, render a list of roll maximal element find until given here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax3 = (numbers) => {\n  let max = numbers[0];\n  let result = [];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result = [max];\n    } else if (numbers[i] === max) {\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/*\n  From a give list of integers, render a list of roll minimal element find until given here and now \n   in the succession.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 2, 2, 1]\n  */\nconst rollingMin3 = (numbers) => {\n  let min = numbers[0];\n  let result = [];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n      result = [min];\n    } else if (numbers[i] === min) {\n      result.push(min);\n    }\n  }\n  return result;\n};\n\n/*\n  From a give list of integers, render a list of roll maximal element find until given here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax4 = (numbers) => {\n  let max = numbers[0];\n  let result = [];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result = [max];\n    } else if (numbers[i] === max) {\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/*\n  From a give list of integers, render a list of roll minimal element find until given here and now \n   in the succession.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 2, 2, 1]\n  */\nconst rollingMin4 = (numbers) => {\n  let min = numbers[0];\n  let result = [];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n      result = [min];\n    } else if (numbers[i] === min) {\n      result.push(min);\n    }\n  }\n  return result;\n};\n\n/*\n  From a give list of integers, render a list of roll maximal element find until given here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax5 = (numbers) => {\n  let max = numbers[0];\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are give a list of integers. \n   publish a routine nextSmallest() that return the second smallest component of the list.\n   Return null if there is no such component. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a list of integers. \n   publish a routine nextSmallest() that return the second smallest component of the list.\n   Return null if there is no such component. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst[i];\n        lst[i] = lst[j];\n        lst[j] = tmp;\n      }\n      j++;\n    }\n    i++;\n  }\n  return lst[0];\n}\n\nconst nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst[i];\n        lst[i] = lst[j];\n        lst[j] = tmp;\n      }\n      j++;\n    }\n    i++;\n  }\n  return lst[0];\n}\n\nconst nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst[i];\n        lst[i] = lst[j];\n        lst[j] = tmp;\n      }\n      j++;\n    }\n    i++;\n  }\n  return lst[0];\n}\n\nconst nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst[i];\n        lst[i] = lst[j];\n        lst[j] = tmp;\n      }\n      j++;\n    }\n    i++;\n  }\n  return lst[0];\n}\n\nconst nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst[i];\n        lst[i] = lst[j];\n        lst[j] = tmp;\n      }\n      j++;\n    }\n    i++;\n  }\n  return lst[0];\n}\n\nconst nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst[i];\n        lst[i] = lst[j];\n        lst[j] = tmp;\n      }\n      j++;\n    }\n    i++;\n  }\n  return lst[0];\n}\n\nconst nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst[i];\n        lst[i] = lst[j];\n        lst[j] = tmp;\n      }\n      j++;\n    }\n    i++;\n  }\n  return lst[0];\n}\n\nconst nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst[i];\n        lst[i] = lst[j];\n        lst[j] = tmp;\n      }\n      j++;\n    }\n    i++;\n  }\n  return lst[0];\n}\n\nconst nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst[i];\n        lst[i] = lst[j];\n        lst[j] = tmp;\n      }\n      j++;\n    }\n    i++;\n  }\n  return lst[0];\n}\n\nconst nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst[i];\n        lst[i] = lst[j];\n        lst[j] = tmp;\n      }\n      j++;\n    }\n    i++;\n  }\n  return lst[0];\n}\n\nconst nextSmallest = (lst) = > {\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i + 1;\n    while (j < l) {\n      if (lst[i] < lst[j]) {\n        let tmp = lst", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be give a string of parole, and your job equal to reckon the act \n   of boredoms. A boredom is a conviction that start with the discussion \" I \". \n   conviction are delimited by'.','?' or'!'. \n \n   For exercise:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 2, "perturbed": true, "gc": "/*\n  You'll be give a string of parole, and your job equal to reckon the act \n   of boredoms. A boredom is a conviction that start with the discussion \" I \". \n   conviction are delimited by'.','?' or'!'. \n \n   For exercise:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored2 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored3 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored4 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored5 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored6 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored7 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored8 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored9 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored10 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored11 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored12 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored13 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored14 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored15 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored16 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst isBored17 = (S) => {\n  let i = 0\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n    } else {\n      return 0\n    }\n  }\n  return 1\n}\n\nconst is", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/92", "prompt": "/* produce a function that takes 3 number. \n   return true if one of the number is equal to the sum of the early two, and all numbers are integer. \n   Returns fake in any other case.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 2, "perturbed": true, "gc": "/* produce a function that takes 3 number. \n   return true if one of the number is equal to the sum of the early two, and all numbers are integer. \n   Returns fake in any other case.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true;\n  }\n  return false;\n};\n\nmodule.exports = anyInt;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  compose a function that takes a message, and encodes in such a \n   means that it swap casing of all letter, replaces all vowels in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english rudiment. \n   Assume only letter. \n  \n   exemplar:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function that takes a message, and encodes in such a \n   means that it swap casing of all letter, replaces all vowels in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english rudiment. \n   Assume only letter. \n  \n   exemplar:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let result = ''\n  let i = 0\n  while (i < message.length) {\n    let letter = message[i]\n    let nextLetter = message[i + 1]\n    let nextNextLetter = message[i + 2]\n    let nextNextNextLetter = message[i + 3]\n    let nextNextNextNextLetter = message[i + 4]\n    if (letter === nextLetter) {\n      result += letter\n      i += 2\n    } else if (letter === nextNextLetter) {\n      result += letter\n      i += 3\n    } else if (letter === nextNextNextLetter) {\n      result += letter\n      i += 4\n    } else if (letter === nextNextNextNextLetter) {\n      result += letter\n      i += 5\n    } else {\n      result += letter\n      i += 1\n    }\n  }\n  return result\n}\n\nmodule.exports = encode\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/94", "prompt": "/*You are give a list of integers. \n   You necessitate to determine the large choice value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 2, "perturbed": true, "gc": "/*You are give a list of integers. \n   You necessitate to determine the large choice value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst test = () => {\n  console.log(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]));\n  console.log(skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]));\n  console.log(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  give a dictionary, return truthful if all key equal chain in lower \n   case or all keys are chain in upper case, else return false. \n   The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 2, "perturbed": true, "gc": "/*\n  give a dictionary, return truthful if all key equal chain in lower \n   case or all keys are chain in upper case, else return false. \n   The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  let keys = Object.keys(dict);\n  let lower = keys.map((key) => key.toLowerCase());\n  let upper = keys.map((key) => key.toUpperCase());\n  return lower.every((key) => dict[key] === dict[key]) && upper.every((key) => dict[key] === dict[key]);\n};\n\nmodule.exports = checkDictCase;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a affair that takes an non - minus integer and render an array of the first n\n   integers that be choice number and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 2, "perturbed": true, "gc": "/*Implement a affair that takes an non - minus integer and render an array of the first n\n   integers that be choice number and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [1];\n  }\n  return [...Array(n).keys()].map((key) => {\n    const n = n - 1;\n    return [...Array(n).keys()].map((key) => {\n      const n = n - 1;\n      return [...Array(n).keys()].map((key) => {\n        const n = n - 1;\n        return [...Array(n).keys()].map((key) => {\n          const n = n - 1;\n          return [...Array(n).keys()].map((key) => {\n            const n = n - 1;\n            return [...Array(n).keys()].map((key) => {\n              const n = n - 1;\n              return [...Array(n).keys()].map((key) => {\n                const n = n - 1;\n                return [...Array(n).keys()].map((key) => {\n                  const n = n - 1;\n                  return [...Array(n).keys()].map((key) => {\n                    const n = n - 1;\n                    return [...Array(n).keys()].map((key) => {\n                      const n = n - 1;\n                      return [...Array(n).keys()].map((key) => {\n                        const n = n - 1;\n                        return [...Array(n).keys()].map((key) => {\n                          const n = n - 1;\n                          return [...Array(n).keys()].map((key) => {\n                            const n = n - 1;\n                            return [...Array(n).keys()].map((key) => {\n                              const n = n - 1;\n                              return [...Array(n).keys()].map((key) => {\n                                const n = n - 1;\n                                return [...Array(n).keys()].map((key) => {\n                                  const n = n - 1;\n                                  return [...Array(n).keys()].map((key) => {\n                                    const n = n - 1;\n                                    return [...Array(n).keys()].map((key) => {\n                                      const n = n - 1;\n                                      return [...Array(n).keys()].map((key) => {\n                                        const n = n - 1;\n                                        return [...Array(n).keys()].map((key) => {\n                                          const n = n - 1;\n                                          return [...Array(n).keys()].map((key) => {\n                                            const n = n - 1;\n                                            return [...Array(n).keys()].map((key) => {\n                                              const n = n - 1;\n                                              return [...Array(n).keys()].map((key) => {\n                                                const n = n - 1;\n                                                return [...Array(n).keys()].map((key) => {\n                                                  const n = n - 1;\n                                                  return [...Array(n).keys()].map((key) => {\n                                                    const n = n - 1;\n                                                    return [...Array(n).keys()].map((key) => {\n                                                      const n = n - 1;\n                                                      return [...Array(n).keys()].map((key) => {\n                                                        const n = n - 1;\n                                                        return [...Array(n).keys()].map((key) => {\n                                                          const n = n - 1;\n                                                          return [...Array(n).keys()].map((key) => {\n                                                            const n = n - 1;\n                                                            return [...Array(n).keys()].map((key) => {\n                                                              const n = n - 1;\n                                                              return [...Array(n).keys()].map((key) => {\n                                                                const n = n - 1;\n                                                                return [...Array(n).keys()].map((key) => {\n                                                                  const n = n - 1;\n                                                                  return [...Array(n).keys()].map((key) => {\n                                                                    const n = n - 1;\n                                                                    return [...Array(n).keys()].map((key) => {\n                                                                      const n = n - 1;\n                                                                      return [...Array(n).keys()].map((key) => {\n                                                                        const n = n - 1;\n                                                                        return [...Array(n).keys()].map((key) => {\n                                                                          const n = n - 1;\n                                                                          return [...Array(n).keys()].map((key) => {\n                                                                            const n = n - 1;\n                                                                            return [...Array(n).keys()].map((key) => {\n                                                                              const n = n - 1;\n                                                                              return [...Array(n).keys()].map((key) => {\n                                                                                const n = n - 1;\n                                                                                return [...Array(n).keys()].map((key) => {\n                                                                                  const n = n - 1;\n                                                                                  return [...Array(n).keys()].map((key) => {\n                                                                                    const n = n - 1;\n                                                                                    return [...Array(n).keys()].map((key) => {\n                                                                                      const n = n - 1;\n                                                                                      return [...Array(n).keys", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the affair that takes two integer and return \n   the intersection of their whole digit. \n   Assume the input is constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 2, "perturbed": true, "gc": "/*Complete the affair that takes two integer and return \n   the intersection of their whole digit. \n   Assume the input is constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let result = 0;\n  while (a > 0) {\n    if (a % 10 == b % 10) {\n      result += a % 10;\n      a /= 10;\n      b /= 10;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\nmodule.exports = multiply;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  give a string s, consider the phone number of capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 2, "perturbed": true, "gc": "/*\n  give a string s, consider the phone number of capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i + 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = countUpper;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/99", "prompt": "/* produce a function that takes a value (chain) represent a number \n   and render the closest integer to it. If the number be equidistant \n   from two integers, round it off from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 2, "perturbed": true, "gc": "/* produce a function that takes a value (chain) represent a number \n   and render the closest integer to it. If the number be equidistant \n   from two integers, round it off from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const int = Math.floor(value);\n  const dec = value - int;\n  if (dec === 0) {\n    return int;\n  }\n  if (dec < 0) {\n    return int - 1;\n  }\n  return int + 1;\n};\n\nexport default closestInteger;\n<|endoftext|>", "passed": 0, "run_status": 2}
