{"task_id": "JavaScript/0", "prompt": "/* Check match if in given pass list of numbers, are any two numbers closer to each other than \n   given hold threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 1, "perturbed": true, "gc": "/* Check match if in given pass list of numbers, are any two numbers closer to each other than \n   given hold threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const min = numbers.reduce((min, number) => Math.min(number, min), Infinity);\n  const max = numbers.reduce((max, number) => Math.max(number, max), -Infinity);\n  const range = max - min;\n  const thresholdSquared = threshold * threshold;\n  return numbers.reduce((result, number) => {\n    const distance = Math.abs(number - min);\n    if (distance < thresholdSquared) {\n      return result;\n    }\n    return result || distance < range;\n  }, false);\n};\n\nmodule.exports = hasCloseElements;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/1", "prompt": "/* Input input signal to this function routine is a string containing incorporate multiple groups of nested nest parentheses. Your goal finish is to \n   separate those group into separate freestanding strings and return the list of those. \n   Separate disjoined groups group are balanced (each open brace couple is properly closed) and not nested within each other \n   Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 1, "perturbed": true, "gc": "/* Input input signal to this function routine is a string containing incorporate multiple groups of nested nest parentheses. Your goal finish is to \n   separate those group into separate freestanding strings and return the list of those. \n   Separate disjoined groups group are balanced (each open brace couple is properly closed) and not nested within each other \n   Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  let paren_list = [];\n  let paren_count = 0;\n  let paren_string_length = paren_string.length;\n  let paren_string_index = 0;\n  let paren_string_char = '';\n  let paren_string_char_index = 0;\n  while (paren_string_index < paren_string_length) {\n    paren_string_char = paren_string[paren_string_index];\n    if (paren_string_char === '(') {\n      paren_count++;\n    } else if (paren_string_char === ')') {\n      paren_count--;\n    }\n    if (paren_count === 0) {\n      paren_list.push(paren_string.substring(paren_string_char_index, paren_string_index));\n      paren_string_char_index = paren_string_index + 1;\n    }\n    paren_string_index++;\n  }\n  return paren_list;\n};\n\nconst test_separateParenGroups = () => {\n  let paren_list = separateParenGroups('( ) (( )) (( )( ))');\n  console.log(paren_list);\n};\n\ntest_separateParenGroups();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/10", "prompt": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  if (string === '') {\n    return string;\n  }\n  const longestPostfix = string.split('').reverse().join('');\n  const prefix = longestPostfix.split('').reverse().join('');\n  const prefixLength = prefix.length;\n  const longestPalindrome = longestPostfix.split('').reverse().join('');\n  const longestPalindromeLength = longestPalindrome.length;\n  const longestPalindromePrefix = longestPalindrome.split('').reverse().join('');\n  const longestPalindromePrefixLength = longestPalindromePrefix.length;\n  const longestPalindromePrefixSuffix = longestPalindromePrefix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixLength = longestPalindromePrefixSuffix.length;\n  const longestPalindromePrefixSuffixSuffix = longestPalindromePrefixSuffix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixSuffixLength = longestPalindromePrefixSuffixSuffix.length;\n  const longestPalindromePrefixSuffixSuffixSuffix = longestPalindromePrefixSuffixSuffix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixSuffixSuffixLength = longestPalindromePrefixSuffixSuffixSuffix.length;\n  const longestPalindromePrefixSuffixSuffixSuffixSuffix = longestPalindromePrefixSuffixSuffixSuffix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixLength = longestPalindromePrefixSuffixSuffixSuffixSuffix.length;\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffix = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixLength = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffix.length;\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffix = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixLength = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffix.length;\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffix.length;\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix.length;\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix.length;\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix.split('').reverse().join('');\n  const longestPalindromePrefixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuff", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given grant a positive integer n, you have to make seduce a pile atomic pile of n levels grade of stones. \n   The first inaugural level has n stones stone. \n   The number of stones gem in the next future level is: \n       - the next following odd leftover number if n is odd curious. \n       - the next even number if n is even. \n   Return the number of stones in each level in a list, where element at index exponent \n   i represents the number of stones in the level degree (i+1).\n\n   Examples model:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, you have to make seduce a pile atomic pile of n levels grade of stones. \n   The first inaugural level has n stones stone. \n   The number of stones gem in the next future level is: \n       - the next following odd leftover number if n is odd curious. \n       - the next even number if n is even. \n   Return the number of stones in each level in a list, where element at index exponent \n   i represents the number of stones in the level degree (i+1).\n\n   Examples model:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let [a, b, c] = [0, 0, 0];\n  for (let i = 1; i <= n; i++) {\n    let left = i % 2;\n    let right = i % 2 === 0? 1 : 0;\n    if (left === right) {\n      a += i;\n    } else {\n      b += i;\n    }\n    c += i;\n  }\n  return [a, b, c];\n};\n\nmodule.exports = makeAPile;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given grant a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 1, "perturbed": true, "gc": "/*\n  You will be given grant a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/,|\\s+/);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString2 = (s) => {\n  let words = s.split(/,|\\s+/);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString3 = (s) => {\n  let words = s.split(/,|\\s+/);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString4 = (s) => {\n  let words = s.split(/,|\\s+/);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString5 = (s) => {\n  let words = s.split(/,|\\s+/);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString6 = (s) => {\n  let words = s.split(/,|\\s+/);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString7 = (s) => {\n  let words = s.split(/,|\\s+/);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString8 = (s) => {\n  let words = s.split(/,|\\s+/);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString9 = (s) => {\n  let words = s.split(/,|\\s+/);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString10 = (s) => {\n  let words = s.split(/,|", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function affair takes lead two positive numbers phone number x and y and returns the \n   biggest bad even integer number that is in the range image [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 1, "perturbed": true, "gc": "/*This function affair takes lead two positive numbers phone number x and y and returns the \n   biggest bad even integer number that is in the range image [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let x1 = x;\n  let y1 = y;\n  let x2 = x;\n  let y2 = y;\n  let x3 = x;\n  let y3 = y;\n  let x4 = x;\n  let y4 = y;\n  let x5 = x;\n  let y5 = y;\n  let x6 = x;\n  let y6 = y;\n  let x7 = x;\n  let y7 = y;\n  let x8 = x;\n  let y8 = y;\n  let x9 = x;\n  let y9 = y;\n  let x10 = x;\n  let y10 = y;\n  let x11 = x;\n  let y11 = y;\n  let x12 = x;\n  let y12 = y;\n  let x13 = x;\n  let y13 = y;\n  let x14 = x;\n  let y14 = y;\n  let x15 = x;\n  let y15 = y;\n  let x16 = x;\n  let y16 = y;\n  let x17 = x;\n  let y17 = y;\n  let x18 = x;\n  let y18 = y;\n  let x19 = x;\n  let y19 = y;\n  let x20 = x;\n  let y20 = y;\n  let x21 = x;\n  let y21 = y;\n  let x22 = x;\n  let y22 = y;\n  let x23 = x;\n  let y23 = y;\n  let x24 = x;\n  let y24 = y;\n  let x25 = x;\n  let y25 = y;\n  let x26 = x;\n  let y26 = y;\n  let x27 = x;\n  let y27 = y;\n  let x28 = x;\n  let y28 = y;\n  let x29 = x;\n  let y29 = y;\n  let x30 = x;\n  let y30 = y;\n  let x31 = x;\n  let y31 = y;\n  let x32 = x;\n  let y32 = y;\n  let x33 = x;\n  let y33 = y;\n  let x34 = x;\n  let y34 = y;\n  let x35 = x;\n  let y35 = y;\n  let x36 = x;\n  let y36 = y;\n  let x37 = x;\n  let y37 = y;\n  let x38 = x;\n  let y38 = y;\n  let x39 = x;\n  let y39 = y;\n  let x40 = x;\n  let y40 = y;\n  let x41 = x;\n  let y41 = y;\n  let x42 = x;\n  let y42 = y;\n  let x43 = x;\n  let y43 = y;\n  let x44 = x;\n  let y44 = y;\n  let x45 = x;\n  let y45 = y;\n  let x46 = x;\n  let y46 = y;\n  let x47 = x;\n  let y47 = y;\n  let x48 = x;\n  let y48 = y;\n  let x49 = x;\n  let y49 = y;\n  let x50 = x;\n  let y50 = y;\n  let x51 = x;\n  let y51 = y;\n  let x52 = x;\n  let y52 = y;\n  let x53 = x;\n  let y53 = y;\n  let x54 = x;\n  let y54 = y;\n  let x55 = x;\n  let y55 = y;\n  let x56 = x;\n  let y56 = y;\n  let x57 = x;\n  let y57 = y;\n  let x58 = x;\n  let y58 = y;\n  let x59 = x;\n  let y59 = y;\n  let x60 = x;\n  let y60 = y;\n  let x61 = x;\n  let y61 = y;\n  let x62 = x;\n  let y62 = y;\n  let x63 = x;\n  let y63 = y;\n  let x64 = x;\n  let y64 = y;\n  let x65 = x;\n  let y65 = y;\n  let x66 = x;\n  let y66 = y;\n  let x67 = x;\n  let y67 = y;\n  let x68 = x;\n  let y68 = y;\n  let x69 = x;\n  let y69 = y;\n  let x70 = x;\n  let y70 = y;\n  let x71 = x;\n  let y71 = y;\n  let x72 = x;\n  let y72 = y;\n  let x73 = x;\n  let y73 = y;\n  let x74 = x;\n  let y74 = y;\n  let x75 = x;\n  let y75 = y;\n  let x76 = x;\n  let y76 = y;\n  let x77 = x;\n  let y77 = y;\n  let x78 = x;\n  let y78 = y;\n  let x79 = x;\n  let y79 = y;\n  let x80 = x;\n  let y80 = y;\n  let x81 = x;\n  let y81 = y;\n  let x82 = x;\n  let y82 = y;\n  let x83 = x;\n  let y83 = y;\n  let x84 = x;\n  let y84 = y;\n  let x85 = x;\n  let y85 = y;\n  let x86 = x;\n  let y86 = y;\n  let x87 = x;\n  let y87 = y;\n  let x88 = x;\n  let y88 = y;\n  let x89 = x;\n  let y89 = y;\n  let x90 = x;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given grant two positive integers integer n and m, and your task undertaking is to compute calculate the \n   average of the integers from n through m (including admit n and m). \n   Round the answer to the nearest cheeseparing integer and convert that to binary. \n   If n is greater great than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 1, "perturbed": true, "gc": "/*You are given grant two positive integers integer n and m, and your task undertaking is to compute calculate the \n   average of the integers from n through m (including admit n and m). \n   Round the answer to the nearest cheeseparing integer and convert that to binary. \n   If n is greater great than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let avg = 0;\n  for (let i = n; i <= m; i++) {\n    avg += i;\n  }\n  avg /= (m - n + 1);\n  avg = Math.floor(avg);\n  if (avg > 0) {\n    avg = String(avg);\n  }\n  return avg;\n};\n\nconsole.log(roundedAvg(1, 5));\nconsole.log(roundedAvg(7, 5));\nconsole.log(roundedAvg(10, 20));\nconsole.log(roundedAvg(20, 33));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive cocksure integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted in increasing increase order. \n  \n   For example model:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 1, "perturbed": true, "gc": "/*Given a list of positive cocksure integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted in increasing increase order. \n  \n   For example model:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nmodule.exports = uniqueDigits;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given grant an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse revoke the resulting result array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse revoke the resulting result array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < sorted.length; i++) {\n    result.push(sorted[i] + reversed[i]);\n  }\n  return result;\n};\n\nconst byName = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  const sorted = arr.sort((a, b) => a.toLowerCase() - b.toLowerCase());\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < sorted.length; i++) {\n    result.push(sorted[i] + reversed[i]);\n  }\n  return result;\n};\n\nconst byLengthAndName = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  const sorted = arr.sort((a, b) => a.length - b.length);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < sorted.length; i++) {\n    result.push(sorted[i] + reversed[i]);\n  }\n  return result;\n};\n\nconst byLengthAndNameAndRevoke = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  const sorted = arr.sort((a, b) => a.length - b.length);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < sorted.length; i++) {\n    result.push(sorted[i] + reversed[i]);\n  }\n  return result;\n};\n\nconst byLengthAndNameAndRevokeAndSort = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  const sorted = arr.sort((a, b) => a.length - b.length);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < sorted.length; i++) {\n    result.push(sorted[i] + reversed[i]);\n  }\n  return result;\n};\n\nconst byLengthAndNameAndRevokeAndSortAndRevoke = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  const sorted = arr.sort((a, b) => a.length - b.length);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < sorted.length; i++) {\n    result.push(sorted[i] + reversed[i]);\n  }\n  return result;\n};\n\nconst byLengthAndNameAndRevokeAndSortAndRevokeAndSort = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  const sorted = arr.sort((a, b) => a.length - b.length);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < sorted.length; i++) {\n    result.push(sorted[i] + reversed[i]);\n  }\n  return result;\n};\n\nconst byLengthAndNameAndRevokeAndSortAndRevokeAndSortAndRevoke = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  const sorted = arr.sort((a, b) => a.length - b.length);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < sorted.length; i++) {\n    result.push(sorted[i] + reversed[i]);\n  }\n  return result;\n};\n\nconst byLengthAndNameAndRevokeAndSortAndRevokeAndSortAndRevokeAndSort = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  const sorted = arr.sort((a, b) => a.length - b.length);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < sorted.length; i++) {\n    result.push(sorted[i] + reversed[i]);\n  }\n  return result;\n};\n\nconst byLengthAndNameAndRev", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement follow through the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element component at index i is the factorial of i if i is even \n   or the sum kernel of numbers from 1 to i otherwise differently. \n   i starts from 1. \n   the factorial of i is the multiplication generation of the numbers issue from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 1, "perturbed": true, "gc": "/* Implement follow through the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element component at index i is the factorial of i if i is even \n   or the sum kernel of numbers from 1 to i otherwise differently. \n   i starts from 1. \n   the factorial of i is the multiplication generation of the numbers issue from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  let i = 1;\n  while (i < n) {\n    result.push(i);\n    i = i * 2;\n  }\n  return result;\n};\n\nconsole.log(f(5));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given grant a positive integer n, return a tuple that has the number issue of even and odd curious \n   integer palindromes palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, return a tuple that has the number issue of even and odd curious \n   integer palindromes palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let even = 0\n  let odd = 0\n  let oddPalindrome = []\n  let evenPalindrome = []\n  let oddPalindromeIndex = 0\n  let evenPalindromeIndex = 0\n  let oddPalindromeLength = 0\n  let evenPalindromeLength = 0\n\n  while (n > 0) {\n    if (n % 2 === 0) {\n      even++\n      oddPalindrome.push(n)\n      oddPalindromeIndex++\n    } else {\n      odd++\n      evenPalindrome.push(n)\n      evenPalindromeIndex++\n    }\n    n = n / 2\n  }\n\n  oddPalindromeLength = oddPalindrome.length\n  evenPalindromeLength = evenPalindrome.length\n\n  for (let i = 0; i < oddPalindromeLength; i++) {\n    if (oddPalindrome[i] % 2 === 0) {\n      even++\n    } else {\n      odd++\n    }\n  }\n\n  for (let i = 0; i < evenPalindromeLength; i++) {\n    if (evenPalindrome[i] % 2 === 0) {\n      even++\n    } else {\n      odd++\n    }\n  }\n\n  return [even, odd]\n}\n\nmodule.exports = evenOddPalindrome\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number issue of elements which has a sum kernel of digits > 0. \n   If a number act is negative, then its first beginning signed bless digit will be negative minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number issue of elements which has a sum kernel of digits > 0. \n   If a number act is negative, then its first beginning signed bless digit will be negative minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      count += arr[i];\n    }\n  }\n  return count;\n};\n\nmodule.exports = countNums;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers integer arr[1], arr[2],... , arr[N].The\n   numbers phone number in the array will be randomly ordered. Your task undertaking is to determine if \n   it is possible potential to get an array sorted classify in non - decreasing order by performing do \n   the following operation mathematical process on the given feed array: \n       You are allowed to perform do right shift operation any number of times. \n  \n   One right shift operation process means shifting all elements of the array by one \n   position situation in the right direction steering. The last final element of the array will be moved to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain prevail the sorted array by performing the above operation \n   then return true else return false. \n   If the given array is empty then return true dependable. \n\n   Note: The given list is guaranteed undertake to have unique singular elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 1, "perturbed": true, "gc": "/*We have an array 'arr' of N integers integer arr[1], arr[2],..., arr[N].The\n   numbers phone number in the array will be randomly ordered. Your task undertaking is to determine if \n   it is possible potential to get an array sorted classify in non - decreasing order by performing do \n   the following operation mathematical process on the given feed array: \n       You are allowed to perform do right shift operation any number of times. \n  \n   One right shift operation process means shifting all elements of the array by one \n   position situation in the right direction steering. The last final element of the array will be moved to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain prevail the sorted array by performing the above operation \n   then return true else return false. \n   If the given array is empty then return true dependable. \n\n   Note: The given list is guaranteed undertake to have unique singular elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] === arr[i + 1]) {\n      arr.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n  return arr.length === 0;\n};\n\nmodule.exports = moveOneBall;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/11", "prompt": "/* Input input signal are two strings string a and b consisting only of 1s and 0s zero. \n   Perform binary XOR on these inputs input and return result also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 1, "perturbed": true, "gc": "/* Input input signal are two strings string a and b consisting only of 1s and 0s zero. \n   Perform binary XOR on these inputs input and return result also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '1';\n      } else {\n        result += '0';\n      }\n    } else {\n      if (b[i] === '1') {\n        result += '0';\n      } else {\n        result += '1';\n      }\n    }\n  }\n  return result;\n};\n\nmodule.exports = stringXor;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/110", "prompt": "/*In this problem trouble, you will implement enforce a function that takes remove two lists of numbers issue, \n   and determines whether it is possible potential to perform an exchange of elements component \n   between them to make lst1 a list of only even numbers numeral. \n   There is no limit terminus ad quem on the number of exchanged change elements between lst1 and lst2.\n   If it is possible to exchange elements between the lst1 and lst2 to make \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 1, "perturbed": true, "gc": "/*In this problem trouble, you will implement enforce a function that takes remove two lists of numbers issue, \n   and determines whether it is possible potential to perform an exchange of elements component \n   between them to make lst1 a list of only even numbers numeral. \n   There is no limit terminus ad quem on the number of exchanged change elements between lst1 and lst2.\n   If it is possible to exchange elements between the lst1 and lst2 to make \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = 0;\n  let odd = 0;\n  let even_count = 0;\n  let odd_count = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even_count--;\n    } else {\n      odd_count--;\n    }\n  }\n  if (even_count === 0 && odd_count === 0) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n};\n\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 5, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/111", "prompt": "/*Given a string bowed stringed instrument representing exemplify a space separated distinguish lowercase letters letter, return a dictionary \n   of the letter with the most repetition and containing contain the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 1, "perturbed": true, "gc": "/*Given a string bowed stringed instrument representing exemplify a space separated distinguish lowercase letters letter, return a dictionary \n   of the letter with the most repetition and containing contain the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let histogramCount = 0;\n  let histogramLetter = '';\n  let histogramLetterCount = 0;\n  let histogramLetterCounts = [];\n  let histogramLetterCountsLength = 0;\n  let histogramLetterCountsLengths = [];\n  let histogramLetterCountsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengths = [];\n  let histogramLetterCountsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengths = [];\n  let histogramLetterCountsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengths = [];\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengths = [];\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength = 0;\n  let histogramLetterCountsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLengthsLength", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/112", "prompt": "/*Task necessitate \n   We are given pass two strings s and c, you have to deleted delete all the characters in s that are equal adequate to any character in c\n   then check see if the result string chain is palindrome. \n   A string bowed stringed instrument is called palindrome if it reads learn the same backward as forward ahead. \n   You should return a tuple containing the result consequence string and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 1, "perturbed": true, "gc": "/*Task necessitate \n   We are given pass two strings s and c, you have to deleted delete all the characters in s that are equal adequate to any character in c\n   then check see if the result string chain is palindrome. \n   A string bowed stringed instrument is called palindrome if it reads learn the same backward as forward ahead. \n   You should return a tuple containing the result consequence string and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let isPalindrome = true;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === c[0]) {\n      result += s[i];\n      i++;\n    } else {\n      result += s[i];\n      isPalindrome = false;\n      i++;\n    }\n  }\n  return [result, isPalindrome];\n};\n\nconst test = reverseDelete('abcde', 'ae');\nconsole.log(test);\n\nconst test2 = reverseDelete('abcdef', 'b');\nconsole.log(test2);\n\nconst test3 = reverseDelete('abcdedcba', 'ab');\nconsole.log(test3);\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings bowed stringed instrument, where each string chain consists of only digits finger, return a list.\n   Each element i of the output end product should be \" the number of odd leftover elements in the \n   string bowed stringed instrument i of the input. \" where all the i's should be replaced substitute by the number issue \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 1, "perturbed": true, "gc": "/*Given a list of strings bowed stringed instrument, where each string chain consists of only digits finger, return a list.\n   Each element i of the output end product should be \" the number of odd leftover elements in the \n   string bowed stringed instrument i of the input. \" where all the i's should be replaced substitute by the number issue \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let res = []\n  let str = ''\n  for (let i = 0; i < lst.length; i++) {\n    str += lst[i]\n    if (i % 2 === 0) {\n      res.push(str)\n      str = ''\n    }\n  }\n  return res\n}\n\nmodule.exports = oddCount\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given grant an array of integers nums, find line up the minimum minimal sum union of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array of integers nums, find line up the minimum minimal sum union of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const minSum = nums.reduce((a, b) => a + b, 0);\n  const minSumArr = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      const curSum = nums[i];\n      while (i < nums.length && nums[i] > 0) {\n        curSum += nums[i];\n        i++;\n      }\n      if (curSum < minSum) {\n        minSum = curSum;\n        minSumArr = [];\n        minSumArr.push(curSum);\n      } else if (curSum === minSum) {\n        minSumArr.push(curSum);\n      }\n    }\n  }\n  return minSumArr;\n};\n\nmodule.exports = minSubArraySum;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given grant a rectangular grid of wells well. Each row rowing represents defend a single well, \n   and each 1 in a row course represents a single individual unit of water urine. \n   Each well has a corresponding bucket that can be used practice to extract distill water from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use the buckets to empty the wells. \n   Output the number of times clock time you need necessitate to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a rectangular grid of wells well. Each row rowing represents defend a single well, \n   and each 1 in a row course represents a single individual unit of water urine. \n   Each well has a corresponding bucket that can be used practice to extract distill water from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use the buckets to empty the wells. \n   Output the number of times clock time you need necessitate to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const buckets = [...new Set(grid.map(row => row.map(col => col === 1)))];\n  const bucket_count = buckets.length;\n  const bucket_capacity = buckets[0].size;\n  const bucket_count_max = Math.max(...buckets.map(b => b.size));\n  const bucket_count_min = Math.min(...buckets.map(b => b.size));\n\n  let bucket_count_max_min = bucket_count_max - bucket_count_min;\n  let bucket_count_max_min_max = bucket_count_max_min - 1;\n\n  let bucket_count_max_min_max_max = bucket_count_max_min_max - 1;\n\n  let bucket_count_max_min_max_max_max = bucket_count_max_min_max_max - 1;\n\n  let bucket_count_max_min_max_max_max_max = bucket_count_max_min_max_max_max - 1;\n\n  let bucket_count_max_min_max_max_max_max_max = bucket_count_max_min_max_max_max_max - 1;\n\n  let bucket_count_max_min_max_max_max_max_max_max = bucket_count_max_min_max_max_max_max_max - 1;\n\n  let bucket_count_max_min_max_max_max_max_max_max_max = bucket_count_max_min_max_max_max_max_max_max - 1;\n\n  let bucket_count_max_min_max_max_max_max_max_max_max_max = bucket_count_max_min_max_max_max_max_max_max_max - 1;\n\n  let bucket_count_max_min_max_max_max_max_max_max_max_max_max = bucket_count_max_min_max_max_max_max_max_max_max_max - 1;\n\n  let bucket_count_max_min_max_max_max_max_max_max_max_max_max_max = bucket_count_max_min_max_max_max_max_max_max_max_max_max - 1;\n\n  let bucket_count_max_min_max_max_max_max_max_max_max_max_max_max_max_max = bucket_count_max_min_max_max_max_max_max_max_max_max_max_max_max - 1;\n\n  let bucket_count_max_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max = bucket_count_max_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max - 1;\n\n  let bucket_count_max_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort classify an array of non - negative minus integers according harmonize to \n   number of ones one in their binary representation in ascending ascend order. \n   For similar like number of ones one, sort based base on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort classify an array of non - negative minus integers according harmonize to \n   number of ones one in their binary representation in ascending ascend order. \n   For similar like number of ones one, sort based base on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sorted = arr.slice(0);\n  let sortedArr = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let count = 0;\n  let temp = 0;\n  while (i < arr.length) {\n    if (arr[i] === 0) {\n      count++;\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      j++;\n    } else {\n      count = 0;\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      j++;\n    }\n    i++;\n  }\n  while (j < arr.length) {\n    if (arr[j] === 0) {\n      count++;\n      temp = arr[j];\n      arr[j] = arr[k];\n      arr[k] = temp;\n      k++;\n    } else {\n      count = 0;\n      temp = arr[j];\n      arr[j] = arr[k];\n      arr[k] = temp;\n      k++;\n    }\n    j++;\n  }\n  while (k < arr.length) {\n    if (arr[k] === 0) {\n      count++;\n      temp = arr[k];\n      arr[k] = arr[j];\n      arr[j] = temp;\n      j++;\n    } else {\n      count = 0;\n      temp = arr[k];\n      arr[k] = arr[j];\n      arr[j] = temp;\n      j++;\n    }\n    k++;\n  }\n  while (j < arr.length) {\n    arr[j] = arr[j];\n    j++;\n  }\n  return arr;\n};\n\nconst test = () => {\n  let arr = [1, 5, 2, 3, 4];\n  console.log(sortArray(arr));\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked tax to implement \n   a function affair that returns a list of all words news from string s that contain control exactly precisely \n   n consonants, in order decree these words bible appear in the string chain s.\n   If the string s is empty then the function should return an empty list.\n   Note: you may assume the input string contains only letters letter and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 1, "perturbed": true, "gc": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked tax to implement \n   a function affair that returns a list of all words news from string s that contain control exactly precisely \n   n consonants, in order decree these words bible appear in the string chain s.\n   If the string s is empty then the function should return an empty list.\n   Note: you may assume the input string contains only letters letter and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    let k = 0;\n    while (j < s.length && k < n) {\n      if (s[j]!=='') {\n        k++;\n      }\n      j++;\n    }\n    if (k === n) {\n      words.push(s.slice(i, j));\n      i = j;\n    }\n  }\n  return words;\n};\n\nmodule.exports = selectWords;\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/118", "prompt": "/*You are given grant a word. Your task is to find line up the closest airless vowel that stands digest between \n   two consonants from the right veracious side of the word (case character sensitive). \n  \n   Vowels vowel in the beginning and ending doesn't count consider. Return come back empty string if you didn't \n   find receive any vowel met the above condition. \n\n   You may assume that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 1, "perturbed": true, "gc": "/*You are given grant a word. Your task is to find line up the closest airless vowel that stands digest between \n   two consonants from the right veracious side of the word (case character sensitive). \n  \n   Vowels vowel in the beginning and ending doesn't count consider. Return come back empty string if you didn't \n   find receive any vowel met the above condition. \n\n   You may assume that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let result = ''\n  let vowels = ['a', 'e', 'i', 'o', 'u']\n  let consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  let len = word.length\n  let i = 0\n  let j = len - 1\n  let k = 0\n  let min = 0\n  let minIndex = 0\n  while (i < j) {\n    k = 0\n    while (k < len) {\n      if (word[k] === word[i]) {\n        break\n      }\n      if (word[k] === word[j]) {\n        break\n      }\n      if (word[k] === word[i + 1]) {\n        break\n      }\n      if (word[k] === word[j - 1]) {\n        break\n      }\n      k++\n    }\n    if (k === len) {\n      i++\n    } else {\n      j--\n    }\n  }\n  while (i < j) {\n    if (word[i] === word[j]) {\n      break\n    }\n    if (word[i] === word[j + 1]) {\n      break\n    }\n    if (word[i] === word[j - 1]) {\n      break\n    }\n    i++\n    j--\n  }\n  if (i === j) {\n    result = vowels[i]\n  }\n  return result\n}\n\nconsole.log(getClosestVowel(\"yogurt\"))\nconsole.log(getClosestVowel(\"FULL\"))\nconsole.log(getClosestVowel(\"quick\"))\nconsole.log(getClosestVowel(\"ab\"))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/119", "prompt": "/* You are given grant a list of two strings, both strings bowed stringed instrument consist dwell of open overt \n   parentheses' (' or close cheeseparing parentheses')' only. \n   Your job problem is to check if it is possible potential to concatenate the two strings string section in\n   some order, that the resulting result string bowed stringed instrument will be good. \n   A string chain S is considered to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 1, "perturbed": true, "gc": "/* You are given grant a list of two strings, both strings bowed stringed instrument consist dwell of open overt \n   parentheses' (' or close cheeseparing parentheses')' only. \n   Your job problem is to check if it is possible potential to concatenate the two strings string section in\n   some order, that the resulting result string bowed stringed instrument will be good. \n   A string chain S is considered to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let result = 'No';\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    let str1 = str.slice(0, str.length - 1);\n    let str2 = str.slice(str.length - 1, str.length);\n    if (str1 === str2) {\n      result = 'Yes';\n      break;\n    }\n  }\n  return result;\n};\n\nconst test = () => {\n  let lst = ['()(', ')', '()', '()()', '()()()', '()()()()', '()()()()()'];\n  console.log(matchParens(lst));\n};\n\nif (module === require.main) {\n  test();\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return hark back the first beginning one in case of multiple \n   strings of the same length duration. Return null in case character the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 1, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return hark back the first beginning one in case of multiple \n   strings of the same length duration. Return null in case character the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) return null;\n  let longest = strings[0];\n  let longest_duration = 0;\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > longest_duration) {\n      longest = strings[i];\n      longest_duration = strings[i].length;\n    }\n  }\n  return longest;\n};\n\nmodule.exports = longest;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given grant an array arr of integers and a positive cocksure integer k, return a sorted screen list \n   of length duration k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array arr of integers and a positive cocksure integer k, return a sorted screen list \n   of length duration k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const arrLen = arr.length;\n  if (arrLen === 0) return [];\n  if (arrLen === 1) return arr;\n\n  const max = arr[0];\n  let maxIndex = 0;\n  for (let i = 1; i < arrLen; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n\n  const result = [];\n  for (let i = 0; i < k; i++) {\n    result.push(arr[maxIndex]);\n    maxIndex = (maxIndex + 1) % arrLen;\n  }\n\n  return result;\n};\n\nmodule.exports = maximum;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integers integer, return the sum union of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 1, "perturbed": true, "gc": "/*Given a non - empty list of integers integer, return the sum union of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solution;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given grant a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements chemical element with at most two digits finger from the first k elements component of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements chemical element with at most two digits finger from the first k elements component of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nexport default addElements\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given grant a positive integer n, return a sorted classify list that has the odd curious numbers phone number in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns concern a sequence defined specify \n   as follows: start begin with any positive cocksure integer n. Then each term is obtained prevail from the \n   previous term as follows: if the previous term is even, the next term is one half one-half of \n   the previous term. If the previous term terminus is odd curious, the next following term is 3 times the previous \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order holy order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, return a sorted classify list that has the odd curious numbers phone number in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns concern a sequence defined specify \n   as follows: start begin with any positive cocksure integer n. Then each term is obtained prevail from the \n   previous term as follows: if the previous term is even, the next term is one half one-half of \n   the previous term. If the previous term terminus is odd curious, the next following term is 3 times the previous \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order holy order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let oddNum = [1];\n  let oddNumList = [];\n  let oddNumListTemp = [];\n  let oddNumListTempTemp = [];\n  let oddNumListTempTempTemp = [];\n  let oddNumListTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTemp = [];\n  let oddNumListTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTempTemp", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write publish a function routine which validates a given hold date string and \n   returns rejoinder true if the date is valid otherwise differently false. \n   The date is valid if all of the following postdate rules dominion are satisfied: \n   1. The date string bowed stringed instrument is not empty. \n   2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months calendar month 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month calendar month 2. \n   3. The months month should not be less than 1 or higher gamey than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 1, "perturbed": true, "gc": "/*You have to write publish a function routine which validates a given hold date string and \n   returns rejoinder true if the date is valid otherwise differently false. \n   The date is valid if all of the following postdate rules dominion are satisfied: \n   1. The date string bowed stringed instrument is not empty. \n   2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months calendar month 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month calendar month 2. \n   3. The months month should not be less than 1 or higher gamey than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (date.length === 0) {\n    return false;\n  }\n  let month = date.substr(0, 2);\n  let day = date.substr(2, 2);\n  let year = date.substr(4, 4);\n  let days = day.split('-');\n  let months = month.split('-');\n  let yearDays = year.split('-');\n  let monthDays = months.map((month) => {\n    let monthDays = month.split('-');\n    return monthDays[1] - 1;\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return monthDays[1];\n    });\n    return monthDays[1];\n  });\n  let monthDays = monthDays.map((monthDays) => {\n    let monthDays = monthDays.map((monthDays) => {\n      let monthDays = monthDays.split('-');\n      return", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/125", "prompt": "/* Given grant a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 1, "perturbed": true, "gc": "/* Given grant a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = [];\n  let word = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/126", "prompt": "/* Given grant a list of numbers, return whether or not they are sorted classify \n   in ascending rise order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative damaging numbers and only integers integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 1, "perturbed": true, "gc": "/* Given grant a list of numbers, return whether or not they are sorted classify \n   in ascending rise order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative damaging numbers and only integers integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] < lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted2 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted3 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted4 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] < lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted5 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted6 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] < lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted7 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted8 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] < lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted9 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted10 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] < lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted11 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted12 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] < lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted13 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted14 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] < lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted15 = (lst) => {\n  let sorted = true;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n    i++;\n  }\n  return sorted;\n};\n\nconst isSorted16 = (lst) => {\n  let sorted = true", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/127", "prompt": "/*You are given grant two intervals, \n   where each interval time interval is a pair couple of integers integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 1, "perturbed": true, "gc": "/*You are given grant two intervals, \n   where each interval time interval is a pair couple of integers integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1.length!== interval2.length) return \"NO\"\n  const result = []\n  for (let i = 0; i < interval1.length; i++) {\n    const start = interval1[i][0]\n    const end = interval1[i][1]\n    const start2 = interval2[i][0]\n    const end2 = interval2[i][1]\n    if (start > end2 || start2 > end) return \"NO\"\n    if (start2 > end) {\n      result.push(end2)\n    } else {\n      result.push(start2)\n    }\n  }\n  return result.length === 0? \"NO\" : \"YES\"\n}\n\nconsole.log(intersection([[1, 2], [2, 3]], [[-1, 1], [0, 4]]))\nconsole.log(intersection([[-1, 1], [0, 4]], [[-3, -1], [-5, 5]]))\nconsole.log(intersection([[-3, -1], [-5, 5]], [[-1, 1], [0, 4]]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given grant an array arr of integers and you need want to return\n   sum union of magnitudes order of magnitude of integers multiplied reproduce by product of all signs sign of the zodiac \n   of each number in the array, represented exemplify by 1, -1 or 0. \n   Note bill: return null for empty arr.\n\n   Example exercise:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant an array arr of integers and you need want to return\n   sum union of magnitudes order of magnitude of integers multiplied reproduce by product of all signs sign of the zodiac \n   of each number in the array, represented exemplify by 1, -1 or 0. \n   Note bill: return null for empty arr.\n\n   Example exercise:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null;\n  }\n\n  let sign = arr[0];\n  let result = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      continue;\n    }\n    result += Math.abs(arr[i]);\n    if (arr[i] * sign < 0) {\n      sign = -sign;\n    } else {\n      sign = arr[i];\n    }\n  }\n  return result * sign;\n};\n\nmodule.exports = prodSigns;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given grant a grid with N rows and N columns column (N > = 2) and a positive convinced integer k, \n   each cell cellular telephone of the grid contains a value. Every integer in the range image [ 1, N * N ] \n   inclusive appears exactly precisely once on the cells of the grid.\n\n   You have to find rule the minimum path way of length distance k in the grid. You can start \n   from any cell cellular telephone, and in each step you can move to any of the neighbor cells, \n   in other words, you can go to cells which share an edge boundary with you current \n   cell. \n   Please note that a path of length distance k means entail visiting travel to exactly k cells (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length duration k) is considered less than a path B (of length k) if \n   after making the ordered arrange lists of the values value on the cells cellular telephone that A ampere and B boron go \n   through (let lease's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words lyric, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is unique alone. \n   Return an ordered arrange list of the values on the cells that the minimum path go start through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a grid with N rows and N columns column (N > = 2) and a positive convinced integer k, \n   each cell cellular telephone of the grid contains a value. Every integer in the range image [ 1, N * N ] \n   inclusive appears exactly precisely once on the cells of the grid.\n\n   You have to find rule the minimum path way of length distance k in the grid. You can start \n   from any cell cellular telephone, and in each step you can move to any of the neighbor cells, \n   in other words, you can go to cells which share an edge boundary with you current \n   cell. \n   Please note that a path of length distance k means entail visiting travel to exactly k cells (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length duration k) is considered less than a path B (of length k) if \n   after making the ordered arrange lists of the values value on the cells cellular telephone that A ampere and B boron go \n   through (let lease's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words lyric, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is unique alone. \n   Return an ordered arrange list of the values on the cells that the minimum path go start through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const gridSize = grid.length;\n  const gridSize2 = gridSize * gridSize;\n  const grid = new Array(gridSize2).fill(0);\n  for (let i = 0; i < gridSize2; i++) {\n    grid[i] = new Array(gridSize2).fill(0);\n  }\n  for (let i = 0; i < gridSize; i++) {\n    for (let j = 0; j < gridSize; j++) {\n      grid[i * gridSize + j] = grid[i * gridSize + j] + grid[i * gridSize + (j + 1) % gridSize] + grid[(i + 1) * gridSize + j] + grid[(i + 1) * gridSize + (j + 1) % gridSize];\n    }\n  }\n  const result = [];\n  for (let i = 0; i < gridSize; i++) {\n    result.push(grid[i * gridSize + i]);\n  }\n  return result;\n};\n\nmodule.exports = minPath;<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return rejoinder a greatest capital common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder a greatest capital common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a < b) {\n    return greatestCommonDivisor(b, a);\n  }\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a === 1) {\n    return b;\n  }\n  if (b === 1) {\n    return a;\n  }\n  let gcd = 1;\n  while (a % b!== 0) {\n    gcd = gcd * a % b;\n    a = a / b;\n    b = b / a;\n  }\n  return gcd;\n};\n\nmodule.exports = greatestCommonDivisor;\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries. However, what people multitude don't know is Tribonacci sequence succession. \n   Tribonacci sequence is defined define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd leftover.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 1, "perturbed": true, "gc": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries. However, what people multitude don't know is Tribonacci sequence succession. \n   Tribonacci sequence is defined define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd leftover.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 1;\n  let d = 1;\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(a + b + c + d);\n    a = b;\n    b = c;\n    c = d;\n    d = result[i - 1];\n  }\n  return result;\n};\n\nmodule.exports = tri;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive cocksure integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 1, "perturbed": true, "gc": "/*Given a positive cocksure integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0\n  for (let i = 1; i <= n; i++) {\n    result += (i % 2 === 0)? 0 : i\n  }\n  return result\n}\n\nmodule.exports = digits\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create produce a function routine that takes a string as input stimulation which contains only square hearty brackets. \n   The function affair should return true if and only if there is a valid subsequence sequel of brackets \n   where at least one bracket in the subsequence posteriority is nested nest. \n   isNested('[[]]')  true \n   isNested('[]]]]]]][[[[[]')  false assumed \n   isNested('[][]')  false \n   isNested('[]')  false \n   isNested('[[][]]')  true \n   isNested('[[]][[')  true \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 1, "perturbed": true, "gc": "/*\n  Create produce a function routine that takes a string as input stimulation which contains only square hearty brackets. \n   The function affair should return true if and only if there is a valid subsequence sequel of brackets \n   where at least one bracket in the subsequence posteriority is nested nest. \n   isNested('[[]]')  true \n   isNested('[]]]]]]][[[[[]')  false assumed \n   isNested('[][]')  false \n   isNested('[]')  false \n   isNested('[[][]]')  true \n   isNested('[[]][[')  true \n   * / \n const isNested = (string) = > {\n    let brackets = 0;\n    let bracket = 0;\n    let bracketCount = 0;\n    let bracketIndex = 0;\n    let bracketIndex2 = 0;\n    let bracketIndex3 = 0;\n    let bracketIndex4 = 0;\n    let bracketIndex5 = 0;\n    let bracketIndex6 = 0;\n    let bracketIndex7 = 0;\n    let bracketIndex8 = 0;\n    let bracketIndex9 = 0;\n    let bracketIndex10 = 0;\n    let bracketIndex11 = 0;\n    let bracketIndex12 = 0;\n    let bracketIndex13 = 0;\n    let bracketIndex14 = 0;\n    let bracketIndex15 = 0;\n    let bracketIndex16 = 0;\n    let bracketIndex17 = 0;\n    let bracketIndex18 = 0;\n    let bracketIndex19 = 0;\n    let bracketIndex20 = 0;\n    let bracketIndex21 = 0;\n    let bracketIndex22 = 0;\n    let bracketIndex23 = 0;\n    let bracketIndex24 = 0;\n    let bracketIndex25 = 0;\n    let bracketIndex26 = 0;\n    let bracketIndex27 = 0;\n    let bracketIndex28 = 0;\n    let bracketIndex29 = 0;\n    let bracketIndex30 = 0;\n    let bracketIndex31 = 0;\n    let bracketIndex32 = 0;\n    let bracketIndex33 = 0;\n    let bracketIndex34 = 0;\n    let bracketIndex35 = 0;\n    let bracketIndex36 = 0;\n    let bracketIndex37 = 0;\n    let bracketIndex38 = 0;\n    let bracketIndex39 = 0;\n    let bracketIndex40 = 0;\n    let bracketIndex41 = 0;\n    let bracketIndex42 = 0;\n    let bracketIndex43 = 0;\n    let bracketIndex44 = 0;\n    let bracketIndex45 = 0;\n    let bracketIndex46 = 0;\n    let bracketIndex47 = 0;\n    let bracketIndex48 = 0;\n    let bracketIndex49 = 0;\n    let bracketIndex50 = 0;\n    let bracketIndex51 = 0;\n    let bracketIndex52 = 0;\n    let bracketIndex53 = 0;\n    let bracketIndex54 = 0;\n    let bracketIndex55 = 0;\n    let bracketIndex56 = 0;\n    let bracketIndex57 = 0;\n    let bracketIndex58 = 0;\n    let bracketIndex59 = 0;\n    let bracketIndex60 = 0;\n    let bracketIndex61 = 0;\n    let bracketIndex62 = 0;\n    let bracketIndex63 = 0;\n    let bracketIndex64 = 0;\n    let bracketIndex65 = 0;\n    let bracketIndex66 = 0;\n    let bracketIndex67 = 0;\n    let bracketIndex68 = 0;\n    let bracketIndex69 = 0;\n    let bracketIndex70 = 0;\n    let bracketIndex71 = 0;\n    let bracketIndex72 = 0;\n    let bracketIndex73 = 0;\n    let bracketIndex74 = 0;\n    let bracketIndex75 = 0;\n    let bracketIndex76 = 0;\n    let bracketIndex77 = 0;\n    let bracketIndex78 = 0;\n    let bracketIndex79 = 0;\n    let bracketIndex80 = 0;\n    let bracketIndex81 = 0;\n    let bracketIndex82 = 0;\n    let bracketIndex83 = 0;\n    let bracketIndex84 = 0;\n    let bracketIndex85 = 0;\n    let bracketIndex86 = 0;\n    let bracketIndex87 = 0;\n    let bracketIndex88 = 0;\n    let bracketIndex89 = 0;\n    let bracketIndex90 = 0;\n    let bracketIndex91 = 0;\n    let bracketIndex92 = 0;\n    let bracketIndex93 = 0;\n    let bracketIndex94 = 0;\n    let bracketIndex95 = 0;\n    let bracketIndex96 = 0;\n    let bracketIndex97 = 0;\n    let bracketIndex98 = 0;\n    let bracketIndex99 = 0;\n    let bracketIndex100 = 0;\n    let bracketIndex101 = 0;\n    let bracketIndex102 = 0;\n    let bracketIndex103 = 0;\n    let bracketIndex104 = 0;\n    let bracketIndex105 = 0;\n    let bracketIndex106 = 0;\n    let bracketIndex107 = 0;\n    let bracketIndex108 = 0;\n    let bracketIndex109 = 0;\n    let bracketIndex110 = 0;\n    let bracketIndex111 = 0;\n    let bracketIndex112 = 0;\n    let bracketIndex113 = 0;\n    let bracketIndex114 = 0;\n    let bracketIndex115 = 0;\n    let bracketIndex116 = 0;\n    let bracketIndex117 = 0;\n    let bracketIndex118 = 0;\n    let bracketIndex119 = 0;\n    let bracketIndex120 = 0;\n    let bracketIndex121 = 0;\n    let bracketIndex122 = 0;\n    let bracketIndex123 = 0;\n    let bracketIndex124 = 0;\n    let bracketIndex125 = 0;\n    let bracketIndex126 = 0;\n    let bracketIndex127 = 0;\n    let bracketIndex128 = 0;\n    let bracketIndex129 = 0;\n    let bracketIndex130 = 0;\n    let bracketIndex131 = 0;\n    let bracketIndex132 = 0;\n    let bracketIndex133 = 0;\n    let bracketIndex134 = 0;\n    let bracketIndex135 = 0;\n    let bracketIndex136 = 0;\n    let bracketIndex137 = 0;\n    let bracketIndex138 = 0;\n    let bracketIndex139 = 0;\n    let bracketIndex140 = 0;\n    let bracketIndex141 = 0;\n    let bracketIndex142 = 0;\n    let bracketIndex143 = 0;\n    let bracketIndex144 = 0;\n    let bracketIndex145 = 0;\n    let bracketIndex146 = 0;\n    let bracketIndex147 = 0;\n    let bracketIndex148 = 0;\n    let bracketIndex149 = 0;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given grant a list of numbers. \n   You need want to return the sum union of squared numbers phone number in the given list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "/*You are given grant a list of numbers. \n   You need want to return the sum union of squared numbers phone number in the given list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let i = 0;\n  while (i < lst.length) {\n    sum += Math.pow(lst[i], 2);\n    i++;\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1,2,3]));\nconsole.log(sumSquares([1,4,9]));\nconsole.log(sumSquares([1,3,5,7]));\nconsole.log(sumSquares([1.4,4.2,0]));\nconsole.log(sumSquares([-2.4,1,1]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create produce a function routine that returns true truthful if the last character fictional character \n   of a given string drawstring is an alphabetical character quality and is not \n   a part contribution of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that returns true truthful if the last character fictional character \n   of a given string drawstring is an alphabetical character quality and is not \n   a part contribution of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (lastChar.match(/[a-zA-Z]/)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/* Create a function that returns true if the last character of a given string is an alphabetical character quality \n   and is not a part contribution of a word, and false assumed otherwise. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (lastChar.match(/[a-zA-Z]/)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/* Create a function that returns true if the last character of a given string is an alphabetical character quality \n   and is not a part contribution of a word, and false assumed otherwise. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (lastChar.match(/[a-zA-Z]/)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/* Create a function that returns true if the last character of a given string is an alphabetical character quality \n   and is not a part contribution of a word, and false assumed otherwise. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (lastChar.match(/[a-zA-Z]/)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/* Create a function that returns true if the last character of a given string is an alphabetical character quality \n   and is not a part contribution of a word, and false assumed otherwise. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (lastChar.match(/[a-zA-Z]/)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/* Create a function that returns true if the last character of a given string is an alphabetical character quality \n   and is not a part contribution of a word, and false assumed otherwise. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (lastChar.match(/[a-zA-Z]/)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/* Create a function that returns true if the last character of a given string is an alphabetical character quality \n   and is not a part contribution of a word, and false assumed otherwise. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (lastChar.match(/[a-zA-Z]/)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/* Create a function that returns true if the last character of a given string is an alphabetical character quality \n   and is not a part contribution of a word, and false assumed otherwise. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function affair which returns retort the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 1, "perturbed": true, "gc": "/*Create a function affair which returns retort the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let ret = -1;\n  let arrLen = arr.length;\n  let arrIndex = 0;\n  while (arrIndex < arrLen) {\n    let arrItem = arr[arrIndex];\n    let arrItemIndex = arrIndex + 1;\n    while (arrItemIndex < arrLen) {\n      if (arrItem < arr[arrItemIndex]) {\n        break;\n      }\n      arrItemIndex++;\n    }\n    if (arrItemIndex < arrLen) {\n      ret = arrIndex;\n      break;\n    }\n    arrIndex++;\n  }\n  return ret;\n};\n\nmodule.exports = canArrange;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create produce a function routine that returns a tuple (a, b), where 'a' is \n   the largest bombastic of negative integers integer, and 'b' is the smallest \n   of positive incontrovertible integers in a list.\n   If there is no negative minus or positive positivist integers, return them as null nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that returns a tuple (a, b), where 'a' is \n   the largest bombastic of negative integers integer, and 'b' is the smallest \n   of positive incontrovertible integers in a list.\n   If there is no negative minus or positive positivist integers, return them as null nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  let lstLen = lst.length;\n  if (lstLen > 0) {\n    for (let i = 0; i < lstLen; i++) {\n      let num = lst[i];\n      if (num < 0) {\n        if (max === null) {\n          max = num;\n        } else if (num > max) {\n          max = num;\n        }\n      } else if (num > 0) {\n        if (min === null) {\n          min = num;\n        } else if (num < min) {\n          min = num;\n        }\n      }\n    }\n  }\n  return [max, min];\n};\n\nmodule.exports = largestSmallestIntegers;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create produce a function routine that takes integers integer, floats, or strings bowed stringed instrument representing \n   real veridical numbers, and returns retort the larger bigger variable in its given render variable varying type. \n   Return null nothing if the values are equal. \n   Note: If a real number is represented as a string, the floating float point might be. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  null \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 1, "perturbed": true, "gc": "/*\n  Create produce a function routine that takes integers integer, floats, or strings bowed stringed instrument representing \n   real veridical numbers, and returns retort the larger bigger variable in its given render variable varying type. \n   Return null nothing if the values are equal. \n   Note: If a real number is represented as a string, the floating float point might be. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  null \n   * / \n const compareOne = (a, b) = > {\n  if (a === b) {\n   return a;\n  } else {\n   return null;\n  }\n }\n */\n\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return a;\n  } else {\n    return null;\n  }\n};\n\nmodule.exports = compareOne;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate measure whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 1, "perturbed": true, "gc": "/*Evaluate measure whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_2 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_3 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_4 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_5 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_6 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_7 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_8 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_9 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_10 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_11 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_12 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_13 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_14 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_15 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_16 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_17 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_18 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_19 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_20 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_21 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_22 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_23 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSumEven_24 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nconst isEqualToSum", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exemplar:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 1, "perturbed": true, "gc": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exemplar:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n < 0) {\n    throw new Error('The special factorial is defined as: \n      brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n      where n > 0 \n    ');\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) *... * specialFactorial(1);\n};\n\nconst factorial = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  return n * factorial(n - 1);\n};\n\nconst factorial_recursive = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  return n * factorial_recursive(n - 1);\n};\n\nconst factorial_iterative = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\nconst factorial_recursive_iterative = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\nconst factorial_iterative_recursive = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\nconst factorial_iterative_recursive_recursive = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\nconst factorial_iterative_recursive_recursive_recursive = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\nconst factorial_iterative_recursive_recursive_recursive_recursive = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\nconst factorial_iterative_recursive_recursive_recursive_recursive = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\nconst factorial_iterative_recursive_recursive_recursive_recursive_recursive = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\nconst factorial_iterative_recursive_recursive_recursive_recursive_recursive = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\nconst factorial_iterative_recursive_recursive_recursive_recursive_recursive = (n) => {\n  if (n < 0) {\n    throw new Error('The factorial is defined as: \n      n! = 1 * 2 * 3 *... * n \n      where n > 0 \n    ');\n  }\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\nconst factorial_iterative_recursive_recursive_recursive_recursive_recursive = (n) => {\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return rejoinder list of all prefixes prefix from shortest to longest of the input stimulation string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder list of all prefixes prefix from shortest to longest of the input stimulation string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [];\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.substr(0, i);\n    if (prefixes.indexOf(prefix) === -1) {\n      prefixes.push(prefix);\n    }\n    i++;\n  }\n  return prefixes;\n};\n\n/**\n  * Return the first prefix of the input stimulation string\n  * @param {string} string\n  * @return {string}\n  */\nconst firstPrefix = (string) => {\n  let prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/**\n  * Return the last prefix of the input stimulation string\n  * @param {string} string\n  * @return {string}\n  */\nconst lastPrefix = (string) => {\n  let prefixes = allPrefixes(string);\n  return prefixes[prefixes.length - 1];\n};\n\n/**\n  * Return the first suffix of the input stimulation string\n  * @param {string} string\n  * @return {string}\n  */\nconst firstSuffix = (string) => {\n  let suffixes = allPrefixes(string);\n  return suffixes[suffixes.length - 1];\n};\n\n/**\n  * Return the last suffix of the input stimulation string\n  * @param {string} string\n  * @return {string}\n  */\nconst lastSuffix = (string) => {\n  let suffixes = allPrefixes(string);\n  return suffixes[0];\n};\n\n/**\n  * Return the first and last prefix and suffix of the input stimulation string\n  * @param {string} string\n  * @return {string}\n  */\nconst firstAndLastPrefixAndSuffix = (string) => {\n  let prefixes = allPrefixes(string);\n  let suffixes = allPrefixes(string);\n  return prefixes[0] + suffixes[0];\n};\n\n/**\n  * Return the first and last prefix and suffix of the input stimulation string\n  * @param {string} string\n  * @return {string}\n  */\nconst firstAndLastSuffix = (string) => {\n  let suffixes = allPrefixes(string);\n  let prefixes = allPrefixes(string);\n  return suffixes[0] + prefixes[0];\n};\n\n/**\n  * Return the first and last prefix and suffix of the input stimulation string\n  * @param {string} string\n  * @return {string}\n  */\nconst firstAndLastSuffixAndPrefix = (string) => {\n  let prefixes = allPrefixes(string);\n  let suffixes = allPrefixes(string);\n  return suffixes[0] + prefixes[0];\n};\n\nmodule.exports = {\n  firstPrefix,\n  lastPrefix,\n  firstSuffix,\n  lastSuffix,\n  firstAndLastPrefixAndSuffix,\n  firstAndLastSuffix,\n  firstAndLastSuffixAndPrefix,\n};\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given grant a string text, replace substitute all spaces space in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace substitute all consecutive spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a string text, replace substitute all spaces space in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace substitute all consecutive spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\nconst fixSpaces2 = (text) => {\n  return text.replace(/\\s+/g, '-')\n}\n\nconst fixSpaces3 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces4 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces5 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces6 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces7 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces8 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces9 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces10 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces11 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces12 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces13 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces14 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces15 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces16 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces17 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces18 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces19 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces20 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces21 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces22 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces23 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces24 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces25 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces26 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces27 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces28 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces29 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces30 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces31 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces32 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces33 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces34 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces35 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces36 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces37 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces38 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces39 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces40 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces41 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces42 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces43 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces44 = (text) => {\n  return text.replace(/\\s+/g,'')\n}\n\nconst fixSpaces45 = (text) => {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a function affair which takes lead a string representing defend a file's name, and returns \n  ' Yes' if the the file's name is valid, and returns rejoinder' No' otherwise. \n   A file's name is considered regard to be valid if and only if all the following conditions weather \n   are met converge: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains check exactly precisely one dot'.' \n   - The substring before the dot department of transportation should not be empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 1, "perturbed": true, "gc": "/*Create a function affair which takes lead a string representing defend a file's name, and returns \n 'Yes' if the the file's name is valid, and returns rejoinder' No' otherwise. \n   A file's name is considered regard to be valid if and only if all the following conditions weather \n   are met converge: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains check exactly precisely one dot'.' \n   - The substring before the dot department of transportation should not be empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  if (file_name.length < 3) {\n    return \"No\";\n  }\n  let file_name_check = file_name.split(\".\");\n  if (file_name_check[0].length < 3) {\n    return \"No\";\n  }\n  if (file_name_check[0].indexOf(\".\")!== 0) {\n    return \"No\";\n  }\n  let file_name_check_after_dot = file_name_check[1].split(\" \");\n  if (file_name_check_after_dot.length!== 1) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].length < 3) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\".\")!== 0) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\"a\")!== 0) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\"z\")!== 0) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\"A\")!== 0) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\"Z\")!== 0) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\"t\")!== 0) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\"x\")!== 0) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\"e\")!== 0) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\"d\")!== 0) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\"l\")!== 0) {\n    return \"No\";\n  }\n  if (file_name_check_after_dot[0].indexOf(\".\")!== 0) {\n    return \"No\";\n  }\n  return \"Yes\";\n};\n\nmodule.exports = fileNameCheck;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function affair will take lead a list of integers. For all entries introduction in the list, the function shall square feather the integer entry if its index exponent is a \n   multiple of 3 and will cube the integer entry if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change deepen the entries submission in the list whose indexes are not a multiple of 3 or 4. The function routine shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "/*\"\n  This function affair will take lead a list of integers. For all entries introduction in the list, the function shall square feather the integer entry if its index exponent is a \n   multiple of 3 and will cube the integer entry if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change deepen the entries submission in the list whose indexes are not a multiple of 3 or 4. The function routine shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 || i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1,2,3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1,-5,2,-1,-5]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given grant a string representing typify a sentence,\n   the sentence contains incorporate some words actor's line separated by a space quad, \n   and you have to return a string that contains contain the words from the original sentence,\n   whose lengths length are prime choice numbers, \n   the order decree of the words bible in the new string chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a string representing typify a sentence,\n   the sentence contains incorporate some words actor's line separated by a space quad, \n   and you have to return a string that contains contain the words from the original sentence,\n   whose lengths length are prime choice numbers, \n   the order decree of the words bible in the new string chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(' ');\n  let result = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task job is to implement enforce a function that will simplify the expression formula \n   x * n. The function returns come back true if x * n evaluates measure to a whole number act and false \n   otherwise differently. Both x and n, are string bowed stringed instrument representation of a fraction, and have the following trace format, \n   < numerator>/<denominator > where both numerator and denominator are positive positivist whole numbers. \n\n   You can assume that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false fake \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 1, "perturbed": true, "gc": "/*Your task job is to implement enforce a function that will simplify the expression formula \n   x * n. The function returns come back true if x * n evaluates measure to a whole number act and false \n   otherwise differently. Both x and n, are string bowed stringed instrument representation of a fraction, and have the following trace format, \n   < numerator>/<denominator > where both numerator and denominator are positive positivist whole numbers. \n\n   You can assume that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false fake \n   * / \n const simplify = (x, n) = > {\n   let x = x.split(\"/\");\n   let n = n.split(\"/\");\n   let x_num = x[0];\n   let x_den = x[1];\n   let n_num = n[0];\n   let n_den = n[1];\n   let x_num_int = parseInt(x_num);\n   let n_num_int = parseInt(n_num);\n   let x_den_int = parseInt(x_den);\n   let n_den_int = parseInt(n_den);\n   let x_num_float = parseFloat(x_num);\n   let n_num_float = parseFloat(n_num);\n   let x_den_float = parseFloat(x_den);\n   let n_den_float = parseFloat(n_den);\n   let x_num_float_int = x_num_float.toFixed(0);\n   let n_num_float_int = n_num_float.toFixed(0);\n   let x_den_float_int = x_den_float.toFixed(0);\n   let n_den_float_int = n_den_float.toFixed(0);\n   let x_num_float_float = x_num_float.toFixed(1);\n   let n_num_float_float = n_num_float.toFixed(1);\n   let x_den_float_float = x_den_float.toFixed(1);\n   let n_den_float_float = n_den_float.toFixed(1);\n   let x_num_float_int_int = x_num_float_int.toString();\n   let n_num_float_int_int = n_num_float_int.toString();\n   let x_den_float_int_int = x_den_float_int.toString();\n   let n_den_float_int_int = n_den_float_int.toString();\n   let x_num_float_float_int = x_num_float_float.toString();\n   let n_num_float_float_int = n_num_float_float.toString();\n   let x_den_float_float_int = x_den_float_float.toString();\n   let n_den_float_float_int = n_den_float_float.toString();\n   let x_num_float_int_float = x_num_float_int_int.toString();\n   let n_num_float_int_float = n_num_float_int_float.toString();\n   let x_den_float_int_float = x_den_float_int_float.toString();\n   let n_den_float_int_float = n_den_float_int_float.toString();\n   let x_num_float_float_float = x_num_float_float_int.toString();\n   let n_num_float_float_float = n_num_float_float_int.toString();\n   let x_den_float_float_float = x_den_float_float_int.toString();\n   let n_den_float_float_float = n_den_float_float_int.toString();\n   let x_num_float_float_float_float = x_num_float_float_float.toString();\n   let n_num_float_float_float_float = n_num_float_float_float.toString();\n   let x_den_float_float_float_float = x_den_float_float_float.toString();\n   let n_den_float_float_float_float = n_den_float_float_float.toString();\n   let x_num_float_float_float_float_float = x_num_float_float_float_float.toString();\n   let n_num_float_float_float_float_float = n_num_float_float_float_float.toString();\n   let x_den_float_float_float_float_float = x_den_float_float_float_float.toString();\n   let n_den_float_float_float_float_float = n_den_float_float_float_float.toString();\n   let x_num_float_float_float_float_float_float = x_num_float_float_float_float_float.toString();\n   let n_num_float_float_float_float_float_float = n_num_float_float_float_float_float.toString();\n   let x_den_float_float_float_float_float_float = x_den_float_float_float_float_float.toString();\n   let n_den_float_float_float_float_float_float = n_den_float_float_float_float_float.toString();\n   let x_num_float_float_float_float_float_float_float = x_num_float_float_float_float_float_float.toString();\n   let n_num_float_float_float_float_float_float_float = n_num_float_float_float_float_float_float.toString();\n   let x_den_float_float_float_float_float_float_float = x_den_float_float_float_float_float_float.toString();\n   let n_den_float_float_float_float_float_float_float = n_den_float_float_float_float_float_float.toString();\n   let x_num_float_float_float_float_float_float_float_float =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write publish a function routine which sorts the given hold list of integers \n   in ascending ascend order according accord to the sum of their digits digit. \n   Note: if there are several respective items token with similar sum union of their digits, \n   order them based on their index in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine which sorts the given hold list of integers \n   in ascending ascend order according accord to the sum of their digits digit. \n   Note: if there are several respective items token with similar sum union of their digits, \n   order them based on their index in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  if (nums.length === 0) {\n    return [];\n  }\n\n  const sorted = nums.sort((a, b) => {\n    const sumA = a.map(digit => digit).reduce((a, b) => a + b);\n    const sumB = b.map(digit => digit).reduce((a, b) => a + b);\n    if (sumA < sumB) {\n      return -1;\n    } else if (sumA > sumB) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n\n  return sorted;\n};\n\nmodule.exports = orderByPoints;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/146", "prompt": "/*Write a function affair that takes lead an array of numbers as input stimulation and returns \n   the number issue of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number numeral are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that takes lead an array of numbers as input stimulation and returns \n   the number issue of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number numeral are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1 && nums[i] % 10 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = specialFilter;<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given grant a positive integer n. You have to create produce an integer array a of length duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number phone number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a positive integer n. You have to create produce an integer array a of length duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number phone number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.reduce((acc, curr) => {\n    const [i, j, k] = acc;\n    if (i < j && j < k) {\n      return [...acc, curr];\n    }\n    return acc;\n  }, []);\n};\n\nmodule.exports = getMaxTriples;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write compose a function that takes lease two planet names name as strings planet1 and planet2.\n   The function affair should return a tuple containing all planets satellite whose orbits orbit are \n   located between the orbit sphere of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function should return an empty tuple if planet1 or planet2\n   are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 1, "perturbed": true, "gc": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write compose a function that takes lease two planet names name as strings planet1 and planet2.\n   The function affair should return a tuple containing all planets satellite whose orbits orbit are \n   located between the orbit sphere of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function should return an empty tuple if planet1 or planet2\n   are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let result = [];\n  let planet1_orbit = get_orbit(planet1);\n  let planet2_orbit = get_orbit(planet2);\n  let planet1_distance = get_distance(planet1_orbit, planet2_orbit);\n  let planet2_distance = get_distance(planet2_orbit, planet1_orbit);\n  let planet1_distance_to_sun = get_distance_to_sun(planet1_orbit);\n  let planet2_distance_to_sun = get_distance_to_sun(planet2_orbit);\n  let planet1_distance_to_sun_is_smaller = planet1_distance_to_sun < planet2_distance_to_sun;\n  let planet1_distance_to_sun_is_larger = planet1_distance_to_sun > planet2_distance_to_sun;\n  if (planet1_distance_to_sun_is_smaller) {\n    result = result.concat(get_satellites_from_orbit(planet1_orbit));\n  }\n  if (planet1_distance_to_sun_is_larger) {\n    result = result.concat(get_satellites_from_orbit(planet2_orbit));\n  }\n  return result;\n};\n\nconst get_distance = (orbit) => {\n  return Math.sqrt(Math.pow(orbit.x, 2) + Math.pow(orbit.y, 2) + Math.pow(orbit.z, 2));\n};\n\nconst get_distance_to_sun = (orbit) => {\n  return Math.sqrt(Math.pow(orbit.x, 2) + Math.pow(orbit.y, 2) + Math.pow(orbit.z, 2)) - 6371;\n};\n\nconst get_satellites_from_orbit = (orbit) => {\n  let result = [];\n  let planet = {\n    name: \"Sun\",\n    x: 0,\n    y: 0,\n    z: 0\n  };\n  let i = 0;\n  while (i < 8) {\n    let planet_orbit = get_orbit(planet.name);\n    let planet_distance = get_distance(planet_orbit, orbit);\n    if (planet_distance < planet.x) {\n      planet = {\n        name: planet.name,\n        x: planet.x,\n        y: planet.y,\n        z: planet.z\n      };\n      result.push(planet);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst get_orbit = (planet_name) => {\n  let planet = {\n    name: planet_name,\n    x: 0,\n    y: 0,\n    z: 0\n  };\n  let i = 0;\n  while (i < 8) {\n    let planet_orbit = get_orbit(planet.name);\n    let planet_distance = get_distance(planet_orbit, planet);\n    if (planet_distance < planet.x) {\n      planet = {\n        name: planet.name,\n        x: planet.x,\n        y: planet.y,\n        z: planet.z\n      };\n    }\n    i++;\n  }\n  return planet;\n};\n\nmodule.exports = bf;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function affair that accepts take a list of strings as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd lengths duration from it, \n   and returns the resulted result list with a sorted classify order, \n   The list is always constantly a list of strings bowed stringed instrument and never an array of numbers, \n   and it may contain control duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list sorted by that rule. \n   If two words password have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted classify order decree. \n   You may assume wear that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that accepts take a list of strings as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd lengths duration from it, \n   and returns the resulted result list with a sorted classify order, \n   The list is always constantly a list of strings bowed stringed instrument and never an array of numbers, \n   and it may contain control duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list sorted by that rule. \n   If two words password have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted classify order decree. \n   You may assume wear that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const sortedList = [];\n  const sortedListLength = [];\n  const sortedListLengthIndex = [];\n  const sortedListLengthIndexIndex = [];\n  const sortedListLengthIndexLength = [];\n  const sortedListLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLength = [];\n  const sortedListLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLength = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLength = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLength = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLength = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLength = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLength = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndex = [];\n  const sortedListLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndexLengthIndex", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 1, "perturbed": true, "gc": "/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} ${i + 1} ${i + 2} ${i + 3} ${i + 4} ${i + 5} ${i + 6} ${i + 7} ${i + 8} ${i + 9} ${i + 10} ${i + 11} ${i + 12} ${i + 13} ${i + 14} ${i + 15} ${i + 16} ${i + 17} ${i + 18} ${i + 19} ${i + 20} ${i + 21} ${i + 22} ${i + 23} ${i + 24} ${i + 25} ${i + 26} ${i + 27} ${i + 28} ${i + 29} ${i + 30} ${i + 31} ${i + 32} ${i + 33} ${i + 34} ${i + 35} ${i + 36} ${i + 37} ${i + 38} ${i + 39} ${i + 40} ${i + 41} ${i + 42} ${i + 43} ${i + 44} ${i + 45} ${i + 46} ${i + 47} ${i + 48} ${i + 49} ${i + 50} ${i + 51} ${i + 52} ${i + 53} ${i + 54} ${i + 55} ${i + 56} ${i + 57} ${i + 58} ${i + 59} ${i + 60} ${i + 61} ${i + 62} ${i + 63} ${i + 64} ${i + 65} ${i + 66} ${i + 67} ${i + 68} ${i + 69} ${i + 70} ${i + 71} ${i + 72} ${i + 73} ${i + 74} ${i + 75} ${i + 76} ${i + 77} ${i + 78} ${i + 79} ${i + 80} ${i + 81} ${i + 82} ${i + 83} ${i + 84} ${i + 85} ${i + 86} ${i + 87} ${i + 88} ${i + 89} ${i + 90} ${i + 91} ${i + 92} ${i + 93} ${i + 94} ${i + 95} ${i + 96} ${i + 97} ${i + 98} ${i + 99} ${i + 100} ${i + 101} ${i + 102} ${i + 103} ${i + 104} ${i + 105} ${i + 106} ${i + 107} ${i + 108} ${i + 109} ${i + 110} ${i + 111} ${i + 112} ${i + 113} ${i + 114} ${i + 115} ${i + 116} ${i + 117} ${i + 118} ${i + 119} ${i + 120} ${i + 121} ${i + 122} ${i + 123} ${i + 124} ${i + 125} ${i + 126} ${i + 127} ${i + 128} ${i + 129} ${i + 130} ${i + 131} ${i + 132} ${i + 133} ${i + 134} ${i + 135} ${i + 136} ${i + 137} ${i + 138} ${i + 139} ${i + 140} ${i + 141} ${i + 142} ${i + 143} ${i + 144} ${i + 145} ${i + 146} ${i + 147} ${i + 148} ${i + 149} ${i + 150} ${i + 151} ${i + 152} ${i + 153} ${i + 154} ${i + 155} ${i + 156} ${i + 157} ${i + 158} ${i + 159} ${i + 160} ${i + 161} ${i + 162} ${i + 163} ${i + 164} ${i + 165} ${i + 166} ${i + 167} ${i + 168} ${i + 169} ${i + 170} ${i + 171} ${i + 172} ${i + 173} ${i + 174} ${i + 175} ${i + 176} ${i + 177} ${i + 178} ${i + 179} ${i + 180} ${i + 181} ${i + 182} ${i + 183} ${i + 184} ${i + 185} ${i + 186} ${i + 187} ${i + 188} ${i + 189} ${i + 190} ${i + 191} ${i + 192} ${i + 193} ${i + 194} ${i + 195} ${i + 196} ${i + 197} ${i + 198} ${i + 199} ${i + 200} ${i + 201} ${i + 202} ${i + 203} ${i + 204} ${i + 205} ${i + 206} ${i + 207} ${i + 208} ${i + 209} ${i + 210} ${i + 211} ${i + 212} ${i + 213} ${i + 214} ${i + 215} ${i + 216} ${i + 217} ${i + 218} ${i + 219} ${i + 220} ${i + 221} ${i + 222} ${i + 223} ${i + 224} ${i + 225} ${i + 226} ${i + 227} ${i + 228} ${i + 229} ${i + 230} ${i + 231} ${i + 232} ${i + 233} ${i + 234} ${i + 235} ${i + 236} ${i + 237} ${i + 238} ${i + 239} ${i + 240} ${i + 241} ${i + 242} ${i + 243} ${i + 244} ${i + 245} ${i + 246} ${i + 247} ${i + 248} ${i + 249} ${i + 250} ${i + 251} ${i + 252} ${i + 253} ${i + 254} ${i + 255} ${i + 256} ${i + 257} ${i + 258} ${i + 259} ${i + 260} ${i + 261} ${i + 262} ${i + 263} ${i + 264} ${i + 265} ${i + 266} ${i + 267} ${i + 268} ${i + 269} ${i + 270} ${i + 271} ${i + 272} ${i + 273} ${i + 274} ${i + 275} ${i + 276} ${i + 277} ${i + 278} ${i + 279} ${i + 280} ${i + 281} ${i + 282} ${i + 283} ${i + 284} ${i + 285} ${i + 286} ${i +", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/150", "prompt": "/*A simple elementary program platform which should return the value of x if n is \n   a prime number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 1, "perturbed": true, "gc": "/*A simple elementary program platform which should return the value of x if n is \n   a prime number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 == 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst main = () => {\n  console.log(xOrY(7, 34, 12));\n  console.log(xOrY(15, 8, 5));\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given grant a list of numbers, return the sum kernel of squares square of the numbers phone number \n   in the list that are odd. Ignore numbers issue that are negative or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 1, "perturbed": true, "gc": "/* Given grant a list of numbers, return the sum kernel of squares square of the numbers phone number \n   in the list that are odd. Ignore numbers issue that are negative or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (lst.length == 0) {\n     return 0;\n   }\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     let num = lst[i];\n     if (num % 2 == 1) {\n       sum += num * num;\n     }\n   }\n   return sum;\n }\n * @author: Junaid Malik\n *\n */\n\npublic class DoubleTheDifference {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = sc.nextInt();\n\t\t}\n\t\tsc.close();\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i] % 2 == 1) {\n\t\t\t\tsum += arr[i] * arr[i];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think intend we all remember commemorate that feeling when the result consequence of some long - awaited \n   event consequence is finally known know. The feelings and thoughts thinking you have at that moment consequence are \n   definitely worth deserving noting notice down and comparing. \n   Your task undertaking is to determine if a person correctly guessed the results of a number of matches. \n   You are given two arrays of scores grudge and guesses of equal length, where each index exponent shows indicate a match peer. \n   Return an array of the same length denoting how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 1, "perturbed": true, "gc": "/*I think intend we all remember commemorate that feeling when the result consequence of some long - awaited \n   event consequence is finally known know. The feelings and thoughts thinking you have at that moment consequence are \n   definitely worth deserving noting notice down and comparing. \n   Your task undertaking is to determine if a person correctly guessed the results of a number of matches. \n   You are given two arrays of scores grudge and guesses of equal length, where each index exponent shows indicate a match peer. \n   Return an array of the same length denoting how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const grudge = game.map(guess => Math.abs(guess - game[guess]));\n  const guesses = game.map(guess => guess);\n  const result = [];\n  for (let i = 0; i < guesses.length; i++) {\n    if (guesses[i] === game[i]) {\n      result[i] = 0;\n    } else {\n      result[i] = Math.abs(guesses[i] - game[i]);\n    }\n  }\n  return result;\n};\n\nmodule.exports = compare;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/153", "prompt": "/*You will be given grant the name of a class (a string bowed stringed instrument) and a list of extensions.\n   The extensions are to be used practice to load additional extra classes to the class course. The \n   strength of the extension reference is as follows: Let permit CAP be the number of the uppercase capital \n   letters letter in the extension's name, and let lease SM be the number of lowercase letters \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should find the strongest solid extension elongation and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes issue forth first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 1, "perturbed": true, "gc": "/*You will be given grant the name of a class (a string bowed stringed instrument) and a list of extensions.\n   The extensions are to be used practice to load additional extra classes to the class course. The \n   strength of the extension reference is as follows: Let permit CAP be the number of the uppercase capital \n   letters letter in the extension's name, and let lease SM be the number of lowercase letters \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should find the strongest solid extension elongation and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes issue forth first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strength = 0;\n  let extension_name = '';\n  let extension_name_length = 0;\n  let extension_name_index = 0;\n  let extension_name_index_length = 0;\n  let extension_name_index_index = 0;\n  let extension_name_index_index_length = 0;\n  let extension_name_index_index_index = 0;\n  let extension_name_index_index_index_length = 0;\n  let extension_name_index_index_index_index = 0;\n  let extension_name_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are given grant 2 words. You need want to return true truthful if the second word discussion or any of its rotations is a substring in the first inaugural word \n   cycpatternCheck(\"abcd\",\"abd\") = > false fake \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > false assumed \n   cycpatternCheck(\"abab\",\"baa\") = > true dependable \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true genuine \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 1, "perturbed": true, "gc": "/*You are given grant 2 words. You need want to return true truthful if the second word discussion or any of its rotations is a substring in the first inaugural word \n   cycpatternCheck(\"abcd\",\"abd\") = > false fake \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > false assumed \n   cycpatternCheck(\"abab\",\"baa\") = > true dependable \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true genuine \n   * / \n const cycpatternCheck = (a, b) = > {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let aa = 0;\n  let bb = 0;\n  let cc = 0;\n  let dd = 0;\n  let ee = 0;\n  let ff = 0;\n  let gg = 0;\n  let hh = 0;\n  let ii = 0;\n  let jj = 0;\n  let kk = 0;\n  let ll = 0;\n  let mm = 0;\n  let nn = 0;\n  let oo = 0;\n  let pp = 0;\n  let qq = 0;\n  let rr = 0;\n  let ss = 0;\n  let tt = 0;\n  let uu = 0;\n  let vv = 0;\n  let ww = 0;\n  let xx = 0;\n  let yy = 0;\n  let zz = 0;\n  let aaa = 0;\n  let bbb = 0;\n  let ccc = 0;\n  let ddd = 0;\n  let eee = 0;\n  let fff = 0;\n  let ggg = 0;\n  let hhh = 0;\n  let iii = 0;\n  let jjj = 0;\n  let kkk = 0;\n  let lll = 0;\n  let mmm = 0;\n  let nnn = 0;\n  let ooo = 0;\n  let ppp = 0;\n  let qqq = 0;\n  let rrr = 0;\n  let sss = 0;\n  let ttt = 0;\n  let uuu = 0;\n  let vvv = 0;\n  let wwww = 0;\n  let xxx = 0;\n  let yyy = 0;\n  let zzz = 0;\n  let aaaa = 0;\n  let bbbb = 0;\n  let cccc = 0;\n  let dddd = 0;\n  let eeee = 0;\n  let ffff = 0;\n  let gggg = 0;\n  let hhhh = 0;\n  let iiiii = 0;\n  let jjjj = 0;\n  let kkkk = 0;\n  let llll = 0;\n  let mmmm = 0;\n  let nnnn = 0;\n  let oooo = 0;\n  let pppp = 0;\n  let qqqq = 0;\n  let rrrr = 0;\n  let ssss = 0;\n  let tttt = 0;\n  let uuuu = 0;\n  let vvvv = 0;\n  let wwwww = 0;\n  let xxxx = 0;\n  let yyyy = 0;\n  let zzzz = 0;\n  let aaaaa = 0;\n  let bbbbb = 0;\n  let ccccc = 0;\n  let ddddd = 0;\n  let eeeee = 0;\n  let fffff = 0;\n  let ggggg = 0;\n  let hhhhh = 0;\n  let iiiiii = 0;\n  let jjjjj = 0;\n  let kkkkk = 0;\n  let lllll = 0;\n  let mmmmm = 0;\n  let nnnnn = 0;\n  let ooooo = 0;\n  let ppppp = 0;\n  let qqqqq = 0;\n  let rrrrr = 0;\n  let sssss = 0;\n  let ttttt = 0;\n  let uuuuu = 0;\n  let vvvvv = 0;\n  let wwwwww = 0;\n  let xxxxxx = 0;\n  let yyyyyy = 0;\n  let zzzzzz = 0;\n  let aaaaaa = 0;\n  let bbbbbb = 0;\n  let cccccc = 0;\n  let dddddd = 0;\n  let eeeeee = 0;\n  let ffffff = 0;\n  let gggggg = 0;\n  let hhhhhh = 0;\n  let iiiiii = 0;\n  let jjjjj = 0;\n  let kkkkk = 0;\n  let llllll = 0;\n  let mmmmmm = 0;\n  let nnnnnn = 0;\n  let oooooo = 0;\n  let pppppp = 0;\n  let qqqqqq = 0;\n  let rrrrrr = 0;\n  let ssssss = 0;\n  let tttttt = 0;\n  let uuuuuu = 0;\n  let vvvvvv = 0;\n  let wwwwwww = 0;\n  let xxxxxxx = 0;\n  let yyyyyyy = 0;\n  let zzzzzzz = 0;\n  let aaaaaaa = 0;\n  let bbbbbbb = 0;\n  let ccccccc = 0;\n  let ddddddd = 0;\n  let eeeeeee = 0;\n  let fffffff = 0;\n  let ggggggg = 0;\n  let hhhhhhh = 0;\n  let iiiiiii = 0;\n  let jjjjjjj = 0;\n  let kkkkkkk = 0;\n  let llllllll = 0;\n  let mmmmmmm = 0;\n  let nnnnnnn = 0;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number issue of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 1, "perturbed": true, "gc": "/*Given an integer. return a tuple that has the number issue of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenDigit = 0\n  let oddDigit = 0\n  let evenDigitCount = 0\n  let oddDigitCount = 0\n  let evenDigitSum = 0\n  let oddDigitSum = 0\n  let evenDigitSum2 = 0\n  let oddDigitSum2 = 0\n  let evenDigitSum3 = 0\n  let oddDigitSum3 = 0\n  let evenDigitSum4 = 0\n  let oddDigitSum4 = 0\n  let evenDigitSum5 = 0\n  let oddDigitSum5 = 0\n  let evenDigitSum6 = 0\n  let oddDigitSum6 = 0\n  let evenDigitSum7 = 0\n  let oddDigitSum7 = 0\n  let evenDigitSum8 = 0\n  let oddDigitSum8 = 0\n  let evenDigitSum9 = 0\n  let oddDigitSum9 = 0\n  let evenDigitSum10 = 0\n  let oddDigitSum10 = 0\n  let evenDigitSum11 = 0\n  let oddDigitSum11 = 0\n  let evenDigitSum12 = 0\n  let oddDigitSum12 = 0\n  let evenDigitSum13 = 0\n  let oddDigitSum13 = 0\n  let evenDigitSum14 = 0\n  let oddDigitSum14 = 0\n  let evenDigitSum15 = 0\n  let oddDigitSum15 = 0\n  let evenDigitSum16 = 0\n  let oddDigitSum16 = 0\n  let evenDigitSum17 = 0\n  let oddDigitSum17 = 0\n  let evenDigitSum18 = 0\n  let oddDigitSum18 = 0\n  let evenDigitSum19 = 0\n  let oddDigitSum19 = 0\n  let evenDigitSum20 = 0\n  let oddDigitSum20 = 0\n  let evenDigitSum21 = 0\n  let oddDigitSum21 = 0\n  let evenDigitSum22 = 0\n  let oddDigitSum22 = 0\n  let evenDigitSum23 = 0\n  let oddDigitSum23 = 0\n  let evenDigitSum24 = 0\n  let oddDigitSum24 = 0\n  let evenDigitSum25 = 0\n  let oddDigitSum25 = 0\n  let evenDigitSum26 = 0\n  let oddDigitSum26 = 0\n  let evenDigitSum27 = 0\n  let oddDigitSum27 = 0\n  let evenDigitSum28 = 0\n  let oddDigitSum28 = 0\n  let evenDigitSum29 = 0\n  let oddDigitSum29 = 0\n  let evenDigitSum30 = 0\n  let oddDigitSum30 = 0\n  let evenDigitSum31 = 0\n  let oddDigitSum31 = 0\n  let evenDigitSum32 = 0\n  let oddDigitSum32 = 0\n  let evenDigitSum33 = 0\n  let oddDigitSum33 = 0\n  let evenDigitSum34 = 0\n  let oddDigitSum34 = 0\n  let evenDigitSum35 = 0\n  let oddDigitSum35 = 0\n  let evenDigitSum36 = 0\n  let oddDigitSum36 = 0\n  let evenDigitSum37 = 0\n  let oddDigitSum37 = 0\n  let evenDigitSum38 = 0\n  let oddDigitSum38 = 0\n  let evenDigitSum39 = 0\n  let oddDigitSum39 = 0\n  let evenDigitSum40 = 0\n  let oddDigitSum40 = 0\n  let evenDigitSum41 = 0\n  let oddDigitSum41 = 0\n  let evenDigitSum42 = 0\n  let oddDigitSum42 = 0\n  let evenDigitSum43 = 0\n  let oddDigitSum43 = 0\n  let evenDigitSum44 = 0\n  let oddDigitSum44 = 0\n  let evenDigitSum45 = 0\n  let oddDigitSum45 = 0\n  let evenDigitSum46 = 0\n  let oddDigitSum46 = 0\n  let evenDigitSum47 = 0\n  let oddDigitSum47 = 0\n  let evenDigitSum48 = 0\n  let oddDigitSum48 = 0\n  let evenDigitSum49 = 0\n  let oddDigitSum49 = 0\n  let evenDigitSum50 = 0\n  let oddDigitSum50 = 0\n  let evenDigitSum51 = 0\n  let oddDigitSum51 = 0\n  let evenDigitSum52 = 0\n  let oddDigitSum52 = 0\n  let evenDigitSum53 = 0\n  let oddDigitSum53 = 0\n  let evenDigitSum54 = 0\n  let oddDigitSum54 = 0\n  let evenDigitSum55 = 0\n  let oddDigitSum55 = 0\n  let evenDigitSum56 = 0\n  let oddDigitSum56 = 0\n  let evenDigitSum57 = 0\n  let oddDigitSum57 = 0\n  let evenDigitSum58 = 0\n  let oddDigitSum58 = 0\n  let evenDigitSum59 = 0\n  let oddDigitSum59 = 0\n  let evenDigitSum60 = 0\n  let oddDigitSum60 = 0\n  let evenDigitSum61 = 0\n  let oddDigitSum61 = 0\n  let evenDigitSum62 = 0\n  let oddDigitSum62 = 0\n  let evenDigitSum63 = 0\n  let oddDigitSum63 = 0\n  let evenDigitSum64 = 0\n  let oddDigitSum64 = 0\n  let evenDigitSum65 = 0\n  let oddDigitSum65 = 0\n  let evenDigitSum66 = 0\n  let oddDigitSum66 = 0\n  let evenDigitSum67 = 0\n  let oddDigitSum67 = 0\n  let evenDigitSum68 = 0\n  let oddDigitSum68 = 0\n  let evenDigitSum69 = 0\n  let oddDigitSum69 = 0\n  let evenDigitSum70 = 0\n  let oddDigitSum70 = 0\n  let evenDigitSum71 = 0\n  let oddDigitSum71 = 0\n  let evenDigitSum72 = 0\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given grant a positive integer, obtain receive its roman numeral equivalent as a string chain, \n   and return it in lowercase small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer, obtain receive its roman numeral equivalent as a string chain, \n   and return it in lowercase small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let result = '';\n  let num = number;\n  while (num > 0) {\n    let digit = num % 10;\n    num = num / 10;\n    if (digit == 1 || digit == 2 || digit == 3 || digit == 4 || digit == 5 || digit == 6 || digit == 7 || digit == 8 || digit == 9) {\n      result += 'iv';\n    } else if (digit == 0 || digit == 5 || digit == 10 || digit == 15 || digit == 20 || digit == 25 || digit == 30 || digit == 35 || digit == 40 || digit == 45 || digit == 50 || digit == 55 || digit == 60 || digit == 65 || digit == 70 || digit == 75 || digit == 80 || digit == 85 || digit == 90) {\n      result += 'ix';\n    } else if (digit == 4 || digit == 9 || digit == 14 || digit == 19 || digit == 24 || digit == 29 || digit == 34 || digit == 39 || digit == 44 || digit == 49 || digit == 54 || digit == 59 || digit == 64 || digit == 69 || digit == 74 || digit == 79 || digit == 84 || digit == 89 || digit == 94) {\n      result += 'lx';\n    } else if (digit == 8 || digit == 13 || digit == 18 || digit == 23 || digit == 28 || digit == 33 || digit == 38 || digit == 43 || digit == 48 || digit == 53 || digit == 58 || digit == 63 || digit == 68 || digit == 73 || digit == 78 || digit == 83 || digit == 88) {\n      result += 'xc';\n    } else if (digit == 7 || digit == 12 || digit == 17 || digit == 22 || digit == 27 || digit == 32 || digit == 37 || digit == 42 || digit == 47 || digit == 52 || digit == 57 || digit == 62 || digit == 67 || digit == 72 || digit == 77 || digit == 82 || digit == 87 || digit == 92) {\n      result += 'li';\n    } else if (digit == 6 || digit == 11 || digit == 16 || digit == 21 || digit == 26 || digit == 31 || digit == 36 || digit == 41 || digit == 46 || digit == 51 || digit == 56 || digit == 61 || digit == 66 || digit == 71 || digit == 76 || digit == 81 || digit == 86 || digit == 91) {\n      result += 'xc';\n    } else if (digit == 5 || digit == 10 || digit == 15 || digit == 20 || digit == 25 || digit == 30 || digit == 35 || digit == 40 || digit == 45 || digit == 50 || digit == 55 || digit == 60 || digit == 65 || digit == 70 || digit == 75 || digit == 80 || digit == 85 || digit == 90) {\n      result += 'xl';\n    } else {\n      result += 'c';\n    }\n  }\n  return result.toLowerCase();\n};\n\nmodule.exports = intToMiniRoman;<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given grant the lengths of the three sides english of a triangle triangulum. Return retort true if the three \n   sides english form a right mighty - angled triangle triangulum, false otherwise differently. \n   A right mighty - angled triangle triangulum is a triangle in which one angle is right angle or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 1, "perturbed": true, "gc": "/*\n Given grant the lengths of the three sides english of a triangle triangulum. Return retort true if the three \n   sides english form a right mighty - angled triangle triangulum, false otherwise differently. \n   A right mighty - angled triangle triangulum is a triangle in which one angle is right angle or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const sides = [a, b, c];\n  const len = sides.reduce((a, b) => a + b, 0);\n  return len === 3;\n};\n\nexport default rightAngleTriangle;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function affair that accepts take a list of strings. \n   The list contains incorporate different words. Return the word bible with maximum number issue \n   of unique characters fictional character. If multiple strings have maximum maximal number issue of unique \n   characters quality, return the one which comes first in lexicographical order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that accepts take a list of strings. \n   The list contains incorporate different words. Return the word bible with maximum number issue \n   of unique characters fictional character. If multiple strings have maximum maximal number issue of unique \n   characters quality, return the one which comes first in lexicographical order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   const max = words[0];\n   for (let i = 1; i < words.length; i++) {\n     if (words[i].length > max.length) {\n       max = words[i];\n     }\n   }\n   return max;\n }\n*/\n\nconst findMax = (words) => {\n  const max = words[0];\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n    }\n  }\n  return max;\n};\n\nconst test = () => {\n  const words = [\"name\", \" of \", \" string \"];\n  console.log(findMax(words));\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete the day sidereal day's meals. \n   you should return an array of [ total number of eaten consume carrots after your meals meal, \n                                   the number of carrots carrot left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 1, "perturbed": true, "gc": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete the day sidereal day's meals. \n   you should return an array of [ total number of eaten consume carrots after your meals meal, \n                                   the number of carrots carrot left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  // write your code here\n  let result = [];\n  let i = 0;\n  while (i < number) {\n    if (remaining >= need) {\n      result.push(remaining - need);\n      remaining -= need;\n      i++;\n    } else {\n      result.push(remaining);\n      remaining = 0;\n      i++;\n    }\n  }\n  return result;\n};\n\n// console.log(eat(5, 6, 10));\n// console.log(eat(4, 8, 9));\n// console.log(eat(1, 10, 10));\n// console.log(eat(2, 11, 5));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/16", "prompt": "/* Given grant a string, find out how many distinct clear-cut characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 1, "perturbed": true, "gc": "/* Given grant a string, find out how many distinct clear-cut characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let char = '';\n  for (let i = 0; i < string.length; i++) {\n    char = string[i];\n    if (char === char.toUpperCase()) {\n      count++;\n    } else {\n      count = 0;\n      char = char.toLowerCase();\n    }\n  }\n  return count;\n};\n\nmodule.exports = countDistinctCharacters;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given grant two lists operator, and operand. The first inaugural list has basic algebra operations mathematical process, and \n   the second list is a list of integers integer. Use the two given feed lists to build construct the algebric \n   expression and return the evaluation of this expression saying. \n\n   The basic algebra operations: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant two lists operator, and operand. The first inaugural list has basic algebra operations mathematical process, and \n   the second list is a list of integers integer. Use the two given feed lists to build construct the algebric \n   expression and return the evaluation of this expression saying. \n\n   The basic algebra operations: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorList = operator.split(',');\n  let operandList = operand.split(',');\n  let i = 0;\n  let j = 0;\n  while (i < operatorList.length && j < operandList.length) {\n    if (operatorList[i] === operandList[j]) {\n      result += parseInt(operandList[j + 1]);\n      j += 2;\n    } else if (operatorList[i] === '+') {\n      result += parseInt(operandList[j]) + parseInt(operandList[j + 1]);\n      j += 2;\n    } else if (operatorList[i] === '-') {\n      result += parseInt(operandList[j]) - parseInt(operandList[j + 1]);\n      j += 2;\n    } else if (operatorList[i] === '*') {\n      result += parseInt(operandList[j]) * parseInt(operandList[j + 1]);\n      j += 2;\n    } else if (operatorList[i] === '/') {\n      result += parseInt(operandList[j]) / parseInt(operandList[j + 1]);\n      j += 2;\n    } else if (operatorList[i] === '//') {\n      result += parseInt(operandList[j]) // parseInt(operandList[j + 1]);\n      j += 2;\n    }\n    i += 1;\n  }\n  return result;\n};\n\nconst main = () => {\n  const input = readInput();\n  const operatorList = input.split(',');\n  const operandList = input.split(',');\n  console.log(doAlgebra(operatorList[0], operandList[1]));\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given grant a string s.\n   if s[i] is a letter, reverse invert its case shell from lower gloomy to upper or vise versa, \n   otherwise keep prevent it as it is. \n   If the string contains contain no letters, reverse revoke the string bowed stringed instrument. \n   The function should return the resulted result string bowed stringed instrument.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*You are given grant a string s.\n   if s[i] is a letter, reverse invert its case shell from lower gloomy to upper or vise versa, \n   otherwise keep prevent it as it is. \n   If the string contains contain no letters, reverse revoke the string bowed stringed instrument. \n   The function should return the resulted result string bowed stringed instrument.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = s;\n  let i = 0;\n  while (i < s.length) {\n    let letter = s[i];\n    if (isLetter(letter)) {\n      if (isLower(letter)) {\n        result = result.replace(/[a-z]/ig, (match) => {\n          return match.toUpperCase();\n        });\n      } else if (isUpper(letter)) {\n        result = result.replace(/[A-Z]/ig, (match) => {\n          return match.toLowerCase();\n        });\n      }\n    } else {\n      result = result.replace(/[A-Za-z]/ig, (match) => {\n        return match.toUpperCase();\n      });\n    }\n    i++;\n  }\n  return result;\n};\n\nconst isLetter = (s) => {\n  return /[a-z]/.test(s);\n};\n\nconst isLower = (s) => {\n  return /[a-z]/.test(s) && s.toLowerCase() === s;\n};\n\nconst isUpper = (s) => {\n  return /[A-Z]/.test(s) && s.toUpperCase() === s;\n};\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given grant a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/**\n  Given a string 'text', return its sha1 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToSha1('Hello world') == 'd7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592'\n  */\nconst stringToSha1 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const hash = crypto.createHash('sha1');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/**\n  Given a string 'text', return its sha256 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToSha256('Hello world') == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n  */\nconst stringToSha256 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const hash = crypto.createHash('sha256');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/**\n  Given a string 'text', return its sha512 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToSha512('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const hash = crypto.createHash('sha512');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/**\n  Given a string 'text', return its sha384 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToSha384('Hello world') == '38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b'\n  */\nconst stringToSha384 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const hash = crypto.createHash('sha384');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/**\n  Given a string 'text', return its sha3 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToSha3('Hello world') == 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n  */\nconst stringToSha3 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const hash = crypto.createHash('sha3');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/**\n  Given a string 'text', return its sha3-256 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToSha3256('Hello world') == 'e4c4d8b9f9b9c9a9ce9c92367be8f0b3655a2f2b0f1b7fec0c5c2b0dccec'\n  */\nconst stringToSha3256 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const hash = crypto.createHash('sha3-256');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/**\n  Given a string 'text', return its sha3-512 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToSha3512('Hello world') == 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n  */\nconst stringToSha3512 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const hash = crypto.createHash('sha3-512');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\nexport default {\n  stringToMd5,\n  stringToSha1,\n  stringToSha256,\n  stringToSha512,\n  stringToSha384,\n  stringToSha3,\n  stringToSha3256,\n  stringToSha3512\n};\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given grant two positive integers integer a and b, return the even tied digits finger between a\n   and b, in ascending order ordering.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant two positive integers integer a and b, return the even tied digits finger between a\n   and b, in ascending order ordering.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n    i++;\n  }\n  return result;\n};\n\nmodule.exports = generateIntegers;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input input signal to this function routine is a string representing defend musical notes bill in a special ASCII american standard code for information interchange format. \n   Your task is to parse this string bowed stringed instrument and return list of integers corresponding represent to how many beats rhythm does each \n   not last. \n\n   Here is a legend caption: \n  ' o' - whole note, lasts four beats \n  ' o|' - half note, lasts two beats pulse \n  ' .|' - quater note eminence, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 1, "perturbed": true, "gc": "/* Input input signal to this function routine is a string representing defend musical notes bill in a special ASCII american standard code for information interchange format. \n   Your task is to parse this string bowed stringed instrument and return list of integers corresponding represent to how many beats rhythm does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole note, lasts four beats \n 'o|' - half note, lasts two beats pulse \n  '.|' - quater note eminence, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_list = [];\n  let beat_count = 0;\n  let beat_count_temp = 0;\n  let beat_count_temp_temp = 0;\n  let beat_count_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  let beat_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find line up how many times a given pass substring can be found in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 1, "perturbed": true, "gc": "/* Find line up how many times a given pass substring can be found in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0\n  let i = 0\n  while (i < string.length) {\n    if (string.substr(i, substring.length) === substring) {\n      count++\n      i += substring.length\n    } else {\n      i++\n    }\n  }\n  return count\n}\n\nmodule.exports = howManyTimes\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/19", "prompt": "/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 1, "perturbed": true, "gc": "/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest to largest big\n  */\nconst sortNumbers2 = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest to largest big\n  */\nconst sortNumbers3 = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest to largest big\n  */\nconst sortNumbers4 = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest to largest big\n  */\nconst sortNumbers5 = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest to largest big\n  */\nconst sortNumbers6 = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest to largest big\n  */\nconst sortNumbers7 = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest to largest big\n  */\nconst sortNumbers8 = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest to largest big\n  */\nconst sortNumbers9 = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest to largest big\n  */\nconst sortNumbers10 = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest to largest big\n  */\nconst sortNumbers11 = (numbers) => {\n  let sortedNumbers = numbers.split('').sort((a, b) => {\n    return a - b;\n  });\n  return sortedNumbers.join('');\n};\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n  Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n  Return come back the string with numbers sorted classify from smallest", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given grant a positive floating float point item number, it can be decomposed disintegrate into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return fall the decimal part character of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 1, "perturbed": true, "gc": "/* Given grant a positive floating float point item number, it can be decomposed disintegrate into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return fall the decimal part character of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let integerPart = Math.floor(number);\n  let decimals = number - integerPart;\n  if (decimals < 0) {\n    decimals = 0;\n  }\n  return decimals;\n};\n\nmodule.exports = {\n  truncateNumber\n};\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   other and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 1, "perturbed": true, "gc": "/* From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   other and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const min = numbers.reduce((min, num) => {\n    return Math.min(num, min);\n  }, Infinity);\n  const max = numbers.reduce((max, num) => {\n    return Math.max(num, max);\n  }, -Infinity);\n  const range = max - min;\n  const closest = numbers.reduce((closest, num) => {\n    return Math.abs(num - min) < Math.abs(num - max)? num : closest;\n  }, Infinity);\n  return [closest, closest + range];\n};\n\n/*\n  From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements2 = (numbers) => {\n  const min = numbers.reduce((min, num) => {\n    return Math.min(num, min);\n  }, Infinity);\n  const max = numbers.reduce((max, num) => {\n    return Math.max(num, max);\n  }, -Infinity);\n  const range = max - min;\n  const closest = numbers.reduce((closest, num) => {\n    return Math.abs(num - min) < Math.abs(num - max)? num : closest;\n  }, Infinity);\n  return [closest, closest + range];\n};\n\n/*\n  From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements3 = (numbers) => {\n  const min = numbers.reduce((min, num) => {\n    return Math.min(num, min);\n  }, Infinity);\n  const max = numbers.reduce((max, num) => {\n    return Math.max(num, max);\n  }, -Infinity);\n  const range = max - min;\n  const closest = numbers.reduce((closest, num) => {\n    return Math.abs(num - min) < Math.abs(num - max)? num : closest;\n  }, Infinity);\n  return [closest, closest + range];\n};\n\n/*\n  From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements4 = (numbers) => {\n  const min = numbers.reduce((min, num) => {\n    return Math.min(num, min);\n  }, Infinity);\n  const max = numbers.reduce((max, num) => {\n    return Math.max(num, max);\n  }, -Infinity);\n  const range = max - min;\n  const closest = numbers.reduce((closest, num) => {\n    return Math.abs(num - min) < Math.abs(num - max)? num : closest;\n  }, Infinity);\n  return [closest, closest + range];\n};\n\n/*\n  From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements5 = (numbers) => {\n  const min = numbers.reduce((min, num) => {\n    return Math.min(num, min);\n  }, Infinity);\n  const max = numbers.reduce((max, num) => {\n    return Math.max(num, max);\n  }, -Infinity);\n  const range = max - min;\n  const closest = numbers.reduce((closest, num) => {\n    return Math.abs(num - min) < Math.abs(num - max)? num : closest;\n  }, Infinity);\n  return [closest, closest + range];\n};\n\nmodule.exports = {\n  findClosestElements,\n  findClosestElements2,\n  findClosestElements3,\n  findClosestElements4,\n  findClosestElements5\n};\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/21", "prompt": "/* Given grant list of numbers (of at least two elements), apply use a linear analogue transform to that list,\n   such that the smallest minor number will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 1, "perturbed": true, "gc": "/* Given grant list of numbers (of at least two elements), apply use a linear analogue transform to that list,\n   such that the smallest minor number will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const result = []\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i]\n    result.push(number / Math.max(number, 1))\n  }\n  return result\n}\n\n/* Given a list of numbers, return a list of their logarithms\n  >>> rescaleToLog([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.3010299956639812, 0.5730103007946649, 0.8450975667898305, 1.0]\n  */\nconst rescaleToLog = (numbers) => {\n  const result = []\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i]\n    result.push(Math.log(number))\n  }\n  return result\n}\n\n/* Given a list of numbers, return a list of their logarithms\n  >>> rescaleToLog([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.3010299956639812, 0.5730103007946649, 0.8450975667898305, 1.0]\n  */\nconst rescaleToLog2 = (numbers) => {\n  const result = []\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i]\n    result.push(Math.log(number) / Math.log(2))\n  }\n  return result\n}\n\n/* Given a list of numbers, return a list of their logarithms\n  >>> rescaleToLog2([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.3010299956639812, 0.5730103007946649, 0.8450975667898305, 1.0]\n  */\nconst rescaleToLog10 = (numbers) => {\n  const result = []\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i]\n    result.push(Math.log10(number))\n  }\n  return result\n}\n\n/* Given a list of numbers, return a list of their logarithms\n  >>> rescaleToLog10([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.3010299956639812, 0.5730103007946649, 0.8450975667898305, 1.0]\n  */\nconst rescaleToLog2Pi = (numbers) => {\n  const result = []\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i]\n    result.push(Math.log(number) / Math.log(2 * Math.PI))\n  }\n  return result\n}\n\n/* Given a list of numbers, return a list of their logarithms\n  >>> rescaleToLog2Pi([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.3010299956639812, 0.5730103007946649, 0.8450975667898305, 1.0]\n  */\nconst rescaleToLog10Pi = (numbers) => {\n  const result = []\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i]\n    result.push(Math.log10(number) / Math.log(2 * Math.PI))\n  }\n  return result\n}\n\n/* Given a list of numbers, return a list of their logarithms\n  >>> rescaleToLog10Pi([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.3010299956639812, 0.5730103007946649, 0.8450975667898305, 1.0]\n  */\nconst rescaleToLog10E = (numbers) => {\n  const result = []\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i]\n    result.push(Math.log10(number))\n  }\n  return result\n}\n\n/* Given a list of numbers, return a list of their logarithms\n  >>> rescaleToLog10E([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.3010299956639812, 0.5730103007946649, 0.8450975667898305, 1.0]\n  */\nconst rescaleToLog2PiE = (numbers) => {\n  const result = []\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i]\n    result.push(Math.log2(number) / Math.log(2 * Math.PI))\n  }\n  return result\n}\n\n/* Given a list of numbers, return a list of their logarithms\n  >>> rescaleToLog2PiE([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.3010299956639812, 0.5730103007946649, 0.8450975667898305, 1.0]\n  */\nconst rescaleToLog10PiE = (numbers) => {\n  const result = []\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i]\n    result.push(Math.log10(number) / Math.log(2 * Math.PI))\n  }\n  return result\n}\n\n/* Given a list of numbers, return a list of their logarithms\n  >>> rescaleToLog10PiE([1.0, 2.0, 3.0,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/22", "prompt": "/* Filter given grant list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 1, "perturbed": true, "gc": "/* Filter given grant list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n  * Filter given grant list of any python values only for strings\n  * @param values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n  * Filter given grant list of any python values only for booleans\n  * @param values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n  * Filter given grant list of any python values only for null\n  * @param values\n  * @returns {Array}\n  */\nconst filterNulls = (values) => {\n  return values.filter(value => value === null);\n};\n\n/**\n  * Filter given grant list of any python values only for undefined\n  * @param values\n  * @returns {Array}\n  */\nconst filterUndefineds = (values) => {\n  return values.filter(value => value === undefined);\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n  * Filter given grant list of any python values only for arrays\n  * @param values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(value => typeof value === 'array');\n};\n\n/**\n  * Filter given grant list of any python values only for functions\n  * @param values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(value => typeof value === 'function');\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndFunctions = (values) => {\n  return values.filter(value => typeof value === 'object' || typeof value === 'function');\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndArrays = (values) => {\n  return values.filter(value => typeof value === 'object' || typeof value === 'array');\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndNulls = (values) => {\n  return values.filter(value => typeof value === 'object' || value === null);\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndUndefineds = (values) => {\n  return values.filter(value => typeof value === 'object' || value === undefined);\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndStrings = (values) => {\n  return values.filter(value => typeof value === 'object' || typeof value ==='string');\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndArraysAndNulls = (values) => {\n  return values.filter(value => typeof value === 'object' || typeof value === 'array' || value === null);\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndArraysAndUndefineds = (values) => {\n  return values.filter(value => typeof value === 'object' || typeof value === 'array' || value === undefined);\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndArraysAndStrings = (values) => {\n  return values.filter(value => typeof value === 'object' || typeof value === 'array' || typeof value ==='string');\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndArraysAndFunctions = (values) => {\n  return values.filter(value => typeof value === 'object' || typeof value === 'array' || typeof value === 'function');\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndArraysAndNullsAndUndefineds = (values) => {\n  return values.filter(value => typeof value === 'object' || typeof value === 'array' || value === null || value === undefined);\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndArraysAndNullsAndUndefinedsAndStrings = (values) => {\n  return values.filter(value => typeof value === 'object' || typeof value === 'array' || value === null || value === undefined || typeof value ==='string');\n};\n\n/**\n  * Filter given grant list of any python values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjectsAndArraysAndNullsAndUndefinedsAndFunctions = (values) => {\n  return values.filter(value => typeof value === 'object' || typeof value === 'array' || value === null || value === undefined || typeof", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return rejoinder length duration of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder length duration of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  if (string.length === 0) {\n    return 0\n  }\n  return string.length\n}\n\n/**\n  * Return true if given string is a number\n  * @param string\n  * @returns {boolean}\n  */\nconst isNumber = (string) => {\n  return string.match(/^[0-9]+$/)!== null\n}\n\n/**\n  * Return true if given string is a boolean\n  * @param string\n  * @returns {boolean}\n  */\nconst isBoolean = (string) => {\n  return string.match(/^(true|false)$/)!== null\n}\n\n/**\n  * Return true if given string is a string\n  * @param string\n  * @returns {boolean}\n  */\nconst isString = (string) => {\n  return string.match(/^[a-zA-Z0-9_]+$/)!== null\n}\n\n/**\n  * Return true if given string is a number or boolean\n  * @param string\n  * @returns {boolean}\n  */\nconst isNumberOrBoolean = (string) => {\n  return isNumber(string) || isBoolean(string)\n}\n\n/**\n  * Return true if given string is a string or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrNumber = (string) => {\n  return isString(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrNumberOrBoolean = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrNumberOrBooleanOrNumber = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOrNumberOrNumber = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOrNumberOrNumberOrBoolean = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOrNumberOrNumberOrBoolean = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOrNumberOrNumberOrBooleanOrBoolean = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOrNumberOrNumberOrBooleanOrBooleanOrBoolean = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOrNumberOrNumberOrBooleanOrBooleanOrBooleanOrBoolean = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOrNumberOrNumberOrBooleanOrBooleanOrBooleanOrBooleanOrBoolean = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOrNumberOrNumberOrBooleanOrBooleanOrBooleanOrBooleanOrBooleanOrBoolean = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOrNumberOrNumberOrBooleanOrBooleanOrBooleanOrBooleanOrBooleanOrBooleanOrBooleanOrBoolean = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOrNumberOrNumberOrBooleanOrBooleanOrBooleanOrBooleanOrBooleanOrBooleanOrBooleanOrBooleanOrBooleanOrBooleanOrBoolean = (string) => {\n  return isStringOrNumber(string) || isBoolean(string) || isNumber(string)\n}\n\n/**\n  * Return true if given string is a string or boolean or number or number\n  * @param string\n  * @returns {boolean}\n  */\nconst isStringOrBooleanOr", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/24", "prompt": "/* For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 1, "perturbed": true, "gc": "/* For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let max = 1\n  let maxDivisor = 1\n  let divisor = 2\n  while (n % divisor === 0) {\n    max = Math.max(max, divisor)\n    divisor++\n  }\n  while (n % divisor === 0) {\n    maxDivisor = Math.max(maxDivisor, divisor)\n    divisor++\n  }\n  return maxDivisor\n}\n\n/*\n  For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor2 = (n) => {\n  let max = 1\n  let maxDivisor = 1\n  let divisor = 2\n  while (n % divisor === 0) {\n    max = Math.max(max, divisor)\n    divisor++\n  }\n  while (n % divisor === 0) {\n    maxDivisor = Math.max(maxDivisor, divisor)\n    divisor++\n  }\n  return maxDivisor\n}\n\n/*\n  For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor3 = (n) => {\n  let max = 1\n  let maxDivisor = 1\n  let divisor = 2\n  while (n % divisor === 0) {\n    max = Math.max(max, divisor)\n    divisor++\n  }\n  while (n % divisor === 0) {\n    maxDivisor = Math.max(maxDivisor, divisor)\n    divisor++\n  }\n  return maxDivisor\n}\n\n/*\n  For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor4 = (n) => {\n  let max = 1\n  let maxDivisor = 1\n  let divisor = 2\n  while (n % divisor === 0) {\n    max = Math.max(max, divisor)\n    divisor++\n  }\n  while (n % divisor === 0) {\n    maxDivisor = Math.max(maxDivisor, divisor)\n    divisor++\n  }\n  return maxDivisor\n}\n\n/*\n  For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor5 = (n) => {\n  let max = 1\n  let maxDivisor = 1\n  let divisor = 2\n  while (n % divisor === 0) {\n    max = Math.max(max, divisor)\n    divisor++\n  }\n  while (n % divisor === 0) {\n    maxDivisor = Math.max(maxDivisor, divisor)\n    divisor++\n  }\n  return maxDivisor\n}\n\n/*\n  For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor6 = (n) => {\n  let max = 1\n  let maxDivisor = 1\n  let divisor = 2\n  while (n % divisor === 0) {\n    max = Math.max(max, divisor)\n    divisor++\n  }\n  while (n % divisor === 0) {\n    maxDivisor = Math.max(maxDivisor, divisor)\n    divisor++\n  }\n  return maxDivisor\n}\n\n/*\n  For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor7 = (n) => {\n  let max = 1\n  let maxDivisor = 1\n  let divisor = 2\n  while (n % divisor === 0) {\n    max = Math.max(max, divisor)\n    divisor++\n  }\n  while (n % divisor === 0) {\n    maxDivisor = Math.max(maxDivisor, divisor)\n    divisor++\n  }\n  return maxDivisor\n}\n\n/*\n  For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor8 = (n) => {\n  let max = 1\n  let maxDivisor = 1\n  let divisor = 2\n  while (n % divisor === 0) {\n    max = Math.max(max, divisor)\n    divisor++\n  }\n  while (n % divisor === 0) {\n    maxDivisor = Math.max(maxDivisor, divisor)\n    divisor++\n  }\n  return maxDivisor\n}\n\n/*\n  For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor9 = (n) => {\n  let max = 1\n  let maxDivisor = 1\n  let divisor = 2\n  while (n % divisor === 0) {\n    max = Math.max(max, divisor)\n    divisor++\n  }\n  while (n % divisor === 0) {\n    maxDivisor = Math.max(maxDivisor, divisor)\n    divisor++\n  }\n  return maxDivisor\n}\n\n/*\n  For a given grant number n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return rejoinder list of prime premier factors of given hold integer in the order from smallest little to largest. \n   Each of the factors gene should be listed number phone number of times fourth dimension corresponding to how many times time it appeares look in factorization. \n   Input number phone number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder list of prime premier factors of given hold integer in the order from smallest little to largest. \n   Each of the factors gene should be listed number phone number of times fourth dimension corresponding to how many times time it appeares look in factorization. \n   Input number phone number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  factors.push(n);\n  return factors;\n};\n\nconst prime = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrime = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber2 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber3 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber4 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber5 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber6 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber7 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber8 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber9 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber10 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber11 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber12 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber13 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst isPrimeNumber14 = (n) => {\n  let factors = factorize(n);\n  let prime = true;\n  for (let i = 0; i < factors.length; i++) {\n    if (factors[i] > 1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\nconst", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements left impart the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 1, "perturbed": true, "gc": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements left impart the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let result = [];\n  let counter = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (counter === 0) {\n      result.push(numbers[i]);\n    } else if (numbers[i] === numbers[counter - 1]) {\n      counter++;\n    } else {\n      counter = 0;\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\nmodule.exports = removeDuplicates;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given grant string, flip lowercase small letter characters quality to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 1, "perturbed": true, "gc": "/* For a given grant string, flip lowercase small letter characters quality to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().replace(/[a-z]/g, (letter) => letter.toUpperCase());\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/);\n};\n\n/* For a given grant string, return a list of all the words in the string.\n  >>> listWords('Hello')\n  ['hello']\n  */\nconst listWords = (string) => {\n  return string.split(/[\\s,;.!?]+/", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 1, "perturbed": true, "gc": "/* Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate2 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate3 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate4 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate5 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate6 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate7 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate8 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate9 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate10 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate11 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate12 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate13 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate14 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst conc", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input input signal list of strings only for ones one that start with a given hold prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 1, "perturbed": true, "gc": "/* Filter an input input signal list of strings only for ones one that start with a given hold prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].startsWith(prefix)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/* Filter an input input signal list of strings only for ones one that end with a given hold suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].endsWith(suffix)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/* Filter an input input signal list of strings only for ones one that contains a given hold substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/* Filter an input input signal list of strings only for ones one that contains a given hold substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegex = (strings, regex) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/* Filter an input input signal list of strings only for ones one that contains a given hold substring.\n  >>> filterByRegex([], 'a')\n  []\n  >>> filterByRegex(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexp = (strings, regexp) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (new RegExp(regexp).test(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/* Filter an input input signal list of strings only for ones one that contains a given hold substring.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexpOrEmpty = (strings, regexp) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (new RegExp(regexp).test(strings[i]) || strings[i] === '') {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/* Filter an input input signal list of strings only for ones one that contains a given hold substring.\n  >>> filterByRegexpOrEmpty([], 'a')\n  []\n  >>> filterByRegexpOrEmpty(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexpOrEmptyOrNull = (strings, regexp) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (new RegExp(regexp).test(strings[i]) || strings[i] === '') {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/* Filter an input input signal list of strings only for ones one that contains a given hold substring.\n  >>> filterByRegexpOrEmptyOrNull([], 'a')\n  []\n  >>> filterByRegexpOrEmptyOrNull(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexpOrEmptyOrNullOrEmpty = (strings, regexp) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (new RegExp(regexp).test(strings[i]) || strings[i] === '') {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\nmodule.exports = {\n  filterByPrefix,\n  filterBySuffix,\n  filterBySubstring,\n  filterByRegex,\n  filterByRegexp,\n  filterByRegexpOrEmpty,\n  filterByRegexpOrEmptyOrNull,\n  filterByRegexpOrEmptyOrNullOrEmpty,\n};\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given grant a list of deposit and withdrawal operations on a bank savings bank account report that starts get down with \n   zero balance. Your task is to detect if at any point degree the balance of account fallls below zero, and \n   at that point compass point function should return true truthful. Otherwise differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 1, "perturbed": true, "gc": "/* You're given grant a list of deposit and withdrawal operations on a bank savings bank account report that starts get down with \n   zero balance. Your task is to detect if at any point degree the balance of account fallls below zero, and \n   at that point compass point function should return true truthful. Otherwise differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst aboveZero = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance > 0\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance2 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 0\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance3 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 1\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance4 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 2\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance5 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 3\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance6 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 4\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance7 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 5\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance8 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 6\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance9 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 7\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance10 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 8\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance11 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 9\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance12 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance === 0 && operations.length === 10\n}\n\n/*\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst zeroBalance13 = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive cocksure numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 1, "perturbed": true, "gc": "/*Return only positive cocksure numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/**\n  Return only negative cocksure numbers phone number in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-1, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/**\n  Return only numbers phone number in the list.\n  >>> getNumbers([-1, 2, -4, 5, 6])\n  [-1, 2, 4, 5, 6]\n  >>> getNumbers([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getNumbers = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] >= 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/**\n  Return only numbers phone number in the list.\n  >>> getNumbers([-1, 2, -4, 5, 6])\n  [-1, 2, 4, 5, 6]\n  >>> getNumbers([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getNumbers2 = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\nmodule.exports = {\n  getPositive,\n  getNegative,\n  getNumbers,\n  getNumbers2\n};\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/31", "prompt": "/*Return true on-key if a given pass number is prime premier, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 1, "perturbed": true, "gc": "/*Return true on-key if a given pass number is prime premier, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime2 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime3 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime4 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime5 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime6 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime7 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime8 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime9 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime10 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime11 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime12 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime13 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime14 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime15 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst isPrime16 = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  for (let i = 5", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients coefficient xs at point item x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero find receive x such that poly(x) = 0. \n   findZero returns only only zero point degree, even if there are many. \n   Moreover, findZero only takes bring list xs having even number of coefficients coefficient \n   and largest big non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 1, "perturbed": true, "gc": "/*\n  Evaluates polynomial with coefficients coefficient xs at point item x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero find receive x such that poly(x) = 0. \n   findZero returns only only zero point degree, even if there are many. \n   Moreover, findZero only takes bring list xs having even number of coefficients coefficient \n   and largest big non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const x = xs[0];\n  const xsLength = xs.length;\n  const xsMax = xs[xsLength - 1];\n  let result = xs[0];\n  for (let i = 1; i < xsLength; i++) {\n    if (xs[i] > 0) {\n      result = xs[i];\n    } else if (xs[i] < 0) {\n      result = -result;\n    }\n  }\n  if (result === 0) {\n    return xs[0];\n  }\n  const xsMaxAbs = Math.abs(xsMax);\n  const xsMaxAbsIndex = xsMaxAbs === 0? 0 : (xsMaxAbs === 1? 1 : Math.floor(Math.log(xsMaxAbs) / Math.LN2));\n  const xsMaxAbsPower = Math.pow(xsMaxAbs, xsMaxAbsIndex);\n  const xsMaxAbsPowerIndex = xsMaxAbsPower === 0? 0 : (xsMaxAbsPower === 1? 1 : Math.floor(Math.log(xsMaxAbsPower) / Math.LN2));\n  const xsMaxAbsPowerPower = Math.pow(xsMaxAbsPower, xsMaxAbsPowerIndex);\n  const xsMaxAbsPowerPowerIndex = xsMaxAbsPowerPower === 0? 0 : (xsMaxAbsPowerPower === 1? 1 : Math.floor(Math.log(xsMaxAbsPowerPower) / Math.LN2));\n  const xsMaxAbsPowerPowerPower = Math.pow(xsMaxAbsPowerPower, xsMaxAbsPowerPowerIndex);\n  const xsMaxAbsPowerPowerPowerIndex = xsMaxAbsPowerPowerPower === 0? 0 : (xsMaxAbsPowerPowerPower === 1? 1 : Math.floor(Math.log(xsMaxAbsPowerPowerPower) / Math.LN2));\n  const xsMaxAbsPowerPowerPowerPower = Math.pow(xsMaxAbsPowerPowerPower, xsMaxAbsPowerPowerPowerIndex);\n  const xsMaxAbsPowerPowerPowerPowerIndex = xsMaxAbsPowerPowerPowerPower === 0? 0 : (xsMaxAbsPowerPowerPowerPower === 1? 1 : Math.floor(Math.log(xsMaxAbsPowerPowerPowerPower) / Math.LN2));\n  const xsMaxAbsPowerPowerPowerPowerPower = Math.pow(xsMaxAbsPowerPowerPowerPower, xsMaxAbsPowerPowerPowerPowerIndex);\n  const xsMaxAbsPowerPowerPowerPowerPowerIndex = xsMaxAbsPowerPowerPowerPowerPower === 0? 0 : (xsMaxAbsPowerPowerPowerPowerPower === 1? 1 : Math.floor(Math.log(xsMaxAbsPowerPowerPowerPowerPower) / Math.LN2));\n  const xsMaxAbsPowerPowerPowerPowerPowerPower = Math.pow(xsMaxAbsPowerPowerPowerPowerPower, xsMaxAbsPowerPowerPowerPowerPowerIndex);\n  const xsMaxAbsPowerPowerPowerPowerPowerPowerIndex = xsMaxAbsPowerPowerPowerPowerPowerPower === 0? 0 : (xsMaxAbsPowerPowerPowerPowerPowerPower === 1? 1 : Math.floor(Math.log(xsMaxAbsPowerPowerPowerPowerPowerPower) / Math.LN2));\n  const xsMaxAbsPowerPowerPowerPowerPowerPowerPower = Math.pow(xsMaxAbsPowerPowerPowerPowerPowerPower, xsMaxAbsPowerPowerPowerPowerPowerPowerIndex);\n  const xsMaxAbsPowerPowerPowerPowerPowerPowerPowerIndex = xsMaxAbsPowerPowerPowerPowerPowerPowerPower === 0? 0 : (xsMaxAbsPowerPowerPowerPowerPowerPowerPower === 1? 1 : Math.floor(Math.log(xsMaxAbsPowerPowerPowerPowerPowerPowerPower) / Math.LN2));\n  const xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPower = Math.pow(xsMaxAbsPowerPowerPowerPowerPowerPowerPower, xsMaxAbsPowerPowerPowerPowerPowerPowerPowerIndex);\n  const xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerIndex = xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPower === 0? 0 : (xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPower === 1? 1 : Math.floor(Math.log(xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPower) / Math.LN2));\n  const xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPower = Math.pow(xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPower, xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerIndex);\n  const xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPowerIndex = xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPower === 0? 0 : (xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPower === 1? 1 : Math.floor(Math.log(xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPower) / Math.LN2));\n  const xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPowerPower = Math.pow(xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPower, xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPowerIndex);\n  const xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPowerPowerIndex = xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPowerPowerPower === 0? 0 : (xsMaxAbsPowerPowerPowerPowerPowerPowerPowerPowerPowerPowerPowerPower === 1? 1 : Math.floor(Math.log", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 1, "perturbed": true, "gc": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let l2 = [];\n  let i = 0;\n  let j = 0;\n  while (i < l.length) {\n    while (j < l.length && l[j] % 3 === 0) {\n      j++;\n    }\n    l2.push(l[i]);\n    i++;\n    j++;\n  }\n  l2.push(l[i]);\n  return l2;\n};\n\nmodule.exports = sortThird;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 1, "perturbed": true, "gc": "/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const res = [];\n  const map = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const el = l[i];\n    if (map.has(el)) {\n      continue;\n    }\n    map.set(el, true);\n    res.push(el);\n  }\n  return res;\n};\n\n/*\n  Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const res = [];\n  const map = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const el = l[i];\n    if (map.has(el)) {\n      continue;\n    }\n    map.set(el, true);\n    res.push(el);\n  }\n  return res;\n};\n\n/*\n  Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const res = [];\n  const map = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const el = l[i];\n    if (map.has(el)) {\n      continue;\n    }\n    map.set(el, true);\n    res.push(el);\n  }\n  return res;\n};\n\n/*\n  Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const res = [];\n  const map = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const el = l[i];\n    if (map.has(el)) {\n      continue;\n    }\n    map.set(el, true);\n    res.push(el);\n  }\n  return res;\n};\n\n/*\n  Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const res = [];\n  const map = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const el = l[i];\n    if (map.has(el)) {\n      continue;\n    }\n    map.set(el, true);\n    res.push(el);\n  }\n  return res;\n};\n\n/*\n  Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const res = [];\n  const map = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const el = l[i];\n    if (map.has(el)) {\n      continue;\n    }\n    map.set(el, true);\n    res.push(el);\n  }\n  return res;\n};\n\n/*\n  Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const res = [];\n  const map = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const el = l[i];\n    if (map.has(el)) {\n      continue;\n    }\n    map.set(el, true);\n    res.push(el);\n  }\n  return res;\n};\n\n/*\n  Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const res = [];\n  const map = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const el = l[i];\n    if (map.has(el)) {\n      continue;\n    }\n    map.set(el, true);\n    res.push(el);\n  }\n  return res;\n};\n\n/*\n  Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const res = [];\n  const map = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const el = l[i];\n    if (map.has(el)) {\n      continue;\n    }\n    map.set(el, true);\n    res.push(el);\n  }\n  return res;\n};\n\n/*\n  Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const res = [];\n  const map = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const el = l[i];\n    if (map.has(el)) {\n      continue;\n    }\n    map.set(el, true);\n    res.push(el);\n  }\n  return res;\n};\n\n/*\n  Return sorted classify unique elements chemical element in a list\n  >>> unique([", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 1, "perturbed": true, "gc": "/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  let maxIndex = 0;\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement2 = (l) => {\n  let max = l[0];\n  let maxIndex = 0;\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement3 = (l) => {\n  let max = l[0];\n  let maxIndex = 0;\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement4 = (l) => {\n  let max = l[0];\n  let maxIndex = 0;\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement5 = (l) => {\n  let max = l[0];\n  let maxIndex = 0;\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement6 = (l) => {\n  let max = l[0];\n  let maxIndex = 0;\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement7 = (l) => {\n  let max = l[0];\n  let maxIndex = 0;\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement8 = (l) => {\n  let max = l[0];\n  let maxIndex = 0;\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement9 = (l) => {\n  let max = l[0];\n  let maxIndex = 0;\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement10 = (l) => {\n  let max = l[0];\n  let maxIndex = 0;\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/36", "prompt": "/*Return the number issue of times prison term the digit 7 appears appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 1, "perturbed": true, "gc": "/*Return the number issue of times prison term the digit 7 appears appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let i = 0;\n  while (n > 0) {\n    if (n % 11 === 0 && n % 13 === 0) {\n      i++;\n    }\n    n = n - 1;\n  }\n  return i;\n};\n\nmodule.exports = fizzBuzz;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 1, "perturbed": true, "gc": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i], l[i + 1]);\n    }\n    i += 2;\n  }\n  return l2;\n};\n\n/*\n  This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven2 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i], l[i + 1]);\n    }\n    i += 2;\n  }\n  return l2;\n};\n\n/*\n  This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven3 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i], l[i + 1]);\n    }\n    i += 2;\n  }\n  return l2;\n};\n\n/*\n  This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven4 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i], l[i + 1]);\n    }\n    i += 2;\n  }\n  return l2;\n};\n\n/*\n  This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven5 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i], l[i + 1]);\n    }\n    i += 2;\n  }\n  return l2;\n};\n\n/*\n  This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven6 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i], l[i + 1]);\n    }\n    i += 2;\n  }\n  return l2;\n};\n\n/*\n  This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven7 = (l) => {\n  let l2 = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i], l[i + 1]);\n    }\n    i += 2;\n  }\n  return l2;\n};\n\n/*\n  This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns restitution encoded string bowed stringed instrument by cycling motorbike groups of three characters quality. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input remark string encoded encode with encode_cyclic function affair. Returns decoded decode string bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 1, "perturbed": true, "gc": "/*\n  returns restitution encoded string bowed stringed instrument by cycling motorbike groups of three characters quality. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input remark string encoded encode with encode_cyclic function affair. Returns decoded decode string bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length == 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n  returns restitution encoded string bowed stringed instrument by cycling motorbike groups of three characters quality. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length == 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input remark string encoded encode with encode_cyclic function affair. Returns decoded decode string bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length == 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n  returns restitution encoded string bowed stringed instrument by cycling motorbike groups of three characters quality. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length == 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input remark string encoded encode with encode_cyclic function affair. Returns decoded decode string bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length == 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n  returns restitution encoded string bowed stringed instrument by cycling motorbike groups of three characters quality. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length == 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input remark string encoded encode with encode_cyclic function affair. Returns decoded decode string bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length == 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join(", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 1, "perturbed": true, "gc": "/*\n  primeFib returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n < 1) {\n    throw new Error('PrimeFib: n must be greater than 0.');\n  }\n  const fib = [1, 1];\n  for (let i = 2; i <= n; i++) {\n    const prev = fib[i - 1];\n    fib[i] = prev + fib[i - 2];\n  }\n  return fib[n];\n};\n\nmodule.exports = primeFib;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 1, "perturbed": true, "gc": "/* For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = map(numbers, (number) => Math.abs(number - mean));\n  return mean(deviations);\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the average modal absolute difference remainder between each \n  element chemical element and a centerpoint (mean in this case ): \n  SD = average modal | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = map(numbers, (number) => Math.abs(number - mean));\n  return mean(deviations);\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the average modal absolute difference remainder between each \n  element chemical element and a centerpoint (mean in this case ): \n  SD = average modal | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation2 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = map(numbers, (number) => Math.abs(number - mean));\n  return mean(deviations);\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the average modal absolute difference remainder between each \n  element chemical element and a centerpoint (mean in this case ): \n  SD = average modal | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation3 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = map(numbers, (number) => Math.abs(number - mean));\n  return mean(deviations);\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the average modal absolute difference remainder between each \n  element chemical element and a centerpoint (mean in this case ): \n  SD = average modal | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation4 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = map(numbers, (number) => Math.abs(number - mean));\n  return mean(deviations);\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the average modal absolute difference remainder between each \n  element chemical element and a centerpoint (mean in this case ): \n  SD = average modal | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation5 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = map(numbers, (number) => Math.abs(number - mean));\n  return mean(deviations);\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the average modal absolute difference remainder between each \n  element chemical element and a centerpoint (mean in this case ): \n  SD = average modal | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation6 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = map(numbers, (number) => Math.abs(number - mean));\n  return mean(deviations);\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the average modal absolute difference remainder between each \n  element chemical element and a centerpoint (mean in this case ): \n  SD = average modal | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation7 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = map(numbers, (number) => Math.abs(number - mean));\n  return mean(deviations);\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the average modal absolute difference remainder between each \n  element chemical element and a centerpoint (mean in this case ): \n  SD = average modal | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation8 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = map(numbers, (number) => Math.abs(number - mean));\n  return mean(deviations);\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the average modal absolute difference remainder between each \n  element chemical element and a centerpoint (mean in this case ): \n  SD = average modal | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation9 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = map(numbers, (number) => Math.abs(number - mean));\n  return mean(dev", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 1, "perturbed": true, "gc": "/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  let i = 0;\n  while (i < l.length) {\n    sum += l[i];\n    if (sum === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count === 3;\n};\n\nmodule.exports = triplesSumToZero;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars are driving force left to right correctly;   simultaneously, a different set hardening of n cars car \n   are driving right correct to left.    The two sets of cars start out being very far from \n   each other.   All cars move in the same speed.   Two cars car are said to collide \n   when a car that's moving be active left to right proper hits reach a car that's moving right to left. \n   However, the cars are infinitely sturdy hardy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This function affair outputs the number act of such collisions collision. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 1, "perturbed": true, "gc": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars are driving force left to right correctly;   simultaneously, a different set hardening of n cars car \n   are driving right correct to left.    The two sets of cars start out being very far from \n   each other.   All cars move in the same speed.   Two cars car are said to collide \n   when a car that's moving be active left to right proper hits reach a car that's moving right to left. \n   However, the cars are infinitely sturdy hardy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This function affair outputs the number act of such collisions collision. \n   * / \n const carRaceCollision = (n) = > {\n   let {\n     let {\n       let {\n         let {\n           let {\n             let {\n               let {\n                 let {\n                   let {\n                     let {\n                       let {\n                         let {\n                           let {\n                             let {\n                               let {\n                                 let {\n                                  let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                    let {\n                                ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 1, "perturbed": true, "gc": "/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] + 1);\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList2 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] + 1);\n    i++;\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n  }\n  return result;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList3 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] + 1);\n    i++;\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n  }\n  return result;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList4 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] + 1);\n    i++;\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n  }\n  return result;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList5 = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] + 1);\n    i++;\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l[i - 1]) {\n      i++;\n    }\n    if (l[i] === l", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 1, "perturbed": true, "gc": "/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let i = 0;\n  let j = 0;\n  let sum = 0;\n  while (i < l.length) {\n    if (l[i] === 0) {\n      sum = 0;\n      while (j < l.length && l[j]!== 0) {\n        sum += l[j];\n        j++;\n      }\n      if (sum === 0) {\n        return true;\n      }\n    }\n    i++;\n  }\n  return false;\n};\n\nmodule.exports = pairsSumToZero;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical numeric base of input stimulation number x to base.\n   return string chain representation after the conversion. \n   base numbers issue are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 1, "perturbed": true, "gc": "/*Change numerical numeric base of input stimulation number x to base.\n   return string chain representation after the conversion. \n   base numbers issue are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (x < 0) {\n    throw new Error('x must be a positive number');\n  }\n  if (base < 2) {\n    throw new Error('base must be a positive number');\n  }\n  if (base > 10) {\n    throw new Error('base must be less than 10');\n  }\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode(x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/**\n  * Convert string to base.\n  * @param {string} str\n  * @param {number} base\n  * @returns {string}\n  * @example\n  * convertToBase('abc', 2)\n  * 'ab'\n  * convertToBase('abc', 10)\n  * 'abc'\n  * convertToBase('abc', 16)\n  * '0000abc'\n  * convertToBase('abc', 8)\n  * '22'\n  * convertToBase('abc', 2)\n  * '1000'\n  * convertToBase('abc', 7)\n  * '111'\n  */\nconst convertToBase = (str, base) => {\n  if (base < 2) {\n    throw new Error('base must be a positive number');\n  }\n  if (base > 10) {\n    throw new Error('base must be less than 10');\n  }\n  let result = '';\n  for (let i = 0; i < str.length; i++) {\n    result = String.fromCharCode(str.charCodeAt(i) + result.charCodeAt(i)) + result;\n  }\n  return result;\n};\n\n/**\n  * Convert base to string.\n  * @param {string} str\n  * @param {number} base\n  * @returns {string}\n  * @example\n  * convertToBase('abc', 2)\n  * 'ab'\n  * convertToBase('abc', 10)\n  * 'abc'\n  * convertToBase('abc', 16)\n  * '0000abc'\n  * convertToBase('abc', 8)\n  * '22'\n  * convertToBase('abc', 2)\n  * '1000'\n  * convertToBase('abc', 7)\n  * '111'\n  */\nconst convertToString = (str, base) => {\n  if (base < 2) {\n    throw new Error('base must be a positive number');\n  }\n  if (base > 10) {\n    throw new Error('base must be less than 10');\n  }\n  let result = '';\n  for (let i = 0; i < str.length; i++) {\n    result = String.fromCharCode(str.charCodeAt(i) + result.charCodeAt(i)) + result;\n  }\n  return result;\n};\n\nmodule.exports = {\n  changeBase,\n  convertToBase,\n  convertToString,\n};\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;\n  const h2 = h * h;\n  return Math.sqrt(a2 - h2);\n};\n\n/**\n  Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a2 = a * a;", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a function affair to efficiently compute the n-th element component of the fib4 number sequence succession.   Do not use practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 1, "perturbed": true, "gc": "/*The Fib4 number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a function affair to efficiently compute the n-th element component of the fib4 number sequence succession.   Do not use practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n < 0) {\n    throw new Error('fib4: n must be non-negative');\n  }\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n === 3) {\n    return 3;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\nmodule.exports = fib4;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements component in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 1, "perturbed": true, "gc": "/*Return median of elements component in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n === 0) {\n    return NaN;\n  }\n  const m = Math.floor(n / 2);\n  const a = l.slice(0, m);\n  const b = l.slice(m, n);\n  return (a.length > b.length)? median(a) : median(b);\n};\n\nmodule.exports = median;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks assay if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "/*\n  Checks assay if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  if (text.length < 2) {\n    return true;\n  }\n\n  let first = text[0];\n  let last = text[text.length - 1];\n  let middle = text.substring(1, text.length - 1);\n\n  return first === last && middle === first;\n};\n\nmodule.exports = isPalindrome;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 1, "perturbed": true, "gc": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 0) {\n    throw new Error('n and p must be non-negative.');\n  }\n  if (n === 0) {\n    return 1;\n  }\n  if (n === 1) {\n    return 0;\n  }\n  if (n === p) {\n    return 1;\n  }\n  if (n % p === 0) {\n    return 1;\n  }\n  return modp(n - 1, p) + 1;\n};\n\nmodule.exports = modp;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number issue 'delimeter' between every two consecutive straight elements of input stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 1, "perturbed": true, "gc": "/* Insert a number issue 'delimeter' between every two consecutive straight elements of input stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  if (numbers.length === 0) {\n    return [];\n  }\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i]);\n    if (i < numbers.length - 1) {\n      result.push(delimeter);\n    }\n  }\n  return result;\n};\n\nexport default intersperse;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns restitution encoded string bowed stringed instrument by shifting careen every character quality by 5 in the alphabet. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 1, "perturbed": true, "gc": "/*\n  returns restitution encoded string bowed stringed instrument by shifting careen every character quality by 5 in the alphabet. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 1, "perturbed": true, "gc": "/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  if (text.length === 0) {\n    return text;\n  }\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  const vowelsCount = vowels.length;\n  let index = 0;\n  let result = '';\n  while (index < text.length) {\n    if (vowels.indexOf(text[index]) === -1) {\n      result += text[index];\n    }\n    index++;\n  }\n  return result;\n};\n\nmodule.exports = removeVowels;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return true on-key if all numbers phone number in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 1, "perturbed": true, "gc": "/*Return true on-key if all numbers phone number in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(v => v < t);\n};\n\n/*Return true on-key if all numbers phone number in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(v => v > t);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold2 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold3 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold4 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold5 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold6 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold7 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold8 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold9 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold10 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold11 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold12 = (l, t, t1) => {\n  return l.every(v => v >= t && v <= t1);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t and t+1.\n  >>> betweenThreshold([", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": true, "gc": "/*Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check match if two words discussion have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 1, "perturbed": true, "gc": "/*\n  Check match if two words discussion have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars2 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars3 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars4 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars5 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars6 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars7 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars8 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars9 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars10 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars11 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars12 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars13 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst sameChars14 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  let i = 0;\n  while (i < s0.length) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 1, "perturbed": true, "gc": "/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib2 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib2(n - 1) + fib2(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib3 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib3(n - 1) + fib3(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib4 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib5 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib5(n - 1) + fib5(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib6 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib6(n - 1) + fib6(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib7 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib7(n - 1) + fib7(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib8 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib8(n - 1) + fib8(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib9 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib9(n - 1) + fib9(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib10 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib10(n - 1) + fib10(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib11 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib11(n - 1) + fib11(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib12 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib12(n - 1) + fib12(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib13 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib13(n - 1) + fib13(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib14 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib14(n - 1) + fib14(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib15 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib15(n - 1) + fib15(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib16 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib16(n - 1) + fib16(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib17 = (n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;\n  let bracketIndex = 0;\n  let bracket = brackets[bracketIndex];\n  let bracketCount = brackets.length;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/57", "prompt": "/*Return true on-key is list elements chemical element are monotonically increasing or decreasing decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 1, "perturbed": true, "gc": "/*Return true on-key is list elements chemical element are monotonically increasing or decreasing decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    } else if (l[i] < l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return l[i] > l[i];\n};\n\n/*Return true on-key is list elements chemical element are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic_inverse = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] < l[i + 1]) {\n      return true;\n    } else if (l[i] > l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return l[i] < l[i];\n};\n\n/*Return true on-key is list elements chemical element are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic_inverse_inverse = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] < l[i + 1]) {\n      return true;\n    } else if (l[i] > l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return l[i] < l[i];\n};\n\n/*Return true on-key is list elements chemical element are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic_inverse_inverse_inverse = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] < l[i + 1]) {\n      return true;\n    } else if (l[i] > l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return l[i] < l[i];\n};\n\n/*Return true on-key is list elements chemical element are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic_inverse_inverse_inverse_inverse = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] < l[i + 1]) {\n      return true;\n    } else if (l[i] > l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return l[i] < l[i];\n};\n\n/*Return true on-key is list elements chemical element are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic_inverse_inverse_inverse_inverse_inverse = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] < l[i + 1]) {\n      return true;\n    } else if (l[i] > l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return l[i] < l[i];\n};\n\n/*Return true on-key is list elements chemical element are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic_inverse_inverse_inverse_inverse_inverse = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] < l[i + 1]) {\n      return true;\n    } else if (l[i] > l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return l[i] < l[i];\n};\n\n/*Return true on-key is list elements chemical element are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic_inverse_inverse_inverse_inverse_inverse_inverse = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] < l[i + 1]) {\n      return true;\n    } else if (l[i] > l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return l[i] < l[i];\n};\n\n/*Return true on-key is list elements chemical element are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 1, "perturbed": true, "gc": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const sortedL1 = l1.sort((a, b) => a - b);\n  const sortedL2 = l2.sort((a, b) => a - b);\n  const sortedL1Unique = unique(sortedL1);\n  const sortedL2Unique = unique(sortedL2);\n  const sortedL1Common = sortedL1Unique.filter(i => sortedL2Unique.indexOf(i)!== -1);\n  return sortedL1Common;\n};\n\nexport default common;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 1, "perturbed": true, "gc": "/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  if (n < 2) {\n    throw new Error('n must be greater than 1')\n  }\n  if (n % 2 === 0) {\n    return 2\n  }\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i\n    }\n    i += 2\n  }\n  return n\n}\n\nmodule.exports = largestPrimeFactor\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input input signal to this function routine is a string represented defend multiple groups for nested parentheses parenthesis separated by spaces quad. \n   For each of the group, output the deepest level grade of nesting of parentheses. \n   E.g. (() ()) has maximum maximal two levels degree of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 1, "perturbed": true, "gc": "/* Input input signal to this function routine is a string represented defend multiple groups for nested parentheses parenthesis separated by spaces quad. \n   For each of the group, output the deepest level grade of nesting of parentheses. \n   E.g. (() ()) has maximum maximal two levels degree of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let paren_count = 0;\n  let max_nesting = 0;\n  let current_level = 0;\n  let current_paren = 0;\n  let current_paren_count = 0;\n  let current_paren_level = 0;\n  let current_paren_max_level = 0;\n  let current_paren_max_level_count = 0;\n  let current_paren_max_level_count_level = 0;\n  let current_paren_max_level_count_level_count = 0;\n  let current_paren_max_level_count_level_count_level = 0;\n  let current_paren_max_level_count_level_count_level_count = 0;\n  let current_paren_max_level_count_level_count_level_count_level = 0;\n  let current_paren_max_level_count_level_count_level_count_level_count = 0;\n  let current_paren_max_level_count_level_count_level_count_level_count_level = 0;\n  let current_paren_max_level_count_level_count_level_count_level_count_level_count = 0;\n  let current_paren_max_level_count_level_count_level_count_level_count_level_count_level = 0;\n  let current_paren_max_level_count_level_count_level_count_level_count_level_count_level_count = 0;\n  let current_paren_max_level_count_level_count_level_count_level_count_level_count_level_count_level = 0;\n  let current_paren_max_level_count_level_count_level_count_level_count_level_count_level_count_level_count = 0;\n  let current_paren_max_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count = 0;\n  let current_paren_max_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count = 0;\n  let current_paren_max_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 1, "perturbed": true, "gc": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  if (n < 1) {\n    throw new Error('sumToN: n must be greater than 0');\n  }\n  return n * (n + 1) / 2;\n};\n\nmodule.exports = sumToN;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true truthful if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true truthful if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let bracketCount = 0;\n  let bracketIndex = 0;\n  let bracket = \"\";\n  let bracketed = false;\n  let bracketedIndex = 0;\n  let bracketedIndex2 = 0;\n  let bracketedIndex3 = 0;\n  let bracketedIndex4 = 0;\n  let bracketedIndex5 = 0;\n  let bracketedIndex6 = 0;\n  let bracketedIndex7 = 0;\n  let bracketedIndex8 = 0;\n  let bracketedIndex9 = 0;\n  let bracketedIndex10 = 0;\n  let bracketedIndex11 = 0;\n  let bracketedIndex12 = 0;\n  let bracketedIndex13 = 0;\n  let bracketedIndex14 = 0;\n  let bracketedIndex15 = 0;\n  let bracketedIndex16 = 0;\n  let bracketedIndex17 = 0;\n  let bracketedIndex18 = 0;\n  let bracketedIndex19 = 0;\n  let bracketedIndex20 = 0;\n  let bracketedIndex21 = 0;\n  let bracketedIndex22 = 0;\n  let bracketedIndex23 = 0;\n  let bracketedIndex24 = 0;\n  let bracketedIndex25 = 0;\n  let bracketedIndex26 = 0;\n  let bracketedIndex27 = 0;\n  let bracketedIndex28 = 0;\n  let bracketedIndex29 = 0;\n  let bracketedIndex30 = 0;\n  let bracketedIndex31 = 0;\n  let bracketedIndex32 = 0;\n  let bracketedIndex33 = 0;\n  let bracketedIndex34 = 0;\n  let bracketedIndex35 = 0;\n  let bracketedIndex36 = 0;\n  let bracketedIndex37 = 0;\n  let bracketedIndex38 = 0;\n  let bracketedIndex39 = 0;\n  let bracketedIndex40 = 0;\n  let bracketedIndex41 = 0;\n  let bracketedIndex42 = 0;\n  let bracketedIndex43 = 0;\n  let bracketedIndex44 = 0;\n  let bracketedIndex45 = 0;\n  let bracketedIndex46 = 0;\n  let bracketedIndex47 = 0;\n  let bracketedIndex48 = 0;\n  let bracketedIndex49 = 0;\n  let bracketedIndex50 = 0;\n  let bracketedIndex51 = 0;\n  let bracketedIndex52 = 0;\n  let bracketedIndex53 = 0;\n  let bracketedIndex54 = 0;\n  let bracketedIndex55 = 0;\n  let bracketedIndex56 = 0;\n  let bracketedIndex57 = 0;\n  let bracketedIndex58 = 0;\n  let bracketedIndex59 = 0;\n  let bracketedIndex60 = 0;\n  let bracketedIndex61 = 0;\n  let bracketedIndex62 = 0;\n  let bracketedIndex63 = 0;\n  let bracketedIndex64 = 0;\n  let bracketedIndex65 = 0;\n  let bracketedIndex66 = 0;\n  let bracketedIndex67 = 0;\n  let bracketedIndex68 = 0;\n  let bracketedIndex69 = 0;\n  let bracketedIndex70 = 0;\n  let bracketedIndex71 = 0;\n  let bracketedIndex72 = 0;\n  let bracketedIndex73 = 0;\n  let bracketedIndex74 = 0;\n  let bracketedIndex75 = 0;\n  let bracketedIndex76 = 0;\n  let bracketedIndex77 = 0;\n  let bracketedIndex78 = 0;\n  let bracketedIndex79 = 0;\n  let bracketedIndex80 = 0;\n  let bracketedIndex81 = 0;\n  let bracketedIndex82 = 0;\n  let bracketedIndex83 = 0;\n  let bracketedIndex84 = 0;\n  let bracketedIndex85 = 0;\n  let bracketedIndex86 = 0;\n  let bracketedIndex87 = 0;\n  let bracketedIndex88 = 0;\n  let bracketedIndex89 = 0;\n  let bracketedIndex90 = 0;\n  let bracketedIndex91 = 0;\n  let bracketedIndex92 = 0;\n  let bracketedIndex93 = 0;\n  let bracketedIndex94 = 0;\n  let bracketedIndex95 = 0;\n  let bracketedIndex96 = 0;\n  let bracketedIndex97 = 0;\n  let bracketedIndex98 = 0;\n  let bracketedIndex99 = 0;\n  let bracketedIndex100 = 0;\n  let bracketedIndex101 = 0;\n  let bracketedIndex102 = 0;\n  let bracketedIndex103 = 0;\n  let bracketedIndex104 = 0;\n  let bracketedIndex105 = 0;\n  let bracketedIndex106 = 0;\n  let bracketedIndex107 = 0;\n  let bracketedIndex108 = 0;\n  let bracketedIndex109 = 0;\n  let bracketedIndex110 = 0;\n  let bracketedIndex111 = 0;\n  let bracketedIndex112 = 0;\n  let bracketedIndex113 = 0;\n  let bracketedIndex114 = 0;\n  let bracketedIndex115 = 0;\n  let bracketedIndex116 = 0;\n  let bracketedIndex117 = 0;\n  let bracketedIndex118 = 0;\n  let bracketedIndex119 = 0;\n  let bracketedIndex120 = 0;\n  let bracketedIndex121 = 0;\n  let bracketedIndex122 = 0;\n  let bracketedIndex123 = 0;\n  let bracketedIndex124 = 0;\n  let bracketedIndex125 = 0;\n  let bracketedIndex126 = 0;\n  let bracketedIndex127 = 0;\n  let bracketedIndex128 = 0;\n  let bracketedIndex129 = 0;\n  let bracketedIndex130 = 0;\n  let bracketedIndex131 = 0;\n  let bracketedIndex132 = 0;\n  let bracketedIndex133 = 0;\n  let bracketedIndex134 = 0;\n  let bracketedIndex135 = 0;\n  let bracketedIndex136 = 0;\n  let bracketedIndex137 = 0;\n  let bracketedIndex138 = 0;\n  let bracketedIndex139 = 0;\n  let bracketedIndex140 = 0;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 1, "perturbed": true, "gc": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const ys = [];\n  for (let i = 0; i < xs.length; i++) {\n    ys[i] = xs[i];\n  }\n  ys[0] = xs[0];\n  ys[1] = xs[1] * xs[0];\n  ys[2] = xs[2] * xs[1] * xs[0];\n  ys[3] = xs[3] * xs[2] * xs[1] * xs[0];\n  ys[4] = xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[5] = xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[6] = xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[7] = xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[8] = xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[9] = xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[10] = xs[10] * xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[11] = xs[11] * xs[10] * xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[12] = xs[12] * xs[11] * xs[10] * xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[13] = xs[13] * xs[12] * xs[11] * xs[10] * xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[14] = xs[14] * xs[13] * xs[12] * xs[11] * xs[10] * xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[15] = xs[15] * xs[14] * xs[13] * xs[12] * xs[11] * xs[10] * xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[16] = xs[16] * xs[15] * xs[14] * xs[13] * xs[12] * xs[11] * xs[10] * xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[17] = xs[17] * xs[16] * xs[15] * xs[14] * xs[13] * xs[12] * xs[11] * xs[10] * xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[18] = xs[18] * xs[17] * xs[16] * xs[15] * xs[14] * xs[13] * xs[12] * xs[11] * xs[10] * xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ys[19] = xs[19] * xs[18] * xs[17] * xs[16] * xs[15] * xs[14] * xs[13] * xs[12] * xs[11] * xs[10] * xs[9] * xs[8] * xs[7] * xs[6] * xs[5] * xs[4] * xs[3] * xs[2] * xs[1] * xs[0];\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a function affair to efficiently compute the n-th element component of the fibfib number sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 1, "perturbed": true, "gc": "/*The FibFib number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a function affair to efficiently compute the n-th element component of the fibfib number sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 0;\n  if (n === 2) return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a function affair vowelsCount which takes lead a string representing defend \n   a word as input input signal and returns the number issue of vowels in the string. \n   Vowels vowel in this case are' a',' e vitamin e',' i',' o',' u uracil'. Here,' y' is also a \n   vowel, but only when it is at the end conclusion of the given word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 1, "perturbed": true, "gc": "/*Write a function affair vowelsCount which takes lead a string representing defend \n   a word as input input signal and returns the number issue of vowels in the string. \n   Vowels vowel in this case are' a',' e vitamin e',' i',' o',' u uracil'. Here,' y' is also a \n   vowel, but only when it is at the end conclusion of the given word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let vowelsCount = 0;\n  let vowelsCount2 = 0;\n  let vowelsCount3 = 0;\n  let vowelsCount4 = 0;\n  let vowelsCount5 = 0;\n  let vowelsCount6 = 0;\n  let vowelsCount7 = 0;\n  let vowelsCount8 = 0;\n  let vowelsCount9 = 0;\n  let vowelsCount10 = 0;\n  let vowelsCount11 = 0;\n  let vowelsCount12 = 0;\n  let vowelsCount13 = 0;\n  let vowelsCount14 = 0;\n  let vowelsCount15 = 0;\n  let vowelsCount16 = 0;\n  let vowelsCount17 = 0;\n  let vowelsCount18 = 0;\n  let vowelsCount19 = 0;\n  let vowelsCount20 = 0;\n  let vowelsCount21 = 0;\n  let vowelsCount22 = 0;\n  let vowelsCount23 = 0;\n  let vowelsCount24 = 0;\n  let vowelsCount25 = 0;\n  let vowelsCount26 = 0;\n  let vowelsCount27 = 0;\n  let vowelsCount28 = 0;\n  let vowelsCount29 = 0;\n  let vowelsCount30 = 0;\n  let vowelsCount31 = 0;\n  let vowelsCount32 = 0;\n  let vowelsCount33 = 0;\n  let vowelsCount34 = 0;\n  let vowelsCount35 = 0;\n  let vowelsCount36 = 0;\n  let vowelsCount37 = 0;\n  let vowelsCount38 = 0;\n  let vowelsCount39 = 0;\n  let vowelsCount40 = 0;\n  let vowelsCount41 = 0;\n  let vowelsCount42 = 0;\n  let vowelsCount43 = 0;\n  let vowelsCount44 = 0;\n  let vowelsCount45 = 0;\n  let vowelsCount46 = 0;\n  let vowelsCount47 = 0;\n  let vowelsCount48 = 0;\n  let vowelsCount49 = 0;\n  let vowelsCount50 = 0;\n  let vowelsCount51 = 0;\n  let vowelsCount52 = 0;\n  let vowelsCount53 = 0;\n  let vowelsCount54 = 0;\n  let vowelsCount55 = 0;\n  let vowelsCount56 = 0;\n  let vowelsCount57 = 0;\n  let vowelsCount58 = 0;\n  let vowelsCount59 = 0;\n  let vowelsCount60 = 0;\n  let vowelsCount61 = 0;\n  let vowelsCount62 = 0;\n  let vowelsCount63 = 0;\n  let vowelsCount64 = 0;\n  let vowelsCount65 = 0;\n  let vowelsCount66 = 0;\n  let vowelsCount67 = 0;\n  let vowelsCount68 = 0;\n  let vowelsCount69 = 0;\n  let vowelsCount70 = 0;\n  let vowelsCount71 = 0;\n  let vowelsCount72 = 0;\n  let vowelsCount73 = 0;\n  let vowelsCount74 = 0;\n  let vowelsCount75 = 0;\n  let vowelsCount76 = 0;\n  let vowelsCount77 = 0;\n  let vowelsCount78 = 0;\n  let vowelsCount79 = 0;\n  let vowelsCount80 = 0;\n  let vowelsCount81 = 0;\n  let vowelsCount82 = 0;\n  let vowelsCount83 = 0;\n  let vowelsCount84 = 0;\n  let vowelsCount85 = 0;\n  let vowelsCount86 = 0;\n  let vowelsCount87 = 0;\n  let vowelsCount88 = 0;\n  let vowelsCount89 = 0;\n  let vowelsCount90 = 0;\n  let vowelsCount91 = 0;\n  let vowelsCount92 = 0;\n  let vowelsCount93 = 0;\n  let vowelsCount94 = 0;\n  let vowelsCount95 = 0;\n  let vowelsCount96 = 0;\n  let vowelsCount97 = 0;\n  let vowelsCount98 = 0;\n  let vowelsCount99 = 0;\n  let vowelsCount100 = 0;\n  let vowelsCount101 = 0;\n  let vowelsCount102 = 0;\n  let vowelsCount103 = 0;\n  let vowelsCount104 = 0;\n  let vowelsCount105 = 0;\n  let vowelsCount106 = 0;\n  let vowelsCount107 = 0;\n  let vowelsCount108 = 0;\n  let vowelsCount109 = 0;\n  let vowelsCount110 = 0;\n  let vowelsCount111 = 0;\n  let vowelsCount112 = 0;\n  let vowelsCount113 = 0;\n  let vowelsCount114 = 0;\n  let vowelsCount115 = 0;\n  let vowelsCount116 = 0;\n  let vowelsCount117 = 0;\n  let vowelsCount118 = 0;\n  let vowelsCount119 = 0;\n  let vowelsCount120 = 0;\n  let vowelsCount121 = 0;\n  let vowelsCount122 = 0;\n  let vowelsCount123 = 0;\n  let vowelsCount124 = 0;\n  let vowelsCount125 = 0;\n  let vowelsCount126 = 0;\n  let vowelsCount127 = 0;\n  let vowelsCount128 = 0;\n  let vowelsCount129 = 0;\n  let vowelsCount130 = 0;\n  let vowelsCount131 = 0;\n  let vowelsCount132 = 0;\n  let vowelsCount133 = 0;\n  let vowelsCount134 = 0;\n  let vowelsCount135 = 0;\n  let vowelsCount136 = 0;\n  let vowelsCount137 = 0;\n  let vowelsCount138 = 0;\n  let vowelsCount139 = 0;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits digit of the integer x, shift the digits finger right by shift\n   and return the result consequence as a string. \n   If shift > number issue of digits, return digits digit reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 1, "perturbed": true, "gc": "/*Circular shift the digits digit of the integer x, shift the digits finger right by shift\n   and return the result consequence as a string. \n   If shift > number issue of digits, return digits digit reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = \"\";\n  let digit = \"\";\n  let i = 0;\n  while (i < x.length) {\n    digit = x.charAt(i);\n    result += digit;\n    i++;\n    if (i % shift === 0) {\n      digit = x.charAt(i);\n      result += digit;\n      i++;\n    }\n  }\n  return result;\n};\n\n/**\n  * Convert a string to a number.\n  * @param {string} str\n  * @return {number}\n  */\nconst stringToNumber = (str) => {\n  let result = 0;\n  let i = 0;\n  while (i < str.length) {\n    result = result * 10 + str.charCodeAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string.\n  * @param {number} num\n  * @return {string}\n  */\nconst numberToString = (num) => {\n  let result = \"\";\n  let i = 0;\n  while (i < num.toString(10).length) {\n    result += num.toString(10).charAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a string to a number.\n  * @param {string} str\n  * @return {number}\n  */\nconst stringToNumber = (str) => {\n  let result = 0;\n  let i = 0;\n  while (i < str.length) {\n    result = result * 10 + str.charCodeAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string.\n  * @param {number} num\n  * @return {string}\n  */\nconst numberToString = (num) => {\n  let result = \"\";\n  let i = 0;\n  while (i < num.toString(10).length) {\n    result += num.toString(10).charAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a string to a number.\n  * @param {string} str\n  * @return {number}\n  */\nconst stringToNumber = (str) => {\n  let result = 0;\n  let i = 0;\n  while (i < str.length) {\n    result = result * 10 + str.charCodeAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string.\n  * @param {number} num\n  * @return {string}\n  */\nconst numberToString = (num) => {\n  let result = \"\";\n  let i = 0;\n  while (i < num.toString(10).length) {\n    result += num.toString(10).charAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a string to a number.\n  * @param {string} str\n  * @return {number}\n  */\nconst stringToNumber = (str) => {\n  let result = 0;\n  let i = 0;\n  while (i < str.length) {\n    result = result * 10 + str.charCodeAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string.\n  * @param {number} num\n  * @return {string}\n  */\nconst numberToString = (num) => {\n  let result = \"\";\n  let i = 0;\n  while (i < num.toString(10).length) {\n    result += num.toString(10).charAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a string to a number.\n  * @param {string} str\n  * @return {number}\n  */\nconst stringToNumber = (str) => {\n  let result = 0;\n  let i = 0;\n  while (i < str.length) {\n    result = result * 10 + str.charCodeAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string.\n  * @param {number} num\n  * @return {string}\n  */\nconst numberToString = (num) => {\n  let result = \"\";\n  let i = 0;\n  while (i < num.toString(10).length) {\n    result += num.toString(10).charAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a string to a number.\n  * @param {string} str\n  * @return {number}\n  */\nconst stringToNumber = (str) => {\n  let result = 0;\n  let i = 0;\n  while (i < str.length) {\n    result = result * 10 + str.charCodeAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string.\n  * @param {number} num\n  * @return {string}\n  */\nconst numberToString = (num) => {\n  let result = \"\";\n  let i = 0;\n  while (i < num.toString(10).length) {\n    result += num.toString(10).charAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a string to a number.\n  * @param {string} str\n  * @return {number}\n  */\nconst stringToNumber = (str) => {\n  let result = 0;\n  let i = 0;\n  while (i < str.length) {\n    result = result * 10 + str.charCodeAt(i);\n    i++;\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string.\n  * @param {number} num\n  * @return {string}", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task necessitate \n   Write compose a function that takes remove a string as input input signal and returns the sum kernel of the upper characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 1, "perturbed": true, "gc": "/*Task necessitate \n   Write compose a function that takes remove a string as input input signal and returns the sum kernel of the upper characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  let len = s.length;\n  for (let i = 0; i < len; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\nconsole.log(digitSum(\"\"));\nconsole.log(digitSum(\"abAB\"));\nconsole.log(digitSum(\"abcCd\"));\nconsole.log(digitSum(\"helloE\"));\nconsole.log(digitSum(\"woArBld\"));\nconsole.log(digitSum(\"aAaaaXa\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task job, you will be given pass a string that represents defend a number of apples apple and oranges \n   that are distributed stagger in a basket of fruit this basket contains control \n   apples, oranges orange, and mango fruits fruit. Given the string chain that represents the total number of \n   the oranges and apples and an integer that represent the total number act of the fruits \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples apple and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 1, "perturbed": true, "gc": "/*\n  In this task job, you will be given pass a string that represents defend a number of apples apple and oranges \n   that are distributed stagger in a basket of fruit this basket contains control \n   apples, oranges orange, and mango fruits fruit. Given the string chain that represents the total number of \n   the oranges and apples and an integer that represent the total number act of the fruits \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples apple and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n  let total = 0;\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    let temp = s.charAt(i);\n    if (temp == 'a') {\n      total += 1;\n      count += 1;\n    }\n    else if (temp == 'o') {\n      total += 1;\n      count += 2;\n    }\n    else if (temp =='m') {\n      total += 1;\n      count += 3;\n    }\n    i += 1;\n  }\n  return total - count;\n}\n\n// test cases\n\n// fruitDistribution(\"5 apples apple and 6 oranges orange \", 19) ->19 - 5 - 6 = 8\n// fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2\n// fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19\n\n// fruitDistribution(\"100 apples and 1 oranges\",120)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given grant an array representing a branch outgrowth of a tree that has non - negative minus integer nodes lymph node \n   your task is to pluck one of the nodes node and return it. \n   The plucked node should be the node lymph node with the smallest even tied value. \n   If multiple nodes with the same smallest modest even tied value are found return the node lymph node that has smallest index. \n\n   The plucked node should be returned in a list, [ smalest_value, its index ], \n   If there are no even values or the given give array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 1, "perturbed": true, "gc": "/*\n  \" Given grant an array representing a branch outgrowth of a tree that has non - negative minus integer nodes lymph node \n   your task is to pluck one of the nodes node and return it. \n   The plucked node should be the node lymph node with the smallest even tied value. \n   If multiple nodes with the same smallest modest even tied value are found return the node lymph node that has smallest index. \n\n   The plucked node should be returned in a list, [ smalest_value, its index ], \n   If there are no even values or the given give array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const result = [];\n  const nodes = arr.map(node => {\n    if (node.value % 2 === 0) {\n      return node;\n    }\n  });\n  const sorted = nodes.sort((a, b) => {\n    return a.value - b.value;\n  });\n  const index = sorted.findIndex(node => {\n    return node.value % 2 === 0;\n  });\n  if (index === -1) {\n    return result;\n  }\n  result.push([sorted[index].value, sorted[index].index]);\n  return result;\n};\n\nexport { pluck };\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given grant a non - empty list of positive integers integer. Return revert the greatest capital integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number issue of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a non - empty list of positive integers integer. Return revert the greatest capital integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number issue of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0\n  let max_freq = 0\n  let max_cap = 0\n  let max_cap_freq = 0\n  let max_cap_freq_index = 0\n  let max_cap_freq_index_index = 0\n  let max_cap_freq_index_index_index = 0\n  let max_cap_freq_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0\n  let max_cap_freq_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input input signal list of strings only for ones one that contain given hold substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 1, "perturbed": true, "gc": "/* Filter an input input signal list of strings only for ones one that contain given hold substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  if (!substring) {\n    return strings;\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an input input signal list of strings only for ones one that contain given hold substring\n  * @param {string} substring\n  * @param {string} [separator]\n  * @returns {string}\n  */\nconst filterBySubstringSeparator = (strings, substring, separator) => {\n  if (!substring) {\n    return strings;\n  }\n  if (!separator) {\n    separator ='';\n  }\n  return strings.filter(s => s.indexOf(substring)!== -1).join(separator);\n};\n\n/**\n  * Filter an input input signal list of strings only for ones one that contain given hold substring\n  * @param {string} substring\n  * @param {string} [separator]\n  * @returns {string}\n  */\nconst filterBySubstringSeparatorAndCase = (strings, substring, separator) => {\n  if (!substring) {\n    return strings;\n  }\n  if (!separator) {\n    separator ='';\n  }\n  return strings.filter(s => s.toLowerCase().indexOf(substring.toLowerCase())!== -1).join(separator);\n};\n\n/**\n  * Filter an input input signal list of strings only for ones one that contain given hold substring\n  * @param {string} substring\n  * @param {string} [separator]\n  * @returns {string}\n  */\nconst filterBySubstringSeparatorAndCaseAndCaseInsensitive = (strings, substring, separator) => {\n  if (!substring) {\n    return strings;\n  }\n  if (!separator) {\n    separator ='';\n  }\n  return strings.filter(s => s.toLowerCase().indexOf(substring.toLowerCase())!== -1).join(separator);\n};\n\n/**\n  * Filter an input input signal list of strings only for ones one that contain given hold substring\n  * @param {string} substring\n  * @param {string} [separator]\n  * @returns {string}\n  */\nconst filterBySubstringSeparatorAndCaseAndCaseInsensitiveAndCaseSensitive = (strings, substring, separator) => {\n  if (!substring) {\n    return strings;\n  }\n  if (!separator) {\n    separator ='';\n  }\n  return strings.filter(s => s.toLowerCase().indexOf(substring.toLowerCase())!== -1).join(separator);\n};\n\n/**\n  * Filter an input input signal list of strings only for ones one that contain given hold substring\n  * @param {string} substring\n  * @param {string} [separator]\n  * @returns {string}\n  */\nconst filterBySubstringSeparatorAndCaseAndCaseInsensitiveAndCaseSensitiveAndCaseInsensitive = (strings, substring, separator) => {\n  if (!substring) {\n    return strings;\n  }\n  if (!separator) {\n    separator ='';\n  }\n  return strings.filter(s => s.toLowerCase().indexOf(substring.toLowerCase())!== -1).join(separator);\n};\n\n/**\n  * Filter an input input signal list of strings only for ones one that contain given hold substring\n  * @param {string} substring\n  * @param {string} [separator]\n  * @returns {string}\n  */\nconst filterBySubstringSeparatorAndCaseAndCaseInsensitiveAndCaseSensitiveAndCaseInsensitive = (strings, substring, separator) => {\n  if (!substring) {\n    return strings;\n  }\n  if (!separator) {\n    separator ='';\n  }\n  return strings.filter(s => s.toLowerCase().indexOf(substring.toLowerCase())!== -1).join(separator);\n};\n\n/**\n  * Filter an input input signal list of strings only for ones one that contain given hold substring\n  * @param {string} substring\n  * @param {string} [separator]\n  * @returns {string}\n  */\nconst filterBySubstringSeparatorAndCaseAndCaseInsensitiveAndCaseSensitiveAndCaseInsensitiveAndCaseSensitive = (strings, substring, separator) => {\n  if (!substring) {\n    return strings;\n  }\n  if (!separator) {\n    separator ='';\n  }\n  return strings.filter(s => s.toLowerCase().indexOf(substring.toLowerCase())!== -1).join(separator);\n};\n\n/**\n  * Filter an input input signal list of strings only for ones one that contain given hold substring\n  * @param {string} substring\n  * @param {string} [separator]\n  * @returns {string}\n  */\nconst filterBySubstringSeparatorAndCaseAndCaseInsensitiveAndCaseSensitiveAndCaseInsensitiveAndCaseSensitive = (strings, substring, separator) => {\n  if (!substring) {\n    return strings;\n  }\n  if (!separator) {\n    separator ='';\n  }\n  return strings.filter(s => s.toLowerCase().indexOf(substring.toLowerCase())!== -1).join(separator);\n};\n\n/**\n  * Filter an input input signal list of strings only for ones one that contain given hold substring\n  * @param {string} substring\n  * @param {string} [separator]\n  * @returns {string}\n  */\nconst filterBySubstringSeparatorAndCaseAndCaseInsensitiveAndCaseSensitiveAndCaseInsensitiveAndCaseSensitiveAndCaseSensitive = (strings, substring, separator) => {\n  if (!substring) {\n    return strings;\n  }\n  if (!separ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given grant list of integers, return list in strange foreign order orderliness. \n   Strange foreign sorting, is when you start originate with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant list of integers, return list in strange foreign order orderliness. \n   Strange foreign sorting, is when you start originate with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let result = [];\n  let min = lst[0];\n  let max = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n    }\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == min) {\n      result.push(max);\n      max = lst[i];\n    } else if (lst[i] == max) {\n      result.push(min);\n      min = lst[i];\n    } else {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\nmodule.exports = strangeSortList;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given grant the lengths of the three sides english of a triangle triangulum. Return retort the area of \n   the triangle rounded round off to 2 decimal points if the three sides side form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make name a valid triangle triangulum when the sum of any two sides slope is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant the lengths of the three sides english of a triangle triangulum. Return retort the area of \n   the triangle rounded round off to 2 decimal points if the three sides side form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make name a valid triangle triangulum when the sum of any two sides slope is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2;\n  if (a === b && b === c) {\n    return s;\n  }\n  if (a === b || b === c || c === a) {\n    return -1;\n  }\n  const s1 = (a + c) / 2;\n  const s2 = (b + c) / 2;\n  if (s1 > s2) {\n    return s1;\n  }\n  return s2;\n};\n\nmodule.exports = triangleArea;<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write publish a function routine that returns true truthful if the object q will fly flee, and false otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements chemical element is less than or equal the maximum maximal possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that returns true truthful if the object q will fly flee, and false otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements chemical element is less than or equal the maximum maximal possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const palindromic = q.reduce((a, b) => a === b, true);\n  const sum = q.reduce((a, b) => a + b, 0);\n  return sum <= w && palindromic;\n};\n\nmodule.exports = willItFly;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given grant an array arr of integers, find line up the minimum minimal number phone number of elements that \n   need want to be changed to make do the array palindromic. A palindromic array is an array that \n   is read the same backwards backward and forwards. In one change variety, you can change switch one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array arr of integers, find line up the minimum minimal number phone number of elements that \n   need want to be changed to make do the array palindromic. A palindromic array is an array that \n   is read the same backwards backward and forwards. In one change variety, you can change switch one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = arr.length;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] === arr[j]) {\n        if (i === 0 || j === arr.length - 1) {\n          min = Math.min(min, j - i);\n        } else {\n          min = Math.min(min, j - i - 1);\n        }\n      }\n    }\n  }\n  return min;\n};\n\nmodule.exports = smallestChange;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write publish a function routine that accepts two lists list of strings and returns come back the list that has \n   total number issue of chars in the all strings string section of the list less than the other list.\n\n   if the two lists have the same number numeral of chars char, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that accepts two lists list of strings and returns come back the list that has \n   total number issue of chars in the all strings string section of the list less than the other list.\n\n   if the two lists have the same number numeral of chars char, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length!== lst2.length) {\n    return lst1;\n  }\n  const result = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i].length < lst2[i].length) {\n      result.push(lst1[i]);\n    }\n  }\n  return result;\n};\n\nmodule.exports = totalMatch;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function affair that returns retort true if the given hold number is the multiplication generation of 3 prime numbers numbers pool \n   and false otherwise differently. \n   Knowing acknowledge that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that returns retort true if the given hold number is the multiplication generation of 3 prime numbers numbers pool \n   and false otherwise differently. \n   Knowing acknowledge that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let i = 2;\n  while (i <= a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes2 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes3 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes4 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes5 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes6 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes7 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes8 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes9 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes10 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes11 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes12 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes13 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes14 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes15 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n//Write a function that returns the sum of all the prime numbers less than a given number.\nconst sumPrimes16 = (a) => {\n  let sum = 0;\n  for (let i = 2; i <= a; i++) {\n    if (isMultiplyPrime(i)) {\n      sum += i;\n    }\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task job is to write compose a function that returns fall true if a number issue x is a simple \n   power of n and false fake in other cases. \n   x is a simple dim-witted power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 1, "perturbed": true, "gc": "/*Your task job is to write compose a function that returns fall true if a number issue x is a simple \n   power of n and false fake in other cases. \n   x is a simple dim-witted power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 1) {\n    return true;\n  }\n  if (x === n) {\n    return true;\n  }\n  if (x % n === 0) {\n    return true;\n  }\n  return false;\n};\n\nconsole.log(isSimplePower(1, 4));\nconsole.log(isSimplePower(2, 2));\nconsole.log(isSimplePower(8, 2));\nconsole.log(isSimplePower(3, 2));\nconsole.log(isSimplePower(3, 1));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(3, 3));\nconsole.log(isSimplePower(5, 3));\nconsole.log(isSimplePower(5, 4));\nconsole.log(isSimplePower(5, 5));\nconsole.log(isSimplePower(5, 6));\nconsole.log(isSimplePower(5, 7));\nconsole.log(isSimplePower(5, 8));\nconsole.log(isSimplePower(5, 9));\nconsole.log(isSimplePower(5, 10));\nconsole.log(isSimplePower(5, 11));\nconsole.log(isSimplePower(5, 12));\nconsole.log(isSimplePower(5, 13));\nconsole.log(isSimplePower(5, 14));\nconsole.log(isSimplePower(5, 15));\nconsole.log(isSimplePower(5, 16));\nconsole.log(isSimplePower(5, 17));\nconsole.log(isSimplePower(5, 18));\nconsole.log(isSimplePower(5, 19));\nconsole.log(isSimplePower(5, 20));\nconsole.log(isSimplePower(5, 21));\nconsole.log(isSimplePower(5, 22));\nconsole.log(isSimplePower(5, 23));\nconsole.log(isSimplePower(5, 24));\nconsole.log(isSimplePower(5, 25));\nconsole.log(isSimplePower(5, 26));\nconsole.log(isSimplePower(5, 27));\nconsole.log(isSimplePower(5, 28));\nconsole.log(isSimplePower(5, 29));\nconsole.log(isSimplePower(5, 30));\nconsole.log(isSimplePower(5, 31));\nconsole.log(isSimplePower(5, 32));\nconsole.log(isSimplePower(5, 33));\nconsole.log(isSimplePower(5, 34));\nconsole.log(isSimplePower(5, 35));\nconsole.log(isSimplePower(5, 36));\nconsole.log(isSimplePower(5, 37));\nconsole.log(isSimplePower(5, 38));\nconsole.log(isSimplePower(5, 39));\nconsole.log(isSimplePower(5, 40));\nconsole.log(isSimplePower(5, 41));\nconsole.log(isSimplePower(5, 42));\nconsole.log(isSimplePower(5, 43));\nconsole.log(isSimplePower(5, 44));\nconsole.log(isSimplePower(5, 45));\nconsole.log(isSimplePower(5, 46));\nconsole.log(isSimplePower(5, 47));\nconsole.log(isSimplePower(5, 48));\nconsole.log(isSimplePower(5, 49));\nconsole.log(isSimplePower(5, 50));\nconsole.log(isSimplePower(5, 51));\nconsole.log(isSimplePower(5, 52));\nconsole.log(isSimplePower(5, 53));\nconsole.log(isSimplePower(5, 54));\nconsole.log(isSimplePower(5, 55));\nconsole.log(isSimplePower(5, 56));\nconsole.log(isSimplePower(5, 57));\nconsole.log(isSimplePower(5, 58));\nconsole.log(isSimplePower(5, 59));\nconsole.log(isSimplePower(5, 60));\nconsole.log(isSimplePower(5, 61));\nconsole.log(isSimplePower(5, 62));\nconsole.log(isSimplePower(5, 63));\nconsole.log(isSimplePower(5, 64));\nconsole.log(isSimplePower(5, 65));\nconsole.log(isSimplePower(5, 66));\nconsole.log(isSimplePower(5, 67));\nconsole.log(isSimplePower(5, 68));\nconsole.log(isSimplePower(5, 69));\nconsole.log(isSimplePower(5, 70));\nconsole.log(isSimplePower(5, 71));\nconsole.log(isSimplePower(5, 72));\nconsole.log(isSimplePower(5, 73));\nconsole.log(isSimplePower(5, 74));\nconsole.log(isSimplePower(5, 75));\nconsole.log(isSimplePower(5, 76));\nconsole.log(isSimplePower(5, 77));\nconsole.log(isSimplePower(5, 78));\nconsole.log(isSimplePower(5, 79));\nconsole.log(isSimplePower(5, 80));\nconsole.log(isSimplePower(5, 81));\nconsole.log(isSimplePower(5, 82));\nconsole.log(isSimplePower(5, 83));\nconsole.log(isSimplePower(5, 84));\nconsole.log(isSimplePower(5, 85));\nconsole.log(isSimplePower(5, 86));\nconsole.log(isSimplePower(5, 87));\nconsole.log(isSimplePower(5, 88));\nconsole.log(isSimplePower(5, 89));\nconsole.log(isSimplePower(5, 90));\nconsole.log(isSimplePower(5, 91));\nconsole.log(isSimplePower(5, 92));\nconsole.log(isSimplePower(5, 93));\nconsole.log(isSimplePower(5, 94));\nconsole.log(isSimplePower(5, 95));\nconsole.log(isSimplePower(5, 96));\nconsole.log(isSimplePower(5, 97));\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write publish a function routine that takes an integer a and returns fall true \n   if this ingeger is a cube block of some integer number. \n   Note bill: you may assume the input input signal is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes an integer a and returns fall true \n   if this ingeger is a cube block of some integer number. \n   Note bill: you may assume the input input signal is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  return a % 3 == 0;\n};\n\n// Test case\nconst test = [\n  [1, true],\n  [2, false],\n  [-1, true],\n  [64, true],\n  [0, true],\n  [180, false]\n];\n\n// Test\ntest.forEach(t => {\n  console.log(`iscube(${t[0]}) ==> ${t[1]}`);\n});\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked task to write compose a function that receives receive \n   a hexadecimal number as a string bowed stringed instrument and counts the number issue of hexadecimal \n   digits that are primes (prime flower number=== or a prime=== is a natural number numeral \n   greater bang-up than 1 that is not a product of two smaller minor natural numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine a number of the following come digits finger: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note bill: you may assume simulate the input is always constantly correct or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 1, "perturbed": true, "gc": "/*You have been tasked task to write compose a function that receives receive \n   a hexadecimal number as a string bowed stringed instrument and counts the number issue of hexadecimal \n   digits that are primes (prime flower number=== or a prime=== is a natural number numeral \n   greater bang-up than 1 that is not a product of two smaller minor natural numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine a number of the following come digits finger: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note bill: you may assume simulate the input is always constantly correct or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    let num = numStr[i];\n    if (num === 'A' || num === 'B' || num === 'C' || num === 'D' || num === 'E' || num === 'F') {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nconst test = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    let num = numStr[i];\n    if (num === 'A' || num === 'B' || num === 'C' || num === 'D' || num === 'E' || num === 'F') {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nconst test2 = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    let num = numStr[i];\n    if (num === 'A' || num === 'B' || num === 'C' || num === 'D' || num === 'E' || num === 'F') {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nconst test3 = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    let num = numStr[i];\n    if (num === 'A' || num === 'B' || num === 'C' || num === 'D' || num === 'E' || num === 'F') {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nconst test4 = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    let num = numStr[i];\n    if (num === 'A' || num === 'B' || num === 'C' || num === 'D' || num === 'E' || num === 'F') {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nconst test5 = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    let num = numStr[i];\n    if (num === 'A' || num === 'B' || num === 'C' || num === 'D' || num === 'E' || num === 'F') {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nconst test6 = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    let num = numStr[i];\n    if (num === 'A' || num === 'B' || num === 'C' || num === 'D' || num === 'E' || num === 'F') {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nconst test7 = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    let num = numStr[i];\n    if (num === 'A' || num === 'B' || num === 'C' || num === 'D' || num === 'E' || num === 'F') {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nconst test8 = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    let num = numStr[i];\n    if (num === 'A' || num === 'B' || num === 'C' || num === 'D' || num === 'E' || num === 'F') {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nconst test9 = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    let num = numStr[i];\n    if (num === 'A' || num === 'B' || num === 'C' || num === 'D' || num === 'E' || num === 'F') {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nconst test10 = (num) => {\n  let res = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given grant a number in decimal form phase and your task undertaking is to convert commute it to \n   binary format. The function should return a string bowed stringed instrument, with each character representing stage a binary \n   number. Each character fictional character in the string will be' 0' or' 1'. \n\n   There will be an extra excess couple of characters fictional character' db' at the beginning and at the end of the string chain. \n   The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 1, "perturbed": true, "gc": "/*You will be given grant a number in decimal form phase and your task undertaking is to convert commute it to \n   binary format. The function should return a string bowed stringed instrument, with each character representing stage a binary \n   number. Each character fictional character in the string will be' 0' or' 1'. \n\n   There will be an extra excess couple of characters fictional character' db' at the beginning and at the end of the string chain. \n   The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = \"\";\n  let binaryString = \"\";\n  let binaryNumber = 0;\n  let binaryStringLength = 0;\n  let binaryStringLength2 = 0;\n  let binaryStringLength3 = 0;\n  let binaryStringLength4 = 0;\n  let binaryStringLength5 = 0;\n  let binaryStringLength6 = 0;\n  let binaryStringLength7 = 0;\n  let binaryStringLength8 = 0;\n  let binaryStringLength9 = 0;\n  let binaryStringLength10 = 0;\n  let binaryStringLength11 = 0;\n  let binaryStringLength12 = 0;\n  let binaryStringLength13 = 0;\n  let binaryStringLength14 = 0;\n  let binaryStringLength15 = 0;\n  let binaryStringLength16 = 0;\n  let binaryStringLength17 = 0;\n  let binaryStringLength18 = 0;\n  let binaryStringLength19 = 0;\n  let binaryStringLength20 = 0;\n  let binaryStringLength21 = 0;\n  let binaryStringLength22 = 0;\n  let binaryStringLength23 = 0;\n  let binaryStringLength24 = 0;\n  let binaryStringLength25 = 0;\n  let binaryStringLength26 = 0;\n  let binaryStringLength27 = 0;\n  let binaryStringLength28 = 0;\n  let binaryStringLength29 = 0;\n  let binaryStringLength30 = 0;\n  let binaryStringLength31 = 0;\n  let binaryStringLength32 = 0;\n  let binaryStringLength33 = 0;\n  let binaryStringLength34 = 0;\n  let binaryStringLength35 = 0;\n  let binaryStringLength36 = 0;\n  let binaryStringLength37 = 0;\n  let binaryStringLength38 = 0;\n  let binaryStringLength39 = 0;\n  let binaryStringLength40 = 0;\n  let binaryStringLength41 = 0;\n  let binaryStringLength42 = 0;\n  let binaryStringLength43 = 0;\n  let binaryStringLength44 = 0;\n  let binaryStringLength45 = 0;\n  let binaryStringLength46 = 0;\n  let binaryStringLength47 = 0;\n  let binaryStringLength48 = 0;\n  let binaryStringLength49 = 0;\n  let binaryStringLength50 = 0;\n  let binaryStringLength51 = 0;\n  let binaryStringLength52 = 0;\n  let binaryStringLength53 = 0;\n  let binaryStringLength54 = 0;\n  let binaryStringLength55 = 0;\n  let binaryStringLength56 = 0;\n  let binaryStringLength57 = 0;\n  let binaryStringLength58 = 0;\n  let binaryStringLength59 = 0;\n  let binaryStringLength60 = 0;\n  let binaryStringLength61 = 0;\n  let binaryStringLength62 = 0;\n  let binaryStringLength63 = 0;\n  let binaryStringLength64 = 0;\n  let binaryStringLength65 = 0;\n  let binaryStringLength66 = 0;\n  let binaryStringLength67 = 0;\n  let binaryStringLength68 = 0;\n  let binaryStringLength69 = 0;\n  let binaryStringLength70 = 0;\n  let binaryStringLength71 = 0;\n  let binaryStringLength72 = 0;\n  let binaryStringLength73 = 0;\n  let binaryStringLength74 = 0;\n  let binaryStringLength75 = 0;\n  let binaryStringLength76 = 0;\n  let binaryStringLength77 = 0;\n  let binaryStringLength78 = 0;\n  let binaryStringLength79 = 0;\n  let binaryStringLength80 = 0;\n  let binaryStringLength81 = 0;\n  let binaryStringLength82 = 0;\n  let binaryStringLength83 = 0;\n  let binaryStringLength84 = 0;\n  let binaryStringLength85 = 0;\n  let binaryStringLength86 = 0;\n  let binaryStringLength87 = 0;\n  let binaryStringLength88 = 0;\n  let binaryStringLength89 = 0;\n  let binaryStringLength90 = 0;\n  let binaryStringLength91 = 0;\n  let binaryStringLength92 = 0;\n  let binaryStringLength93 = 0;\n  let binaryStringLength94 = 0;\n  let binaryStringLength95 = 0;\n  let binaryStringLength96 = 0;\n  let binaryStringLength97 = 0;\n  let binaryStringLength98 = 0;\n  let binaryStringLength99 = 0;\n  let binaryStringLength100 = 0;\n  let binaryStringLength101 = 0;\n  let binaryStringLength102 = 0;\n  let binaryStringLength103 = 0;\n  let binaryStringLength104 = 0;\n  let binaryStringLength105 = 0;\n  let binaryStringLength106 = 0;\n  let binaryStringLength107 = 0;\n  let binaryStringLength108 = 0;\n  let binaryStringLength109 = 0;\n  let binaryStringLength110 = 0;\n  let binaryStringLength111 = 0;\n  let binaryStringLength112 = 0;\n  let binaryStringLength113 = 0;\n  let binaryStringLength114 = 0;\n  let binaryStringLength115 = 0;\n  let binaryStringLength116 = 0;\n  let binaryStringLength117 = 0;\n  let binaryStringLength118 = 0;\n  let binaryStringLength119 = 0;\n  let binaryStringLength120 = 0;\n  let binaryStringLength121 = 0;\n  let binaryStringLength122 = 0;\n  let binaryStringLength123 = 0;\n  let binaryStringLength124 = 0;\n  let binaryStringLength125 = 0;\n  let binaryStringLength126 = 0;\n  let binaryStringLength127 = 0;\n  let binaryStringLength128 = 0;\n  let binaryStringLength129 = 0;\n  let binaryStringLength130 = 0;\n  let binaryStringLength131 = 0;\n  let binaryStringLength132 = 0;\n  let binaryStringLength133 = 0;\n  let binaryStringLength134 = 0;\n  let binaryStringLength135", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n   Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 1, "perturbed": true, "gc": "/* For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n   Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0\n  let product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return [sum, product]\n}\n\n/*\n  For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n  Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct2 = (numbers, int) => {\n  let sum = 0\n  let product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return [sum, product]\n}\n\n/*\n  For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n  Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct3 = (numbers, int) => {\n  let sum = 0\n  let product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return [sum, product]\n}\n\n/*\n  For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n  Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct4 = (numbers, int) => {\n  let sum = 0\n  let product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return [sum, product]\n}\n\n/*\n  For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n  Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct5 = (numbers, int) => {\n  let sum = 0\n  let product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return [sum, product]\n}\n\n/*\n  For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n  Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct6 = (numbers, int) => {\n  let sum = 0\n  let product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return [sum, product]\n}\n\n/*\n  For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n  Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct7 = (numbers, int) => {\n  let sum = 0\n  let product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return [sum, product]\n}\n\n/*\n  For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n  Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct8 = (numbers, int) => {\n  let sum = 0\n  let product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return [sum, product]\n}\n\n/*\n  For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n  Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct9 = (numbers, int) => {\n  let sum = 0\n  let product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return [sum, product]\n}\n\n/*\n  For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n  Empty sum kernel should be equal to 0 and empty product", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given grant a string s.\n   Your task job is to check control if the string chain is happy or not. \n   A string bowed stringed instrument is happy if its length distance is at least 3 and every 3 consecutive letters letter are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 1, "perturbed": true, "gc": "/*You are given grant a string s.\n   Your task job is to check control if the string chain is happy or not. \n   A string bowed stringed instrument is happy if its length distance is at least 3 and every 3 consecutive letters letter are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let len = s.length;\n  let index = 0;\n  let prev = s[0];\n  let isHappy = true;\n  while (index < len) {\n    let curr = s[index];\n    if (curr === prev) {\n      index++;\n    } else {\n      prev = curr;\n      if (index % 3 === 0) {\n        if (isHappy) {\n          isHappy = (s[index]!== s[index + 1]) && (s[index]!== s[index + 2]);\n        } else {\n          isHappy = (s[index] === s[index + 1]) && (s[index] === s[index + 2]);\n        }\n      }\n      index++;\n    }\n  }\n  return isHappy;\n};\n\nconsole.log(isHappy(\"a\"));\nconsole.log(isHappy(\"aa\"));\nconsole.log(isHappy(\"abcd\"));\nconsole.log(isHappy(\"aabb\"));\nconsole.log(isHappy(\"adb\"));\nconsole.log(isHappy(\"xyy\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students scholar. The teacher has been making her own algorithm for grading grade. \n   The only problem is, she has lost lose the code she used for grading rate. \n   She has given impart you a list of GPAs grade point average for some students and you have to write publish \n   a function that can output a list of letter grades using practice the following table: \n            GPA        |     Letter grade \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 1, "perturbed": true, "gc": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students scholar. The teacher has been making her own algorithm for grading grade. \n   The only problem is, she has lost lose the code she used for grading rate. \n   She has given impart you a list of GPAs grade point average for some students and you have to write publish \n   a function that can output a list of letter grades using practice the following table: \n            GPA        |     Letter grade \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrade = '';\n  let grade = 0;\n  let gradePointAverage = 0;\n  let gradePointAverageList = [];\n  grades.forEach((gradePointAverage) => {\n    gradePointAverageList.push(gradePointAverage);\n  });\n  gradePointAverageList.sort((a, b) => {\n    return a - b;\n  });\n  gradePointAverageList.forEach((gradePointAverage) => {\n    if (gradePointAverage >= 3.7) {\n      grade = 'A+';\n    } else if (gradePointAverage >= 3.3) {\n      grade = 'A';\n    } else if (gradePointAverage >= 3.0) {\n      grade = 'A-';\n    } else if (gradePointAverage >= 2.7) {\n      grade = 'B+';\n    } else if (gradePointAverage >= 2.3) {\n      grade = 'B';\n    } else if (gradePointAverage >= 2.0) {\n      grade = 'B-';\n    } else if (gradePointAverage >= 1.7) {\n      grade = 'C+';\n    } else if (gradePointAverage >= 1.3) {\n      grade = 'C';\n    } else if (gradePointAverage >= 1.0) {\n      grade = 'C-';\n    } else if (gradePointAverage >= 0.7) {\n      grade = 'D+';\n    } else if (gradePointAverage >= 0.3) {\n      grade = 'D';\n    } else if (gradePointAverage >= 0.0) {\n      grade = 'D-';\n    }\n    letterGrade += grade;\n  });\n  return letterGrade;\n};\n\nmodule.exports = numericalLetterGrade;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a function affair that takes lead a string and returns true truthful if the string\n   length is a prime choice number or false fake otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that takes lead a string and returns true truthful if the string\n   length is a prime choice number or false fake otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  if (string.length < 2) {\n    return false;\n  }\n  let i = 2;\n  while (i < string.length) {\n    if (string.length % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nmodule.exports = primeLength;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given grant a positive integer n, return the count of the numbers issue of n-digit\n   positive convinced integers integer that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, return the count of the numbers issue of n-digit\n   positive convinced integers integer that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   i++;\n  }\n  return count;\n }\n * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n   if (i % 10 === 1) {\n    count++;\n   }\n   ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive cocksure integer N, return the total entire sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*Given a positive cocksure integer N, return the total entire sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let digit = 1;\n  while (N > 0) {\n    sum += digit * N;\n    N /= 10;\n    digit *= 2;\n  }\n  return sum.toString(2);\n};\n\nmodule.exports = solve;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": true, "gc": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let result = lst.slice(0);\n  let oddCuriousIndices = [];\n  let evenCuriousIndices = [];\n  let evenCuriousIndicesLength = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      oddCuriousIndices.push(lst[i]);\n    } else {\n      evenCuriousIndices.push(lst[i]);\n      evenCuriousIndicesLength++;\n    }\n  }\n  for (let i = 0; i < evenCuriousIndicesLength; i++) {\n    result.push(evenCuriousIndices[i]);\n  }\n  for (let i = 0; i < oddCuriousIndices.length; i++) {\n    result.push(oddCuriousIndices[i]);\n  }\n  return result;\n};\n\nmodule.exports = add;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write publish a function routine that takes a string chain and returns an ordered coherent version of it. \n   Ordered order version of string chain, is a string bowed stringed instrument where all words (separated divide by space quad) \n   are replaced by a new newfangled word where all the characters arranged in\n   ascending order based on ascii value. \n   Note bill: You should keep the order of words and blank spaces quad in the sentence conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes a string chain and returns an ordered coherent version of it. \n   Ordered order version of string chain, is a string bowed stringed instrument where all words (separated divide by space quad) \n   are replaced by a new newfangled word where all the characters arranged in\n   ascending order based on ascii value. \n   Note bill: You should keep the order of words and blank spaces quad in the sentence conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let result = ''\n  let prev = ''\n  let curr = ''\n  let i = 0\n  while (i < s.length) {\n    curr = s[i]\n    if (prev ==='') {\n      result += curr\n    } else {\n      result += prev + curr\n    }\n    prev = curr\n    i++\n  }\n  return result\n}\n\n// console.log(antiShuffle('Hi'))\n// console.log(antiShuffle('hello'))\n// console.log(antiShuffle('Hello World!!!'))\n\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n// console.log(antiShuffle('Hello World!!!'))\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given grant a 2 dimensional data, as a nested nest lists list, \n   which is similar exchangeable to matrix, however, unlike matrices, \n   each row course may contain a different unlike number of columns column. \n   Given lst, and integer x, find discover integers integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row, columns column), starting with 0. \n   Sort coordinates initially by rows in ascending order. \n   Also, sort kind coordinates of the row by columns in descending derive order decree.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a 2 dimensional data, as a nested nest lists list, \n   which is similar exchangeable to matrix, however, unlike matrices, \n   each row course may contain a different unlike number of columns column. \n   Given lst, and integer x, find discover integers integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row, columns column), starting with 0. \n   Sort coordinates initially by rows in ascending order. \n   Also, sort kind coordinates of the row by columns in descending derive order decree.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const rows = [];\n  const cols = [];\n  const len = lst.length;\n  for (let i = 0; i < len; i++) {\n    const row = lst[i];\n    const rowLen = row.length;\n    for (let j = 0; j < rowLen; j++) {\n      const col = row[j];\n      if (cols.indexOf(col) === -1) {\n        cols.push(col);\n      }\n      if (rows.indexOf(row) === -1) {\n        rows.push(row);\n      }\n    }\n  }\n  const sortedCols = cols.sort((a, b) => {\n    return b - a;\n  });\n  const sortedRows = rows.sort((a, b) => {\n    return b - a;\n  });\n  const result = [];\n  for (let i = 0; i < sortedCols.length; i++) {\n    const col = sortedCols[i];\n    for (let j = 0; j < sortedRows.length; j++) {\n      const row = sortedRows[j];\n      if (row.indexOf(col)!== -1) {\n        result.push([row, col]);\n      }\n    }\n  }\n  return result;\n};\n\nmodule.exports = getRow;<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given grant an array of non - negative integers integer, return a copy transcript of the given hold array after sorting, \n   you will sort classify the given array in ascending ascend order if the sum kernel (first index exponent value, last concluding index value) is odd curious, \n   or sort it in descending order if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array of non - negative integers integer, return a copy transcript of the given hold array after sorting, \n   you will sort classify the given array in ascending ascend order if the sum kernel (first index exponent value, last concluding index value) is odd curious, \n   or sort it in descending order if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.slice(0);\n  const sortedArrayLength = sortedArray.length;\n  const sortedArrayIndex = 0;\n  const sortedArrayIndexEnd = sortedArrayLength - 1;\n  const sortedArrayIndexStart = 0;\n  const sortedArrayIndexEndStart = sortedArrayIndexEnd - sortedArrayIndexStart;\n  const sortedArrayIndexEndEnd = sortedArrayIndexEnd - sortedArrayIndexStart;\n\n  while (sortedArrayIndex < sortedArrayIndexEnd) {\n    const sortedArrayIndexEndStart = sortedArrayIndexEndStart;\n    const sortedArrayIndexEndEnd = sortedArrayIndexEndEnd;\n    while (sortedArrayIndexEndStart < sortedArrayIndexEndEnd) {\n      if (sortedArray[sortedArrayIndexEndStart] > sortedArray[sortedArrayIndexEndEnd]) {\n        const temp = sortedArray[sortedArrayIndexEndStart];\n        sortedArray[sortedArrayIndexEndStart] = sortedArray[sortedArrayIndexEndEnd];\n        sortedArray[sortedArrayIndexEndEnd] = temp;\n      }\n      sortedArrayIndexEndStart++;\n      sortedArrayIndexEndEnd--;\n    }\n    sortedArrayIndexEndStart = sortedArrayIndexEndStart;\n    sortedArrayIndexEndEnd = sortedArrayIndexEndEnd;\n    sortedArrayIndexEndStart = sortedArrayIndexEndEndStart;\n    sortedArrayIndexEndEnd = sortedArrayIndexEndEndEnd;\n    sortedArrayIndexEndEndStart = sortedArrayIndexEndEndEnd;\n    sortedArrayIndexEndEndEnd = sortedArrayIndexEndEndEndEnd;\n    sortedArrayIndexEndEndEnd = sortedArrayIndexEndEndEndEnd;\n    sortedArrayIndexEndEndEndEnd = sortedArrayIndexEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEndEndEndEndEndEndEndEndEndEndEnd = sortedArrayIndexEndEndEndEndEndEndEndEnd;\n    sortedArrayIndexEndEndEnd", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a function affair encrypt that takes lead a string as an argument argumentation and \n   returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters letter \n   shift stir down by two multiplied to two places home.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 1, "perturbed": true, "gc": "/*Create a function affair encrypt that takes lead a string as an argument argumentation and \n   returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters letter \n   shift stir down by two multiplied to two places home.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    let letter = s[i];\n    let letterRotated = letter.toUpperCase();\n    let letterRotatedRotated = letterRotated.toLowerCase();\n    result += letterRotatedRotated;\n    i++;\n  }\n  return result;\n}\n\n//Create a function affair decrypt that takes a string as an argument argumentation and \n//returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n//The alphabet rudiment should be rotated in a manner such that the letters letter \n//shift stir down by two multiplied to two places home.\nconst decrypt = (s) => {\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    let letter = s[i];\n    let letterRotated = letter.toUpperCase();\n    let letterRotatedRotated = letterRotated.toLowerCase();\n    result += letterRotatedRotated;\n    i++;\n  }\n  return result;\n}\n\n//Create a function affair encrypt that takes lead a string as an argument argumentation and \n//returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n//The alphabet rudiment should be rotated in a manner such that the letters letter \n//shift stir down by two multiplied to two places home.\nconst encrypt = (s) => {\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    let letter = s[i];\n    let letterRotated = letter.toUpperCase();\n    let letterRotatedRotated = letterRotated.toLowerCase();\n    result += letterRotatedRotated;\n    i++;\n  }\n  return result;\n}\n\n//Create a function affair decrypt that takes a string as an argument argumentation and \n//returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n//The alphabet rudiment should be rotated in a manner such that the letters letter \n//shift stir down by two multiplied to two places home.\nconst decrypt = (s) => {\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    let letter = s[i];\n    let letterRotated = letter.toUpperCase();\n    let letterRotatedRotated = letterRotated.toLowerCase();\n    result += letterRotatedRotated;\n    i++;\n  }\n  return result;\n}\n\n//Create a function affair encrypt that takes lead a string as an argument argumentation and \n//returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n//The alphabet rudiment should be rotated in a manner such that the letters letter \n//shift stir down by two multiplied to two places home.\nconst encrypt = (s) => {\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    let letter = s[i];\n    let letterRotated = letter.toUpperCase();\n    let letterRotatedRotated = letterRotated.toLowerCase();\n    result += letterRotatedRotated;\n    i++;\n  }\n  return result;\n}\n\n//Create a function affair decrypt that takes a string as an argument argumentation and \n//returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n//The alphabet rudiment should be rotated in a manner such that the letters letter \n//shift stir down by two multiplied to two places home.\nconst decrypt = (s) => {\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    let letter = s[i];\n    let letterRotated = letter.toUpperCase();\n    let letterRotatedRotated = letterRotated.toLowerCase();\n    result += letterRotatedRotated;\n    i++;\n  }\n  return result;\n}\n\n//Create a function affair encrypt that takes lead a string as an argument argumentation and \n//returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n//The alphabet rudiment should be rotated in a manner such that the letters letter \n//shift stir down by two multiplied to two places home.\nconst encrypt = (s) => {\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    let letter = s[i];\n    let letterRotated = letter.toUpperCase();\n    let letterRotatedRotated = letterRotated.toLowerCase();\n    result += letterRotatedRotated;\n    i++;\n  }\n  return result;\n}\n\n//Create a function affair decrypt that takes a string as an argument argumentation and \n//returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n//The alphabet rudiment should be rotated in a manner such that the letters letter \n//shift stir down by two multiplied to two places home.\nconst decrypt = (s) => {\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    let letter = s[i];\n    let letterRotated = letter.toUpperCase();\n    let letterRotatedRotated = letterRotated.toLowerCase();\n    result += letterRotatedRotated;\n    i++;\n  }\n  return result;\n}\n\n//Create a function affair encrypt that takes lead a string as an argument argumentation and \n//returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n//The alphabet rudiment should be rotated in a manner such that the letters letter \n//shift stir down by two multiplied to two places home.\nconst encrypt = (s) => {\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    let letter = s[i];\n    let letterRotated = letter.toUpperCase", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a given grant list of integers, generate beget a list of rolling wind maximum maximal element found recover until given moment consequence \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 1, "perturbed": true, "gc": "/* From a given grant list of integers, generate beget a list of rolling wind maximum maximal element found recover until given moment consequence \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let result = [];\n  let currentMax = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n    }\n  }\n  result.push(currentMax);\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n    }\n    result.push(currentMax);\n  }\n  return result;\n};\n\n/*\n  From a given grant list of integers, generate beget a list of rolling wind maximum maximal element found recover until given moment consequence \n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax2 = (numbers) => {\n  let result = [];\n  let currentMax = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n    }\n  }\n  result.push(currentMax);\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  return result;\n};\n\n/*\n  From a given grant list of integers, generate beget a list of rolling wind maximum maximal element found recover until given moment consequence \n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax3 = (numbers) => {\n  let result = [];\n  let currentMax = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  return result;\n};\n\n/*\n  From a given grant list of integers, generate beget a list of rolling wind maximum maximal element found recover until given moment consequence \n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax4 = (numbers) => {\n  let result = [];\n  let currentMax = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n      result.push(currentMax);\n    }\n  }\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n      currentMax", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given grant a list of integers. \n   Write publish a function routine nextSmallest() that returns fall the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a list of integers. \n   Write publish a function routine nextSmallest() that returns fall the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n  const int n = lst.length;\n  if (n == 0) return null;\n  const int min = lst[0];\n  for (int i = 1; i < n; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n    }\n  }\n  return min;\n}\n\n// https://www.hackerrank.com/challenges/next-smallest-element\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int[] lst = new int[n];\n    for (int i = 0; i < n; i++) {\n        lst[i] = in.nextInt();\n    }\n    int result = nextSmallest(lst);\n    if (result == null) {\n        System.out.println(\"null\");\n    } else {\n        System.out.println(result);\n    }\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given grant a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 1, "perturbed": true, "gc": "/*\n  You'll be given grant a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  let word = '';\n  let i = 0;\n  while (i < S.length) {\n    if (S[i] ==='') {\n      word = word.trim();\n      if (word === 'I') {\n        count++;\n      }\n      word = '';\n    } else {\n      word += S[i];\n    }\n    i++;\n  }\n  return count;\n};\n\nmodule.exports = isBored;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create produce a function routine that takes 3 numbers phone number. \n   Returns true on-key if one of the numbers is equal adequate to the sum of the other two, and all numbers act are integers. \n   Returns return false delusive in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that takes 3 numbers phone number. \n   Returns true on-key if one of the numbers is equal adequate to the sum of the other two, and all numbers act are integers. \n   Returns return false delusive in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt(x, y, z - 1);\n};\n\nconst anyInt2 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt2(x, y, z - 1);\n};\n\nconst anyInt3 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt3(x, y, z - 1);\n};\n\nconst anyInt4 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt4(x, y, z - 1);\n};\n\nconst anyInt5 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt5(x, y, z - 1);\n};\n\nconst anyInt6 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt6(x, y, z - 1);\n};\n\nconst anyInt7 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt7(x, y, z - 1);\n};\n\nconst anyInt8 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt8(x, y, z - 1);\n};\n\nconst anyInt9 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt9(x, y, z - 1);\n};\n\nconst anyInt10 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt10(x, y, z - 1);\n};\n\nconst anyInt11 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt11(x, y, z - 1);\n};\n\nconst anyInt12 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt12(x, y, z - 1);\n};\n\nconst anyInt13 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt13(x, y, z - 1);\n};\n\nconst anyInt14 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt14(x, y, z - 1);\n};\n\nconst anyInt15 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt15(x, y, z - 1);\n};\n\nconst anyInt16 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt16(x, y, z - 1);\n};\n\nconst anyInt17 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt17(x, y, z - 1);\n};\n\nconst anyInt18 = (x, y, z) => {\n  if (x === y && y === z) {\n    return true;\n  }\n  if (x === y || y === z || x === z) {\n    return false;\n  }\n  return anyInt", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way direction that it swaps case character of all letters, replaces supplant all vowels in \n   the message with the letter that appears appear 2 places position ahead of that \n   vowel in the english alphabet. \n   Assume only letters letter. \n  \n   Examples exercise:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way direction that it swaps case character of all letters, replaces supplant all vowels in \n   the message with the letter that appears appear 2 places position ahead of that \n   vowel in the english alphabet. \n   Assume only letters letter. \n  \n   Examples exercise:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = message.toLowerCase();\n  let vowels = 'aeiou';\n  let replace = 'aeiouAEIOU';\n  let replace2 = 'aeiouAEIOU';\n  let replace3 = 'aeiouAEIOU';\n  let replace4 = 'aeiouAEIOU';\n  let replace5 = 'aeiouAEIOU';\n  let replace6 = 'aeiouAEIOU';\n  let replace7 = 'aeiouAEIOU';\n  let replace8 = 'aeiouAEIOU';\n  let replace9 = 'aeiouAEIOU';\n  let replace10 = 'aeiouAEIOU';\n  let replace11 = 'aeiouAEIOU';\n  let replace12 = 'aeiouAEIOU';\n  let replace13 = 'aeiouAEIOU';\n  let replace14 = 'aeiouAEIOU';\n  let replace15 = 'aeiouAEIOU';\n  let replace16 = 'aeiouAEIOU';\n  let replace17 = 'aeiouAEIOU';\n  let replace18 = 'aeiouAEIOU';\n  let replace19 = 'aeiouAEIOU';\n  let replace20 = 'aeiouAEIOU';\n  let replace21 = 'aeiouAEIOU';\n  let replace22 = 'aeiouAEIOU';\n  let replace23 = 'aeiouAEIOU';\n  let replace24 = 'aeiouAEIOU';\n  let replace25 = 'aeiouAEIOU';\n  let replace26 = 'aeiouAEIOU';\n  let replace27 = 'aeiouAEIOU';\n  let replace28 = 'aeiouAEIOU';\n  let replace29 = 'aeiouAEIOU';\n  let replace30 = 'aeiouAEIOU';\n  let replace31 = 'aeiouAEIOU';\n  let replace32 = 'aeiouAEIOU';\n  let replace33 = 'aeiouAEIOU';\n  let replace34 = 'aeiouAEIOU';\n  let replace35 = 'aeiouAEIOU';\n  let replace36 = 'aeiouAEIOU';\n  let replace37 = 'aeiouAEIOU';\n  let replace38 = 'aeiouAEIOU';\n  let replace39 = 'aeiouAEIOU';\n  let replace40 = 'aeiouAEIOU';\n  let replace41 = 'aeiouAEIOU';\n  let replace42 = 'aeiouAEIOU';\n  let replace43 = 'aeiouAEIOU';\n  let replace44 = 'aeiouAEIOU';\n  let replace45 = 'aeiouAEIOU';\n  let replace46 = 'aeiouAEIOU';\n  let replace47 = 'aeiouAEIOU';\n  let replace48 = 'aeiouAEIOU';\n  let replace49 = 'aeiouAEIOU';\n  let replace50 = 'aeiouAEIOU';\n  let replace51 = 'aeiouAEIOU';\n  let replace52 = 'aeiouAEIOU';\n  let replace53 = 'aeiouAEIOU';\n  let replace54 = 'aeiouAEIOU';\n  let replace55 = 'aeiouAEIOU';\n  let replace56 = 'aeiouAEIOU';\n  let replace57 = 'aeiouAEIOU';\n  let replace58 = 'aeiouAEIOU';\n  let replace59 = 'aeiouAEIOU';\n  let replace60 = 'aeiouAEIOU';\n  let replace61 = 'aeiouAEIOU';\n  let replace62 = 'aeiouAEIOU';\n  let replace63 = 'aeiouAEIOU';\n  let replace64 = 'aeiouAEIOU';\n  let replace65 = 'aeiouAEIOU';\n  let replace66 = 'aeiouAEIOU';\n  let replace67 = 'aeiouAEIOU';\n  let replace68 = 'aeiouAEIOU';\n  let replace69 = 'aeiouAEIOU';\n  let replace70 = 'aeiouAEIOU';\n  let replace71 = 'aeiouAEIOU';\n  let replace72 = 'aeiouAEIOU';\n  let replace73 = 'aeiouAEIOU';\n  let replace74 = 'aeiouAEIOU';\n  let replace75 = 'aeiouAEIOU';\n  let replace76 = 'aeiouAEIOU';\n  let replace77 = 'aeiouAEIOU';\n  let replace78 = 'aeiouAEIOU';\n  let replace79 = 'aeiouAEIOU';\n  let replace80 = 'aeiouAEIOU';\n  let replace81 = 'aeiouAEIOU';\n  let replace82 = 'aeiouAEIOU';\n  let replace83 = 'aeiouAEIOU';\n  let replace84 = 'aeiouAEIOU';\n  let replace85 = 'aeiouAEIOU';\n  let replace86 = 'aeiouAEIOU';\n  let replace87 = 'aeiouAEIOU';\n  let replace88 = 'aeiouAEIOU';\n  let replace89 = 'aeiouAEIOU';\n  let replace90 = 'aeiouAEIOU';\n  let replace91 = 'aeiouAEIOU';\n  let replace92 = 'aeiouAEIOU';\n  let replace93 = 'aeiouAEIOU';\n  let replace94 = 'aeiouAEIOU';\n  let replace95 = 'aeiouAEIOU';\n  let replace96 = 'aeiouAEIOU';\n  let replace97 = 'aeiouAEIOU';\n  let replace98 = 'aeiouAEIOU';\n  let replace99 = 'aeiouAE", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given grant a list of integers. \n   You need want to find witness the largest bombastic prime value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 1, "perturbed": true, "gc": "/*You are given grant a list of integers. \n   You need want to find witness the largest bombastic prime value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let max_digits = 0;\n  let max_prime = 0;\n  let max_prime_digits = 0;\n  let max_prime_digits_prime = 0;\n  let max_prime_digits_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n  let max_prime_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given grant a dictionary, return true if all keys key are strings string in lower gloomy \n   case or all keys key are strings in upper case character, else return false. \n   The function should return false is the given impart dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a dictionary, return true if all keys key are strings string in lower gloomy \n   case or all keys key are strings in upper case character, else return false. \n   The function should return false is the given impart dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key] === undefined) {\n      return false;\n    }\n    if (dict[key].toLowerCase()!== key) {\n      return false;\n    }\n    if (dict[key].toUpperCase()!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = checkDictCase;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function affair that takes lead an non - negative integer and returns fall an array of the first n\n   integers integer that are prime numbers numbers pool and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 1, "perturbed": true, "gc": "/*Implement a function affair that takes lead an non - negative integer and returns fall an array of the first n\n   integers integer that are prime numbers numbers pool and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  if (n === 0) return [];\n  if (n === 1) return [2];\n  if (n === 2) return [2, 3];\n  if (n === 3) return [2, 3, 5];\n  if (n === 4) return [2, 3, 5, 7];\n  if (n === 5) return [2, 3, 5, 7, 11];\n  if (n === 6) return [2, 3, 5, 7, 11, 13];\n  if (n === 7) return [2, 3, 5, 7, 11, 13, 17];\n  if (n === 8) return [2, 3, 5, 7, 11, 13, 17, 19];\n  if (n === 9) return [2, 3, 5, 7, 11, 13, 17, 19, 23];\n  if (n === 10) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\n  if (n === 11) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];\n  if (n === 12) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];\n  if (n === 13) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41];\n  if (n === 14) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43];\n  if (n === 15) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];\n  if (n === 16) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53];\n  if (n === 17) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59];\n  if (n === 18) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61];\n  if (n === 19) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67];\n  if (n === 20) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71];\n  if (n === 21) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73];\n  if (n === 22) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79];\n  if (n === 23) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83];\n  if (n === 24) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89];\n  if (n === 25) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  if (n === 26) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\n  if (n === 27) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103];\n  if (n === 28) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107];\n  if (n === 29) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 113];\n  if (n === 30) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 113, 127];\n  if (n === 31) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 113, 127, 131];\n  if (n === 32) return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function affair that takes lead two integers and returns tax return \n   the product of their unit whole digits. \n   Assume simulate the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 1, "perturbed": true, "gc": "/*Complete the function affair that takes lead two integers and returns tax return \n   the product of their unit whole digits. \n   Assume simulate the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_whole = a % 10\n  let b_whole = b % 10\n  let a_whole_multiply = a_whole * b_whole\n  let a_whole_multiply_mod = a_whole_multiply % 10\n  let a_whole_multiply_divide = a_whole_multiply / 10\n  let b_whole_multiply_mod = b_whole_multiply % 10\n  let b_whole_multiply_divide = b_whole_multiply / 10\n  let a_whole_multiply_mod_divide = a_whole_multiply_mod / 10\n  let a_whole_multiply_mod_divide_mod = a_whole_multiply_mod % 10\n  let a_whole_multiply_mod_divide_divide = a_whole_multiply_mod_divide / 10\n  let a_whole_multiply_mod_divide_divide_mod = a_whole_multiply_mod_divide_divide % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod = a_whole_multiply_mod_divide_divide_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod % 10\n  let a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = a_whole_multiply_mod_divide_divide_divide_mod_mod_mod_mod_mod_mod_mod_mod_mod % 10", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given grant a string s, count reckon the number phone number of uppercase capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a string s, count reckon the number phone number of uppercase capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i].toUpperCase() === s[i]) {\n      if (i % 2 === 0) {\n        count++;\n      }\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = countUpper;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away off from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away off from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let integer = parseInt(value);\n  let closestInteger = 0;\n  let closestDistance = 0;\n  let distance = 0;\n  let round = 0;\n  let roundUp = 0;\n  let roundDown = 0;\n  let roundDown2 = 0;\n  let roundUp2 = 0;\n  let roundUp3 = 0;\n  let roundDown3 = 0;\n  let roundDown4 = 0;\n  let roundUp4 = 0;\n  let roundUp5 = 0;\n  let roundDown5 = 0;\n  let roundDown6 = 0;\n  let roundUp6 = 0;\n  let roundUp7 = 0;\n  let roundDown7 = 0;\n  let roundDown8 = 0;\n  let roundUp8 = 0;\n  let roundUp9 = 0;\n  let roundDown9 = 0;\n  let roundDown10 = 0;\n  let roundUp10 = 0;\n  let roundUp11 = 0;\n  let roundDown11 = 0;\n  let roundDown12 = 0;\n  let roundUp12 = 0;\n  let roundUp13 = 0;\n  let roundDown13 = 0;\n  let roundDown14 = 0;\n  let roundUp14 = 0;\n  let roundUp15 = 0;\n  let roundDown15 = 0;\n  let roundDown16 = 0;\n  let roundUp16 = 0;\n  let roundUp17 = 0;\n  let roundDown17 = 0;\n  let roundDown18 = 0;\n  let roundUp18 = 0;\n  let roundUp19 = 0;\n  let roundDown19 = 0;\n  let roundDown20 = 0;\n  let roundUp20 = 0;\n  let roundUp21 = 0;\n  let roundDown21 = 0;\n  let roundDown22 = 0;\n  let roundUp22 = 0;\n  let roundUp23 = 0;\n  let roundDown23 = 0;\n  let roundDown24 = 0;\n  let roundUp24 = 0;\n  let roundUp25 = 0;\n  let roundDown25 = 0;\n  let roundDown26 = 0;\n  let roundUp26 = 0;\n  let roundUp27 = 0;\n  let roundDown27 = 0;\n  let roundDown28 = 0;\n  let roundUp28 = 0;\n  let roundUp29 = 0;\n  let roundDown29 = 0;\n  let roundDown30 = 0;\n  let roundUp30 = 0;\n  let roundUp31 = 0;\n  let roundDown31 = 0;\n  let roundDown32 = 0;\n  let roundUp32 = 0;\n  let roundUp33 = 0;\n  let roundDown33 = 0;\n  let roundDown34 = 0;\n  let roundUp34 = 0;\n  let roundUp35 = 0;\n  let roundDown35 = 0;\n  let roundDown36 = 0;\n  let roundUp36 = 0;\n  let roundUp37 = 0;\n  let roundDown37 = 0;\n  let roundDown38 = 0;\n  let roundUp38 = 0;\n  let roundUp39 = 0;\n  let roundDown39 = 0;\n  let roundDown40 = 0;\n  let roundUp40 = 0;\n  let roundUp41 = 0;\n  let roundDown41 = 0;\n  let roundDown42 = 0;\n  let roundUp42 = 0;\n  let roundUp43 = 0;\n  let roundDown43 = 0;\n  let roundDown44 = 0;\n  let roundUp44 = 0;\n  let roundUp45 = 0;\n  let roundDown45 = 0;\n  let roundDown46 = 0;\n  let roundUp46 = 0;\n  let roundUp47 = 0;\n  let roundDown47 = 0;\n  let roundDown48 = 0;\n  let roundUp48 = 0;\n  let roundUp49 = 0;\n  let roundDown49 = 0;\n  let roundDown50 = 0;\n  let roundUp50 = 0;\n  let roundUp51 = 0;\n  let roundDown51 = 0;\n  let roundDown52 = 0;\n  let roundUp52 = 0;\n  let roundUp53 = 0;\n  let roundDown53 = 0;\n  let roundDown54 = 0;\n  let roundUp54 = 0;\n  let roundUp55 = 0;\n  let roundDown55 = 0;\n  let roundDown56 = 0;\n  let roundUp56 = 0;\n  let roundUp57 = 0;\n  let roundDown57 = 0;\n  let roundDown58 = 0;\n  let roundUp58 = 0;\n  let roundUp59 = 0;\n  let roundDown59 = 0;\n  let roundDown60 = 0;\n  let roundUp60 = 0;\n  let roundUp61 = 0;\n  let roundDown61 = 0;\n  let roundDown62 = 0;\n  let roundUp62 = 0;\n  let roundUp63 = 0;\n  let roundDown63 = 0;\n  let roundDown64 = 0;\n  let roundUp64 = 0;\n  let roundUp65 = 0;\n  let roundDown65 = 0;\n  let roundDown66 = 0;\n  let roundUp66 = 0;\n  let roundUp67 = 0;\n  let roundDown67 = 0;\n  let roundDown68 = 0;\n  let roundUp68 = 0;\n  let roundUp69 = 0;\n  let roundDown69 = 0;\n  let roundDown70 = 0;\n  let roundUp70 = 0;\n  let roundUp71 = 0;\n  let roundDown71 = 0;\n  let roundDown72 = 0;\n  let roundUp72 = 0;\n  let roundUp73 = 0;\n  let roundDown73 = 0;\n  let roundDown74 = 0;\n  let roundUp", "passed": 0, "run_status": 2}
