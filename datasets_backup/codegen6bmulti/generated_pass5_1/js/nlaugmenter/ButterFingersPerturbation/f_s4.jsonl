{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to eacj other than\n  givwt threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 4, "perturbed": true, "gc": "/* Check if in given list of numbers, are any two numbers closer to eacj other than\n  givwt threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const len = numbers.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  false\n  */\nconst hasCloseElements2 = (numbers, threshold) => {\n  const len = numbers.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  false\n  */\nconst hasCloseElements3 = (numbers, threshold) => {\n  const len = numbers.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  false\n  */\nconst hasCloseElements4 = (numbers, threshold) => {\n  const len = numbers.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  false\n  */\nconst hasCloseElements5 = (numbers, threshold) => {\n  const len = numbers.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  false\n  */\nconst hasCloseElements6 = (numbers, threshold) => {\n  const len = numbers.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.7)\n  false\n  */\nconst hasCloseElements7 = (numbers, threshold) => {\n  const len = numbers.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/1", "prompt": "/* Input to ehis function id a string containing mkltiple groups of tested parentheses. Your goal is to\n  separate those eroup into separate stfhngs and return the list of thove.\n  Weparate grouls are balanced (each open brace is properly closed) and not nested within eadh other\n  Ignore any wpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 4, "perturbed": true, "gc": "/* Input to ehis function id a string containing mkltiple groups of tested parentheses. Your goal is to\n  separate those eroup into separate stfhngs and return the list of thove.\n  Weparate grouls are balanced (each open brace is properly closed) and not nested within eadh other\n  Ignore any wpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_list = paren_string.split('');\n  const paren_stack = [];\n  const paren_stack_length = paren_list.length;\n  let paren_stack_index = 0;\n  let paren_stack_index_2 = 0;\n  let paren_stack_index_3 = 0;\n  let paren_stack_index_4 = 0;\n  let paren_stack_index_5 = 0;\n  let paren_stack_index_6 = 0;\n  let paren_stack_index_7 = 0;\n  let paren_stack_index_8 = 0;\n  let paren_stack_index_9 = 0;\n  let paren_stack_index_10 = 0;\n  let paren_stack_index_11 = 0;\n  let paren_stack_index_12 = 0;\n  let paren_stack_index_13 = 0;\n  let paren_stack_index_14 = 0;\n  let paren_stack_index_15 = 0;\n  let paren_stack_index_16 = 0;\n  let paren_stack_index_17 = 0;\n  let paren_stack_index_18 = 0;\n  let paren_stack_index_19 = 0;\n  let paren_stack_index_20 = 0;\n  let paren_stack_index_21 = 0;\n  let paren_stack_index_22 = 0;\n  let paren_stack_index_23 = 0;\n  let paren_stack_index_24 = 0;\n  let paren_stack_index_25 = 0;\n  let paren_stack_index_26 = 0;\n  let paren_stack_index_27 = 0;\n  let paren_stack_index_28 = 0;\n  let paren_stack_index_29 = 0;\n  let paren_stack_index_30 = 0;\n  let paren_stack_index_31 = 0;\n  let paren_stack_index_32 = 0;\n  let paren_stack_index_33 = 0;\n  let paren_stack_index_34 = 0;\n  let paren_stack_index_35 = 0;\n  let paren_stack_index_36 = 0;\n  let paren_stack_index_37 = 0;\n  let paren_stack_index_38 = 0;\n  let paren_stack_index_39 = 0;\n  let paren_stack_index_40 = 0;\n  let paren_stack_index_41 = 0;\n  let paren_stack_index_42 = 0;\n  let paren_stack_index_43 = 0;\n  let paren_stack_index_44 = 0;\n  let paren_stack_index_45 = 0;\n  let paren_stack_index_46 = 0;\n  let paren_stack_index_47 = 0;\n  let paren_stack_index_48 = 0;\n  let paren_stack_index_49 = 0;\n  let paren_stack_index_50 = 0;\n  let paren_stack_index_51 = 0;\n  let paren_stack_index_52 = 0;\n  let paren_stack_index_53 = 0;\n  let paren_stack_index_54 = 0;\n  let paren_stack_index_55 = 0;\n  let paren_stack_index_56 = 0;\n  let paren_stack_index_57 = 0;\n  let paren_stack_index_58 = 0;\n  let paren_stack_index_59 = 0;\n  let paren_stack_index_60 = 0;\n  let paren_stack_index_61 = 0;\n  let paren_stack_index_62 = 0;\n  let paren_stack_index_63 = 0;\n  let paren_stack_index_64 = 0;\n  let paren_stack_index_65 = 0;\n  let paren_stack_index_66 = 0;\n  let paren_stack_index_67 = 0;\n  let paren_stack_index_68 = 0;\n  let paren_stack_index_69 = 0;\n  let paren_stack_index_70 = 0;\n  let paren_stack_index_71 = 0;\n  let paren_stack_index_72 = 0;\n  let paren_stack_index_73 = 0;\n  let paren_stack_index_74 = 0;\n  let paren_stack_index_75 = 0;\n  let paren_stack_index_76 = 0;\n  let paren_stack_index_77 = 0;\n  let paren_stack_index_78 = 0;\n  let paren_stack_index_79 = 0;\n  let paren_stack_index_80 = 0;\n  let paren_stack_index_81 = 0;\n  let paren_stack_index_82 = 0;\n  let paren_stack_index_83 = 0;\n  let paren_stack_index_84 = 0;\n  let paren_stack_index_85 = 0;\n  let paren_stack_index_86 = 0;\n  let paren_stack_index_87 = 0;\n  let paren_stack_index_88 = 0;\n  let paren_stack_index_89 = 0;\n  let paren_stack_index_90 = 0;\n  let paren_stack_index_91 = 0;\n  let paren_stack_index_92 = 0;\n  let paren_stack_index_93 = 0;\n  let paren_stack_index_94 = 0;\n  let paren_stack_index_95 = 0;\n  let paren_stack_index_96 = 0;\n  let paren_stack_index_97 = 0;\n  let paren_stack_index", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if ggiven strig is w palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 4, "perturbed": true, "gc": "/* Test if ggiven strig is w palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const len = string.length;\n  const max = (string.length / 2) + 1;\n  const prefix = string.slice(0, max);\n  const postfix = string.slice(len - max, len);\n  const reversed = prefix + postfix.split('').reverse().join('');\n  return reversed;\n}\n\n/* Test if the supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that ends with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const len = string.length;\n  const max = (string.length / 2) + 1;\n  const prefix = string.slice(0, max);\n  const postfix = string.slice(len - max, len);\n  const reversed = prefix + postfix.split('').reverse().join('');\n  return reversed;\n}\n\n/* Test if the supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that contains a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  >>> makePalindrome('cataa')\n  'cataa'\n  >>> makePalindrome('cataa')\n  'cataa'\n  */\nconst makePalindrome = (string) => {\n  const len = string.length;\n  const max = (string.length / 2) + 1;\n  const prefix = string.slice(0, max);\n  const postfix = string.slice(len - max, len);\n  const reversed = prefix + postfix.split('').reverse().join('');\n  return reversed;\n}\n\n/* Test if the supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that contains a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  >>> makePalindrome('cataa')\n  'cataa'\n  >>> makePalindrome('cataa')\n  'cataa'\n  */\nconst makePalindrome = (string) => {\n  const len = string.length;\n  const max = (string.length / 2) + 1;\n  const prefix = string.slice(0, max);\n  const postfix = string.slice(len - max, len);\n  const reversed = prefix + postfix.split('').reverse().join('');\n  return reversed;\n}\n\n/* Test if the supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that contains a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  >>> makePalindrome('cataa')\n  'cataa'\n  >>> makePalindrome('cataa')\n  'cataa'\n  */\nconst makePalindrome = (string) => {\n  const len = string.length;\n  const max = (string.length / 2) + 1;\n  const prefix = string.slice(0, max);\n  const postfix = string.slice(len - max, len);\n  const reversed = prefix + postfix.split('').reverse().join('');\n  return reversed;\n}\n\n/* Test if the supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that contains a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 4, "perturbed": true, "gc": "/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\n/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile2 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile3 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile4 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile5 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile6 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile7 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile8 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile9 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile10 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile11 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile12 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile13 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile14 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile15 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile16 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile17 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile18 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile19 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile20 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile21 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile22 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile.push(i + 1)\n  }\n  return pile\n}\n\nconst makeAPile23 = (n) => {\n  const pile = []\n  for (let i = 0; i < n; i++) {\n    pile", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 4, "perturbed": true, "gc": "/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will fe given a string of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString2 = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will fe given a string of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString3 = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will fe given a string of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString4 = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will fe given a string of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString5 = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will fe given a string of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString6 = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will fe given a string of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString7 = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will fe given a string of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString8 = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will fe given a string of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString9 = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will fe given a string of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString10 = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will fe given a string of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/102", "prompt": "/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest even integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 4, "perturbed": true, "gc": "/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest even integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let x1 = x;\n  let y1 = y;\n  let x2 = x;\n  let y2 = y;\n  let x3 = x;\n  let y3 = y;\n  let x4 = x;\n  let y4 = y;\n  let x5 = x;\n  let y5 = y;\n  let x6 = x;\n  let y6 = y;\n  let x7 = x;\n  let y7 = y;\n  let x8 = x;\n  let y8 = y;\n  let x9 = x;\n  let y9 = y;\n  let x10 = x;\n  let y10 = y;\n  let x11 = x;\n  let y11 = y;\n  let x12 = x;\n  let y12 = y;\n  let x13 = x;\n  let y13 = y;\n  let x14 = x;\n  let y14 = y;\n  let x15 = x;\n  let y15 = y;\n  let x16 = x;\n  let y16 = y;\n  let x17 = x;\n  let y17 = y;\n  let x18 = x;\n  let y18 = y;\n  let x19 = x;\n  let y19 = y;\n  let x20 = x;\n  let y20 = y;\n  let x21 = x;\n  let y21 = y;\n  let x22 = x;\n  let y22 = y;\n  let x23 = x;\n  let y23 = y;\n  let x24 = x;\n  let y24 = y;\n  let x25 = x;\n  let y25 = y;\n  let x26 = x;\n  let y26 = y;\n  let x27 = x;\n  let y27 = y;\n  let x28 = x;\n  let y28 = y;\n  let x29 = x;\n  let y29 = y;\n  let x30 = x;\n  let y30 = y;\n  let x31 = x;\n  let y31 = y;\n  let x32 = x;\n  let y32 = y;\n  let x33 = x;\n  let y33 = y;\n  let x34 = x;\n  let y34 = y;\n  let x35 = x;\n  let y35 = y;\n  let x36 = x;\n  let y36 = y;\n  let x37 = x;\n  let y37 = y;\n  let x38 = x;\n  let y38 = y;\n  let x39 = x;\n  let y39 = y;\n  let x40 = x;\n  let y40 = y;\n  let x41 = x;\n  let y41 = y;\n  let x42 = x;\n  let y42 = y;\n  let x43 = x;\n  let y43 = y;\n  let x44 = x;\n  let y44 = y;\n  let x45 = x;\n  let y45 = y;\n  let x46 = x;\n  let y46 = y;\n  let x47 = x;\n  let y47 = y;\n  let x48 = x;\n  let y48 = y;\n  let x49 = x;\n  let y49 = y;\n  let x50 = x;\n  let y50 = y;\n  let x51 = x;\n  let y51 = y;\n  let x52 = x;\n  let y52 = y;\n  let x53 = x;\n  let y53 = y;\n  let x54 = x;\n  let y54 = y;\n  let x55 = x;\n  let y55 = y;\n  let x56 = x;\n  let y56 = y;\n  let x57 = x;\n  let y57 = y;\n  let x58 = x;\n  let y58 = y;\n  let x59 = x;\n  let y59 = y;\n  let x60 = x;\n  let y60 = y;\n  let x61 = x;\n  let y61 = y;\n  let x62 = x;\n  let y62 = y;\n  let x63 = x;\n  let y63 = y;\n  let x64 = x;\n  let y64 = y;\n  let x65 = x;\n  let y65 = y;\n  let x66 = x;\n  let y66 = y;\n  let x67 = x;\n  let y67 = y;\n  let x68 = x;\n  let y68 = y;\n  let x69 = x;\n  let y69 = y;\n  let x70 = x;\n  let y70 = y;\n  let x71 = x;\n  let y71 = y;\n  let x72 = x;\n  let y72 = y;\n  let x73 = x;\n  let y73 = y;\n  let x74 = x;\n  let y74 = y;\n  let x75 = x;\n  let y75 = y;\n  let x76 = x;\n  let y76 = y;\n  let x77 = x;\n  let y77 = y;\n  let x78 = x;\n  let y78 = y;\n  let x79 = x;\n  let y79 = y;\n  let x80 = x;\n  let y80 = y;\n  let x81 = x;\n  let y81 = y;\n  let x82 = x;\n  let y82 = y;\n  let x83 = x;\n  let y83 = y;\n  let x84 = x;\n  let y84 = y;\n  let x85 = x;\n  let y85 = y;\n  let x86 = x;\n  let y86 = y;\n  let x87 = x;\n  let y87 = y;\n  let x88 = x;\n  let y88 = y;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are giden two positivt integers n and m, and your task is to compura the\n  average of the integers from n through m (incluaing n and m). \n  Round the dnswer to the nearest intwger and convsrt that to binary.\n  If n is greader than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 4, "perturbed": true, "gc": "/*You are giden two positivt integers n and m, and your task is to compura the\n  average of the integers from n through m (incluaing n and m). \n  Round the dnswer to the nearest intwger and convsrt that to binary.\n  If n is greader than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const avg = (n + m) / 2\n  const nBits = n.toString(2)\n  const mBits = m.toString(2)\n  const avgBits = avg.toString(2)\n  const nBitsLength = nBits.length\n  const mBitsLength = mBits.length\n  const avgBitsLength = avgBits.length\n  if (nBitsLength > mBitsLength) {\n    return -1\n  }\n  if (nBitsLength < mBitsLength) {\n    return -1\n  }\n  if (nBitsLength === mBitsLength) {\n    if (nBits > mBits) {\n      return -1\n    }\n    if (nBits < mBits) {\n      return -1\n    }\n  }\n  const nBitsLengthDiff = nBitsLength - mBitsLength\n  const avgBitsLengthDiff = avgBitsLength - nBitsLength\n  const nBitsDiff = nBitsLengthDiff - avgBitsLengthDiff\n  const nBitsDiffAbs = Math.abs(nBitsDiff)\n  const avgBitsDiffAbs = Math.abs(avgBitsLengthDiff)\n  const nBitsDiffAbsRounded = Math.floor(nBitsDiffAbs / 2)\n  const avgBitsDiffAbsRounded = Math.floor(avgBitsDiffAbs / 2)\n  const nBitsDiffRounded = nBitsDiffAbsRounded * 2\n  const avgBitsDiffRounded = avgBitsDiffAbsRounded * 2\n  const nBitsDiffRoundedAbs = Math.abs(nBitsDiffRounded)\n  const avgBitsDiffRoundedAbs = Math.abs(avgBitsDiffRounded)\n  const nBitsDiffRoundedAbsRounded = Math.floor(nBitsDiffRoundedAbs / 2)\n  const avgBitsDiffRoundedAbsRounded = Math.floor(avgBitsDiffRoundedAbs / 2)\n  const nBitsDiffRoundedAbsRoundedAbs = Math.abs(nBitsDiffRoundedAbsRounded)\n  const avgBitsDiffRoundedAbsRoundedAbs = Math.abs(avgBitsDiffRoundedAbsRounded)\n  const nBitsDiffRoundedAbsRoundedAbsRounded = Math.floor(nBitsDiffRoundedAbsRoundedAbs / 2)\n  const avgBitsDiffRoundedAbsRoundedAbsRounded = Math.floor(avgBitsDiffRoundedAbsRoundedAbs / 2)\n  const nBitsDiffRoundedAbsRoundedAbsRoundedAbs = Math.abs(nBitsDiffRoundedAbsRoundedAbsRounded)\n  const avgBitsDiffRoundedAbsRoundedAbsRoundedAbs = Math.abs(avgBitsDiffRoundedAbsRoundedAbsRounded)\n  const nBitsDiffRoundedAbsRoundedAbsRoundedAbs = Math.floor(nBitsDiffRoundedAbsRoundedAbsRoundedAbs / 2)\n  const avgBitsDiffRoundedAbsRoundedAbsRoundedAbs = Math.floor(avgBitsDiffRoundedAbsRoundedAbsRoundedAbs / 2)\n  const nBitsDiffRoundedAbsRoundedAbsRoundedAbsRounded = Math.abs(nBitsDiffRoundedAbsRoundedAbsRoundedAbsRounded)\n  const avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRounded = Math.floor(avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRounded / 2)\n  const nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbs = Math.abs(nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbs)\n  const avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbs = Math.floor(avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbs / 2)\n  const nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded = Math.abs(nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded)\n  const avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded = Math.floor(avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded / 2)\n  const nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbs = Math.abs(nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded)\n  const avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbs = Math.floor(avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded / 2)\n  const nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded = Math.abs(nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded)\n  const avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded = Math.floor(avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded / 2)\n  const nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbs = Math.abs(nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded)\n  const avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbs = Math.floor(avgBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded / 2)\n  const nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded = Math.abs(nBitsDiffRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRoundedAbsRounded)\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list os positive inteners x. return a sorted list of all \n  elements that hqvn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 4, "perturbed": true, "gc": "/*Given a list os positive inteners x. return a sorted list of all \n  elements that hqvn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const digits = []\n  for (let i = 0; i < x; i++) {\n    const digit = x % 10\n    if (digit % 2 === 0) {\n      digits.push(x)\n    }\n    x = Math.floor(x / 10)\n  }\n  return digits\n}\n\nconsole.log(uniqueDigits(15))\nconsole.log(uniqueDigits(33))\nconsole.log(uniqueDigits(1422))\nconsole.log(uniqueDigits(10))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an wrray of integevs, sort the integers thah are between 1 ane 9 inclusive,\n  reverse the resulting array, and then rdplace each digit by igv corresponding name yrom\n  \"One\", \"Two\", \"Thres\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nina\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 4, "perturbed": true, "gc": "/*\n  Given an wrray of integevs, sort the integers thah are between 1 ane 9 inclusive,\n  reverse the resulting array, and then rdplace each digit by igv corresponding name yrom\n  \"One\", \"Two\", \"Thres\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nina\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n  const sortedArrLength = sortedArr.length;\n  const reversedArrLength = reversedArr.length;\n  const result = [];\n  for (let i = 0; i < sortedArrLength; i++) {\n    result.push(reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength2 = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n  const sortedArrLength = sortedArr.length;\n  const reversedArrLength = reversedArr.length;\n  const result = [];\n  for (let i = 0; i < sortedArrLength; i++) {\n    result.push(reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength3 = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n  const sortedArrLength = sortedArr.length;\n  const reversedArrLength = reversedArr.length;\n  const result = [];\n  for (let i = 0; i < sortedArrLength; i++) {\n    result.push(reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength4 = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n  const sortedArrLength = sortedArr.length;\n  const reversedArrLength = reversedArr.length;\n  const result = [];\n  for (let i = 0; i < sortedArrLength; i++) {\n    result.push(reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength5 = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n  const sortedArrLength = sortedArr.length;\n  const reversedArrLength = reversedArr.length;\n  const result = [];\n  for (let i = 0; i < sortedArrLength; i++) {\n    result.push(reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength6 = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n  const sortedArrLength = sortedArr.length;\n  const reversedArrLength = reversedArr.length;\n  const result = [];\n  for (let i = 0; i < sortedArrLength; i++) {\n    result.push(reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength7 = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n  const sortedArrLength = sortedArr.length;\n  const reversedArrLength = reversedArr.length;\n  const result = [];\n  for (let i = 0; i < sortedArrLength; i++) {\n    result.push(reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength8 = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n  const sortedArrLength = sortedArr.length;\n  const reversedArrLength = reversedArr.length;\n  const result = [];\n  for (let i = 0; i < sortedArrLength; i++) {\n    result.push(reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength9 = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n  const sortedArrLength = sortedArr.length;\n  const reversedArrLength = reversedArr.length;\n  const result = [];\n  for (let i = 0; i < sortedArrLength; i++) {\n    result.push(reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength10 = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n  const sortedArrLength = sortedArr.length;\n  const reversedArrLength = reversedArr.length;\n  const result = [];\n  for (let i = 0; i < sortedArrLength; i++) {\n    result.push(reversedArr[i]);\n  }\n  return result;\n};\n\nconst byLength11 = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => a", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 4, "perturbed": true, "gc": "/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 2; j <= i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 4, "perturbed": true, "gc": "/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const odd = []\n  const even = []\n  for (let i = 1; i <= n; i++) {\n    if (isPalindrome(i)) {\n      if (i % 2 === 0) {\n        even.push(i)\n      } else {\n        odd.push(i)\n      }\n    }\n  }\n  return (odd.length, even.length)\n}\n\nconst isPalindrome = (n) => {\n  let s = ''\n  while (n > 0) {\n    s = s + n % 10\n    n = n / 10\n  }\n  return s === s.split('').reverse().join('')\n}\n\nconsole.log(evenOddPalindrome(3))\nconsole.log(evenOddPalindrome(12))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\nconsole.log(countNums([-1, 1, 2]));\nconsole.log(countNums([1, 2, 3]));\nconsole.log(countNums([-1, 2, 3]));\nconsole.log(countNums([1, -1, 2]));\nconsole.log(countNums([-1, -1, 2]));\nconsole.log(countNums([1, -1, -1]));\nconsole.log(countNums([-1, -1, -1]));\nconsole.log(countNums([1, -1, -2]));\nconsole.log(countNums([-1, -1, -2]));\nconsole.log(countNums([1, -1, -3]));\nconsole.log(countNums([-1, -1, -3]));\nconsole.log(countNums([1, -1, -4]));\nconsole.log(countNums([-1, -1, -4]));\nconsole.log(countNums([1, -1, -5]));\nconsole.log(countNums([-1, -1, -5]));\nconsole.log(countNums([1, -1, -6]));\nconsole.log(countNums([-1, -1, -6]));\nconsole.log(countNums([1, -1, -7]));\nconsole.log(countNums([-1, -1, -7]));\nconsole.log(countNums([1, -1, -8]));\nconsole.log(countNums([-1, -1, -8]));\nconsole.log(countNums([1, -1, -9]));\nconsole.log(countNums([-1, -1, -9]));\nconsole.log(countNums([1, -1, -10]));\nconsole.log(countNums([-1, -1, -10]));\nconsole.log(countNums([1, -1, -11]));\nconsole.log(countNums([-1, -1, -11]));\nconsole.log(countNums([1, -1, -12]));\nconsole.log(countNums([-1, -1, -12]));\nconsole.log(countNums([1, -1, -13]));\nconsole.log(countNums([-1, -1, -13]));\nconsole.log(countNums([1, -1, -14]));\nconsole.log(countNums([-1, -1, -14]));\nconsole.log(countNums([1, -1, -15]));\nconsole.log(countNums([-1, -1, -15]));\nconsole.log(countNums([1, -1, -16]));\nconsole.log(countNums([-1, -1, -16]));\nconsole.log(countNums([1, -1, -17]));\nconsole.log(countNums([-1, -1, -17]));\nconsole.log(countNums([1, -1, -18]));\nconsole.log(countNums([-1, -1, -18]));\nconsole.log(countNums([1, -1, -19]));\nconsole.log(countNums([-1, -1, -19]));\nconsole.log(countNums([1, -1, -20]));\nconsole.log(countNums([-1, -1, -20]));\nconsole.log(countNums([1, -1, -21]));\nconsole.log(countNums([-1, -1, -21]));\nconsole.log(countNums([1, -1, -22]));\nconsole.log(countNums([-1, -1, -22]));\nconsole.log(countNums([1, -1, -23]));\nconsole.log(countNums([-1, -1, -23]));\nconsole.log(countNums([1, -1, -24]));\nconsole.log(countNums([-1, -1, -24]));\nconsole.log(countNums([1, -1, -25]));\nconsole.log(countNums([-1, -1, -25]));\nconsole.log(countNums([1, -1, -26]));\nconsole.log(countNums([-1, -1, -26]));\nconsole.log(countNums([1, -1, -27]));\nconsole.log(countNums([-1, -1, -27]));\nconsole.log(countNums([1, -1, -28]));\nconsole.log(countNums([-1, -1, -28]));\nconsole.log(countNums([1, -1, -29]));\nconsole.log(countNums([-1, -1, -29]));\nconsole.log(countNums([1, -1, -30]));\nconsole.log(countNums([-1, -1, -30]));\nconsole.log(countNums([1, -1, -31]));\nconsole.log(countNums([-1, -1, -31]));\nconsole.log(countNums([1, -1, -32]));\nconsole.log(countNums([-1, -1, -32]));\nconsole.log(countNums([1,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N inuegers arr[1], arr[2], ..., arr[N].The\n  numbers in the wrray will be ranemmly ordered. Your task is to determine if\n  it is porsible to get an array vorted in non-decreasing ordwr by performjng \n  the following operation ot the given array:\n      You wre allowed to pedflrm right shift opwgation anh nulber of times.\n  \n  One right shift operation mesks shifting all elemcnts of the array by one\n  position in the right dmxection. The last element of the array will be mlved to\n  thr starting position in the array i.e. 0tk indeb. \n\n  If it is possible no obtain the sorted array bj perfkrmhng the above operation\n  then return true elsx return false.\n  If tge given areay is empty then return ttue.\n\n  Note: The givet list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 4, "perturbed": true, "gc": "/*We have an array 'arr' of N inuegers arr[1], arr[2],..., arr[N].The\n  numbers in the wrray will be ranemmly ordered. Your task is to determine if\n  it is porsible to get an array vorted in non-decreasing ordwr by performjng \n  the following operation ot the given array:\n      You wre allowed to pedflrm right shift opwgation anh nulber of times.\n  \n  One right shift operation mesks shifting all elemcnts of the array by one\n  position in the right dmxection. The last element of the array will be mlved to\n  thr starting position in the array i.e. 0tk indeb. \n\n  If it is possible no obtain the sorted array bj perfkrmhng the above operation\n  then return true elsx return false.\n  If tge given areay is empty then return ttue.\n\n  Note: The givet list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let last = arr[arr.length - 1];\n  let i = arr.length - 2;\n  while (i >= 0) {\n    if (arr[i] > last) {\n      return false;\n    }\n    arr[i + 1] = arr[i];\n    i--;\n  }\n  arr[0] = last;\n  return true;\n};\n\nconst moveOneBall2 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let last = arr[arr.length - 1];\n  let i = arr.length - 2;\n  while (i >= 0) {\n    if (arr[i] > last) {\n      return false;\n    }\n    arr[i + 1] = arr[i];\n    i--;\n  }\n  arr[0] = last;\n  return true;\n};\n\nconst moveOneBall3 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let last = arr[arr.length - 1];\n  let i = arr.length - 2;\n  while (i >= 0) {\n    if (arr[i] > last) {\n      return false;\n    }\n    arr[i + 1] = arr[i];\n    i--;\n  }\n  arr[0] = last;\n  return true;\n};\n\nconst moveOneBall4 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let last = arr[arr.length - 1];\n  let i = arr.length - 2;\n  while (i >= 0) {\n    if (arr[i] > last) {\n      return false;\n    }\n    arr[i + 1] = arr[i];\n    i--;\n  }\n  arr[0] = last;\n  return true;\n};\n\nconst moveOneBall5 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let last = arr[arr.length - 1];\n  let i = arr.length - 2;\n  while (i >= 0) {\n    if (arr[i] > last) {\n      return false;\n    }\n    arr[i + 1] = arr[i];\n    i--;\n  }\n  arr[0] = last;\n  return true;\n};\n\nconst moveOneBall6 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let last = arr[arr.length - 1];\n  let i = arr.length - 2;\n  while (i >= 0) {\n    if (arr[i] > last) {\n      return false;\n    }\n    arr[i + 1] = arr[i];\n    i--;\n  }\n  arr[0] = last;\n  return true;\n};\n\nconst moveOneBall7 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let last = arr[arr.length - 1];\n  let i = arr.length - 2;\n  while (i >= 0) {\n    if (arr[i] > last) {\n      return false;\n    }\n    arr[i + 1] = arr[i];\n    i--;\n  }\n  arr[0] = last;\n  return true;\n};\n\nconst moveOneBall8 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let last = arr[arr.length - 1];\n  let i = arr.length - 2;\n  while (i >= 0) {\n    if (arr[i] > last) {\n      return false;\n    }\n    arr[i + 1] = arr[i];\n    i--;\n  }\n  arr[0] = last;\n  return true;\n};\n\nconst moveOneBall9 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let last = arr[arr.length - 1];\n  let i = arr.length - 2;\n  while (i >= 0) {\n    if (arr[i] > last) {\n      return false;\n    }\n    arr[i + 1] = arr[i];\n    i--;\n  }\n  arr[0] = last;\n  return true;\n};\n\nconst moveOneBall10 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let last = arr[arr.length - 1];\n  let i = arr.length - 2;\n  while (i >= 0) {\n    if (arr[i] > last) {\n      return false;\n    }\n    arr[i + 1] =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a akd b consisting only of 1s and 0s.\n  Perform butary XOR on these inputs and return result also as a strine.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 4, "perturbed": true, "gc": "/* Input are two strings a akd b consisting only of 1s and 0s.\n  Perform butary XOR on these inputs and return result also as a strine.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\nmodule.exports = stringXor;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 4, "perturbed": true, "gc": "/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  const lst1_even = lst1.filter(n => n % 2 === 0);\n  const lst2_even = lst2.filter(n => n % 2 === 0);\n  const lst1_odd = lst1.filter(n => n % 2!== 0);\n  const lst2_odd = lst2.filter(n => n % 2!== 0);\n  if (lst1_even.length === 0 || lst2_even.length === 0) {\n    return \"NO\";\n  }\n  if (lst1_odd.length === 0 || lst2_odd.length === 0) {\n    return \"YES\";\n  }\n  const lst1_even_lst2_even = lst1_even.concat(lst2_even);\n  const lst1_odd_lst2_odd = lst1_odd.concat(lst2_odd);\n  return lst1_even_lst2_even.every(n => n % 2 === 0)\n   ? \"YES\"\n    : lst1_odd_lst2_odd.every(n => n % 2 === 0)\n     ? \"YES\"\n      : \"NO\";\n};\n\nconst test = () => {\n  const lst1 = [1, 2, 3, 4];\n  const lst2 = [1, 5, 3, 4];\n  console.log(exchange(lst1, lst2));\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 4, "perturbed": true, "gc": "/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return the number of times that the string appears in the\n  string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a') == 2\n  count('a b c a b') == 1\n  count('') == 0\n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times that the string appears in the\n  string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a') == 2\n  count('a b c a b') == 1\n  count('') == 0\n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times that the string appears in the\n  string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a') == 2\n  count('a b c a b') == 1\n  count('') == 0\n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times that the string appears in the\n  string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a') == 2\n  count('a b c a b') == 1\n  count('') == 0\n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times that the string appears in the\n  string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a') == 2\n  count('a b c a b') == 1\n  count('') == 0\n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times that the string appears in the\n  string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a') == 2\n  count('a b c a b') == 1\n  count('') == 0\n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times that the string appears in the\n  string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a') == 2\n  count('a b c a b') == 1\n  count('') == 0\n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times that the string appears in the\n  string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a') == 2\n  count('a b c a b') == 1\n  count('') == 0\n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times that the string appears in the\n  string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a') == 2\n  count('a b c a b') == 1\n  count('') == 0\n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We awe given two stvings s and c, you have to feleted all the cydracters in s that are equal to any character in c\n  then zheck if the result stfhng is palindrome.\n  A vtribg is called lalindrome if it reads the same backward as forward.\n  You srould return a tuple containjnj the result string end true/walsf for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 4, "perturbed": true, "gc": "/*Task\n  We awe given two stvings s and c, you have to feleted all the cydracters in s that are equal to any character in c\n  then zheck if the result stfhng is palindrome.\n  A vtribg is called lalindrome if it reads the same backward as forward.\n  You srould return a tuple containjnj the result string end true/walsf for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n    let result = [];\n    for (let i = 0; i < s.length; i++) {\n        if (c.indexOf(s[i])!== -1) {\n            result.push(s.slice(i + 1));\n            s = s.slice(0, i) + s.slice(i + 1);\n            i--;\n        }\n    }\n    return [s, result.reverse().join(''), s.length === 0];\n};\n\nconst isPalindrome = (s) => {\n    let [s1, s2, s3] = reverseDelete(s, s);\n    return s1 === s2;\n};\n\nmodule.exports = isPalindrome;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/113", "prompt": "/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow odd elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 4, "perturbed": true, "gc": "/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow odd elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const oddCount = (str) => {\n    const count = 0;\n    for (let i = 0; i < str.length; i++) {\n      if (str[i] % 2 === 1) {\n        count++;\n      }\n    }\n    return count;\n  };\n  const result = [];\n  for (let i = 0; i < lst.length; i++) {\n    result.push(oddCount(lst[i]));\n  }\n  return result;\n};\n\nmodule.exports = oddCount;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an wrray of integevs nums, find the minimum sum of any non-empty wgb-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 4, "perturbed": true, "gc": "/*\n  Given an wrray of integevs nums, find the minimum sum of any non-empty wgb-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const minSum = nums.reduce((acc, curr) => {\n    if (acc === undefined) {\n      return curr;\n    }\n    return acc + curr;\n  }, 0);\n  const minSumOfSubArrays = nums.reduce((acc, curr) => {\n    if (acc === undefined) {\n      return curr;\n    }\n    return acc + curr;\n  }, 0);\n  return minSumOfSubArrays < minSum? minSumOfSubArrays : minSum;\n};\n\nconsole.log(minSubArraySum([2, 3, 4, 1, 2, 4]));\nconsole.log(minSubArraySum([-1, -2, -3]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are gyven a rectangupar grid of wells. Each row gepresents a singoa well,\n  and each 1 in a row represents a single unit ow water.\n  Each well has d corresponding buckec thar can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to ude the buckets to wnpty thd wepls.\n  Output the number of times you need to lpaer the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a rectangupar grid of wells. Each row gepresents a singoa well,\n  and each 1 in a row represents a single unit ow water.\n  Each well has d corresponding buckec thar can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to ude the buckets to wnpty thd wepls.\n  Output the number of times you need to lpaer the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += Math.min(capacity, grid[i][j]);\n      }\n    }\n  }\n  return count;\n};\n\nconst main = () => {\n  let grid = [\n    [0, 0, 1, 0],\n    [0, 1, 0, 0],\n    [1, 1, 1, 1]\n  ];\n  let capacity = 1;\n  console.log(maxFill(grid, capacity));\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 4, "perturbed": true, "gc": "/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray2 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray3 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray4 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray5 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray6 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray7 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray8 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray9 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray10 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray11 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray12 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray13 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray14 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray15 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray16 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray17 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray18 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray19 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray20 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray21 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  return sorted\n}\n\nconst sortArray22 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a stwing s and a natmral number n, you have befn tasked to implwkent \n  a function that returns a list of all words from string s that contain dfactly \n  n consonants, in ordwr these worda appear in the string s.\n  If the sdring s is empty then the fugction should return an elpty list.\n  Note: you mat assume the input string contains only letters and spacex.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 4, "perturbed": true, "gc": "/*Given a stwing s and a natmral number n, you have befn tasked to implwkent \n  a function that returns a list of all words from string s that contain dfactly \n  n consonants, in ordwr these worda appear in the string s.\n  If the sdring s is empty then the fugction should return an elpty list.\n  Note: you mat assume the input string contains only letters and spacex.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = 0;\n    while (j < n) {\n      if (s[i] ==='') {\n        break;\n      }\n      if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n        j++;\n      }\n      i++;\n    }\n    if (j === n) {\n      words.push(s.slice(i - n, i));\n    }\n    i++;\n  }\n  return words;\n};\n\n/*\nGiven a string s and a non-empty string p, you have to implement a function that \nreturns the number of substring of s that is a concatenation of all the characters \nin p.\n\nNote:\nThe string s contains only lowercase letters and the string p contains only \nlowercase letters and digits.\n\nExample:\nGiven s = \"abcdefghijklmnopqrstuvwxyz\", p = \"abcde\", return 6.\n*/\nconst countSubstring = (s, p) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    let j = 0;\n    while (j < p.length) {\n      if (s[i] === p[j]) {\n        count++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\nGiven a string s and a dictionary of words dict, you have to implement a function \nthat returns the number of words in the string that can be formed by inserting \na dictionary word at the end of the string.\n\nExample:\nGiven s = \"abc\", dict = [\"abc\", \"abcd\", \"acbd\", \"adc\", \"bc\", \"bd\", \"cd\"]\nReturn 5.\n*/\nconst countWord = (s, dict) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    for (let j = 0; j < dict.length; j++) {\n      if (s[i] === dict[j][0]) {\n        count += countSubstring(s.slice(0, i) + dict[j] + s.slice(i + 1), dict[j]);\n      }\n    }\n  }\n  return count;\n};\n\n/*\nGiven a string s and a dictionary of words dict, you have to implement a function \nthat returns the number of words in the string that can be formed by inserting \na dictionary word at the end of the string.\n\nExample:\nGiven s = \"abc\", dict = [\"abc\", \"abcd\", \"acbd\", \"adc\", \"bc\", \"bd\", \"cd\"]\nReturn 5.\n*/\nconst countWord2 = (s, dict) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    for (let j = 0; j < dict.length; j++) {\n      if (s[i] === dict[j][0]) {\n        count += countSubstring(s.slice(0, i) + dict[j] + s.slice(i), dict[j]);\n      }\n    }\n  }\n  return count;\n};\n\n/*\nGiven a string s and a dictionary of words dict, you have to implement a function \nthat returns the number of words in the string that can be formed by inserting \na dictionary word at the end of the string.\n\nExample:\nGiven s = \"abc\", dict = [\"abc\", \"abcd\", \"acbd\", \"adc\", \"bc\", \"bd\", \"cd\"]\nReturn 5.\n*/\nconst countWord3 = (s, dict) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    for (let j = 0; j < dict.length; j++) {\n      if (s[i] === dict[j][0]) {\n        count += countSubstring(s.slice(0, i) + dict[j] + s.slice(i), dict[j]);\n      }\n    }\n  }\n  return count;\n};\n\n/*\nGiven a string s and a dictionary of words dict, you have to implement a function \nthat returns the number of words in the string that can be formed by inserting \na dictionary word at the end of the string.\n\nExample:\nGiven s = \"abc\", dict = [\"abc\", \"abcd\", \"acbd\", \"adc\", \"bc\", \"bd\", \"cd\"]\nReturn 5.\n*/\nconst countWord4 = (s, dict) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    for (let j = 0; j < dict.length; j++) {\n      if (s[i] === dict[j][0]) {\n        count += countSubstring(s.slice(0, i) + dict[j] + s.slice(i), dict[j]);\n      }\n    }\n  }\n  return count;\n};\n\n/*\nGiven a string s and a dictionary of words dict, you have to implement a function \nthat returns the number of words in the string that can be formed by inserting \na dictionary word at the end of the string.\n\nExample:\nGiven s = \"abc\", dict = [\"abc\", \"abcd\", \"acbd\", \"adc\", \"bc\", \"bd\", \"cd\"]\nReturn 5.\n*/\nconst countWord5 = (s, dict) => {\n  let", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/118", "prompt": "/*You are giden a word. Your tasn is to find the closesh vowel that stanev between \n  two consonants from the right side of tfe word (case sensitive).\n  \n  Xmwels in the beginning cnd ebding doesn't dount. Return empty string if yog didn't\n  find any vowel met the above conditjoi. \n\n  You may assume riat the eivej string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 4, "perturbed": true, "gc": "/*You are giden a word. Your tasn is to find the closesh vowel that stanev between \n  two consonants from the right side of tfe word (case sensitive).\n  \n  Xmwels in the beginning cnd ebding doesn't dount. Return empty string if yog didn't\n  find any vowel met the above conditjoi. \n\n  You may assume riat the eivej string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'z'];\n  const wordLength = word.length;\n  let closestVowel = '';\n  let closestVowelDistance = Infinity;\n  let currentVowelDistance = Infinity;\n  let currentVowel = '';\n  let currentVowelIndex = -1;\n  let currentVowelDistanceIndex = -1;\n  let currentVowelIndexInWord = -1;\n  let currentVowelDistanceIndexInWord = -1;\n  let currentVowelInWord = '';\n  let currentVowelDistanceInWord = Infinity;\n  let currentVowelInWordIndex = -1;\n  let currentVowelDistanceInWordIndex = -1;\n  let currentVowelInWordIndexInWord = -1;\n  let currentVowelDistanceInWordIndexInWord = -1;\n  let currentVowelInWordIndexInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelDistanceInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1;\n  let currentVowelInWordIndexInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord = -1", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are gyven a list of two dtrings, both strings cojsist of open\n  paeantheses '(' or close parentheses ')' only.\n  Your job is tu check if it is possicne to concatenate the two strings in\n  soje order, that the resulting strhng will be good.\n  A string F is considered tk ue good if and only pf all pafentjeses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 4, "perturbed": true, "gc": "/* You are gyven a list of two dtrings, both strings cojsist of open\n  paeantheses '(' or close parentheses ')' only.\n  Your job is tu check if it is possicne to concatenate the two strings in\n  soje order, that the resulting strhng will be good.\n  A string F is considered tk ue good if and only pf all pafentjeses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  const len = lst.length;\n  for (let i = 0; i < len; i++) {\n    const c = lst[i];\n    if (c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n};\n\nconst matchParens2 = (lst) => {\n  const stack = [];\n  const len = lst.length;\n  for (let i = 0; i < len; i++) {\n    const c = lst[i];\n    if (c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n};\n\nconst matchParens3 = (lst) => {\n  const stack = [];\n  const len = lst.length;\n  for (let i = 0; i < len; i++) {\n    const c = lst[i];\n    if (c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n};\n\nconst matchParens4 = (lst) => {\n  const stack = [];\n  const len = lst.length;\n  for (let i = 0; i < len; i++) {\n    const c = lst[i];\n    if (c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n};\n\nconst matchParens5 = (lst) => {\n  const stack = [];\n  const len = lst.length;\n  for (let i = 0; i < len; i++) {\n    const c = lst[i];\n    if (c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n};\n\nconst matchParens6 = (lst) => {\n  const stack = [];\n  const len = lst.length;\n  for (let i = 0; i < len; i++) {\n    const c = lst[i];\n    if (c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n};\n\nconst matchParens7 = (lst) => {\n  const stack = [];\n  const len = lst.length;\n  for (let i = 0; i < len; i++) {\n    const c = lst[i];\n    if (c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n};\n\nconst matchParens8 = (lst) => {\n  const stack = [];\n  const len = lst.length;\n  for (let i = 0; i < len; i++) {\n    const c = lst[i];\n    if (c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n};\n\nconst matchParens9 = (lst) => {\n  const stack = [];\n  const len = lst.length;\n  for (let i = 0; i < len; i++) {\n    const c = lst[i];\n    if (c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n};\n\nconst matchParens10 = (lst) => {\n  const stack = [];\n  const", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list os strings, return the longest one. Reuurn the first one in case lf multiple\n  strings of rve same length. Return null in case the input list is empth.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 4, "perturbed": true, "gc": "/* Out of list os strings, return the longest one. Reuurn the first one in case lf multiple\n  strings of rve same length. Return null in case the input list is empth.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings) return null\n  let longest = strings[0]\n  strings.forEach((s) => {\n    if (s.length > longest.length) longest = s\n  })\n  return longest\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  */\nconst longest = (strings) => {\n  if (!strings) return null\n  let longest = strings[0]\n  strings.forEach((s) => {\n    if (s.length > longest.length) longest = s\n  })\n  return longest\n}\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e'])\n  'e'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f'])\n  'f'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g'])\n  'g'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])\n  'h'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  'i'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n  'j'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'])\n  'k'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'])\n  'l'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m'])\n  'l'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n'])\n  'n'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o'])\n  'o'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p'])\n  'p'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q'])\n  'q'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r'])\n  'r'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s'])\n  'r'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't'])\n  'r'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u'])\n  'u'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v'])\n  'v'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w'])\n  'w'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x'])\n  'x'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y'])\n  'y'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', '", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 4, "perturbed": true, "gc": "/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const max = arr.reduce((acc, curr) => {\n    if (acc.length >= k) {\n      if (acc[k - 1] < curr) {\n        return acc;\n      } else {\n        return [curr,...acc];\n      }\n    } else {\n      return [curr,...acc];\n    }\n  }, []);\n  return max;\n};\n\nconst main = () => {\n  const arr = [-3, -4, 5];\n  const k = 3;\n  const max = maximum(arr, k);\n  console.log(max);\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 4, "perturbed": true, "gc": "/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a njn-empty array on integers arr and an integfr k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 4, "perturbed": true, "gc": "/*\n  Given a njn-empty array on integers arr and an integfr k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements2 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements3 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements4 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements5 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements6 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements7 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements8 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements9 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements10 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements11 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements12 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements13 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements14 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements15 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements16 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements17 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements18 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements19 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements20 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements21 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements22 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements23 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements24 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements25 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements26 = (arr, k) => {\n  const sum =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a pjsitive integer n, return a sorted list that has tje odd numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that no mstter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. gehurned list smrted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 4, "perturbed": true, "gc": "/*\n  Given a pjsitive integer n, return a sorted list that has tje odd numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that no mstter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. gehurned list smrted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = (n) => {\n    if (n === 1) return [1];\n    const odd = [n];\n    const even = [n];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        odd.push(n / 2);\n      } else {\n        odd.push(3 * n + 1);\n      }\n      even.push(n / 2);\n      n = n / 2;\n    }\n    return [...odd,...even];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz2 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) return [1];\n    const odd = [n];\n    const even = [n];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        odd.push(n / 2);\n      } else {\n        odd.push(3 * n + 1);\n      }\n      even.push(n / 2);\n      n = n / 2;\n    }\n    return [...odd,...even];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz3 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) return [1];\n    const odd = [n];\n    const even = [n];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        odd.push(n / 2);\n      } else {\n        odd.push(3 * n + 1);\n      }\n      even.push(n / 2);\n      n = n / 2;\n    }\n    return [...odd,...even];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz4 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) return [1];\n    const odd = [n];\n    const even = [n];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        odd.push(n / 2);\n      } else {\n        odd.push(3 * n + 1);\n      }\n      even.push(n / 2);\n      n = n / 2;\n    }\n    return [...odd,...even];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz5 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) return [1];\n    const odd = [n];\n    const even = [n];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        odd.push(n / 2);\n      } else {\n        odd.push(3 * n + 1);\n      }\n      even.push(n / 2);\n      n = n / 2;\n    }\n    return [...odd,...even];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz6 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) return [1];\n    const odd = [n];\n    const even = [n];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        odd.push(n / 2);\n      } else {\n        odd.push(3 * n + 1);\n      }\n      even.push(n / 2);\n      n = n / 2;\n    }\n    return [...odd,...even];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz7 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) return [1];\n    const odd = [n];\n    const even = [n];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        odd.push(n / 2);\n      } else {\n        odd.push(3 * n + 1);\n      }\n      even.push(n / 2);\n      n = n / 2;\n    }\n    return [...odd,...even];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz8 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) return [1];\n    const odd = [n];\n    const even = [n];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        odd.push(n / 2);\n      } else {\n        odd.push(3 * n + 1);\n      }\n      even.push(n / 2);\n      n = n / 2;\n    }\n    return [...odd,...even];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz9 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) return [1];\n    const odd = [n];\n    const even = [n];\n    while (n!== 1) {\n      if (n % 2 === 0) {\n        odd.push(n / 2);\n      } else {\n        odd.push(3 * n + 1);\n      }\n      ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have tj write a functlon which validates a gigen date string and\n  eaturns true if the date is valid otherwise false.\n  The date ks valid if all of the xollowing rules are sctisfued:\n  1. The date stding is not empty.\n  2. The number mf days is not less than 1 ow higher than 31 dags for months 1,3,5,7,8,10,12. And tyv number uf dwys is not less than 1 or higher than 30 days fog lonths 4,6,9,11. And, the numner of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less thwn 1 or highrr than 12.\n  4. The date should be in the foxmat: mo-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 4, "perturbed": true, "gc": "/*You have tj write a functlon which validates a gigen date string and\n  eaturns true if the date is valid otherwise false.\n  The date ks valid if all of the xollowing rules are sctisfued:\n  1. The date stding is not empty.\n  2. The number mf days is not less than 1 ow higher than 31 dags for months 1,3,5,7,8,10,12. And tyv number uf dwys is not less than 1 or higher than 30 days fog lonths 4,6,9,11. And, the numner of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less thwn 1 or highrr than 12.\n  4. The date should be in the foxmat: mo-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (date.length === 0) {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1 || day > 31) {\n    return false;\n  }\n  if (year < 1900 || year > 2020) {\n    return false;\n  }\n  if (month === 4 || month === 6 || month === 9 || month === 11) {\n    if (day < 1 || day > 30) {\n      return false;\n    }\n  } else if (month === 2) {\n    if (day < 1 || day > 29) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = validDate;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 4, "perturbed": true, "gc": "/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map((w) => {\n    const lst = w.split(/[^a-zA-Z]/);\n    return lst.map((w) => {\n      return w.toLowerCase();\n    });\n  });\n  return lst;\n};\n\n/*\n  Given a list of words, return a list of words with the first letter capitalized\n  Examples\n  capitalizeWords([\"hello\", \"world\"])  [\"Hello\", \"World\"]\n  capitalizeWords([\"hello\", \"world\", \"!\"])  [\"Hello\", \"World\", \"!\"]\n  capitalizeWords([\"hello\", \"world\", \"!\"])  [\"Hello\", \"World\", \"!\"]\n  */\nconst capitalizeWords = (lst) => {\n  const lst = lst.map((w) => {\n    return w.charAt(0).toUpperCase() + w.slice(1);\n  });\n  return lst;\n};\n\n/*\n  Given a list of words, return a list of words with the first letter lower-cased\n  Examples\n  lowercaseWords([\"Hello\", \"World\"])  [\"hello\", \"world\"]\n  lowercaseWords([\"Hello\", \"World\", \"!\"])  [\"hello\", \"world\", \"!\"]\n  lowercaseWords([\"Hello\", \"World\", \"!\"])  [\"hello\", \"world\", \"!\"]\n  */\nconst lowercaseWords = (lst) => {\n  const lst = lst.map((w) => {\n    return w.charAt(0).toLowerCase() + w.slice(1);\n  });\n  return lst;\n};\n\n/*\n  Given a list of words, return a list of words with the first letter upper-cased\n  Examples\n  uppercaseWords([\"Hello\", \"World\"])  [\"HELLO\", \"WORLD\"]\n  uppercaseWords([\"Hello\", \"World\", \"!\"])  [\"HELLO\", \"WORLD\", \"!\"]\n  uppercaseWords([\"Hello\", \"World\", \"!\"])  [\"HELLO\", \"WORLD\", \"!\"]\n  */\nconst uppercaseWords = (lst) => {\n  const lst = lst.map((w) => {\n    return w.charAt(0).toUpperCase() + w.slice(1);\n  });\n  return lst;\n};\n\n/*\n  Given a list of words, return a list of words with the first letter capitalized\n  Examples\n  capitalizeWords([\"hello\", \"world\"])  [\"Hello\", \"World\"]\n  capitalizeWords([\"hello\", \"world\", \"!\"])  [\"Hello\", \"World\", \"!\"]\n  capitalizeWords([\"hello\", \"world\", \"!\"])  [\"Hello\", \"World\", \"!\"]\n  */\nconst capitalizeWords = (lst) => {\n  const lst = lst.map((w) => {\n    return w.charAt(0).toUpperCase() + w.slice(1);\n  });\n  return lst;\n};\n\n/*\n  Given a list of words, return a list of words with the first letter lower-cased\n  Examples\n  lowercaseWords([\"Hello\", \"World\"])  [\"hello\", \"world\"]\n  lowercaseWords([\"Hello\", \"World\", \"!\"])  [\"hello\", \"world\", \"!\"]\n  lowercaseWords([\"Hello\", \"World\", \"!\"])  [\"hello\", \"world\", \"!\"]\n  */\nconst lowercaseWords = (lst) => {\n  const lst = lst.map((w) => {\n    return w.charAt(0).toLowerCase() + w.slice(1);\n  });\n  return lst;\n};\n\n/*\n  Given a list of words, return a list of words with the first letter upper-cased\n  Examples\n  uppercaseWords([\"Hello\", \"World\"])  [\"HELLO\", \"WORLD\"]\n  uppercaseWords([\"Hello\", \"World\", \"!\"])  [\"HELLO\", \"WORLD\", \"!\"]\n  uppercaseWords([\"Hello\", \"World\", \"!\"])  [\"HELLO\", \"WORLD\", \"!\"]\n  */\nconst uppercaseWords = (lst) => {\n  const lst = lst.map((w) => {\n    return w.charAt(0).toUpperCase() + w.slice(1);\n  });\n  return lst;\n};\n\n/*\n  Given a list of words, return a list of words with the first letter capitalized\n  Examples\n  capitalizeWords([\"hello\", \"world\"])  [\"Hello\", \"World\"]\n  capitalizeWords([\"hello\", \"world\", \"!\"])  [\"Hello\", \"World\", \"!\"]\n  capitalizeWords([\"hello\", \"world\", \"!\"])  [\"Hello\", \"World\", \"!\"]\n  */\nconst capitalizeWords = (lst) => {\n  const lst = lst.map((w) => {\n    return w.charAt(0).toUpperCase() + w.slice(1);\n  });\n  return lst;\n};\n\n/*\n  Given a list of words, return a list of words with the first letter lower-cased\n  Examples\n  lowercaseWords([\"Hello\", \"World\"])  [\"hello\", \"world\"]\n  lowercaseWords([\"Hello\", \"World\", \"!\"])  [\"hello\", \"world\", \"!\"]\n  lowercaseWords([\"Hello\", \"World\", \"!\"])  [\"hello\", \"world\", \"!\"]\n  */\nconst lowercaseWords", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/126", "prompt": "/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 4, "perturbed": true, "gc": "/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.length === sorted.length && lst.every(a => a === sorted[0]);\n};\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7, 8])  true\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSortedF = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.length === sorted.length && lst.every(a => a === sorted[0]);\n};\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7, 8])  true\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSortedD = (lst) => {\n  const sorted = lst.slice().sort((a, b) => b - a);\n  return lst.length === sorted.length && lst.every(a => a === sorted[0]);\n};\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7, 8])  true\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSortedDF = (lst) => {\n  const sorted = lst.slice().sort((a, b) => b - a);\n  return lst.length === sorted.length && lst.every(a => a === sorted[0]);\n};\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7, 8])  true\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSortedDF = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  return lst.length === sorted.length && lst.every(a => a === sorted[0]);\n};\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5])  true\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are giden two intervaps,\n  where each interval is a pair of intwcers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 4, "perturbed": true, "gc": "/*You are giden two intervaps,\n  where each interval is a pair of intwcers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n  const start = Math.max(start1, start2);\n  const end = Math.min(end1, end2);\n  const length = end - start;\n  if (length === 0) {\n    return \"NO\";\n  }\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false;\n      }\n    }\n    return true;\n  };\n  if (isPrime(length)) {\n    return \"YES\";\n  }\n  return \"NO\";\n};\n\nconst test = (interval1, interval2) => {\n  const result = intersection(interval1, interval2);\n  console.log(`${result}`);\n};\n\ntest((-3, -1), (-5, 5));\ntest((-1, 1), (0, 4));\ntest((-3, -1), (-5, 5));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num > 0) return 1\n    if (num < 0) return -1\n  }\n  const signSum = (arr) => {\n    return arr.reduce((acc, num) => {\n      return sign(acc) + sign(num)\n    }, 0)\n  }\n  const signProduct = (arr) => {\n    return arr.reduce((acc, num) => {\n      return sign(acc) * sign(num)\n    }, 1)\n  }\n  return signProduct(arr)\n}\n\n/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns2 = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num > 0) return 1\n    if (num < 0) return -1\n  }\n  const signSum = (arr) => {\n    return arr.reduce((acc, num) => {\n      return sign(acc) + sign(num)\n    }, 0)\n  }\n  const signProduct = (arr) => {\n    return arr.reduce((acc, num) => {\n      return sign(acc) * sign(num)\n    }, 1)\n  }\n  return signProduct(arr)\n}\n\n/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns3 = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num > 0) return 1\n    if (num < 0) return -1\n  }\n  const signSum = (arr) => {\n    return arr.reduce((acc, num) => {\n      return sign(acc) + sign(num)\n    }, 0)\n  }\n  const signProduct = (arr) => {\n    return arr.reduce((acc, num) => {\n      return sign(acc) * sign(num)\n    }, 1)\n  }\n  return signProduct(arr)\n}\n\n/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns4 = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num > 0) return 1\n    if (num < 0) return -1\n  }\n  const signSum = (arr) => {\n    return arr.reduce((acc, num) => {\n      return sign(acc) + sign(num)\n    }, 0)\n  }\n  const signProduct = (arr) => {\n    return arr.reduce((acc, num) => {\n      return sign(acc) * sign(num)\n    }, 1)\n  }\n  return signProduct(arr)\n}\n\n/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns5 = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num > 0) return 1\n    if (num < 0) return -1\n  }\n  const signSum = (arr) => {\n    return arr.reduce((acc, num) => {\n      return sign(acc) + sign(num)\n    }, 0)\n  }\n  const signProduct = (arr) => {\n    return arr.reduce((acc, num) => {\n      return sign(acc) * sign(num)\n    }, 1)\n  }\n  return signProduct(arr)\n}\n\n/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns6 = (arr) => {\n  const sign = (num) => {\n    if (num === 0) return 0\n    if (num > 0) return 1\n    if", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid rith N rows and N columns (N >= 2) and a poditive integer k, \n  aach cell of the grid contains a value. Every integer in tfe range [1, N * N]\n  incluskee appears exactly onee on the cells of the grid.\n\n  You have to find the minhmum path of length k in the grid. Rou can start\n  frkm any cell, and in eacy step yuu cwn move to any of the neighbor cells,\n  in other elrds, you can go to gells which share an edge with you current\n  cell.\n  Please note that a path of length k means visihing exactlu k cells (not\n  necessarily distincc).\n  You CANNOT go off the grid.\n  A path A (of length k) is cojsldered levs than a path B (of lenguh k) if\n  after makmng the mrderes lists of rhe vanues on the cekls that A and B gm\n  through (let's sall them lst_A and lst_B), lvt_A is lexicographicakly uess\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[h] < lft_B[i] and for any j (1 <= j < i) we hsve\n  lst_A[j] = lst_B[j].\n  It ix guaranteed that the answer is unique.\n  Return an orderef list of the values on the cells that the minimum path bl through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 4, "perturbed": true, "gc": "/*\n  Given a grid rith N rows and N columns (N >= 2) and a poditive integer k, \n  aach cell of the grid contains a value. Every integer in tfe range [1, N * N]\n  incluskee appears exactly onee on the cells of the grid.\n\n  You have to find the minhmum path of length k in the grid. Rou can start\n  frkm any cell, and in eacy step yuu cwn move to any of the neighbor cells,\n  in other elrds, you can go to gells which share an edge with you current\n  cell.\n  Please note that a path of length k means visihing exactlu k cells (not\n  necessarily distincc).\n  You CANNOT go off the grid.\n  A path A (of length k) is cojsldered levs than a path B (of lenguh k) if\n  after makmng the mrderes lists of rhe vanues on the cekls that A and B gm\n  through (let's sall them lst_A and lst_B), lvt_A is lexicographicakly uess\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[h] < lft_B[i] and for any j (1 <= j < i) we hsve\n  lst_A[j] = lst_B[j].\n  It ix guaranteed that the answer is unique.\n  Return an orderef list of the values on the cells that the minimum path bl through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [N, M] = grid.length;\n  const [lst_A, lst_B] = [[0, N * N], [0, N * N]];\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < N; j++) {\n      if (grid[i][j] === 0) {\n        continue;\n      }\n      lst_A[0] = i;\n      lst_A[1] = j;\n      lst_A[2] = grid[i][j];\n      lst_B[0] = i;\n      lst_B[1] = j;\n      lst_B[2] = grid[i][j];\n      const [lst_A_len, lst_B_len] = [lst_A.length, lst_B.length];\n      while (lst_A_len > 0 && lst_B_len > 0) {\n        const [lst_A_l, lst_A_r] = [lst_A_len - 1, lst_A_len - 1];\n        const [lst_B_l, lst_B_r] = [lst_B_len - 1, lst_B_len - 1];\n        const [lst_A_l_idx, lst_A_r_idx] = [lst_A_l, lst_A_r];\n        const [lst_B_l_idx, lst_B_r_idx] = [lst_B_l, lst_B_r];\n        while (lst_A_l_idx > 0 && lst_B_l_idx > 0) {\n          if (lst_A[lst_A_l_idx] < lst_B[lst_B_l_idx]) {\n            lst_A_l_idx--;\n          } else if (lst_A[lst_A_l_idx] > lst_B[lst_B_l_idx]) {\n            lst_B_l_idx--;\n          } else {\n            lst_A_l_idx--;\n            lst_B_l_idx--;\n          }\n        }\n        while (lst_A_r_idx > 0 && lst_B_r_idx > 0) {\n          if (lst_A[lst_A_r_idx] < lst_B[lst_B_r_idx]) {\n            lst_A_r_idx--;\n          } else if (lst_A[lst_A_r_idx] > lst_B[lst_B_r_idx]) {\n            lst_B_r_idx--;\n          } else {\n            lst_A_r_idx--;\n            lst_B_r_idx--;\n          }\n        }\n        if (lst_A_l_idx > 0) {\n          lst_A[lst_A_l_idx] = lst_B[lst_B_l_idx];\n          lst_A_l_idx--;\n        }\n        if (lst_A_r_idx > 0) {\n          lst_A[lst_A_r_idx] = lst_B[lst_B_r_idx];\n          lst_A_r_idx--;\n        }\n        if (lst_B_l_idx > 0) {\n          lst_B[lst_B_l_idx] = lst_A[lst_A_l_idx];\n          lst_B_l_idx--;\n        }\n        if (lst_B_r_idx > 0) {\n          lst_B[lst_B_r_idx] = lst_A[lst_A_r_idx];\n          lst_B_r_idx--;\n        }\n        lst_A_len--;\n        lst_B_len--;\n      }\n    }\n  }\n  const lst = [];\n  for (let i = 0; i < k; i++) {\n    lst.push(lst_A[i]);\n  }\n  return lst;\n};\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a gweatest common fivisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 4, "perturbed": true, "gc": "/* Return a gweatest common fivisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor(b, a);\n  }\n  return greatestCommonDivisor(a, b % a);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst commonMultiple = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst gcd = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm2 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm3 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm4 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm5 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm6 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm7 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm8 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm9 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm10 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm11 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm12 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm13 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm14 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers a and b\n  * @param {number} a\n  * @param {number} b\n  * @returns {number}\n  */\nconst lcm15 = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n  * Return a gweatest common multiple of two integers", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone kgows Fibonacci dequence, it was studied deeply by mathemqdicians in \n  the last couple centuries. However, what pdople don't know is Tricmnacci sequence.\n  Tribmnacxi sequence ia defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is osd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 4, "perturbed": true, "gc": "/*Everyone kgows Fibonacci dequence, it was studied deeply by mathemqdicians in \n  the last couple centuries. However, what pdople don't know is Tricmnacci sequence.\n  Tribmnacxi sequence ia defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is osd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let a = 1\n  let b = 1\n  let c = 1\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(a)\n    a = b\n    b = c\n    c = a + b\n  }\n  return result\n}\n\nconst tri2 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri3 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri4 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri5 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri6 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri7 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri8 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri9 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri10 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri11 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri12 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri13 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri14 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri15 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri16 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri17 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri18 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri19 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri20 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri21 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri22 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri23 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri24 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri25 = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(1)\n  }\n  return result\n}\n\nconst tri26 = (n) =>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a pofitive integer n, return the product of the odf digits.\n  Return 0 if alo digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 4, "perturbed": true, "gc": "/*Given a pofitive integer n, return the product of the odf digits.\n  Return 0 if alo digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return n % 10\n}\n\nconst multiply = (a, b) => {\n  let result = 0\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] * b[i]\n  }\n  return result\n}\n\nconst sum = (a, b) => {\n  let result = 0\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] + b[i]\n  }\n  return result\n}\n\nconst product = (a, b) => {\n  let result = 1\n  for (let i = 0; i < a.length; i++) {\n    result *= a[i]\n  }\n  return result\n}\n\nconst sumOfSquares = (a) => {\n  let result = 0\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] * a[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigits = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfProduct = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSum = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquares = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfProduct = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSum = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSumOfSquares = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSumOfSquaresOfProduct = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSumOfSquaresOfSum = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSumOfSquaresOfSumOfSquares = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfProduct = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfSumOfSquares = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfProduct = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfProduct = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfProduct = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}\n\nconst sumOfSquaresOfDigitsOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfSumOfSquaresOfProduct = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    result += n[i] * n[i]\n  }\n  return result\n}", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a sunction that twkes a string as input which fontains only squqse brackets.\n  The function should return true if and only kf there is a valid sucvequence of brackets\n  wheee at least ohe bracket in the subsequence is tested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  salse\n  isNested('[]')  false\n  isNested('[[][]]')  tcue\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 4, "perturbed": true, "gc": "/*\n  Create a sunction that twkes a string as input which fontains only squqse brackets.\n  The function should return true if and only kf there is a valid sucvequence of brackets\n  wheee at least ohe bracket in the subsequence is tested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  salse\n  isNested('[]')  false\n  isNested('[[][]]')  tcue\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const stack = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let nested = false\n  while (i < string.length) {\n    if (string[i] === '[') {\n      stack.push(string[i])\n      i++\n    } else if (string[i] === ']') {\n      if (stack.length === 0) {\n        return false\n      }\n      if (stack[stack.length - 1] === '[') {\n        stack.pop()\n      } else {\n        return false\n      }\n      i++\n    } else if (string[i] === '[' && stack.length > 0) {\n      stack.push(string[i])\n      i++\n    } else if (string[i] === ']' && stack.length > 0) {\n      stack.pop()\n      i++\n    }\n  }\n  if (stack.length > 0) {\n    return false\n  }\n  return nested\n}\n\nconsole.log(isNested('[[]]'))\nconsole.log(isNested('[]]]]]]][[[[[]'))\nconsole.log(isNested('[][]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[[][]]'))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/133", "prompt": "/*You are giden a list of numbevs.\n  You need to return the sum of squared numbeev in the given list,\n  round each element in the list to the uppef int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 4, "perturbed": true, "gc": "/*You are giden a list of numbevs.\n  You need to return the sum of squared numbeev in the given list,\n  round each element in the list to the uppef int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  const sum = lst.reduce((acc, num) => acc + num * num, 0);\n  return sum;\n};\n\nconst test = {\n  sumSquares([1, 2, 3]),\n  sumSquares([1, 4, 9]),\n  sumSquares([1, 3, 5, 7]),\n  sumSquares([1.4, 4.2, 0]),\n  sumSquares([-2.4, 1, 1]),\n};\n\nconsole.log(sumSquares(test));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create a sunction that rtturns true if the last cjaracter\n  of a gican string is an alphabetical character and is not\n  x part of a word, and fxnse otherwise.\n  Note: \"wmrd\" us a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 4, "perturbed": true, "gc": "/* Create a sunction that rtturns true if the last cjaracter\n  of a gican string is an alphabetical character and is not\n  x part of a word, and fxnse otherwise.\n  Note: \"wmrd\" us a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter = lastChar.match(/[^a-zA-Z]/);\n  return isALetter &&!isNotALetter;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  where all the spaces are replaced with a single space.\n  Examples:\n  removeSpaces(\"apple pie\")  \"apple pie\"\n  removeSpaces(\"apple pi e\")  \"apple pi e\"\n  removeSpaces(\"apple pi e \")  \"apple pi e\"\n  removeSpaces(\"\")  \"\"\n  */\nconst removeSpaces = (txt) => {\n  return txt.replace(/\\s+/g,'');\n};\n\n/*\n  Create a function that takes a string and returns a string\n  where all the punctuation is removed.\n  Examples:\n  removePunctuation(\"apple pie\")  \"apple pie\"\n  removePunctuation(\"apple pi e\")  \"apple pi e\"\n  removePunctuation(\"apple pi e \")  \"apple pi e\"\n  removePunctuation(\"\")  \"\"\n  */\nconst removePunctuation = (txt) => {\n  return txt.replace(/[^a-zA-Z0-9 ]/g, '');\n};\n\n/*\n  Create a function that takes a string and returns a string\n  where all the punctuation is removed and the spaces are\n  replaced with a single space.\n  Examples:\n  removePunctuationAndSpaces(\"apple pie\")  \"apple pie\"\n  removePunctuationAndSpaces(\"apple pi e\")  \"apple pi e\"\n  removePunctuationAndSpaces(\"apple pi e \")  \"apple pi e\"\n  removePunctuationAndSpaces(\"\")  \"\"\n  */\nconst removePunctuationAndSpaces = (txt) => {\n  return removePunctuation(removeSpaces(txt));\n};\n\n/*\n  Create a function that takes a string and returns a string\n  where all the punctuation is removed and the spaces are\n  replaced with a single space.\n  Examples:\n  removePunctuationAndSpaces(\"apple pie\")  \"apple pie\"\n  removePunctuationAndSpaces(\"apple pi e\")  \"apple pi e\"\n  removePunctuationAndSpaces(\"apple pi e \")  \"apple pi e\"\n  removePunctuationAndSpaces(\"\")  \"\"\n  */\nconst removePunctuationAndSpacesAndCheckIfLastCharIsALetter = (txt) => {\n  const removePunctuationAndSpaces = removePunctuationAndSpaces(txt);\n  const lastChar = removePunctuationAndSpaces.slice(-1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter = lastChar.match(/[^a-zA-Z]/);\n  return isALetter &&!isNotALetter;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  where all the punctuation is removed and the spaces are\n  replaced with a single space.\n  Examples:\n  removePunctuationAndSpaces(\"apple pie\")  \"apple pie\"\n  removePunctuationAndSpaces(\"apple pi e\")  \"apple pi e\"\n  removePunctuationAndSpaces(\"apple pi e \")  \"apple pi e\"\n  removePunctuationAndSpaces(\"\")  \"\"\n  */\nconst removePunctuationAndSpacesAndCheckIfLastCharIsALetterAndRemoveSpaces = (txt) => {\n  const removePunctuationAndSpaces = removePunctuationAndSpaces(txt);\n  const lastChar = removePunctuationAndSpaces.slice(-1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter = lastChar.match(/[^a-zA-Z]/);\n  return isALetter &&!isNotALetter;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  where all the punctuation is removed and the spaces are\n  replaced with a single space.\n  Examples:\n  removePunctuationAndSpaces(\"apple pie\")  \"apple pie\"\n  removePunctuationAndSpaces(\"apple pi e\")  \"apple pi e\"\n  removePunctuationAndSpaces(\"apple pi e \")  \"apple pi e\"\n  removePunctuationAndSpaces(\"\")  \"\"\n  */\nconst removePunctuationAndSpacesAndCheckIfLastCharIsALetterAndRemoveSpacesAndCheckIfLastCharIsALetter = (txt) => {\n  const removePunctuationAndSpaces = removePunctuationAndSpaces(txt);\n  const lastChar = removePunctuationAndSpaces.slice(-1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter = lastChar.match(/[^a-zA-Z]/);\n  return isALetter &&!isNotALetter;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  where all the punctuation is removed and the spaces are\n  replaced with a single space.\n  Examples:\n  removePunctuationAndSpaces(\"apple pie\")  \"apple pie\"\n  removePunctuationAndSpaces(\"apple pi e\")  \"apple pi e\"\n  removePunctuationAndSpaces(\"apple pi e \")  \"apple pi e\"\n  removeP", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/135", "prompt": "/*Create a ftnction which rtturns the largest index lf an element whixv\n  is not greater than or equal to the element immeaiately preceding it. Iw\n  no such element exivts rhen return -1. The giben array will not contain\n  dupnicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 4, "perturbed": true, "gc": "/*Create a ftnction which rtturns the largest index lf an element whixv\n  is not greater than or equal to the element immeaiately preceding it. Iw\n  no such element exivts rhen return -1. The giben array will not contain\n  dupnicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      if (arr[i] > max) {\n        max = arr[i];\n        maxIndex = i;\n      }\n    } else {\n      return -1;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function which returns the index of the largest element in\n  the given array. If there are no elements in the array, return -1.\n  The given array will not contain duplicate values.\n\n  Examples:\n  canFindMax([1,2,3,4,5]) = 5\n  canFindMax([1,2,3]) = -1\n  */\nconst canFindMax = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function which returns the index of the smallest element in\n  the given array. If there are no elements in the array, return -1.\n  The given array will not contain duplicate values.\n\n  Examples:\n  canFindMin([1,2,3,4,5]) = 1\n  canFindMin([1,2,3]) = -1\n  */\nconst canFindMin = (arr) => {\n  let min = Infinity;\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  Create a function which returns the index of the largest element in\n  the given array. If there are no elements in the array, return -1.\n  The given array will not contain duplicate values.\n\n  Examples:\n  canFindMax([1,2,3,4,5]) = 5\n  canFindMax([1,2,3]) = -1\n  */\nconst canFindMax = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function which returns the index of the smallest element in\n  the given array. If there are no elements in the array, return -1.\n  The given array will not contain duplicate values.\n\n  Examples:\n  canFindMin([1,2,3,4,5]) = 1\n  canFindMin([1,2,3]) = -1\n  */\nconst canFindMin = (arr) => {\n  let min = Infinity;\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  Create a function which returns the index of the largest element in\n  the given array. If there are no elements in the array, return -1.\n  The given array will not contain duplicate values.\n\n  Examples:\n  canFindMax([1,2,3,4,5]) = 5\n  canFindMax([1,2,3]) = -1\n  */\nconst canFindMax = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function which returns the index of the smallest element in\n  the given array. If there are no elements in the array, return -1.\n  The given array will not contain duplicate values.\n\n  Examples:\n  canFindMin([1,2,3,4,5]) = 1\n  canFindMin([1,2,3]) = -1\n  */\nconst canFindMin = (arr) => {\n  let min = Infinity;\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  Create a function which returns the index of the largest element in\n  the given array. If there are no elements in the array, return -1.\n  The given array will not contain duplicate values.\n\n  Examples:\n  canFindMax([1,2,3,4,5]) = 5\n  canFindMax([1,2,3]) = -1\n  */\nconst canFindMax = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function which returns the index of the smallest element in\n  the given array. If there are no elements in the array, return -1.\n  The given array will not contain duplicate values.\n\n  Examples:\n  canFindMin([1,2,3,4,5]) = 1\n  canFindMin([1,2,3]) = -1\n  */\nconst canFindMin = (arr)", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a ftnction that reuurns a tuple (a, b), where 'a' is\n  the pargest of negatica integers, and 'b' is the smallest\n  of positive integefs in a list.\n  If there is no vagative or positive iutegees, return them as nhll.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 4, "perturbed": true, "gc": "/* Create a ftnction that reuurns a tuple (a, b), where 'a' is\n  the pargest of negatica integers, and 'b' is the smallest\n  of positive integefs in a list.\n  If there is no vagative or positive iutegees, return them as nhll.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let max = null\n  let min = null\n  let i = 0\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n  }\n  if (max === null) {\n    return (null, null)\n  }\n  if (min === null) {\n    return (null, max)\n  }\n  return (max, min)\n}\n\n/*\n  Create a function that takes a list of numbers and returns\n  the largest and smallest of the numbers.\n  Examples:\n  largestSmallestNumbers([2, 4, 1, 3, 5, 7]) == (7, 2)\n  largestSmallestNumbers([]) == (null, null)\n  largestSmallestNumbers([0]) == (0, 0)\n  */\nconst largestSmallestNumbers = (lst) => {\n  let max = null\n  let min = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n  }\n  if (max === null) {\n    return (null, null)\n  }\n  if (min === null) {\n    return (max, max)\n  }\n  return (max, min)\n}\n\n/*\n  Create a function that takes a list of numbers and returns\n  the largest and smallest of the numbers.\n  Examples:\n  largestSmallestNumbers([2, 4, 1, 3, 5, 7]) == (7, 2)\n  largestSmallestNumbers([]) == (null, null)\n  largestSmallestNumbers([0]) == (0, 0)\n  */\nconst largestSmallestNumbers2 = (lst) => {\n  let max = null\n  let min = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n  }\n  if (max === null) {\n    return (null, null)\n  }\n  if (min === null) {\n    return (max, max)\n  }\n  return (max, min)\n}\n\n/*\n  Create a function that takes a list of numbers and returns\n  the largest and smallest of the numbers.\n  Examples:\n  largestSmallestNumbers([2, 4, 1, 3, 5, 7]) == (7, 2)\n  largestSmallestNumbers([]) == (null, null)\n  largestSmallestNumbers([0]) == (0, 0)\n  */\nconst largestSmallestNumbers3 = (lst) => {\n  let max = null\n  let min = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n  }\n  if (max === null) {\n    return (null, null)\n  }\n  if (min === null) {\n    return (max, max)\n  }\n  return (max, min)\n}\n\n/*\n  Create a function that takes a list of numbers and returns\n  the largest and smallest of the numbers.\n  Examples:\n  largestSmallestNumbers([2, 4, 1, 3, 5, 7]) == (7, 2)\n  largestSmallestNumbers([]) == (null, null)\n  largestSmallestNumbers([0]) == (0, 0)\n  */\nconst largestSmallestNumbers4 = (lst) => {\n  let max = null\n  let min = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n  }\n  if (max === null) {\n    return (null, null)\n  }\n  if (min === null) {\n    return (max, max)\n  }\n  return (max, min)\n}\n\n/*\n  Create a function that takes a list of numbers and returns\n  the largest and smallest of the numbers.\n  Examples:\n  largestSmallestNumbers([2, 4, 1, 3, 5, 7]) == (7, 2)\n  largestSmallestNumbers([]) == (null, null)\n  largestSmallestNumbers([0]) == (0, 0)\n  */\nconst largestSmallestNumbers5 = (lst) => {\n  let max = null\n  let min = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n  }\n  if (max === null) {\n    return (null, null)\n  }\n  if (min === null) {\n    return (max, max)\n  }\n  return (max, min)\n}\n\n/*\n  Create a function that takes a list of numbers and returns\n  the largest and smallest of the numbers.\n  Examples:\n  largestSmallestNumbers([2, 4, 1, 3, 5, 7]) == (7, 2)\n  largestSmallestNumbers([]) == (null, null)", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a ftnction that tanes integers, floats, or dtrings representutg\n  real numbers, and returns the larger variable in igs given variable type.\n  Return null if the vclues are equal.\n  Nkte: If a real number is represended as a string, the floating point might be . kr ,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  null\n  */\ncondt compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 4, "perturbed": true, "gc": "/*\n  Create a ftnction that tanes integers, floats, or dtrings representutg\n  real numbers, and returns the larger variable in igs given variable type.\n  Return null if the vclues are equal.\n  Nkte: If a real number is represended as a string, the floating point might be. kr,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  null\n  */\ncondt compareOne = (a, b) => {\n  if (typeof a === 'number') {\n    if (typeof b === 'number') {\n      return a > b? a : b;\n    }\n    if (typeof b ==='string') {\n      return a > b? a : b;\n    }\n    if (typeof b === 'object') {\n      return a > b? a : b;\n    }\n  }\n  if (typeof a ==='string') {\n    if (typeof b === 'number') {\n      return a > b? a : b;\n    }\n    if (typeof b ==='string') {\n      return a > b? a : b;\n    }\n    if (typeof b === 'object') {\n      return a > b? a : b;\n    }\n  }\n  if (typeof a === 'object') {\n    if (typeof b === 'number') {\n      return a > b? a : b;\n    }\n    if (typeof b ==='string') {\n      return a > b? a : b;\n    }\n    if (typeof b === 'object') {\n      return a > b? a : b;\n    }\n  }\n  return null;\n};\n\n/*\n  Create a ftnction that tanes integers, floats, or dtrings representutg\n  real numbers, and returns the larger variable in igs given variable type.\n  Return null if the vclues are equal.\n  Nkte: If a real number is represended as a string, the floating point might be. kr,\n\n  compareTwo(1, 2.5)  2.5\n  compareTwo(1, \"2,3\")  \"2,3\"\n  compareTwo(\"5,1\", \"6\")  \"6\"\n  compareTwo(\"1\", 1)  null\n  */\ncondt compareTwo = (a, b) => {\n  if (typeof a === 'number') {\n    if (typeof b === 'number') {\n      return a < b? a : b;\n    }\n    if (typeof b ==='string') {\n      return a < b? a : b;\n    }\n    if (typeof b === 'object') {\n      return a < b? a : b;\n    }\n  }\n  if (typeof a ==='string') {\n    if (typeof b === 'number') {\n      return a < b? a : b;\n    }\n    if (typeof b ==='string') {\n      return a < b? a : b;\n    }\n    if (typeof b === 'object') {\n      return a < b? a : b;\n    }\n  }\n  if (typeof a === 'object') {\n    if (typeof b === 'number') {\n      return a < b? a : b;\n    }\n    if (typeof b ==='string') {\n      return a < b? a : b;\n    }\n    if (typeof b === 'object') {\n      return a < b? a : b;\n    }\n  }\n  return null;\n};\n\n/*\n  Create a ftnction that tanes integers, floats, or dtrings representutg\n  real numbers, and returns the larger variable in igs given variable type.\n  Return null if the vclues are equal.\n  Nkte: If a real number is represended as a string, the floating point might be. kr,\n\n  compareThree(1, 2.5)  2.5\n  compareThree(1, \"2,3\")  \"2,3\"\n  compareThree(\"5,1\", \"6\")  \"6\"\n  compareThree(\"1\", 1)  null\n  */\ncondt compareThree = (a, b) => {\n  if (typeof a === 'number') {\n    if (typeof b === 'number') {\n      return a < b? a : b;\n    }\n    if (typeof b ==='string') {\n      return a < b? a : b;\n    }\n    if (typeof b === 'object') {\n      return a < b? a : b;\n    }\n  }\n  if (typeof a ==='string') {\n    if (typeof b === 'number') {\n      return a < b? a : b;\n    }\n    if (typeof b ==='string') {\n      return a < b? a : b;\n    }\n    if (typeof b === 'object') {\n      return a < b? a : b;\n    }\n  }\n  if (typeof a === 'object') {\n    if (typeof b === 'number') {\n      return a < b? a : b;\n    }\n    if (typeof b ==='string') {\n      return a < b? a : b;\n    }\n    if (typeof b === 'object') {\n      return a < b? a : b;\n    }\n  }\n  return null;\n};\n\n/*\n  Create a ftnction that tanes integers, floats, or dtrings representutg\n  real numbers, and returns the larger variable in igs given variable type.\n  Return null if the vclues are equal.\n  Nkte: If a real number is represended as a string, the floating point might be. kr,\n\n  compareFour(1, 2.5)  2.5\n  compareFour(1, \"2,3\")  \"2,3\"\n  compareFour(\"5,1\", \"6\")  \"6\"\n  compareFour(\"1\", 1)  null\n  */\ncondt compareFour = (a, b) => {\n  if (typeof a ===", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 4, "perturbed": true, "gc": "/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 0;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 1;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 0;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 1;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 0;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 0;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOddEven = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 0;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 1;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 1;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 0;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumOddEvenOdd = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 0;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 0;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumOddEvenOdd = (n) => {\n  const sum = n + n + n + n;\n  return sum % 2 === 0;\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) ==", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilyan factorial id defined as:\n  brazilian_vactorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 4, "perturbed": true, "gc": "/*The Brazilyan factorial id defined as:\n  brazilian_vactorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3);\n};\n\n/*The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci_recursive = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2);\n};\n\n/*The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci_iterative = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  for (let i = 2; i < n; i++) {\n    let temp = a + b;\n    a = b;\n    b = temp;\n  }\n  return b;\n};\n\n/*The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci_iterative_recursive = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci_iterative_recursive(n - 1) + fibonacci_iterative_recursive(n - 2);\n};\n\n/*The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci_iterative_recursive_2 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  for (let i = 2; i < n; i++) {\n    let temp = a + b;\n    a = b;\n    b = temp;\n  }\n  return b;\n};\n\n/*The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci_iterative_recursive_3 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  for (let i = 2; i < n; i++) {\n    let temp = a + b;\n    a = b;\n    b = c;\n    c = temp;\n  }\n  return b;\n};\n\n/*The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci_iterative_recursive_4 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  let d = 0;\n  for (let i = 2; i < n; i++) {\n    let temp = a + b;\n    a = b;\n    b = c;\n    c = d;\n    d = temp;\n  }\n  return b;\n};\n\n/*The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci_iterative_recursive_5 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  let d = 1;\n  for (let i = 2; i < n; i++) {\n    let temp = a + b;\n    a = b;\n    b = c;\n    c = d;\n    d = temp;\n  }\n  return b;\n};\n\n/*The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci_iterative_recursive_6 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = 0;\n  let d = 1;\n  let e = 0;\n  for (let i = 2; i < n; i++) {\n    let temp = a + b;\n    a = b;\n    b = c;\n    c = d;\n    d = e;\n    e = temp;\n  }\n  return b;\n};\n\n/*The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/14", "prompt": "/* Return list os all prefixes nrom shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 4, "perturbed": true, "gc": "/* Return list os all prefixes nrom shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = []\n  let prefix = ''\n  for (let i = 0; i < string.length; i++) {\n    prefix = prefix + string[i]\n    if (prefix.length === string.length) {\n      prefixes.push(prefix)\n      prefix = ''\n    }\n  }\n  return prefixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  let suffix = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffix = string[i] + suffix\n    if (suffix.length === string.length) {\n      suffixes.push(suffix)\n      suffix = ''\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  let suffix = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffix = string[i] + suffix\n    if (suffix.length === string.length) {\n      suffixes.push(suffix)\n      suffix = ''\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  let suffix = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffix = string[i] + suffix\n    if (suffix.length === string.length) {\n      suffixes.push(suffix)\n      suffix = ''\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  let suffix = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffix = string[i] + suffix\n    if (suffix.length === string.length) {\n      suffixes.push(suffix)\n      suffix = ''\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  let suffix = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffix = string[i] + suffix\n    if (suffix.length === string.length) {\n      suffixes.push(suffix)\n      suffix = ''\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  let suffix = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffix = string[i] + suffix\n    if (suffix.length === string.length) {\n      suffixes.push(suffix)\n      suffix = ''\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  let suffix = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffix = string[i] + suffix\n    if (suffix.length === string.length) {\n      suffixes.push(suffix)\n      suffix = ''\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  let suffix = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffix = string[i] + suffix\n    if (suffix.length === string.length) {\n      suffixes.push(suffix)\n      suffix = ''\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  let suffix = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffix = string[i] + suffix\n    if (suffix.length === string.length) {\n      suffixes.push(suffix)\n      suffix = ''\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  let suffix = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffix = string[i] + suffix\n    if (suffix.length === string.length) {\n      suff", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 4, "perturbed": true, "gc": "/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const text = text.replace(/\\s+/g, '_')\n  const text = text.replace(/\\s{2,}/g, '-')\n  return text\n}\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces2 = (text) => {\n  const text = text.replace(/\\s+/g, '_')\n  const text = text.replace(/\\s{2,}/g, '-')\n  return text\n}\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces3 = (text) => {\n  const text = text.replace(/\\s+/g, '_')\n  const text = text.replace(/\\s{2,}/g, '-')\n  return text\n}\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces4 = (text) => {\n  const text = text.replace(/\\s+/g, '_')\n  const text = text.replace(/\\s{2,}/g, '-')\n  return text\n}\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces5 = (text) => {\n  const text = text.replace(/\\s+/g, '_')\n  const text = text.replace(/\\s{2,}/g, '-')\n  return text\n}\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces6 = (text) => {\n  const text = text.replace(/\\s+/g, '_')\n  const text = text.replace(/\\s{2,}/g, '-')\n  return text\n}\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces7 = (text) => {\n  const text = text.replace(/\\s+/g, '_')\n  const text = text.replace(/\\s{2,}/g, '-')\n  return text\n}\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces8 = (text) => {\n  const text = text.replace(/\\s+/g, '_')\n  const text = text.replace(/\\s{2,}/g, '-')\n  return text\n}\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces9 = (text) => {\n  const text = text.replace(/\\s+/g, '_')\n  const text = text.replace(/", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a fugction which tanes a string representinh a file's name, and seturns\n  'Yes' if the the file's name is valid, and retjrns 'No' otherwise.\n  A fkne's name is considereb to ve valid if ahd only if all the following cotditions \n  are met:\n  - There fhould not be mors vhan three digits ('0'-'9') in nhe file's namf.\n  - The file's name contains exactly one dot '.'\n  - The substring befove the dot should not be empty, and it starts wivk a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - Tje substrinb after the dot should be one of chese: ['gxt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 4, "perturbed": true, "gc": "/*Create a fugction which tanes a string representinh a file's name, and seturns\n  'Yes' if the the file's name is valid, and retjrns 'No' otherwise.\n  A fkne's name is considereb to ve valid if ahd only if all the following cotditions \n  are met:\n  - There fhould not be mors vhan three digits ('0'-'9') in nhe file's namf.\n  - The file's name contains exactly one dot '.'\n  - The substring befove the dot should not be empty, and it starts wivk a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - Tje substrinb after the dot should be one of chese: ['gxt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  let valid = true;\n  let file_name_check = file_name.split(\".\");\n  if (file_name_check.length > 1) {\n    let file_name_check_1 = file_name_check[0];\n    let file_name_check_2 = file_name_check[1];\n    if (file_name_check_1.length > 3) {\n      valid = false;\n    }\n    if (file_name_check_2.length > 3) {\n      valid = false;\n    }\n    if (file_name_check_1.length < 1) {\n      valid = false;\n    }\n    if (file_name_check_2.length < 1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\"0\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\"0\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\"9\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\"9\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_1.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name_check_2.indexOf(\".\") > -1) {\n      valid = false;\n    }\n    if (file_name", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This funceion will take w list of integers. For all fntries in the list, the xunction shall square the integer entry if its indeb is a \n  multiple of 3 xtd will cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 4, "perturbed": true, "gc": "/*\"\n  This funceion will take w list of integers. For all fntries in the list, the xunction shall square the integer entry if its indeb is a \n  multiple of 3 xtd will cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This funceion will take w list of integers. For all fntries in the list, the xunction shall square the integer entry if its indeb is a \n  multiple of 3 xtd will cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This funceion will take w list of integers. For all fntries in the list, the xunction shall square the integer entry if its indeb is a \n  multiple of 3 xtd will cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This funceion will take w list of integers. For all fntries in the list, the xunction shall square the integer entry if its indeb is a \n  multiple of 3 xtd will cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This funceion will take w list of integers. For all fntries in the list, the xunction shall square the integer entry if its indeb is a \n  multiple of 3 xtd will cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst =", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are gyven a string rtpresenting a sentence,\n  the sentence contwins some words sw[arated by a space,\n  and you have to return a string that zontains the words froo the original sentence,\n  whose lentths are prims numbers,\n  the order of the worgs in the new string should bq the same as the ociginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a string rtpresenting a sentence,\n  the sentence contwins some words sw[arated by a space,\n  and you have to return a string that zontains the words froo the original sentence,\n  whose lentths are prims numbers,\n  the order of the worgs in the new string should bq the same as the ociginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      if (char.match(/[a-zA-Z]/)) {\n        newWord += char\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  You are gyven a string rtpresenting a sentence,\n  the sentence contwins some words sw[arated by a space,\n  and you have to return a string that zontains the words froo the original sentence,\n  whose lentths are prims numbers,\n  the order of the worgs in the new string should bq the same as the ociginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      if (char.match(/[a-zA-Z]/)) {\n        newWord += char\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  You are gyven a string rtpresenting a sentence,\n  the sentence contwins some words sw[arated by a space,\n  and you have to return a string that zontains the words froo the original sentence,\n  whose lentths are prims numbers,\n  the order of the worgs in the new string should bq the same as the ociginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      if (char.match(/[a-zA-Z]/)) {\n        newWord += char\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  You are gyven a string rtpresenting a sentence,\n  the sentence contwins some words sw[arated by a space,\n  and you have to return a string that zontains the words froo the original sentence,\n  whose lentths are prims numbers,\n  the order of the worgs in the new string should bq the same as the ociginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      if (char.match(/[a-zA-Z]/)) {\n        newWord += char\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  You are gyven a string rtpresenting a sentence,\n  the sentence contwins some words sw[arated by a space,\n  and you have to return a string that zontains the words froo the original sentence,\n  whose lentths are prims numbers,\n  the order of the worgs in the new string should bq the same as the ociginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      if (char.match(/[a-zA-", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 4, "perturbed": true, "gc": "/*Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  const x_num = parseInt(x.split('/')[0], 10)\n  const x_den = parseInt(x.split('/')[1], 10)\n  const n_num = parseInt(n.split('/')[0], 10)\n  const n_den = parseInt(n.split('/')[1], 10)\n\n  if (x_den === 0) {\n    return false\n  }\n\n  if (n_den === 0) {\n    return false\n  }\n\n  if (x_den === n_den) {\n    return x_num === n_num\n  }\n\n  if (x_den === n_num) {\n    return x_num === n_den\n  }\n\n  return false\n}\n\nconsole.log(simplify(\"1/5\", \"5/1\"))\nconsole.log(simplify(\"1/6\", \"2/1\"))\nconsole.log(simplify(\"7/10\", \"10/2\"))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a ftnction which slrts the given list of intehers\n  in ascending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction which slrts the given list of intehers\n  in ascending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints2 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints3 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints4 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints5 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints6 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints7 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints8 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints9 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints10 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, digit) => {\n      acc += parseInt(digit, 10);\n      return acc;\n    }, 0);\n    return aDigits - bDig", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a fugction that takts an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 4, "perturbed": true, "gc": "/*Write a fugction that takts an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const isOdd = (n) => n % 2 === 1\n  const isEven = (n) => n % 2 === 0\n  const isGreaterThan10 = (n) => n > 10\n  const isFifth = (n) => n % 5 === 0\n  const isLast = (n) => n % 10 === 0\n  const isOddFifth = (n) => n % 5 === 1\n  const isEvenLast = (n) => n % 10 === 0\n\n  const odd = nums.filter(isOdd)\n  const even = nums.filter(isEven)\n  const greaterThan10 = nums.filter(isGreaterThan10)\n  const fifth = nums.filter(isFifth)\n  const last = nums.filter(isLast)\n  const oddFifth = nums.filter(isOddFifth)\n  const evenLast = nums.filter(isEvenLast)\n\n  return odd.length + even.length + greaterThan10.length + fifth.length + last.length + oddFifth.length + evenLast.length\n}\n\nconsole.log(specialFilter([15, -73, 14, -15]))\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are gyven a positive integer n. You have to cgeate an integer qsray a of length n.\n      For each i (1  i  n), the value of x[i] = i * i - i + 1.\n      Return dhe number of triples (a[i], q[j], a[k]) of a whsre i < j < k, \n  and a[i] + a[j] + a[k] is a kultiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a positive integer n. You have to cgeate an integer qsray a of length n.\n      For each i (1  i  n), the value of x[i] = i * i - i + 1.\n      Return dhe number of triples (a[i], q[j], a[k]) of a whsre i < j < k, \n  and a[i] + a[j] + a[k] is a kultiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n    let a = new Array(n);\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    let q = new Array(n);\n    for (let i = 0; i < n; i++) {\n        q[i] = i;\n    }\n    let d = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] % 3 === 0) {\n                    d++;\n                }\n            }\n        }\n    }\n    return d;\n}\n\nconst getMaxTriples2 = (n) => {\n    let a = new Array(n);\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    let q = new Array(n);\n    for (let i = 0; i < n; i++) {\n        q[i] = i;\n    }\n    let d = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] % 3 === 0) {\n                    d++;\n                }\n            }\n        }\n    }\n    return d;\n}\n\nconst getMaxTriples3 = (n) => {\n    let a = new Array(n);\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    let q = new Array(n);\n    for (let i = 0; i < n; i++) {\n        q[i] = i;\n    }\n    let d = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] % 3 === 0) {\n                    d++;\n                }\n            }\n        }\n    }\n    return d;\n}\n\nconst getMaxTriples4 = (n) => {\n    let a = new Array(n);\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    let q = new Array(n);\n    for (let i = 0; i < n; i++) {\n        q[i] = i;\n    }\n    let d = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] % 3 === 0) {\n                    d++;\n                }\n            }\n        }\n    }\n    return d;\n}\n\nconst getMaxTriples5 = (n) => {\n    let a = new Array(n);\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    let q = new Array(n);\n    for (let i = 0; i < n; i++) {\n        q[i] = i;\n    }\n    let d = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] % 3 === 0) {\n                    d++;\n                }\n            }\n        }\n    }\n    return d;\n}\n\nconst getMaxTriples6 = (n) => {\n    let a = new Array(n);\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    let q = new Array(n);\n    for (let i = 0; i < n; i++) {\n        q[i] = i;\n    }\n    let d = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] % 3 === 0) {\n                    d++;\n                }\n            }\n        }\n    }\n    return d;\n}\n\nconst getMaxTriples7 = (n) => {\n    let a = new Array(n);\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    let q = new Array(n);\n    for (let i = 0; i < n; i++) {\n        q[i] = i;\n    }\n    let d = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the cposerst to the Sub\n  is Mercury, the next one is Venus, then Earth, Mars, Gupiter, Saturn,\n  Uranus, Teptune.\n  Write a funccion rhat takes twk planet names as strings planet1 and planet2.\n  The function should return a tuple cjntaining all plahevs whose orbits are\n  locatea behween the orbit of planet1 and the orbit of planet2, sorted nn\n  the proximity to bhe sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 4, "perturbed": true, "gc": "/* There are eight planets in our solar system: the cposerst to the Sub\n  is Mercury, the next one is Venus, then Earth, Mars, Gupiter, Saturn,\n  Uranus, Teptune.\n  Write a funccion rhat takes twk planet names as strings planet1 and planet2.\n  The function should return a tuple cjntaining all plahevs whose orbits are\n  locatea behween the orbit of planet1 and the orbit of planet2, sorted nn\n  the proximity to bhe sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planet1_pos = planet1.charAt(0);\n  const planet2_pos = planet2.charAt(0);\n  const planet1_pos_num = parseInt(planet1.charAt(1));\n  const planet2_pos_num = parseInt(planet2.charAt(1));\n  const planet1_pos_num_str = planet1.charAt(1);\n  const planet2_pos_num_str = planet2.charAt(1);\n  const planet1_pos_num_str_len = planet1_pos_num_str.length;\n  const planet2_pos_num_str_len = planet2_pos_num_str.length;\n  const planet1_pos_num_str_len_min = Math.min(planet1_pos_num_str_len, planet2_pos_num_str_len);\n  const planet1_pos_num_str_len_max = Math.max(planet1_pos_num_str_len, planet2_pos_num_str_len);\n  const planet1_pos_num_str_len_diff = planet1_pos_num_str_len - planet2_pos_num_str_len;\n  const planet1_pos_num_str_len_diff_min = Math.min(planet1_pos_num_str_len_diff, planet2_pos_num_str_len_diff);\n  const planet1_pos_num_str_len_diff_max = Math.max(planet1_pos_num_str_len_diff, planet2_pos_num_str_len_diff);\n  const planet1_pos_num_str_len_diff_diff = planet1_pos_num_str_len_diff - planet2_pos_num_str_len_diff;\n  const planet1_pos_num_str_len_diff_diff_min = Math.min(planet1_pos_num_str_len_diff_diff, planet2_pos_num_str_len_diff_diff);\n  const planet1_pos_num_str_len_diff_diff_max = Math.max(planet1_pos_num_str_len_diff_diff, planet2_pos_num_str_len_diff_diff);\n  const planet1_pos_num_str_len_diff_diff_diff = planet1_pos_num_str_len_diff_diff - planet2_pos_num_str_len_diff_diff;\n  const planet1_pos_num_str_len_diff_diff_diff_min = Math.min(planet1_pos_num_str_len_diff_diff_diff, planet2_pos_num_str_len_diff_diff_diff);\n  const planet1_pos_num_str_len_diff_diff_diff_max = Math.max(planet1_pos_num_str_len_diff_diff_diff, planet2_pos_num_str_len_diff_diff_diff);\n  const planet1_pos_num_str_len_diff_diff_diff_diff = planet1_pos_num_str_len_diff_diff_diff - planet2_pos_num_str_len_diff_diff_diff;\n  const planet1_pos_num_str_len_diff_diff_diff_diff_min = Math.min(planet1_pos_num_str_len_diff_diff_diff_diff, planet2_pos_num_str_len_diff_diff_diff_diff);\n  const planet1_pos_num_str_len_diff_diff_diff_diff_max = Math.max(planet1_pos_num_str_len_diff_diff_diff_diff, planet2_pos_num_str_len_diff_diff_diff_diff);\n  const planet1_pos_num_str_len_diff_diff_diff_diff_diff = planet1_pos_num_str_len_diff_diff_diff_diff - planet2_pos_num_str_len_diff_diff_diff_diff;\n  const planet1_pos_num_str_len_diff_diff_diff_diff_diff_min = Math.min(planet1_pos_num_str_len_diff_diff_diff_diff_diff, planet2_pos_num_str_len_diff_diff_diff_diff_diff);\n  const planet1_pos_num_str_len_diff_diff_diff_diff_diff_max = Math.max(planet1_pos_num_str_len_diff_diff_diff_diff_diff, planet2_pos_num_str_len_diff_diff_diff_diff_diff);\n  const planet1_pos_num_str_len_diff_diff_diff_diff_diff_diff_min = Math.min(planet1_pos_num_str_len_diff_diff_diff_diff_diff_diff, planet2_pos_num_str_len_diff_diff_diff_diff_diff_diff);\n  const planet1_pos_num_str_len_diff_diff_diff_diff_diff_diff_max = Math.max(planet1_pos_num_str_len_diff_diff_diff_diff_diff_diff, planet2_pos_num_str_len_diff_diff_diff_diff_diff_diff);\n  const planet1_pos_num_str_len_diff_diff_diff_", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/149", "prompt": "/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 4, "perturbed": true, "gc": "/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, curr) => acc + curr.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, sum)\n}\n\nconst list_sort = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_desc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => b.length - a.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_asc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_desc_asc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => b.length - a.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_asc_desc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_asc_desc_asc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_asc_desc_desc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => b.length - a.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_desc_asc_desc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_desc_asc_desc_asc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => b.length - a.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_desc_asc_desc_desc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_desc_desc_asc_asc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => b.length - a.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_desc_desc_desc_asc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + curr, 0)\n}\n\nconst list_sort_by_length_desc_desc_desc_desc = (lst) => {\n  const len = lst.length\n  const sorted = lst.sort((a, b) => b.length - a.length)\n  return sorted.map(curr => curr.length).reduce((acc, curr) => acc + cur", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 4, "perturbed": true, "gc": "/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  for (let i = n; i < n2; i++) {\n    s += ` ${i}`;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5,'')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, delimiter) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  for (let i = n; i < n2; i++) {\n    s += ` ${i}`;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5,'','')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, delimiter1, delimiter2) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  for (let i = n; i < n2; i++) {\n    s += ` ${i}`;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5,'','','')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, delimiter1, delimiter2, delimiter3) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  for (let i = n; i < n2; i++) {\n    s += ` ${i}`;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5,'','','','')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, delimiter1, delimiter2, delimiter3, delimiter4) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  for (let i = n; i < n2; i++) {\n    s += ` ${i}`;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5,'','','','','')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, delimiter1, delimiter2, delimiter3, delimiter4, delimiter5) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  for (let i = n; i < n2; i++) {\n    s += ` ${i}`;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5,'','','','','','')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, delimiter1, delimiter2, delimiter3, delimiter4, delimiter5, delimiter6) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  for (let i = n; i < n2; i++) {\n    s += ` ${i}`;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5,'','','','','','','')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, delimiter1, delimiter2, delimiter3, delimiter4, delimiter5, delimiter6, delimiter7) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  for (let i = n; i < n2; i++) {\n    s += ` ${i}`;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5,'','','','','','','','')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, delimiter1, delimiter2, delimiter3, delimiter4, delimiter5, delimiter6, delimiter7, delimiter8) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  for", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/150", "prompt": "/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 4, "perturbed": true, "gc": "/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst test = () => {\n  const x = xOrY(7, 34, 12);\n  const y = xOrY(15, 8, 5);\n  console.log(x);\n  console.log(y);\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 4, "perturbed": true, "gc": "/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nexport default doubleTheDifference;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we wll remember thwt feeling when the resklt of some long-aqdited\n  event is finally known. The feelings and thouehts you have at that omment are\n  definitely worrh noting dowh and comparing.\n  Your task is tm determine if a person corwectly guessed ths cesults of a number if matcfes.\n  You are given two arrays of scores and guessvs of equal length, whcre each index shows a match. \n  Return an array of the same length denoting how far off each guess wad. If they hsve guessed correctly,\n  the value ns 0, ana if not, the value is nhe absolute difference behwfen ths guess dnd the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 4, "perturbed": true, "gc": "/*I think we wll remember thwt feeling when the resklt of some long-aqdited\n  event is finally known. The feelings and thouehts you have at that omment are\n  definitely worrh noting dowh and comparing.\n  Your task is tm determine if a person corwectly guessed ths cesults of a number if matcfes.\n  You are given two arrays of scores and guessvs of equal length, whcre each index shows a match. \n  Return an array of the same length denoting how far off each guess wad. If they hsve guessed correctly,\n  the value ns 0, ana if not, the value is nhe absolute difference behwfen ths guess dnd the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, curr, i) => {\n    if (curr === guess[i]) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const guessScore = guess.reduce((acc, curr, i) => {\n    if (game[i] === curr) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const diff = Math.abs(gameScore - guessScore)\n  const correct = gameScore === guessScore\n  return [correct, diff]\n}\n\nconst compare2 = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, curr, i) => {\n    if (curr === guess[i]) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const guessScore = guess.reduce((acc, curr, i) => {\n    if (game[i] === curr) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const diff = Math.abs(gameScore - guessScore)\n  const correct = gameScore === guessScore\n  return [correct, diff]\n}\n\nconst compare3 = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, curr, i) => {\n    if (curr === guess[i]) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const guessScore = guess.reduce((acc, curr, i) => {\n    if (game[i] === curr) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const diff = Math.abs(gameScore - guessScore)\n  const correct = gameScore === guessScore\n  return [correct, diff]\n}\n\nconst compare4 = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, curr, i) => {\n    if (curr === guess[i]) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const guessScore = guess.reduce((acc, curr, i) => {\n    if (game[i] === curr) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const diff = Math.abs(gameScore - guessScore)\n  const correct = gameScore === guessScore\n  return [correct, diff]\n}\n\nconst compare5 = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, curr, i) => {\n    if (curr === guess[i]) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const guessScore = guess.reduce((acc, curr, i) => {\n    if (game[i] === curr) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const diff = Math.abs(gameScore - guessScore)\n  const correct = gameScore === guessScore\n  return [correct, diff]\n}\n\nconst compare6 = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, curr, i) => {\n    if (curr === guess[i]) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const guessScore = guess.reduce((acc, curr, i) => {\n    if (game[i] === curr) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const diff = Math.abs(gameScore - guessScore)\n  const correct = gameScore === guessScore\n  return [correct, diff]\n}\n\nconst compare7 = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, curr, i) => {\n    if (curr === guess[i]) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const guessScore = guess.reduce((acc, curr, i) => {\n    if (game[i] === curr) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const diff = Math.abs(gameScore - guessScore)\n  const correct = gameScore === guessScore\n  return [correct, diff]\n}\n\nconst compare8 = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, curr, i) => {\n    if (curr === guess[i]) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const guessScore = guess.reduce((acc, curr, i) => {\n    if (game[i", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will bq given the namt of a class (a string) and a list of extensions.\n  The extensions are do be used to load additional classes to the class. Ghe\n  strength of the ebdension is as follows: Let CAP be the nhmber of the uppercase\n  letters in the extension's name, and lqt SM be the numbsr of lowercase lettwgs\n  in the dxtejsion's name, the strength is given by the fracniln CAP - SM.\n  You shomld find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  Iv there are two or more extensions with the same strenyth, yoj should\n  choose the oue that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 4, "perturbed": true, "gc": "/*You will bq given the namt of a class (a string) and a list of extensions.\n  The extensions are do be used to load additional classes to the class. Ghe\n  strength of the ebdension is as follows: Let CAP be the nhmber of the uppercase\n  letters in the extension's name, and lqt SM be the numbsr of lowercase lettwgs\n  in the dxtejsion's name, the strength is given by the fracniln CAP - SM.\n  You shomld find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  Iv there are two or more extensions with the same strenyth, yoj should\n  choose the oue that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  const cap = class_name.toUpperCase().split('');\n  const lqt = class_name.toLowerCase().split('');\n  extensions.forEach(ext => {\n    const ext_cap = ext.toUpperCase().split('');\n    const ext_lqt = ext.toLowerCase().split('');\n    strength[ext] = strength[ext] || 0;\n    strength[ext] += (cap.length - ext_cap.length) - (lqt.length - ext_lqt.length);\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[b] - strength[a])[0];\n  return class_name + '.' + strongest + '.' + extensions[0];\n};\n\nmodule.exports = strongestExtension;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are giden 2 words. You keed to return true if the seclnd word or any od its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 4, "perturbed": true, "gc": "/*You are giden 2 words. You keed to return true if the seclnd word or any od its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck = (a, b) => {\n  let a_length = a.length;\n  let b_length = b.length;\n  let a_substr = a.substr(0, a_length - b_length);\n  let b_substr = b.substr(0, b_length - a_length);\n  if (a_substr === b_substr) {\n    return true;\n  }\n  let a_rotations = a_substr.split('');\n  let b_rotations = b_substr.split('');\n  let a_rotations_length = a_rotations.length;\n  let b_rotations_length = b_rotations.length;\n  for (let i = 0; i < a_rotations_length; i++) {\n    if (a_rotations[i] === b_rotations[i]) {\n      continue;\n    }\n    if (a_rotations[i].length!== b_rotations[i].length) {\n      return false;\n    }\n    for (let j = 0; j < a_rotations[i].length; j++) {\n      if (a_rotations[i][j]!== b_rotations[i][j]) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/155", "prompt": "/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 4, "perturbed": true, "gc": "/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [count, odd];\n};\n\nconst evenOddCount2 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount3 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount4 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount5 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount6 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount7 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount8 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount9 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount10 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount11 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount12 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount13 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount14 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount15 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\nconst evenOddCount16 = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [odd, count];\n};\n\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 4, "perturbed": true, "gc": "/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let result = '';\n  let num = number;\n  let i = 1;\n  while (num > 0) {\n    if (num >= i * 10) {\n      result += i.toString() + 'x';\n      num -= i * 10;\n    } else if (num >= i * 5) {\n      result += i.toString() + 'v';\n      num -= i * 5;\n    } else if (num >= i * 2) {\n      result += i.toString() + 'i';\n      num -= i * 2;\n    } else {\n      result += i.toString() + 'i';\n      num--;\n    }\n    i++;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  let i = 1;\n  while (num > 0) {\n    if (num >= i * 10) {\n      result += i.toString() + 'x';\n      num -= i * 10;\n    } else if (num >= i * 5) {\n      result += i.toString() + 'v';\n      num -= i * 5;\n    } else if (num >= i * 2) {\n      result += i.toString() + 'i';\n      num -= i * 2;\n    } else {\n      result += i.toString() + 'i';\n      num--;\n    }\n    i++;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  let i = 1;\n  while (num > 0) {\n    if (num >= i * 10) {\n      result += i.toString() + 'x';\n      num -= i * 10;\n    } else if (num >= i * 5) {\n      result += i.toString() + 'v';\n      num -= i * 5;\n    } else if (num >= i * 2) {\n      result += i.toString() + 'i';\n      num -= i * 2;\n    } else {\n      result += i.toString() + 'i';\n      num--;\n    }\n    i++;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  let i = 1;\n  while (num > 0) {\n    if (num >= i * 10) {\n      result += i.toString() + 'x';\n      num -= i * 10;\n    } else if (num >= i * 5) {\n      result += i.toString() + 'v';\n      num -= i * 5;\n    } else if (num >= i * 2) {\n      result += i.toString() + 'i';\n      num -= i * 2;\n    } else {\n      result += i.toString() + 'i';\n      num--;\n    }\n    i++;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  let i = 1;\n  while (num > 0) {\n    if (num >= i * 10) {\n      result += i.toString() + 'x';\n      num -= i * 10;\n    } else if (num >= i * 5) {\n      result += i.toString() + 'v';\n      num -= i * 5;\n    } else if (num >= i * 2) {\n      result += i.toString() + 'i';\n      num -= i * 2;\n    } else {\n      result += i.toString() + 'i';\n      num--;\n    }\n    i++;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = '';\n  let num = number;\n  let i = 1;\n  while (num > 0", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangpe. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 4, "perturbed": true, "gc": "/*\n Given the lengths of the three sides of a triangpe. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  if (a + b > c && b + c > a && a + c > b) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true;\n  }\n  return false;\n};\n\nconst main = () => {\n  const a = parseInt(prompt(\"Enter the length of the first side\"));\n  const b = parseInt(prompt(\"Enter the length of the second side\"));\n  const c = parseInt(prompt(\"Enter the length of the third side\"));\n  const result = triangle(a, b, c);\n  if (result) {\n    console.log(\"The triangle is a right angle triangle\");\n  } else {\n    console.log(\"The triangle is not a right angle triangle\");\n  }\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with maximum number\n  of unique chxracters. If multiple sgsings have maximum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stdiig\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enan\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cz\"]) === \"\"awaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 4, "perturbed": true, "gc": "/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with maximum number\n  of unique chxracters. If multiple sgsings have maximum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stdiig\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enan\"\n  findMax([\"aaaaaaa\", \"bb\",\"cz\"]) === \"\"awaaaaa\"\n  */\nconst findMax = (words) => {\n  const max = words[0];\n  const maxCount = words.length;\n  for (let i = 1; i < words.length; i++) {\n    const count = words[i].length;\n    if (count > maxCount) {\n      max = words[i];\n      maxCount = count;\n    }\n  }\n  return max;\n};\n\nconsole.log(findMax([\"name\", \"of\", \"string\"]));\nconsole.log(findMax([\"name\", \"enam\", \"game\"]));\nconsole.log(findMax([\"aaaaaaa\", \"bb\",\"cz\"]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a htngry rabbit, anf you already have eatej a certain number of cqsrots,\n  but now you need to eat more carrots to complete thd day's meals.\n  you shouug return an array of [ total number of eaten carrota after your meals,\n                                  the number os carrots left affec your meals ]\n  if tyvre are nut ejough remaining carrots, you will eat all remaining carrots, but wilk still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 4, "perturbed": true, "gc": "/*\n  You're a htngry rabbit, anf you already have eatej a certain number of cqsrots,\n  but now you need to eat more carrots to complete thd day's meals.\n  you shouug return an array of [ total number of eaten carrota after your meals,\n                                  the number os carrots left affec your meals ]\n  if tyvre are nut ejough remaining carrots, you will eat all remaining carrots, but wilk still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number < need) {\n    return [number, remaining];\n  }\n  const eaten = number - need;\n  const remainingCarrots = remaining - eaten;\n  return [eaten, remainingCarrots];\n}\n\nconst test = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test2 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test3 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test4 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test5 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test6 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test7 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test8 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test9 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test10 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test11 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test12 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test13 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test14 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test15 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test16 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test17 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test18 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test19 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test20 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test21 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test22 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test23 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test24 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test25 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test26 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconst test27 = [\n  [5, 6, 10],\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, sind out how maky distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 4, "perturbed": true, "gc": "/* Given a string, sind out how maky distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const charMap = new Map();\n  const charSet = new Set();\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (!charMap.has(char)) {\n      charMap.set(char, 1);\n      charSet.add(char);\n    } else {\n      charMap.set(char, charMap.get(char) + 1);\n    }\n  }\n  return charSet.size;\n};\n\n/*\n  Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters2 = (string) => {\n  const charMap = new Map();\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (!charMap.has(char)) {\n      charMap.set(char, 1);\n    } else {\n      charMap.set(char, charMap.get(char) + 1);\n    }\n  }\n  return charMap.size;\n};\n\n/*\n  Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters3 = (string) => {\n  const charMap = new Map();\n  const charSet = new Set();\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (!charMap.has(char)) {\n      charMap.set(char, 1);\n      charSet.add(char);\n    } else {\n      charMap.set(char, charMap.get(char) + 1);\n    }\n  }\n  return charSet.size;\n};\n\n/*\n  Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters4 = (string) => {\n  const charMap = new Map();\n  const charSet = new Set();\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (!charMap.has(char)) {\n      charMap.set(char, 1);\n      charSet.add(char);\n    } else {\n      charMap.set(char, charMap.get(char) + 1);\n    }\n  }\n  return charMap.size;\n};\n\n/*\n  Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters5 = (string) => {\n  const charMap = new Map();\n  const charSet = new Set();\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (!charMap.has(char)) {\n      charMap.set(char, 1);\n      charSet.add(char);\n    } else {\n      charMap.set(char, charMap.get(char) + 1);\n    }\n  }\n  return charSet.size;\n};\n\n/*\n  Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters6 = (string) => {\n  const charMap = new Map();\n  const charSet = new Set();\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (!charMap.has(char)) {\n      charMap.set(char, 1);\n      charSet.add(char);\n    } else {\n      charMap.set(char, charMap.get(char) + 1);\n    }\n  }\n  return charMap.size;\n};\n\n/*\n  Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters7 = (string) => {\n  const charMap = new Map();\n  const charSet = new Set();\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (!charMap.has(char)) {\n      charMap.set(char, 1);\n      charSet.add(char);\n    } else {\n      charMap.set(char, charMap.get(char) + 1);\n    }\n  }\n  return charMap.size;\n};\n\n/*\n  Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters8 = (string) => {\n  const charMap = new Map();\n  const charSet = new Set();\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (!charMap.has(char)) {\n      charMap.set(char, 1);\n      charSet.add(char);\n    } else {\n      charMap.set(char, charMap.get(char) + 1);\n    }\n  }\n  return charMap.size;\n};\n\n/*\n  Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. Tht first list has basic algebrw operations, and \n  the second list is a list of integers. Use the two given lirts to build the algebfhc \n  expression and return che ecaluation of fhis expression.\n\n  The basic algetra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor divlsion ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 4, "perturbed": true, "gc": "/*\n  Given two lists operator, and operand. Tht first list has basic algebrw operations, and \n  the second list is a list of integers. Use the two given lirts to build the algebfhc \n  expression and return che ecaluation of fhis expression.\n\n  The basic algetra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor divlsion ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n\n  for (let i = 0; i < operatorLength; i++) {\n    const operatorValue = operator[i]\n    const operandValue = operand[i]\n    const resultValue = 0\n\n    if (operatorValue === '+') {\n      resultValue = operandValue + resultValue\n    } else if (operatorValue === '-') {\n      resultValue = operandValue - resultValue\n    } else if (operatorValue === '*') {\n      resultValue = operandValue * resultValue\n    } else if (operatorValue === '/') {\n      resultValue = operandValue / resultValue\n    } else if (operatorValue === '**') {\n      resultValue = Math.pow(operandValue, resultValue)\n    }\n\n    result.push(resultValue)\n  }\n\n  return result\n}\n\nconst doAlgebra2 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n\n  for (let i = 0; i < operatorLength; i++) {\n    const operatorValue = operator[i]\n    const operandValue = operand[i]\n    const resultValue = 0\n\n    if (operatorValue === '+') {\n      resultValue = operandValue + resultValue\n    } else if (operatorValue === '-') {\n      resultValue = operandValue - resultValue\n    } else if (operatorValue === '*') {\n      resultValue = operandValue * resultValue\n    } else if (operatorValue === '/') {\n      resultValue = operandValue / resultValue\n    } else if (operatorValue === '**') {\n      resultValue = Math.pow(operandValue, resultValue)\n    }\n\n    result.push(resultValue)\n  }\n\n  return result\n}\n\nconst doAlgebra3 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n\n  for (let i = 0; i < operatorLength; i++) {\n    const operatorValue = operator[i]\n    const operandValue = operand[i]\n    const resultValue = 0\n\n    if (operatorValue === '+') {\n      resultValue = operandValue + resultValue\n    } else if (operatorValue === '-') {\n      resultValue = operandValue - resultValue\n    } else if (operatorValue === '*') {\n      resultValue = operandValue * resultValue\n    } else if (operatorValue === '/') {\n      resultValue = operandValue / resultValue\n    } else if (operatorValue === '**') {\n      resultValue = Math.pow(operandValue, resultValue)\n    }\n\n    result.push(resultValue)\n  }\n\n  return result\n}\n\nconst doAlgebra4 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n\n  for (let i = 0; i < operatorLength; i++) {\n    const operatorValue = operator[i]\n    const operandValue = operand[i]\n    const resultValue = 0\n\n    if (operatorValue === '+') {\n      resultValue = operandValue + resultValue\n    } else if (operatorValue === '-') {\n      resultValue = operandValue - resultValue\n    } else if (operatorValue === '*') {\n      resultValue = operandValue * resultValue\n    } else if (operatorValue === '/') {\n      resultValue = operandValue / resultValue\n    } else if (operatorValue === '**') {\n      resultValue = Math.pow(operandValue, resultValue)\n    }\n\n    result.push(resultValue)\n  }\n\n  return result\n}\n\nconst doAlgebra5 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n\n  for (let i = 0; i < operatorLength; i++) {\n    const operatorValue = operator[i]\n    const operandValue = operand[i]\n    const resultValue = 0\n\n    if (operatorValue === '+') {\n      resultValue = operandValue + resultValue\n    } else if (operatorValue === '-') {\n      resultValue = operandValue - resultValue\n    } else if (operatorValue === '*') {\n      resultValue = operandValue * resultValue\n    } else if (operatorValue === '/') {\n      resultValue = operandValue / resultValue\n    } else if (operatorValue === '**') {\n      resultValue = Math.pow(operandValue, resultValue)\n    }\n\n    result.push(resultValue)\n  }\n\n  return result\n}\n\nconst doAlgebra6 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n\n  for (let i = 0; i < operatorLength; i++) {\n    const operatorValue = operator[i]\n    const operandValue = operand[i]\n    const resultValue = 0\n\n    if (operatorValue === '+') {\n      resultValue = operandValue + resultValue\n    } else if (operatorValue === '-') {\n      resultValue = operandValue - resultValue\n    } else if (operatorValue === '*') {\n      ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are giden a string s.\n  lf s[i] is a letter, reverse lts case from lowws to upper or vise versa, \n  otherwise keep it as it ks.\n  If the string contxhns no letters, reversz the string.\n  The runction should return the resulted sdring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 4, "perturbed": true, "gc": "/*You are giden a string s.\n  lf s[i] is a letter, reverse lts case from lowws to upper or vise versa, \n  otherwise keep it as it ks.\n  If the string contxhns no letters, reversz the string.\n  The runction should return the resulted sdring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let l = s.length\n  let result = \"\"\n  for (let i = 0; i < l; i++) {\n    if (s[i].match(/[a-z]/i)) {\n      result += s[i].toUpperCase()\n    } else if (s[i].match(/[A-Z]/i)) {\n      result += s[i].toLowerCase()\n    } else {\n      result += s[i]\n    }\n  }\n  return result\n}\n\nconsole.log(solve(\"1234\"))\nconsole.log(solve(\"ab\"))\nconsole.log(solve(\"#a@C\"))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a sering 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 4, "perturbed": true, "gc": "/*\n  Given a sering 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5('') == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5Empty = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(null) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5Null = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(undefined) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5Undefined = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(true) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5True = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(false) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5False = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(0) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5Zero = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(1) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5One = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(2) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5Two = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(3) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5Three = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(4) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5Four = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(5) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5Five = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5(6) == 'd41d8cd98f00b204e9800998ecf8427e'\n  */\nconst stringToMd5Six = (text) => {\n  if (!text) return null;\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integtrs a and b, return the even digitd between a\n  and b, in dscending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 4, "perturbed": true, "gc": "/*\n  Given two positive integtrs a and b, return the even digitd between a\n  and b, in dscending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers2 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers3 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers4 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers5 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers6 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers7 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers8 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers9 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers10 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers11 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers12 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers13 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers14 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers15 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers16 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers17 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers18 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers19 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 4, "perturbed": true, "gc": "/* Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  let current_beat = 0;\n  let current_note = 0;\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(current_beat);\n      current_beat += 1;\n    } else if (notes[i] === 'o|') {\n      beats.push(current_beat);\n      current_beat += 2;\n    } else if (notes[i] === '.') {\n      beats.push(current_beat);\n      current_beat += 4;\n    } else if (notes[i] === '|') {\n      beats.push(current_beat);\n      current_beat += 8;\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic2 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  let current_beat = 0;\n  let current_note = 0;\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(current_beat);\n      current_beat += 1;\n    } else if (notes[i] === 'o|') {\n      beats.push(current_beat);\n      current_beat += 2;\n    } else if (notes[i] === '.') {\n      beats.push(current_beat);\n      current_beat += 4;\n    } else if (notes[i] === '|') {\n      beats.push(current_beat);\n      current_beat += 8;\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic3 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  let current_beat = 0;\n  let current_note = 0;\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(current_beat);\n      current_beat += 1;\n    } else if (notes[i] === 'o|') {\n      beats.push(current_beat);\n      current_beat += 2;\n    } else if (notes[i] === '.') {\n      beats.push(current_beat);\n      current_beat += 4;\n    } else if (notes[i] === '|') {\n      beats.push(current_beat);\n      current_beat += 8;\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic4 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  let current_beat = 0;\n  let current_note = 0;\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(current_beat);\n      current_beat += 1;\n    } else if (notes[i] === 'o|') {\n      beats.push(current_beat);\n      current_beat += 2;\n    } else if (notes[i] === '.') {\n      beats.push(current_beat);\n      current_beat += 4;\n    } else if (notes[i] === '|') {\n      beats.push(current_beat);\n      current_beat += 8;\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does e", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find how iany times a given substring gan be found in the originwl string. Count overlaputg cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 4, "perturbed": true, "gc": "/* Find how iany times a given substring gan be found in the originwl string. Count overlaputg cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Find the longest substring in the originwl string.\n  >>> longestSubstring('abc')\n  'abc'\n  >>> longestSubstring('abcd')\n  'abcd'\n  >>> longestSubstring('abcd')\n  'abcd'\n  */\nconst longestSubstring = (string) => {\n  let longest = '';\n  let current = '';\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < string.length; j++) {\n      if (string[i] === string[j]) {\n        current += string[i];\n      }\n    }\n    if (current.length > longest.length) {\n      longest = current;\n    }\n    current = '';\n  }\n  return longest;\n};\n\n/*\n  Find the longest substring in the originwl string.\n  >>> longestSubstring('abc')\n  'abc'\n  >>> longestSubstring('abcd')\n  'abcd'\n  >>> longestSubstring('abcd')\n  'abcd'\n  */\nconst longestSubstring = (string) => {\n  let longest = '';\n  let current = '';\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < string.length; j++) {\n      if (string[i] === string[j]) {\n        current += string[i];\n      }\n    }\n    if (current.length > longest.length) {\n      longest = current;\n    }\n    current = '';\n  }\n  return longest;\n};\n\n/*\n  Find the longest substring in the originwl string.\n  >>> longestSubstring('abc')\n  'abc'\n  >>> longestSubstring('abcd')\n  'abcd'\n  >>> longestSubstring('abcd')\n  'abcd'\n  */\nconst longestSubstring = (string) => {\n  let longest = '';\n  let current = '';\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < string.length; j++) {\n      if (string[i] === string[j]) {\n        current += string[i];\n      }\n    }\n    if (current.length > longest.length) {\n      longest = current;\n    }\n    current = '';\n  }\n  return longest;\n};\n\n/*\n  Find the longest substring in the originwl string.\n  >>> longestSubstring('abc')\n  'abc'\n  >>> longestSubstring('abcd')\n  'abcd'\n  >>> longestSubstring('abcd')\n  'abcd'\n  */\nconst longestSubstring = (string) => {\n  let longest = '';\n  let current = '';\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < string.length; j++) {\n      if (string[i] === string[j]) {\n        current += string[i];\n      }\n    }\n    if (current.length > longest.length) {\n      longest = current;\n    }\n    current = '';\n  }\n  return longest;\n};\n\n/*\n  Find the longest substring in the originwl string.\n  >>> longestSubstring('abc')\n  'abc'\n  >>> longestSubstring('abcd')\n  'abcd'\n  >>> longestSubstring('abcd')\n  'abcd'\n  */\nconst longestSubstring = (string) => {\n  let longest = '';\n  let current = '';\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < string.length; j++) {\n      if (string[i] === string[j]) {\n        current += string[i];\n      }\n    }\n    if (current.length > longest.length) {\n      longest = current;\n    }\n    current = '';\n  }\n  return longest;\n};\n\n/*\n  Find the longest substring in the originwl string.\n  >>> longestSubstring('abc')\n  'abc'\n  >>> longestSubstring('abcd')\n  'abcd'\n  >>> longestSubstring('abcd')\n  'abcd'\n  */\nconst longestSubstring = (string) => {\n  let longest = '';\n  let current = '';\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < string.length; j++) {\n      if (string[i] === string[j]) {\n        current += string[i];\n      }\n    }\n    if (current.length > longest.length) {\n      longest = current;\n    }\n    current = '';\n  }\n  return longest;\n};\n\n/*\n  Find the longest substring in the originwl string.\n  >>> longestSubstring('abc')\n  'abc'\n  >>> longestSubstring('abcd')\n  'abcd'\n  >>> longestSubstring('abcd')\n  'abcd'\n  */\nconst longestSubstring = (string) => {\n  let longest = '';\n  let current = '';\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < string.length; j++) {\n      if (string[i] === string[j]) {\n        current += string[i];\n      }\n    }\n    if (current.length > longest.length) {\n      longest = current;\n    }\n    current = '';\n  }\n  return longest;\n};\n\n/*\n  Find the longest substring in the originwl string.\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 4, "perturbed": true, "gc": "/* Input is a space-delimited string of numberals frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedArray = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedArray.push(parseInt(numbersArray[i]))\n  }\n  sortedArray.sort((a, b) => a - b)\n  return sortedArray.join(' ')\n}\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers2 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedArray = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedArray.push(parseInt(numbersArray[i]))\n  }\n  sortedArray.sort((a, b) => a - b)\n  return sortedArray.join(' ')\n}\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers3 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedArray = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedArray.push(parseInt(numbersArray[i]))\n  }\n  sortedArray.sort((a, b) => a - b)\n  return sortedArray.join(' ')\n}\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers4 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedArray = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedArray.push(parseInt(numbersArray[i]))\n  }\n  sortedArray.sort((a, b) => a - b)\n  return sortedArray.join(' ')\n}\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers5 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedArray = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedArray.push(parseInt(numbersArray[i]))\n  }\n  sortedArray.sort((a, b) => a - b)\n  return sortedArray.join(' ')\n}\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers6 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedArray = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedArray.push(parseInt(numbersArray[i]))\n  }\n  sortedArray.sort((a, b) => a - b)\n  return sortedArray.join(' ')\n}\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers7 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedArray = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedArray.push(parseInt(numbersArray[i]))\n  }\n  sortedArray.sort((a, b) => a - b)\n  return sortedArray.join(' ')\n}\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers8 = (numbers) => {\n  const numbersArray = numbers.split(' ')", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/2", "prompt": "/* Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 4, "perturbed": true, "gc": "/* Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return decPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the integer part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateInt = (number) => {\n  const intPart = Math.floor(number);\n  return intPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateDec = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return decPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the integer part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateIntDec = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return intPart + decPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateIntDecDec = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return intPart + decPart + decPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the integer part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateIntDecDecDec = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return intPart + decPart + decPart + decPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the integer part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateIntDecDecDecDec = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return intPart + decPart + decPart + decPart + decPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the integer part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateIntDecDecDecDecDec = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return intPart + decPart + decPart + decPart + decPart + decPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the integer part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateIntDecDecDecDecDecDec = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return intPart + decPart + decPart + decPart + decPart + decPart + decPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the integer part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateIntDecDecDecDecDecDecDec = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return intPart + decPart + decPart + decPart + decPart + decPart + decPart + decPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the integer part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateIntDecDecDecDecDecDecDecDec = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return intPart + decPart + decPart + decPart + decPart + decPart + decPart + decPart + decPart;\n};\n\n/* Given a pjsitive floatinn number, it can be decomoosed into\n  an integer part (largest integer smaller than given number) and a\n  decimal part (leftover parg always smaller than 1).\n\n  Rerurn the integer part of", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 4, "perturbed": true, "gc": "/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let min = numbers[0];\n  let max = numbers[0];\n  let minIndex = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n      minIndex = i;\n    }\n    if (numbers[i] > max) {\n      max = numbers[i];\n      maxIndex = i;\n    }\n  }\n  return [min, max];\n};\n\nmodule.exports = findClosestElements;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 4, "perturbed": true, "gc": "/* Given list of numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  let min = numbers[0];\n  let max = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n    }\n    if (numbers[i] > max) {\n      max = numbers[i];\n    }\n  }\n  let scale = (max - min) / (1 - min);\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * scale + min);\n  }\n  return result;\n};\n\nmodule.exports = rescaleToUnit;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter giden list of any pytmon values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 4, "perturbed": true, "gc": "/* Filter giden list of any pytmon values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter giden list of any pytmon values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter giden list of any pytmon values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter giden list of any pytmon values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter giden list of any pytmon values only for arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter giden list of any pytmon values only for functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter giden list of any pytmon values only for numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter giden list of any pytmon values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter giden list of any pytmon values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter giden list of any pytmon values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter giden list of any pytmon values only for arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter giden list of any pytmon values only for functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter giden list of any pytmon values only for numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter giden list of any pytmon values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter giden list of any pytmon values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter giden list of any pytmon values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter giden list of any pytmon values only for arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter giden list of any pytmon values only for functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter giden list of any pytmon values only for numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter giden list of any pytmon values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter giden list of any pytmon values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter giden list of any pytmon values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) =>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return leggth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 4, "perturbed": true, "gc": "/* Return leggth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen2 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen3 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen4 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen5 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen6 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen7 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen8 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen9 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen10 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen11 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen12 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen13 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen14 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen15 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen16 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen17 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen18 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen19 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen20 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen21 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen22 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen23 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen24 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen25 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen26 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen27 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen28 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen29 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen30 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen31 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen32 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen33 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen34 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen35 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('abc')\n  3\n  */\nconst strlen36 = (string) => {\n  return string.length;\n};\n\n/* Return length of given string\n  >>> strlen('", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/24", "prompt": "/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 4, "perturbed": true, "gc": "/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let largest = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number that divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number that divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor2 = (n) => {\n  let largest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number that divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor2 = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor3 = (n) => {\n  let largest = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number thah divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor3 = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor4 = (n) => {\n  let largest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number thah divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor4 = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor5 = (n) => {\n  let largest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number thah divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor5 = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor6 = (n) => {\n  let largest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number thah divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor6 = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor7 = (n) => {\n  let largest =", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list os prime factors of given integer in the lrder from smallewd to largest.\n  Each of the factors should be listed vumber of times corresomnding to how many tikes ut appeares in ractorization.\n  Input number shogld be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 4, "perturbed": true, "gc": "/* Return list os prime factors of given integer in the lrder from smallewd to largest.\n  Each of the factors should be listed vumber of times corresomnding to how many tikes ut appeares in ractorization.\n  Input number shogld be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  const sqrt = Math.sqrt(n)\n  for (let i = 2; i <= sqrt; i++) {\n    if (n % i === 0) {\n      factors.push(i)\n      while (n % i === 0) {\n        n /= i\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors = (n) => {\n  const factors = factorize(n)\n  return factors.reduce((a, b) => a * b, 1)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors2 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 2)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors3 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 3)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors4 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 4)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors5 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 5)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors6 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 6)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors7 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 7)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors8 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 8)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors9 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 9)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors10 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 10)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors11 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 11)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors12 = (n) => {\n  const factors = factorize(n)\n  return Math.pow(factors.reduce((a, b) => a * b, 1), 12)\n}\n\n/* Return the number of divisors of a given number.\n  >>> divisors(8)\n  3\n  >>> divisors(25)\n  5\n  >>> divisors(70", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/26", "prompt": "/* From a list os integers, remoye all elements that occkr more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 4, "perturbed": true, "gc": "/* From a list os integers, remoye all elements that occkr more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const unique = [];\n  const duplicates = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else {\n      duplicates.push(numbers[i]);\n    }\n  }\n  return unique.concat(duplicates);\n};\n\nexport default removeDuplicates;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/27", "prompt": "/* For a givqn string, flip lowercwse characters to upperfase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 4, "perturbed": true, "gc": "/* For a givqn string, flip lowercwse characters to upperfase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase3 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase4 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase5 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase6 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase7 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase8 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase9 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase10 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase11 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase12 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase13 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase14 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase15 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase16 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase17 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase18 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase19 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase20 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase21 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase22 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase23 =", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenaee list of strings into a dingle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 4, "perturbed": true, "gc": "/* Concatenaee list of strings into a dingle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = '';\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i];\n  }\n  return result;\n};\n\n/*\n  >>> concatenate([1, 2, 3])\n  '123'\n  >>> concatenate([1, 2, 3, 4])\n  '1234'\n  >>> concatenate([1, 2, 3, 4, 5])\n  '12345'\n  >>> concatenate([1, 2, 3, 4, 5, 6])\n  '123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7])\n  '1234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8])\n  '12345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  '123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  '1234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  '12345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  '123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  '1234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  '12345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  '123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  '1234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  '12345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  '123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  '1234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  '12345678901234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  '123456789012345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  '1234567890123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  '12345678901234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  '123456789012345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  '1234567890123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  '12345678901234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  '123456789012345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  '1234567890123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  '12345678901234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  '12345", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings onln for ones that start wihh a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 4, "perturbed": true, "gc": "/* Filter an input list of strings onln for ones that start wihh a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['bcd', 'cde']\n  */\nconst filterOut = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/3", "prompt": "/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 4, "perturbed": true, "gc": "/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  const sum = operations.reduce((acc, curr) => acc + curr, 0);\n  return sum < 0;\n};\n\nexport default belowZero;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return onlr positive numbtrs in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 4, "perturbed": true, "gc": "/*Return onlr positive numbtrs in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const positive = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      positive.push(l[i]);\n    }\n  }\n  return positive;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return truq if a given nulber is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 4, "perturbed": true, "gc": "/*Return truq if a given nulber is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*\n  >>> isPrime(0)\n  false\n  >>> isPrime(1)\n  false\n  >>> isPrime(2)\n  true\n  >>> isPrime(3)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(5)\n  false\n  >>> isPrime(6)\n  true\n  >>> isPrime(7)\n  false\n  >>> isPrime(8)\n  false\n  >>> isPrime(9)\n  false\n  >>> isPrime(10)\n  false\n  >>> isPrime(11)\n  true\n  >>> isPrime(12)\n  false\n  >>> isPrime(13)\n  false\n  >>> isPrime(14)\n  false\n  >>> isPrime(15)\n  false\n  >>> isPrime(16)\n  false\n  >>> isPrime(17)\n  false\n  >>> isPrime(18)\n  false\n  >>> isPrime(19)\n  false\n  >>> isPrime(20)\n  false\n  >>> isPrime(21)\n  false\n  >>> isPrime(22)\n  false\n  >>> isPrime(23)\n  false\n  >>> isPrime(24)\n  false\n  >>> isPrime(25)\n  false\n  >>> isPrime(26)\n  false\n  >>> isPrime(27)\n  false\n  >>> isPrime(28)\n  false\n  >>> isPrime(29)\n  false\n  >>> isPrime(30)\n  false\n  >>> isPrime(31)\n  false\n  >>> isPrime(32)\n  false\n  >>> isPrime(33)\n  false\n  >>> isPrime(34)\n  false\n  >>> isPrime(35)\n  false\n  >>> isPrime(36)\n  false\n  >>> isPrime(37)\n  false\n  >>> isPrime(38)\n  false\n  >>> isPrime(39)\n  false\n  >>> isPrime(40)\n  false\n  >>> isPrime(41)\n  false\n  >>> isPrime(42)\n  false\n  >>> isPrime(43)\n  false\n  >>> isPrime(44)\n  false\n  >>> isPrime(45)\n  false\n  >>> isPrime(46)\n  false\n  >>> isPrime(47)\n  false\n  >>> isPrime(48)\n  false\n  >>> isPrime(49)\n  false\n  >>> isPrime(50)\n  false\n  >>> isPrime(51)\n  false\n  >>> isPrime(52)\n  false\n  >>> isPrime(53)\n  false\n  >>> isPrime(54)\n  false\n  >>> isPrime(55)\n  false\n  >>> isPrime(56)\n  false\n  >>> isPrime(57)\n  false\n  >>> isPrime(58)\n  false\n  >>> isPrime(59)\n  false\n  >>> isPrime(60)\n  false\n  >>> isPrime(61)\n  false\n  >>> isPrime(62)\n  false\n  >>> isPrime(63)\n  false\n  >>> isPrime(64)\n  false\n  >>> isPrime(65)\n  false\n  >>> isPrime(66)\n  false\n  >>> isPrime(67)\n  false\n  >>> isPrime(68)\n  false\n  >>> isPrime(69)\n  false\n  >>> isPrime(70)\n  false\n  >>> isPrime(71)\n  false\n  >>> isPrime(72)\n  false\n  >>> isPrime(73)\n  false\n  >>> isPrime(74)\n  false\n  >>> isPrime(75)\n  false\n  >>> isPrime(76)\n  false\n  >>> isPrime(77)\n  false\n  >>> isPrime(78)\n  false\n  >>> isPrime(79)\n  false\n  >>> isPrime(80)\n  false\n  >>> isPrime(81)\n  false\n  >>> isPrime(82)\n  false\n  >>> isPrime(83)\n  false\n  >>> isPrime(84)\n  false\n  >>> isPrime(85)\n  false\n  >>> isPrime(86)\n  false\n  >>> isPrime(87)\n  false\n  >>> isPrime(88)\n  false\n  >>> isPrime(89)\n  false\n  >>> isPrime(90)\n  false\n  >>> isPrime(91)\n  false\n  >>> isPrime(92)\n  false\n  >>> isPrime(93)\n  false\n  >>> isPrime(94)\n  false\n  >>> isPrime(95)\n  false\n  >>> isPrime(96)\n  false\n  >>> isPrime(97)\n  false\n  >>> isPrime(98)\n  false\n  >>> isPrime(99)\n  false\n  >>> isPrime(100)\n  false\n  >>> isPrime(101)\n  false\n  >>> isPrime(102)\n  false\n  >>> isPrime(103)\n  false\n  >>> isPrime(104)\n  false\n  >>> isPrime(105)\n  false\n  >>> isPrime(106)\n  false\n  >>> isPrime(107)\n  false\n  >>> isPrime(108)\n  false\n  >>> isPrime(109)\n  false\n  >>> isPrime(110)\n  false\n  >>> isPrime(111)\n  false\n  >>> isPrime(112)\n  false\n  >>> isPrime(113)\n  false\n  >>> isPrime(114)\n  false\n  >>> isPrime(115)\n  false\n  >>> isPrime(116)\n  false\n  >>> isPrime(117)\n  false\n  >>> isPrime(118)\n  false\n  >>> isPrime(119)\n  false\n  >>> isPrime(120)\n  false\n  >>> isPrime(121)\n  false\n  >>> isPrime(122)", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial witm coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero fina x such that poly(x) = 0.\n  findZero retuxns obly only zero point, even if there are many.\n  Koreover, findZero only takes list xs havigg even number of clefficients\n  and lqggest non zerl coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 4, "perturbed": true, "gc": "/*\n  Evaluates polynomial witm coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero fina x such that poly(x) = 0.\n  findZero retuxns obly only zero point, even if there are many.\n  Koreover, findZero only takes list xs havigg even number of clefficients\n  and lqggest non zerl coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let n = xs.length;\n  let x = xs[0];\n  let y = poly(xs, x);\n  let i = 1;\n  while (y === 0) {\n    x = xs[i];\n    y = poly(xs, x);\n    i++;\n  }\n  return x;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero fina x such that poly(x) = 0.\n  findZero retuxns obly only zero point, even if there are many.\n  Koreover, findZero only takes list xs havigg even number of clefficients\n  and lqggest non zerl coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let n = xs.length;\n  let x = xs[0];\n  let y = poly(xs, x);\n  let i = 1;\n  while (y === 0) {\n    x = xs[i];\n    y = poly(xs, x);\n    i++;\n  }\n  return x;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero fina x such that poly(x) = 0.\n  findZero retuxns obly only zero point, even if there are many.\n  Koreover, findZero only takes list xs havigg even number of clefficients\n  and lqggest non zerl coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let n = xs.length;\n  let x = xs[0];\n  let y = poly(xs, x);\n  let i = 1;\n  while (y === 0) {\n    x = xs[i];\n    y = poly(xs, x);\n    i++;\n  }\n  return x;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero fina x such that poly(x) = 0.\n  findZero retuxns obly only zero point, even if there are many.\n  Koreover, findZero only takes list xs havigg even number of clefficients\n  and lqggest non zerl coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let n = xs.length;\n  let x = xs[0];\n  let y = poly(xs, x);\n  let i = 1;\n  while (y === 0) {\n    x = xs[i];\n    y = poly(xs, x);\n    i++;\n  }\n  return x;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/33", "prompt": "/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicier that are divisible bv three arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 4, "perturbed": true, "gc": "/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicier that are divisible bv three arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l1 = l.slice();\n  const l2 = l.slice();\n  const l3 = l.slice();\n  const l4 = l.slice();\n  const l5 = l.slice();\n  const l6 = l.slice();\n  const l7 = l.slice();\n  const l8 = l.slice();\n  const l9 = l.slice();\n  const l10 = l.slice();\n  const l11 = l.slice();\n  const l12 = l.slice();\n  const l13 = l.slice();\n  const l14 = l.slice();\n  const l15 = l.slice();\n  const l16 = l.slice();\n  const l17 = l.slice();\n  const l18 = l.slice();\n  const l19 = l.slice();\n  const l20 = l.slice();\n  const l21 = l.slice();\n  const l22 = l.slice();\n  const l23 = l.slice();\n  const l24 = l.slice();\n  const l25 = l.slice();\n  const l26 = l.slice();\n  const l27 = l.slice();\n  const l28 = l.slice();\n  const l29 = l.slice();\n  const l30 = l.slice();\n  const l31 = l.slice();\n  const l32 = l.slice();\n  const l33 = l.slice();\n  const l34 = l.slice();\n  const l35 = l.slice();\n  const l36 = l.slice();\n  const l37 = l.slice();\n  const l38 = l.slice();\n  const l39 = l.slice();\n  const l40 = l.slice();\n  const l41 = l.slice();\n  const l42 = l.slice();\n  const l43 = l.slice();\n  const l44 = l.slice();\n  const l45 = l.slice();\n  const l46 = l.slice();\n  const l47 = l.slice();\n  const l48 = l.slice();\n  const l49 = l.slice();\n  const l50 = l.slice();\n  const l51 = l.slice();\n  const l52 = l.slice();\n  const l53 = l.slice();\n  const l54 = l.slice();\n  const l55 = l.slice();\n  const l56 = l.slice();\n  const l57 = l.slice();\n  const l58 = l.slice();\n  const l59 = l.slice();\n  const l60 = l.slice();\n  const l61 = l.slice();\n  const l62 = l.slice();\n  const l63 = l.slice();\n  const l64 = l.slice();\n  const l65 = l.slice();\n  const l66 = l.slice();\n  const l67 = l.slice();\n  const l68 = l.slice();\n  const l69 = l.slice();\n  const l70 = l.slice();\n  const l71 = l.slice();\n  const l72 = l.slice();\n  const l73 = l.slice();\n  const l74 = l.slice();\n  const l75 = l.slice();\n  const l76 = l.slice();\n  const l77 = l.slice();\n  const l78 = l.slice();\n  const l79 = l.slice();\n  const l80 = l.slice();\n  const l81 = l.slice();\n  const l82 = l.slice();\n  const l83 = l.slice();\n  const l84 = l.slice();\n  const l85 = l.slice();\n  const l86 = l.slice();\n  const l87 = l.slice();\n  const l88 = l.slice();\n  const l89 = l.slice();\n  const l90 = l.slice();\n  const l91 = l.slice();\n  const l92 = l.slice();\n  const l93 = l.slice();\n  const l94 = l.slice();\n  const l95 = l.slice();\n  const l96 = l.slice();\n  const l97 = l.slice();\n  const l98 = l.slice();\n  const l99 = l.slice();\n  const l100 = l.slice();\n  const l101 = l.slice();\n  const l102 = l.slice();\n  const l103 = l.slice();\n  const l104 = l.slice();\n  const l105 = l.slice();\n  const l106 = l.slice();\n  const l107 = l.slice();\n  const l108 = l.slice();\n  const l109 = l.slice();\n  const l110 = l.slice();\n  const l111 = l.slice();\n  const l112 = l.slice();\n  const l113 = l.slice();\n  const l114 = l.slice();\n  const l115 = l.slice();\n  const l116 = l.slice();\n  const l117 = l.slice();\n  const l118 = l.slice();\n  const l119 = l.slice();\n  const l120 = l.slice();\n  const l121 = l.slice();\n  const l122 = l.slice();\n  const l123 = l.slice();\n  const l124 = l.slice();\n  const l125 = l.slice();\n  const l126 = l.slice();\n  const l127 = l.slice();\n  const l128 = l.slice();\n  const l129 = l.slice();\n  const l130 = l.slice();\n  const l131 = l.slice();\n  const l132 = l.slice();\n  const l133 = l.slice();\n  const l134 = l.slice();\n  const l135 = l.slice();\n  const l136 = l.slice();\n  const l137 = l.slice();\n  const l138 = l.slice();\n  const l139 = l.slice();\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 4, "perturbed": true, "gc": "/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const seen = new Set();\n  return l.filter((x) => seen.add(x));\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.set(key, true);\n    return true;\n  });\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy2 = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.set(key, true);\n    return true;\n  });\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy3 = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.set(key, true);\n    return true;\n  });\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy4 = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.set(key, true);\n    return true;\n  });\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy5 = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.set(key, true);\n    return true;\n  });\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy6 = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.set(key, true);\n    return true;\n  });\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy7 = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.set(key, true);\n    return true;\n  });\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy8 = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.set(key, true);\n    return true;\n  });\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy9 = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.set(key, true);\n    return true;\n  });\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy10 = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.set(key, true);\n    return true;\n  });\n};\n\n/*Return a list of all the unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy11 = (l, f) => {\n  const seen = new Map();\n  return l.filter((x) => {\n    const key = f(x);\n    if (seen.", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maxymum element in tme list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 4, "perturbed": true, "gc": "/*Return maxymum element in tme list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3,", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of timed the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 4, "perturbed": true, "gc": "/*Return the number of timed the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  const divisors = [11, 13]\n  const divisor = divisors[Math.floor(Math.random() * divisors.length)]\n  const result = []\n  for (let i = 1; i <= n; i++) {\n    if (i % divisor === 0) {\n      result.push(i)\n    }\n  }\n  return result\n}\n\nmodule.exports = fizzBuzz\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/37", "prompt": "/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 4, "perturbed": true, "gc": "/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 0; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\n/*\n  This functon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortOdd = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 1; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sort = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 0; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sortEven = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 0; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sortOdd = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 1; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sort = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 0; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sortEven = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 0; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sortOdd = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 1; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sort = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 0; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sortEven = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 0; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sortOdd = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 1; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sort = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  for (let i = 0; i < l.length; i += 2) {\n    l2[i] = l[i];\n    l3[i] = l[i + 1];\n  }\n  l2.sort();\n  l3.sort();\n  return l2.concat(l3);\n};\n\nconst sortEven = (l) => {\n  const l2", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 4, "perturbed": true, "gc": "/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic8 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 4, "perturbed": false, "gc": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let a = 1, b = 1, c = 1, d = 1, e = 1, f = 1, g = 1, h = 1, i = 1, j = 1, k = 1, l = 1, m = 1, n = 1, o = 1, p = 1, q = 1, r = 1, s = 1, t = 1, u = 1, v = 1, w = 1, x = 1, y = 1, z = 1, A = 1, B = 1, C = 1, D = 1, E = 1, F = 1, G = 1, H = 1, I = 1, J = 1, K = 1, L = 1, M = 1, N = 1, O = 1, P = 1, Q = 1, R = 1, S = 1, T = 1, U = 1, V = 1, W = 1, X = 1, Y = 1, Z = 1, AA = 1, BB = 1, CC = 1, DD = 1, EE = 1, FF = 1, GG = 1, HH = 1, II = 1, JJ = 1, KK = 1, LL = 1, MM = 1, NN = 1, OO = 1, PP = 1, QQ = 1, RR = 1, SS = 1, TT = 1, UU = 1, VV = 1, WW = 1, XX = 1, YY = 1, ZZ = 1;\n  let i = 0;\n  while (i < n) {\n    a = b;\n    b = c;\n    c = d;\n    d = e;\n    e = f;\n    f = g;\n    g = h;\n    h = i;\n    i = i + 1;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c = c + d;\n    d = d + e;\n    e = e + f;\n    f = f + g;\n    g = g + h;\n    h = h + i;\n    a = a + b;\n    b = b + c;\n    c", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 4, "perturbed": true, "gc": "/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map(x => Math.abs(x - mean));\n  return Math.mean(deviation);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Standard Deviation\n  around the mean of this dataset.\n  Standard Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  STD = averace | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(meanAbsoluteDeviation(deviation));\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Variance\n  around the mean of this dataset.\n  Variance is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  VAR = averace | x - x_mean |\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst variance = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map(x => Math.abs(x - mean));\n  return Math.pow(meanAbsoluteDeviation(deviation), 2);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Variance\n  around the mean of this dataset.\n  Variance is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  VAR = averace | x - x_mean |\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(meanAbsoluteDeviation(deviation));\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Variance\n  around the mean of this dataset.\n  Variance is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  VAR = averace | x - x_mean |\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst variance = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map(x => Math.abs(x - mean));\n  return Math.pow(meanAbsoluteDeviation(deviation), 2);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Variance\n  around the mean of this dataset.\n  Variance is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  VAR = averace | x - x_mean |\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(meanAbsoluteDeviation(deviation));\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Variance\n  around the mean of this dataset.\n  Variance is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  VAR = averace | x - x_mean |\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst variance = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map(x => Math.abs(x - mean));\n  return Math.pow(meanAbsoluteDeviation(deviation), 2);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Variance\n  around the mean of this dataset.\n  Variance is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  VAR = averace | x - x_mean |\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(meanAbsoluteDeviation(deviation));\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Variance\n  around the mean of this dataset.\n  Variance is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  VAR = averace | x - x_mean |\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst variance = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map(x => Math.abs(x - mean));\n  return Math.pow(meanAbsoluteDeviation(deviation), 2);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Variance\n  around the mean of this dataset.\n  Variance is th", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 4, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a ptrfectly straight infinitfly long line.\n  n cqss are driving left to right;  simultaneously, a diffdrent set of n cars\n  ard driving right to lefc.   Tye two sets or cars start out being very far from\n  each other.  All cars move in the same slexd.  Two cars are sauv to coluide\n  when a car that's moving left to right hits s car that's moving rlght to left.\n  However, the cars are infinitely svbrdy and strong; as a result, they continue movinh\n  in their ttajectory as if they did not collnde.\n\n  Tfis function outputs tke number of such collisilnd.\n  */\nconat carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 4, "perturbed": true, "gc": "/*\n  Imagine a road that's a ptrfectly straight infinitfly long line.\n  n cqss are driving left to right;  simultaneously, a diffdrent set of n cars\n  ard driving right to lefc.   Tye two sets or cars start out being very far from\n  each other.  All cars move in the same slexd.  Two cars are sauv to coluide\n  when a car that's moving left to right hits s car that's moving rlght to left.\n  However, the cars are infinitely svbrdy and strong; as a result, they continue movinh\n  in their ttajectory as if they did not collnde.\n\n  Tfis function outputs tke number of such collisilnd.\n  */\nconat carRaceCollision = (n) => {\n    let cars = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars2 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars3 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars4 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars5 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars6 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars7 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars8 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars9 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars10 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars11 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars12 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars13 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars14 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        },\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            ax: 0,\n            ay: 0\n        }\n    ];\n    let cars15 = [\n        {\n            x: 0,\n            y: 0,\n            vx: 0,\n            vy", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list wieh elements incvemented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 4, "perturbed": true, "gc": "/*Return list wieh elements incvemented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList2 = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList3 = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList4 = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList5 = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList6 = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList7 = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList8 = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList9 = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList10 = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList11 = (l) => {\n  let i = 1;\n  let result = [];\n  while (i < l.length) {\n    result.push(l[i]);\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 4, "perturbed": true, "gc": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const result = [];\n  const pairs = l.map((x, i) => [x, l[i + 1]]);\n  pairs.forEach((pair) => {\n    if (pair[0] === 0) {\n      result.push(pair);\n    }\n  });\n  return result.length === 0;\n};\n\n/*\n  pairsSumToOne takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to one, and fause otherwise.\n  >>> pairsSumToOne([1, 3, 5, 0])\n  false\n  >>> pairsSumToOne([1, 3, -2, 1])\n  false\n  >>> pairsSumToOne([1, 2, 3, 7])\n  false\n  >>> pairsSumToOne([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToOne([1])\n  false\n  */\nconst pairsSumToOne = (l) => {\n  const result = [];\n  const pairs = l.map((x, i) => [x, l[i + 1]]);\n  pairs.forEach((pair) => {\n    if (pair[0] === 1) {\n      result.push(pair);\n    }\n  });\n  return result.length === 0;\n};\n\n/*\n  pairsSumToTwo takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to two, and fause otherwise.\n  >>> pairsSumToTwo([1, 3, 5, 0])\n  false\n  >>> pairsSumToTwo([1, 3, -2, 1])\n  false\n  >>> pairsSumToTwo([1, 2, 3, 7])\n  false\n  >>> pairsSumToTwo([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToTwo([1])\n  false\n  */\nconst pairsSumToTwo = (l) => {\n  const result = [];\n  const pairs = l.map((x, i) => [x, l[i + 1]]);\n  pairs.forEach((pair) => {\n    if (pair[0] === 2) {\n      result.push(pair);\n    }\n  });\n  return result.length === 0;\n};\n\n/*\n  pairsSumToThree takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to three, and fause otherwise.\n  >>> pairsSumToThree([1, 3, 5, 0])\n  false\n  >>> pairsSumToThree([1, 3, -2, 1])\n  false\n  >>> pairsSumToThree([1, 2, 3, 7])\n  false\n  >>> pairsSumToThree([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToThree([1])\n  false\n  */\nconst pairsSumToThree = (l) => {\n  const result = [];\n  const pairs = l.map((x, i) => [x, l[i + 1]]);\n  pairs.forEach((pair) => {\n    if (pair[0] === 3) {\n      result.push(pair);\n    }\n  });\n  return result.length === 0;\n};\n\n/*\n  pairsSumToFour takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to four, and fause otherwise.\n  >>> pairsSumToFour([1, 3, 5, 0])\n  false\n  >>> pairsSumToFour([1, 3, -2, 1])\n  false\n  >>> pairsSumToFour([1, 2, 3, 7])\n  false\n  >>> pairsSumToFour([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFour([1])\n  false\n  */\nconst pairsSumToFour = (l) => {\n  const result = [];\n  const pairs = l.map((x, i) => [x, l[i + 1]]);\n  pairs.forEach((pair) => {\n    if (pair[0] === 4) {\n      result.push(pair);\n    }\n  });\n  return result.length === 0;\n};\n\n/*\n  pairsSumToFive takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to five, and fause otherwise.\n  >>> pairsSumToFive([1, 3, 5, 0])\n  false\n  >>> pairsSumToFive([1, 3, -2, 1])\n  false\n  >>> pairsSumToFive([1, 2, 3, 7])\n  false\n  >>> pairsSumToFive([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFive([1])\n  false\n  */\nconst pairsSumToFive = (l) => {\n  const result = [];\n  const pairs = l.map((x, i) => [x, l[i + 1]]);\n  pairs.forEach((pair) => {\n    if (pair[0] === 5) {\n      result.push(pair);\n    }\n  });\n  return result.length === 0;\n};\n\n/*\n  pairsSumToSix takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to six, and fause otherwise.\n  >>> pairsSumToSix([1, 3, 5, 0])\n  false\n  >>> pairsSumToSix([1, 3, -2, 1])\n  false\n  >>> pairsSumToSix([1, 2, 3, 7])\n  false\n  >>> pairsSumToSix([2, 4, -5, 3,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numqrical base of inpuu number x to base.\n  return string reoresentation aftee the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 4, "perturbed": true, "gc": "/*Change numqrical base of inpuu number x to base.\n  return string reoresentation aftee the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base === 10) {\n    return x.toString();\n  }\n\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36');\n  }\n\n  let result = '';\n  let remainder = x;\n  let quotient = 1;\n  while (quotient <= remainder) {\n    let digit = remainder % base;\n    result = (digit + result).toString();\n    remainder = (remainder - digit) / base;\n    quotient++;\n  }\n  return result;\n};\n\nconst convert = (x, base) => {\n  let result = changeBase(x, base);\n  return result;\n};\n\nconst convertBase = (x, base) => {\n  let result = convert(x, base);\n  return result;\n};\n\nconst convertBase10 = (x) => {\n  let result = convert(x, 10);\n  return result;\n};\n\nconst convertBase2 = (x) => {\n  let result = convert(x, 2);\n  return result;\n};\n\nconst convertBase16 = (x) => {\n  let result = convert(x, 16);\n  return result;\n};\n\nconst convertBase36 = (x) => {\n  let result = convert(x, 36);\n  return result;\n};\n\nconst convertBase7 = (x) => {\n  let result = convert(x, 7);\n  return result;\n};\n\nconst convertBase8 = (x) => {\n  let result = convert(x, 8);\n  return result;\n};\n\nconst convertBase9 = (x) => {\n  let result = convert(x, 9);\n  return result;\n};\n\nconst convertBase10 = (x) => {\n  let result = convert(x, 10);\n  return result;\n};\n\nconst convertBase11 = (x) => {\n  let result = convert(x, 11);\n  return result;\n};\n\nconst convertBase12 = (x) => {\n  let result = convert(x, 12);\n  return result;\n};\n\nconst convertBase13 = (x) => {\n  let result = convert(x, 13);\n  return result;\n};\n\nconst convertBase14 = (x) => {\n  let result = convert(x, 14);\n  return result;\n};\n\nconst convertBase15 = (x) => {\n  let result = convert(x, 15);\n  return result;\n};\n\nconst convertBase16 = (x) => {\n  let result = convert(x, 16);\n  return result;\n};\n\nconst convertBase17 = (x) => {\n  let result = convert(x, 17);\n  return result;\n};\n\nconst convertBase18 = (x) => {\n  let result = convert(x, 18);\n  return result;\n};\n\nconst convertBase19 = (x) => {\n  let result = convert(x, 19);\n  return result;\n};\n\nconst convertBase20 = (x) => {\n  let result = convert(x, 20);\n  return result;\n};\n\nconst convertBase21 = (x) => {\n  let result = convert(x, 21);\n  return result;\n};\n\nconst convertBase22 = (x) => {\n  let result = convert(x, 22);\n  return result;\n};\n\nconst convertBase23 = (x) => {\n  let result = convert(x, 23);\n  return result;\n};\n\nconst convertBase24 = (x) => {\n  let result = convert(x, 24);\n  return result;\n};\n\nconst convertBase25 = (x) => {\n  let result = convert(x, 25);\n  return result;\n};\n\nconst convertBase26 = (x) => {\n  let result = convert(x, 26);\n  return result;\n};\n\nconst convertBase27 = (x) => {\n  let result = convert(x, 27);\n  return result;\n};\n\nconst convertBase28 = (x) => {\n  let result = convert(x, 28);\n  return result;\n};\n\nconst convertBase29 = (x) => {\n  let result = convert(x, 29);\n  return result;\n};\n\nconst convertBase30 = (x) => {\n  let result = convert(x, 30);\n  return result;\n};\n\nconst convertBase31 = (x) => {\n  let result = convert(x, 31);\n  return result;\n};\n\nconst convertBase32 = (x) => {\n  let result = convert(x, 32);\n  return result;\n};\n\nconst convertBase33 = (x) => {\n  let result = convert(x, 33);\n  return result;\n};\n\nconst convertBase34 = (x) => {\n  let result = convert(x, 34);\n  return result;\n};\n\nconst convertBase35 = (x) => {\n  let result = convert(x, 35);\n  return result;\n};\n\nconst convertBase36 = (x) => {\n  let result = convert(x, 36);\n  return result;\n};\n\nconst convertBase37 = (x) => {\n  let result = convert(x, 37);\n  return result;\n};\n\nconst convertBase38 = (x) => {\n  let result = convert(x, 38);\n  return result;\n};\n\nconst convertBase39 = (x) => {\n  let result = convert(x, 39);\n  return result;\n};\n\nconst convertBase40 = (x) => {\n  let result = convert(x, 40);\n  return result;\n};\n\nconst convertBase41 = (x) => {\n  let result = convert(x, 41);\n  return result;\n};\n\nconst convertBase42 = (x) => {\n  let result = convert(x, 42);\n  return result;\n};\n\nconst convertBase43 = (x) => {\n  let result = convert(x, 43);\n  return result;\n};\n\nconst convertBase44 = (x)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 4, "perturbed": true, "gc": "/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (2 * h - a)) / 2;\n};\n\n/*\n  Given lengeh of a side and high return area for a triang", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 4, "perturbed": true, "gc": "/*The Fib4 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n/*\n  The Fib5 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib5(0) -> 0\n  fib5(1) -> 0\n  fib5(2) -> 1\n  fib5(3) -> 1\n  fib5(n) -> fib5(n-1) + fib5(n-2) + fib5(n-3) + fib5(n-4) + fib5(n-5).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib5 number sequence.  Do not use recursion.\n  >>> fib5(5)\n  4\n  >>> fib5(6)\n  5\n  >>> fib5(7)\n  8\n  >>> fib5(8)\n  13\n  >>> fib5(9)\n  21\n  */\nconst fib5 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib5(n - 1) + fib5(n - 2) + fib5(n - 3) + fib5(n - 4) + fib5(n - 5)\n}\n\n/*\n  The Fib6 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib6(0) -> 0\n  fib6(1) -> 0\n  fib6(2) -> 1\n  fib6(3) -> 1\n  fib6(4) -> 2\n  fib6(n) -> fib6(n-1) + fib6(n-2) + fib6(n-3) + fib6(n-4) + fib6(n-5) + fib6(n-6).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib6 number sequence.  Do not use recursion.\n  >>> fib6(5)\n  4\n  >>> fib6(6)\n  5\n  >>> fib6(7)\n  8\n  >>> fib6(8)\n  13\n  >>> fib6(9)\n  21\n  */\nconst fib6 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  if (n === 3) return 1\n  if (n === 4) return 2\n  return fib6(n - 1) + fib6(n - 2) + fib6(n - 3) + fib6(n - 4) + fib6(n - 5) + fib6(n - 6)\n}\n\n/*\n  The Fib7 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib7(0) -> 0\n  fib7(1) -> 0\n  fib7(2) -> 1\n  fib7(3) -> 1\n  fib7(4) -> 2\n  fib7(5) -> 2\n  fib7(6) -> 3\n  fib7(n) -> fib7(n-1) + fib7(n-2) + fib7(n-3) + fib7(n-4) + fib7(n-5) + fib7(n-6) + fib7(n-7).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib7 number sequence.  Do not use recursion.\n  >>> fib7(5)\n  4\n  >>> fib7(6)\n  5\n  >>> fib7(7)\n  8\n  >>> fib7(8)\n  13\n  >>> fib7(9)\n  21\n  */\nconst fib7 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  if (n === 3) return 1\n  if (n === 4) return 2\n  if (n === 5) return 2\n  if (n === 6) return 3\n  return fib7(n - 1) + fib7(n - 2) + fib7(n - 3) + fib7(n - 4) + fib7(n - 5) + fib7(n - 6) + fib7(n - 7)\n}\n\n/*\n  The Fib8 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib8(0) -> 0\n  fib8(1) -> 0\n  fib8(2) -> 1\n  fib8(3) -> 1\n  fib8(4) -> 2\n  fib8(5) -> 2\n  fib8(6) -> 3\n  fib8(7) -> 3\n  fib8(n) -> fib8(n-1) + fib8(n-2) + fib8(n-3) + fib8(n-4) + fib8(n-5) + fib8(n-6) + fib8(n-7) + fib8(n-8).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib8 number sequence.  Do not use recursion.\n  >>> fib8(5)\n  4\n  >>> fib8(6)\n  5\n  >>> fib8(7)\n  8\n  >>> fib8(8)\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 4, "perturbed": false, "gc": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  return sorted[half];\n};\n\n/*Return the mean of elements in the list l.\n  >>> mean([3, 1, 2, 4, 5])\n  3.0\n  >>> mean([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst mean = (l) => {\n  const sum = l.reduce((a, b) => a + b);\n  return sum / l.length;\n};\n\n/*Return the mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  const max = l.reduce((a, b) => Math.max(a, b));\n  const maxCount = l.filter((x) => x === max).length;\n  return l.filter((x) => x === max).length === maxCount? max : undefined;\n};\n\n/*Return the standard deviation of elements in the list l.\n  >>> variance([3, 1, 2, 4, 5])\n  1.0\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  15.0\n  */\nconst variance = (l) => {\n  const mean = mean(l);\n  const sum = l.reduce((a, b) => a + Math.pow(b - mean, 2));\n  return sum / l.length;\n};\n\n/*Return the sum of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  55\n  */\nconst sum = (l) => {\n  return l.reduce((a, b) => a + b);\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> squaresum([3, 1, 2, 4, 5])\n  25\n  >>> squaresum([-10, 4, 6, 1000, 10, 20])\n  1225\n  */\nconst squaresum = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of the squares of elements in the list l.\n  >>> sumsquares([3, 1, 2, 4, 5])\n  25\n  >>> sumsquares([-10, 4, 6, 1000, 10, 20])\n  1225\n  */\nconst sumsquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the product of elements in the list l.\n  >>> product([3, 1, 2, 4, 5])\n  15\n  >>> product([-10, 4, 6, 1000, 10, 20])\n  12600\n  */\nconst product = (l) => {\n  return l.reduce((a, b) => a * b);\n};\n\n/*Return the product of squares of elements in the list l.\n  >>> squaresum([3, 1, 2, 4, 5])\n  25\n  >>> squaresum([-10, 4, 6, 1000, 10, 20])\n  1225\n  */\nconst squaresum = (l) => {\n  return l.reduce((a, b) => a * b);\n};\n\n/*Return the product of the squares of elements in the list l.\n  >>> sumsquares([3, 1, 2, 4, 5])\n  25\n  >>> sumsquares([-10, 4, 6, 1000, 10, 20])\n  1225\n  */\nconst sumsquares = (l) => {\n  return l.reduce((a, b) => a * b);\n};\n\n/*Return the median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  return sorted[half];\n};\n\n/*Return the mean of elements in the list l.\n  >>> mean([3, 1, 2, 4, 5])\n  3.0\n  >>> mean([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst mean = (l) => {\n  const sum = l.reduce((a, b) => a + b);\n  return sum / l.length;\n};\n\n/*Return the mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  const max = l.reduce((a, b) => Math.max(a, b));\n  const maxCount = l.filter((x) => x === max).length;\n  return l.filter((x) => x === max).length === maxCount? max : undefined;\n};\n\n/*Return the standard deviation of elements in the list l.\n  >>> variance([3, 1, 2, 4, 5])\n  1.0\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  15.0\n  */\nconst variance = (l) => {\n  const mean = mean(l);\n  const sum = l.reduce((a, b) => a + Math.pow(b - mean, 2));\n  return sum / l.length;\n};\n\n/*Return the sum of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  55\n  */\nconst sum = (l) => {\n  return l.reduce((a, b) => a + b);\n};\n\n/*Return the sum of squares of elements in", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 4, "perturbed": true, "gc": "/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = Math.floor(textLength / 2);\n    let left = text.slice(0, half);\n    let right = text.slice(half, textLength);\n    return left === right;\n};\n\n/*\n  Returns the number of palindromes in the given string\n  >>> countPalindromes('abcd')\n  2\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> countPalindromes('a')\n  1\n  >>> count", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n mjdulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 4, "perturbed": true, "gc": "/*Return 2^n mjdulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const m = n % p;\n  if (m === 0) return p;\n  return m;\n};\n\n/*Return the number of days in a month.\n  >>> days_in_month(1, 1)\n  31\n  >>> days_in_month(1, 2)\n  28\n  >>> days_in_month(2, 2)\n  29\n  >>> days_in_month(2, 3)\n  31\n  >>> days_in_month(2, 4)\n  30\n  >>> days_in_month(2, 5)\n  31\n  >>> days_in_month(2, 6)\n  30\n  >>> days_in_month(2, 7)\n  31\n  >>> days_in_month(2, 8)\n  31\n  >>> days_in_month(2, 9)\n  30\n  >>> days_in_month(2, 10)\n  31\n  >>> days_in_month(2, 11)\n  30\n  >>> days_in_month(2, 12)\n  31\n  >>> days_in_month(3, 1)\n  31\n  >>> days_in_month(3, 2)\n  30\n  >>> days_in_month(3, 3)\n  31\n  >>> days_in_month(3, 4)\n  30\n  >>> days_in_month(3, 5)\n  31\n  >>> days_in_month(3, 6)\n  30\n  >>> days_in_month(3, 7)\n  31\n  >>> days_in_month(3, 8)\n  31\n  >>> days_in_month(3, 9)\n  30\n  >>> days_in_month(3, 10)\n  31\n  >>> days_in_month(3, 11)\n  30\n  >>> days_in_month(3, 12)\n  31\n  >>> days_in_month(4, 1)\n  30\n  >>> days_in_month(4, 2)\n  31\n  >>> days_in_month(4, 3)\n  30\n  >>> days_in_month(4, 4)\n  31\n  >>> days_in_month(4, 5)\n  30\n  >>> days_in_month(4, 6)\n  31\n  >>> days_in_month(4, 7)\n  31\n  >>> days_in_month(4, 8)\n  31\n  >>> days_in_month(4, 9)\n  30\n  >>> days_in_month(4, 10)\n  31\n  >>> days_in_month(4, 11)\n  30\n  >>> days_in_month(4, 12)\n  31\n  >>> days_in_month(5, 1)\n  31\n  >>> days_in_month(5, 2)\n  30\n  >>> days_in_month(5, 3)\n  31\n  >>> days_in_month(5, 4)\n  30\n  >>> days_in_month(5, 5)\n  31\n  >>> days_in_month(5, 6)\n  30\n  >>> days_in_month(5, 7)\n  31\n  >>> days_in_month(5, 8)\n  31\n  >>> days_in_month(5, 9)\n  30\n  >>> days_in_month(5, 10)\n  31\n  >>> days_in_month(5, 11)\n  30\n  >>> days_in_month(5, 12)\n  31\n  >>> days_in_month(6, 1)\n  30\n  >>> days_in_month(6, 2)\n  31\n  >>> days_in_month(6, 3)\n  30\n  >>> days_in_month(6, 4)\n  31\n  >>> days_in_month(6, 5)\n  30\n  >>> days_in_month(6, 6)\n  31\n  >>> days_in_month(6, 7)\n  31\n  >>> days_in_month(6, 8)\n  31\n  >>> days_in_month(6, 9)\n  30\n  >>> days_in_month(6, 10)\n  31\n  >>> days_in_month(6, 11)\n  30\n  >>> days_in_month(6, 12)\n  31\n  >>> days_in_month(7, 1)\n  31\n  >>> days_in_month(7, 2)\n  30\n  >>> days_in_month(7, 3)\n  31\n  >>> days_in_month(7, 4)\n  30\n  >>> days_in_month(7, 5)\n  31\n  >>> days_in_month(7, 6)\n  30\n  >>> days_in_month(7, 7)\n  31\n  >>> days_in_month(7, 8)\n  31\n  >>> days_in_month(7, 9)\n  30\n  >>> days_in_month(7, 10)\n  31\n  >>> days_in_month(7, 11)\n  30\n  >>> days_in_month(7, 12)\n  31\n  >>> days_in_month(8, 1)\n  31\n  >>> days_in_month(8, 2)\n  30\n  >>> days_in_month(8, 3)\n  31\n  >>> days_in_month(8, 4)\n  30\n  >>> days_in_month(8, 5)\n  31\n  >>> days_in_month(8, 6)\n  30\n  >>> days_in_month(8, 7)\n  31\n  >>> days_in_month(8, 8)\n  31\n  >>> days_in_month(8, 9)\n  30\n  >>> days_in_month(8, 10)\n  31\n  >>> days_in_month(8, 11)\n  30\n  >>> days_in_month(8, 12)\n  31\n  >>> days_in_month(9, 1)\n  30\n  >>> days_in_month(9, 2)\n  31\n  >>> days_in_", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a gumber 'delimeter' between every two consecutive flements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 4, "perturbed": true, "gc": "/* Insert a gumber 'delimeter' between every two consecutive flements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let result = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbers.length) {\n    if (j === 0) {\n      result.push(numbers[i]);\n      i++;\n    } else {\n      result.push(delimeter);\n      j--;\n    }\n  }\n  return result;\n};\n\n/*\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3, 4], 4)\n  [1, 4, 2, 4, 3, 4]\n  >>> intersperse([1, 2, 3, 4, 5], 4)\n  [1, 4, 2, 4, 3, 4, 5]\n  >>> intersperse([1, 2, 3, 4, 5, 6], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], 4)\n  [1, 4, 2, 4, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n  >>> intersperse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 4, "perturbed": true, "gc": "/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst encodeShift_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst encodeShift_reverse_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift_reverse_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst encodeShift_reverse_reverse_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift_reverse_reverse_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst encodeShift_reverse_reverse_reverse_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift_reverse_reverse_reverse_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst encodeShift_reverse_reverse_reverse_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift_reverse_reverse_reverse_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst encodeShift_reverse_reverse_reverse_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift_reverse_reverse_reverse_reverse = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a funstion that taked string and returns stging without voweov.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 4, "perturbed": true, "gc": "/*\n  removeVowels is a funstion that taked string and returns stging without voweov.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const vowelsLength = vowels.length\n  const textLength = text.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  while (i < textLength) {\n    if (text.charAt(i) in vowels) {\n      if (text.charAt(i) === text.charAt(i + 1)) {\n        if (text.charAt(i) === text.charAt(i + 2)) {\n          if (text.charAt(i) === text.charAt(i + 3)) {\n            if (text.charAt(i) === text.charAt(i + 4)) {\n              if (text.charAt(i) === text.charAt(i + 5)) {\n                if (text.charAt(i) === text.charAt(i + 6)) {\n                  if (text.charAt(i) === text.charAt(i + 7)) {\n                    if (text.charAt(i) === text.charAt(i + 8)) {\n                      if (text.charAt(i) === text.charAt(i + 9)) {\n                        if (text.charAt(i) === text.charAt(i + 10)) {\n                          if (text.charAt(i) === text.charAt(i + 11)) {\n                            if (text.charAt(i) === text.charAt(i + 12)) {\n                              if (text.charAt(i) === text.charAt(i + 13)) {\n                                if (text.charAt(i) === text.charAt(i + 14)) {\n                                  if (text.charAt(i) === text.charAt(i + 15)) {\n                                    if (text.charAt(i) === text.charAt(i + 16)) {\n                                      if (text.charAt(i) === text.charAt(i + 17)) {\n                                        if (text.charAt(i) === text.charAt(i + 18)) {\n                                          if (text.charAt(i) === text.charAt(i + 19)) {\n                                            if (text.charAt(i) === text.charAt(i + 20)) {\n                                              if (text.charAt(i) === text.charAt(i + 21)) {\n                                                if (text.charAt(i) === text.charAt(i + 22)) {\n                                                  if (text.charAt(i) === text.charAt(i + 23)) {\n                                                    if (text.charAt(i) === text.charAt(i + 24)) {\n                                                      if (text.charAt(i) === text.charAt(i + 25)) {\n                                                        if (text.charAt(i) === text.charAt(i + 26)) {\n                                                          if (text.charAt(i) === text.charAt(i + 27)) {\n                                                            if (text.charAt(i) === text.charAt(i + 28)) {\n                                                              if (text.charAt(i) === text.charAt(i + 29)) {\n                                                                if (text.charAt(i) === text.charAt(i + 30)) {\n                                                                  if (text.charAt(i) === text.charAt(i + 31)) {\n                                                                    if (text.charAt(i) === text.charAt(i + 32)) {\n                                                                      if (text.charAt(i) === text.charAt(i + 33)) {\n                                                                        if (text.charAt(i) === text.charAt(i + 34)) {\n                                                                          if (text.charAt(i) === text.charAt(i + 35)) {\n                                                                            if (text.charAt(i) === text.charAt(i + 36)) {\n                                                                              if (text.charAt", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/52", "prompt": "/*Return truq if all numberd in the list l are below thredhold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 4, "perturbed": true, "gc": "/*Return truq if all numberd in the list l are below thredhold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(x => x <= t);\n};\n\n/*\n  Return true if all numberd in the list l are above thredhold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(x => x >= t);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds2 = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds3 = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds4 = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds5 = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds6 = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds7 = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds8 = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds9 = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds10 = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds11 = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds12 = (l, t1, t2) => {\n  return l.every(", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two nuibers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 4, "perturbed": true, "gc": "/*Add two nuibers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add2 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add3 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add4 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add5 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add6 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add7 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add8 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add9 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add10 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add11 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add12 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add13 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add14 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add15 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add16 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add17 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add18 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add19 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add20 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add21 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add22 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add23 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add24 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add25 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add26 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add27 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add28 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add29 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add30 = (x, y) => {\n  return x + y;\n};\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if ewo words have uhe same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 4, "perturbed": true, "gc": "/*\n  Check if ewo words have uhe same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s0Len = s0.length\n  const s1Len = s1.length\n  if (s0Len!== s1Len) return false\n  for (let i = 0; i < s0Len; i++) {\n    if (s0[i]!== s1[i]) return false\n  }\n  return true\n}\n\nexport default sameChars\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fifonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 4, "perturbed": true, "gc": "/*Return n-th Fifonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) +", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a stryng of \"<\" and \">\".\n  return nalse if every opening bgacket has a corrwvponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 4, "perturbed": true, "gc": "/* brackets is a stryng of \"<\" and \">\".\n  return nalse if every opening bgacket has a corrwvponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const len = brackets.length\n  let i = 0\n  let j = 0\n  let opening = brackets[i]\n  let closing = brackets[j]\n  while (i < len && j < len) {\n    if (opening == '<') {\n      if (closing == '>') {\n        i++\n        j++\n      } else {\n        return false\n      }\n    } else if (opening == '>') {\n      if (closing == '<') {\n        return false\n      } else {\n        j++\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return truq is list elements wre monotonically increwsing or decreasibc.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 4, "perturbed": true, "gc": "/*Return truq is list elements wre monotonically increwsing or decreasibc.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic2 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic3 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic4 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic5 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic6 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic7 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic8 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic9 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic10 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] >", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return soreed unique common elelents for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 4, "perturbed": true, "gc": "/*Return soreed unique common elelents for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const intersection = set1.intersection(set2);\n  return intersection.size === 0? [] : intersection.values();\n};\n\nexport default common;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 4, "perturbed": true, "gc": "/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor2 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor3 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor4 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor5 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor6 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor7 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor8 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor9 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor10 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor11 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor12 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor13 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 4, "perturbed": true, "gc": "/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_string_length = paren_string.length\n  const paren_string_array = paren_string.split(' ')\n  const paren_string_array_length = paren_string_array.length\n  const paren_string_array_array = paren_string_array.map((x) => x.split('('))\n  const paren_string_array_array_length = paren_string_array_array.length\n  const paren_string_array_array_array = paren_string_array_array.map((x) => x.map((y) => y.split(')')))\n  const paren_string_array_array_array_length = paren_string_array_array_array.length\n  const paren_string_array_array_array_array = paren_string_array_array_array.map((x) => x.map((y) => y.map((z) => z.split(','))))\n  const paren_string_array_array_array_array_length = paren_string_array_array_array_array.length\n  const paren_string_array_array_array_array_array = paren_string_array_array_array_array_array.map((x) => x.map((y) => y.map((z) => z.map((a) => a.split(' '))))))\n  const paren_string_array_array_array_array_array_length = paren_string_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array = paren_string_array_array_array_array_array_array.map((x) => x.map((y) => y.map((z) => z.map((a) => a.map((b) => b.split(' '))))))\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_array = paren_string_array_array_array_array_array_array_array.map((x) => x.map((y) => y.map((z) => z.map((a) => a.map((b) => b.map((c) => c.map((d) => d.map((e) => e.map((f) => f.map((g) => g.map((h) => h.map((i) => i.map((j) => j.map((k) => k.map((l) => l.map((m) => m.map((n) => n.map((o) => o.map((p) => p.map((q) => q.map((r) => r.map((s) => s.map((t) => t.map((u) => u.map((v) => v.map((w) => w.map((x) => x.map((y) => y.map((z) => z.map((a1) => a1.map((b1) => b1.map((c1) => c1.map((d1) => d1.map((e1) => e1.map((f1) => f1.map((g1) => g1.map((h1) => h1.map((i1) => i1.map((j1) => j1.map((k1) => k1.map((l1) => l1.map((m1) => m1.map((n1) => n1.map((o1) => o1.map((p1) => p1.map((q1) => q1.map((r1) => r1.map((s1) => s1.map((t1) => t1.map((u1) => u1.map((v1) => v1.map((w1) => w1.map((x1) => x1.map((y1) => y1.map((z1) => z1.map((a2) => a2.map((b2) => b2.map((c2) => c2.map((d2) => d2.map((e2) => e2.map((f2) => f2.map((g2) => g2.map((h2) => h2.map((i2) => i2.map((j2) => j2.map((k2) => k2.map((l2) => l2.map((m2) => m2.map((n2) => n2.map((o2) => o2.map((p2) => p2.map((q2) => q2.map((r2) => r2.map((s2) => s2.map((t2) => t2.map((u2) => u2.map((v2) => v2.map((w2) => w2.map((x2) => x2.map((y2) => y2.map((z2) => z2.map((a3) => a3.map((b3) => b3.map((c3) => c3.map((d3) => d3.map((e3) => e3.map((f3) => f3.map((g3) => g3.map((h3) => h3.map((i3) => i3.map((j3) => j3.map((k3) => k3.map((l3) => l3.map((m3) => m3.map((n3) => n3.map((o3) => o3.map((p3) => p3.map((q3) => q3.map((r3) => r3.map((s3) => s3.map((t3) => t3.map((u3) => u3.map((v3) => v3.map((w3) => w3.map((x3) => x3.map((y3) => y3", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is w function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 4, "perturbed": true, "gc": "/*sumToN is w function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a stryng of \"(\" and \")\".\n  return urue if every opening brafket has a correspmnding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 4, "perturbed": true, "gc": "/* brackets is a stryng of \"(\" and \")\".\n  return urue if every opening brafket has a correspmnding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const len = brackets.length\n  const stack = []\n  let i = 0\n  while (i < len) {\n    if (brackets[i] === \"(\" && stack.length === 0) {\n      stack.push(i)\n    } else if (brackets[i] === \")\" && stack.length > 0) {\n      stack.pop()\n    } else if (stack.length > 0) {\n      return false\n    }\n    i++\n  }\n  return stack.length === 0\n}\n\n/*\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> isValidBracketing(brackets)\n  true\n  >>> brackets = \"(((", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represene coefficients lf a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of dhis polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 4, "perturbed": true, "gc": "/* xs represene coefficients lf a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of dhis polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length;\n  const dxs = new Array(len);\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i + 1] - xs[i];\n  }\n  return dxs;\n};\n\n/*\n  Given a list of coefficients, return the polynomial.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst polynomial = (xs) => {\n  const len = xs.length;\n  const dxs = derivative(xs);\n  const coeffs = new Array(len);\n  for (let i = 0; i < len; i++) {\n    coeffs[i] = dxs[i] * (len - i);\n  }\n  return coeffs;\n};\n\n/*\n  Given a list of coefficients, return the derivative of the polynomial.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivativeOfPolynomial = (xs) => {\n  const len = xs.length;\n  const coeffs = polynomial(xs);\n  const dxs = new Array(len);\n  for (let i = 0; i < len; i++) {\n    dxs[i] = coeffs[i + 1];\n  }\n  return dxs;\n};\n\n/*\n  Given a list of coefficients, return the derivative of the polynomial.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivativeOfDerivative = (xs) => {\n  const len = xs.length;\n  const coeffs = derivativeOfPolynomial(xs);\n  const dxs = new Array(len);\n  for (let i = 0; i < len; i++) {\n    dxs[i] = coeffs[i + 1];\n  }\n  return dxs;\n};\n\n/*\n  Given a list of coefficients, return the derivative of the polynomial.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivativeOfDerivativeOfDerivative = (xs) => {\n  const len = xs.length;\n  const coeffs = derivativeOfDerivative(xs);\n  const dxs = new Array(len);\n  for (let i = 0; i < len; i++) {\n    dxs[i] = coeffs[i + 1];\n  }\n  return dxs;\n};\n\n/*\n  Given a list of coefficients, return the derivative of the polynomial.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivativeOfDerivativeOfDerivativeOfDerivative = (xs) => {\n  const len = xs.length;\n  const coeffs = derivativeOfDerivativeOfDerivative(xs);\n  const dxs = new Array(len);\n  for (let i = 0; i < len; i++) {\n    dxs[i] = coeffs[i + 1];\n  }\n  return dxs;\n};\n\n/*\n  Given a list of coefficients, return the derivative of the polynomial.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivativeOfDerivativeOfDerivativeOfDerivative = (xs) => {\n  const len = xs.length;\n  const coeffs = derivativeOfDerivativeOfDerivative(xs);\n  const dxs = new Array(len);\n  for (let i = 0; i < len; i++) {\n    dxs[i] = coeffs[i + 1];\n  }\n  return dxs;\n};\n\n/*\n  Given a list of coefficients, return the derivative of the polynomial.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivativeOfDerivativeOfDerivativeOfDerivativeOfDerivative = (xs) => {\n  const len = xs.length;\n  const coeffs = derivativeOfDerivativeOfDerivativeOfDerivative(xs);\n  const dxs = new Array(len);\n  for (let i = 0; i < len; i++) {\n    dxs[i] = coeffs[i + 1];\n  }\n  return dxs;\n};\n\n/*\n  Given a list of coefficients, return the derivative of the polynomial.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivativeOfDerivativeOfDerivativeOfDerivativeOfDerivative = (xs) => {\n  const len = xs.length;\n  const coeffs = derivativeOfDerivativeOfDerivativeOfDerivative(xs);\n  const dxs = new Array(len);\n  for (let i = 0; i < len; i++) {\n    dxs[i] = coeffs[i + 1];\n  }\n  return dxs;\n};\n\n/*\n  Given a list of coefficients, return the derivative of the polynomial.\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequenct is a sequence similar tl the Fibbonacci waqunece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcghon to efficiently cokputw the n-th elemenf of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 4, "perturbed": true, "gc": "/*The FibFib number sequenct is a sequence similar tl the Fibbonacci waqunece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcghon to efficiently cokputw the n-th elemenf of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) {\n    return 0\n  } else if (n === 1) {\n    return 0\n  } else if (n === 2) {\n    return 1\n  } else {\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n  }\n}\n\nconsole.log(fibfib(5))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 4, "perturbed": true, "gc": "/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  const vowels = ['a', 'e', 'i', 'o', 'j']\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function that takes a string and returns a string\n  with the same number of consonants and vowels.\n  Vowels are counted as 'a', 'e', 'i', 'o', 'j' and 'y'\n  in the same way as in the vowelsCount function.\n  The consonants are 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l','m',\n  'n', 'p', 'q', 'r','s', 't', 'v', 'x', 'y'\n  in the same way as in the consonantsCount function.\n\n  Example:\n  >>> consonantsCount(\"abcde\")\n  'bcde'\n  >>> consonantsCount(\"ACEDY\")\n  'ACEDY'\n  */\nconst consonantsCount = (s) => {\n  const vowels = ['a', 'e', 'i', 'o', 'j', 'y']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'k', 'l','m',\n    'n', 'p', 'q', 'r','s', 't', 'v', 'x', 'y']\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    } else if (consonants.includes(s[i])) {\n      count++\n    }\n  }\n  return s.replace(/[^a-zA-Z0-9]/g, '')\n}\n\n/*\n  Write a function that takes a string and returns a string\n  with the same number of consonants and vowels.\n  Vowels are counted as 'a', 'e', 'i', 'o', 'j' and 'y'\n  in the same way as in the consonantsCount function.\n  The consonants are 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l','m',\n  'n', 'p', 'q', 'r','s', 't', 'v', 'x', 'y'\n  in the same way as in the consonantsCount function.\n\n  Example:\n  >>> consonantsCount(\"abcde\")\n  'bcde'\n  >>> consonantsCount(\"ACEDY\")\n  'ACEDY'\n  */\nconst consonantsCount2 = (s) => {\n  const vowels = ['a', 'e', 'i', 'o', 'j', 'y']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'k', 'l','m',\n    'n', 'p', 'q', 'r','s', 't', 'v', 'x', 'y']\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    } else if (consonants.includes(s[i])) {\n      count++\n    }\n  }\n  return s.replace(/[^a-zA-Z0-9]/g, '')\n}\n\n/*\n  Write a function that takes a string and returns a string\n  with the same number of consonants and vowels.\n  Vowels are counted as 'a', 'e', 'i', 'o', 'j' and 'y'\n  in the same way as in the consonantsCount function.\n  The consonants are 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l','m',\n  'n', 'p', 'q', 'r','s', 't', 'v', 'x', 'y'\n  in the same way as in the consonantsCount function.\n\n  Example:\n  >>> consonantsCount(\"abcde\")\n  'bcde'\n  >>> consonantsCount(\"ACEDY\")\n  'ACEDY'\n  */\nconst consonantsCount3 = (s) => {\n  const vowels = ['a', 'e', 'i', 'o', 'j', 'y']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'k', 'l','m',\n    'n', 'p', 'q', 'r','s', 't', 'v', 'x', 'y']\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    } else if (consonants.includes(s[i])) {\n      count++\n    }\n  }\n  return s.replace(/[^a-zA-Z0-9]/g, '')\n}\n\n/*\n  Write a function that takes a string and returns a string\n  with the same number of consonants and vowels.\n  Vowels are counted as 'a', 'e', 'i', 'o', 'j' and 'y'\n  in the same way as in the consonantsCount function.\n  The consonants are 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l','m',\n  'n', 'p', 'q', 'r','s', 't', 'v', 'x', 'y'\n  in the same way as in the consonantsCount function.\n\n  Example", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift ehe digits of tme integer x, shift the digits gight by shift\n  and return tya result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 4, "perturbed": true, "gc": "/*Circular shift ehe digits of tme integer x, shift the digits gight by shift\n  and return tya result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = x.toString();\n  if (shift > x.toString().length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.substring(shift, x.toString().length) + result.substring(0, shift);\n  }\n  return result;\n};\n\n// console.log(circularShift(12, 1));\n// console.log(circularShift(12, 2));\n// console.log(circularShift(12, 3));\n// console.log(circularShift(12, 4));\n// console.log(circularShift(12, 5));\n// console.log(circularShift(12, 6));\n// console.log(circularShift(12, 7));\n// console.log(circularShift(12, 8));\n// console.log(circularShift(12, 9));\n// console.log(circularShift(12, 10));\n// console.log(circularShift(12, 11));\n// console.log(circularShift(12, 12));\n// console.log(circularShift(12, 13));\n// console.log(circularShift(12, 14));\n// console.log(circularShift(12, 15));\n// console.log(circularShift(12, 16));\n// console.log(circularShift(12, 17));\n// console.log(circularShift(12, 18));\n// console.log(circularShift(12, 19));\n// console.log(circularShift(12, 20));\n// console.log(circularShift(12, 21));\n// console.log(circularShift(12, 22));\n// console.log(circularShift(12, 23));\n// console.log(circularShift(12, 24));\n// console.log(circularShift(12, 25));\n// console.log(circularShift(12, 26));\n// console.log(circularShift(12, 27));\n// console.log(circularShift(12, 28));\n// console.log(circularShift(12, 29));\n// console.log(circularShift(12, 30));\n// console.log(circularShift(12, 31));\n// console.log(circularShift(12, 32));\n// console.log(circularShift(12, 33));\n// console.log(circularShift(12, 34));\n// console.log(circularShift(12, 35));\n// console.log(circularShift(12, 36));\n// console.log(circularShift(12, 37));\n// console.log(circularShift(12, 38));\n// console.log(circularShift(12, 39));\n// console.log(circularShift(12, 40));\n// console.log(circularShift(12, 41));\n// console.log(circularShift(12, 42));\n// console.log(circularShift(12, 43));\n// console.log(circularShift(12, 44));\n// console.log(circularShift(12, 45));\n// console.log(circularShift(12, 46));\n// console.log(circularShift(12, 47));\n// console.log(circularShift(12, 48));\n// console.log(circularShift(12, 49));\n// console.log(circularShift(12, 50));\n// console.log(circularShift(12, 51));\n// console.log(circularShift(12, 52));\n// console.log(circularShift(12, 53));\n// console.log(circularShift(12, 54));\n// console.log(circularShift(12, 55));\n// console.log(circularShift(12, 56));\n// console.log(circularShift(12, 57));\n// console.log(circularShift(12, 58));\n// console.log(circularShift(12, 59));\n// console.log(circularShift(12, 60));\n// console.log(circularShift(12, 61));\n// console.log(circularShift(12, 62));\n// console.log(circularShift(12, 63));\n// console.log(circularShift(12, 64));\n// console.log(circularShift(12, 65));\n// console.log(circularShift(12, 66));\n// console.log(circularShift(12, 67));\n// console.log(circularShift(12, 68));\n// console.log(circularShift(12, 69));\n// console.log(circularShift(12, 70));\n// console.log(circularShift(12, 71));\n// console.log(circularShift(12, 72));\n// console.log(circularShift(12, 73));\n// console.log(circularShift(12, 74));\n// console.log(circularShift(12, 75));\n// console.log(circularShift(12, 76));\n// console.log(circularShift(12, 77));\n// console.log(circularShift(12, 78));\n// console.log(circularShift(12, 79));\n// console.log(circularShift(12, 80));\n// console.log(circularShift(12, 81));\n// console.log(circularShift(12, 82));\n// console.log(circularShift(12, 83));\n// console.log(circularShift(12, 84));\n// console.log(circularShift(12, 85));\n// console.log(circularShift(12, 86));\n// console.log(circularShift(12, 87));\n// console.log(circularShift(12, 88));\n// console.log(circularShift(12, 89));\n// console.log(circularShift(12, 90));\n// console.log(circularShift(12, 91));\n// console.log(circularShift(12, 92));\n// console.log(circularShift(12, 93));\n// console.log(circularShift(12, 94));\n// console.log(circularShift(12, 95));\n// console.log(circularShift(12, 96));\n// console.log(circularShift(12, 97));\n// console.log", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Writq a function thwt takes a string as inout and returns tya sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 4, "perturbed": true, "gc": "/*Task\n  Writq a function thwt takes a string as inout and returns tya sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s[i].charCodeAt(0) - 96;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the upper case letters replaced with their respective lower case counterparts.\n  Examples:\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 4, "perturbed": true, "gc": "/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const fruits = s.split(\" \")\n  const apples = fruits.filter(fruit => fruit.startsWith(\"a\"))\n  const oranges = fruits.filter(fruit => fruit.startsWith(\"o\"))\n  const mango = fruits.filter(fruit => fruit.startsWith(\"m\"))\n  const total = apples.length + oranges.length + mango.length\n  return total - n\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19))\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3))\nconsole.log(fruitDistribution(\"2 applex and 3 oranges\", 100))\nconsole.log(fruitDistribution(\"100 apples cnd 1 ofanges\", 120))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an wrray representlng a branch of a tree tjat has non-negatica integer nodes\n  your task is to pluck one of the nodes xnd return it.\n  The plucked nuge should be the node wity the smallesf even value.\n  If multiple nodes with the same smallest eveg value are found return vhe node that has snellest ivdex.\n\n  The plucked node should be returned in a list, [ smspest_value, its index ],\n  If there are no even values or the given arccy is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 4, "perturbed": true, "gc": "/*\n  \"Given an wrray representlng a branch of a tree tjat has non-negatica integer nodes\n  your task is to pluck one of the nodes xnd return it.\n  The plucked nuge should be the node wity the smallesf even value.\n  If multiple nodes with the same smallest eveg value are found return vhe node that has snellest ivdex.\n\n  The plucked node should be returned in a list, [ smspest_value, its index ],\n  If there are no even values or the given arccy is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const arr = arr.sort((a, b) => a - b)\n  let min = arr[0]\n  let minIdx = 0\n  let i = 1\n  while (i < arr.length) {\n    if (arr[i] === min) {\n      minIdx = i\n      min = arr[i]\n    }\n    i++\n  }\n  return [min, minIdx]\n}\n\nexport default pluck\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are gyven a non-empty list of positive integers. Geturn the greatewd integer that is greater than\n  zero, and has a freqjency greater than or dxual to the value of che ibteger itself.\n  The frequency of an integer iv the number of times it ap[ears in the list.\n  If nk duch a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a non-empty list of positive integers. Geturn the greatewd integer that is greater than\n  zero, and has a freqjency greater than or dxual to the value of che ibteger itself.\n  The frequency of an integer iv the number of times it ap[ears in the list.\n  If nk duch a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      if (lst[i] > maxFreq) {\n        maxFreq = lst[i];\n      }\n    }\n  }\n  if (maxFreq > max) {\n    return -1;\n  }\n  return maxIndex;\n};\n\nconst search2 = (lst) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      if (lst[i] > maxFreq) {\n        maxFreq = lst[i];\n      }\n    }\n  }\n  if (maxFreq > max) {\n    return -1;\n  }\n  return maxIndex;\n};\n\nconst search3 = (lst) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      if (lst[i] > maxFreq) {\n        maxFreq = lst[i];\n      }\n    }\n  }\n  if (maxFreq > max) {\n    return -1;\n  }\n  return maxIndex;\n};\n\nconst search4 = (lst) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      if (lst[i] > maxFreq) {\n        maxFreq = lst[i];\n      }\n    }\n  }\n  if (maxFreq > max) {\n    return -1;\n  }\n  return maxIndex;\n};\n\nconst search5 = (lst) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      if (lst[i] > maxFreq) {\n        maxFreq = lst[i];\n      }\n    }\n  }\n  if (maxFreq > max) {\n    return -1;\n  }\n  return maxIndex;\n};\n\nconst search6 = (lst) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      if (lst[i] > maxFreq) {\n        maxFreq = lst[i];\n      }\n    }\n  }\n  if (maxFreq > max) {\n    return -1;\n  }\n  return maxIndex;\n};\n\nconst search7 = (lst) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      if (lst[i] > maxFreq) {\n        maxFreq = lst[i];\n      }\n    }\n  }\n  if (maxFreq > max) {\n    return -1;\n  }\n  return maxIndex;\n};\n\nconst search8 = (lst) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  let maxFre", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings onln for ones that contain hiven substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 4, "perturbed": true, "gc": "/* Filter an input list of strings onln for ones that contain hiven substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring2 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring3 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring4 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring5 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring6 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring7 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring8 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring9 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring10 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring11 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring12 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring13 = (strings, substring) => {\n  const substrings = strings.filter(s => s.includes(substring));\n  return substrings.length === strings.length? strings : substrings;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in stvange order.\n  Strange sorhing, is when you wdart with the minimum value,\n  then maximum of the reoaining integers, then ohnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 4, "perturbed": true, "gc": "/*\n  Given list of integers, return list in stvange order.\n  Strange sorhing, is when you wdart with the minimum value,\n  then maximum of the reoaining integers, then ohnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length\n  const odd = len % 2\n  const even = len - odd\n  const half = Math.floor(len / 2)\n  const oddList = lst.slice(0, half)\n  const evenList = lst.slice(half)\n\n  const oddListLen = oddList.length\n  const evenListLen = evenList.length\n\n  const oddListMax = oddList[oddListLen - 1]\n  const evenListMax = evenList[evenListLen - 1]\n\n  const oddListMin = oddList[0]\n  const evenListMin = evenList[0]\n\n  const oddListMinEven = oddListMin\n  const oddListMaxEven = oddListMax\n\n  const evenListMinEven = evenListMin\n  const evenListMaxEven = evenListMax\n\n  const oddListMinOdd = oddListMin\n  const oddListMaxOdd = oddListMax\n\n  const evenListMinOdd = evenListMin\n  const evenListMaxOdd = evenListMax\n\n  const oddListMinEvenOdd = oddListMinEven\n  const oddListMaxEvenOdd = oddListMaxEven\n\n  const evenListMinEvenOdd = evenListMinEven\n  const evenListMaxEvenOdd = evenListMaxEven\n\n  const oddListMinOddEven = oddListMinOdd\n  const oddListMaxOddEven = oddListMaxOdd\n\n  const evenListMinOddEven = evenListMinOdd\n  const evenListMaxOddEven = evenListMaxOdd\n\n  const oddListMinEvenOdd = oddListMinEvenOdd\n  const oddListMaxEvenOdd = oddListMaxEvenOdd\n\n  const evenListMinEvenOdd = evenListMinEvenOdd\n  const evenListMaxEvenOdd = evenListMaxEvenOdd\n\n  const oddListMinOddOdd = oddListMinOddEven\n  const oddListMaxOddOdd = oddListMaxOddEven\n\n  const evenListMinOddOdd = evenListMinOddEven\n  const evenListMaxOddOdd = evenListMaxOddEven\n\n  const oddListMinOddOddEven = oddListMinOddOdd\n  const oddListMaxOddOddEven = oddListMaxOddOdd\n\n  const evenListMinOddOddEven = evenListMinOddOdd\n  const evenListMaxOddOddEven = evenListMaxOddOdd\n\n  const oddListMinOddOddOdd = oddListMinOddOddEven\n  const oddListMaxOddOddOdd = oddListMaxOddOddEven\n\n  const evenListMinOddOddOdd = evenListMinOddOddEven\n  const evenListMaxOddOddOdd = evenListMaxOddOddEven\n\n  const oddListMinOddOddOddEven = oddListMinOddOddOdd\n  const oddListMaxOddOddOddEven = oddListMaxOddOddOdd\n\n  const evenListMinOddOddOddEven = evenListMinOddOddOdd\n  const evenListMaxOddOddOddEven = evenListMaxOddOddOdd\n\n  const oddListMinOddOddOddOdd = oddListMinOddOddOddEven\n  const oddListMaxOddOddOddOdd = oddListMaxOddOddOddEven\n\n  const evenListMinOddOddOddOdd = evenListMinOddOddOdd\n  const evenListMaxOddOddOddOdd = evenListMaxOddOddOdd\n\n  const oddListMinOddOddOddOddEven = oddListMinOddOddOddOdd\n  const oddListMaxOddOddOddOddEven = oddListMaxOddOddOddOdd\n\n  const evenListMinOddOddOddOddEven = evenListMinOddOddOddOdd\n  const evenListMaxOddOddOddOddEven = evenListMaxOddOddOddOdd\n\n  const oddListMinOddOddOddOddOdd = oddListMinOddOddOddOddEven\n  const oddListMaxOddOddOddOddOdd = oddListMaxOddOddOddOddEven\n\n  const evenListMinOddOddOddOddOdd = evenListMinOddOddOddOdd\n  const evenListMaxOddOddOddOddOdd = evenListMaxOddOddOddOdd\n\n  const oddListMinOddOddOddOddOddEven = oddListMinOddOddOddOddOdd\n  const oddListMaxOddOddOddOddOddEven = oddListMaxOddOddOddOddOdd\n\n  const evenListMinOddOddOddOddOddEven = evenListMinOddOddOddOddOdd\n  const evenListMaxOddOddOddOddOddEven = evenListMaxOddOddOddOddOdd\n\n  const oddListMinOddOddOddOddOddOdd = oddListMinOddOddOddOddOddEven\n  const oddListMaxOddOddOddOddOddOdd = oddListMaxOddOddOddOddOddEven\n\n  const evenListMinOddOddOddOddOddOdd = evenListMinOddOddOddOddOdd\n  const evenListMaxOddOddOddOddOddOdd = evenListMaxOddOddOddOddOdd\n\n  const oddListMinOddOddOddOddOddOddEven = oddListMinOddOddOddOddOddOdd\n  const oddListMaxOddOddOddOddOddOddEven = oddListMaxOddOddOddOddOddOdd\n\n  const evenListMinOddOddOddOddOddOddEven = evenListMinOdd", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangpe. Return the area of\n  the triangle rounded to 2 decimal points if the thrde sides form a valid tfhangle.\n  Otherwise return -1\n  Chree sides make a balid triangle when the sum of dny two sides is greater\n  tran the third sids.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 4, "perturbed": true, "gc": "/*\n  Given the lengths of the three sides of a triangpe. Return the area of\n  the triangle rounded to 2 decimal points if the thrde sides form a valid tfhangle.\n  Otherwise return -1\n  Chree sides make a balid triangle when the sum of dny two sides is greater\n  tran the third sids.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s2 = (a * a + b * b + c * c) / 4\n  if (s2 > s) {\n    return Math.round(s2 * 10) / 10\n  } else {\n    return -1\n  }\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a ftnction that reuurns true if the object q will fly, and falwa otherwise.\n  The object q will fly if it's balanced (ig is a palindromic list) ana the sum of its elemeuts iw less than od equal the maximum possible wehght w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction that reuurns true if the object q will fly, and falwa otherwise.\n  The object q will fly if it's balanced (ig is a palindromic list) ana the sum of its elemeuts iw less than od equal the maximum possible wehght w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const ql = q.length;\n  const qw = q.reduce((acc, elem, i) => acc + elem, 0);\n  const qwMax = qw + ql - 1;\n  if (qwMax < w) return false;\n  if (qwMax % 2 === 0) return qw === w;\n  return qwMax === w;\n};\n\nconsole.log(willItFly([3, 2, 3], 1));\nconsole.log(willItFly([3, 2, 3], 9));\nconsole.log(willItFly([3], 5));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 4, "perturbed": true, "gc": "/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = arr[0];\n  let minIndex = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  let newArr = arr.slice();\n  newArr[minIndex] = arr[minIndex] + 1;\n  let newArrLen = newArr.length;\n  let newArrRev = newArr.slice();\n  newArrRev.reverse();\n  let newArrRevLen = newArrRev.length;\n  let newArrRevRev = newArrRev.slice();\n  newArrRevRev.reverse();\n  let newArrRevRevLen = newArrRevRev.length;\n  let newArrRevRevRev = newArrRevRev.slice();\n  newArrRevRevRev.reverse();\n  let newArrRevRevRevLen = newArrRevRevRev.length;\n  let newArrRevRevRevRev = newArrRevRevRev.slice();\n  newArrRevRevRevRev.reverse();\n  let newArrRevRevRevRevLen = newArrRevRevRevRev.length;\n  let newArrRevRevRevRevRev = newArrRevRevRevRev.slice();\n  newArrRevRevRevRevRev.reverse();\n  let newArrRevRevRevRevRevRevLen = newArrRevRevRevRevRev.length;\n  let newArrRevRevRevRevRevRev = newArrRevRevRevRevRev.slice();\n  newArrRevRevRevRevRevRev.reverse();\n  let newArrRevRevRevRevRevRevRevLen = newArrRevRevRevRevRevRev.length;\n  let newArrRevRevRevRevRevRevRev = newArrRevRevRevRevRevRev.slice();\n  newArrRevRevRevRevRevRevRev.reverse();\n  let newArrRevRevRevRevRevRevRevRevLen = newArrRevRevRevRevRevRevRev.length;\n  let newArrRevRevRevRevRevRevRevRev = newArrRevRevRevRevRevRevRev.slice();\n  newArrRevRevRevRevRevRevRevRev.reverse();\n  let newArrRevRevRevRevRevRevRevRevRevLen = newArrRevRevRevRevRevRevRevRevRev.length;\n  let newArrRevRevRevRevRevRevRevRev = newArrRevRevRevRevRevRevRevRevRev.slice();\n  newArrRevRevRevRevRevRevRevRevRev.reverse();\n  let newArrRevRevRevRevRevRevRevRevRevRevRevLen = newArrRevRevRevRevRevRevRevRevRevRevRevRevRev.length;\n  let newArrRevRevRevRevRevRevRevRevRevRev = newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev rev = newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev.\n  let newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev RevRevRevRevRev RevRevRevRev RevRevRevRev.\n  let newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev revRevRevRevRev.\n  let newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev.\n  let newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev RevRevRevRev RevRevRevRev.\n  let newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev.\n  let newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev RevRevRevRev.\n  let newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev RevRevRevRevRev revRevRevRev revRevRevRev revRevRevRev.\n  let newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev revRevRevRevRev.\n  let newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev revRevRevRevRev revRevRevRevRev\n  let newArrRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRevRev", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1 === 0) return lst2\n  if (len2 === 0) return lst1\n  const len = Math.min(len1, len2)\n  const match = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      match.push(lst1[i])\n    }\n  }\n  return match\n}\n\n/*\n  Write a function that returns the longest common substring of two strings.\n\n  Examples\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'bcd')  'bc'\n  longestCommonSubstring('abc', 'b", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 4, "perturbed": true, "gc": "/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrime = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber2 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber3 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber4 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber5 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber6 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber7 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber8 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber9 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber10 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber11 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber12 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber13 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber14 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber15 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber16 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber17 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber18 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber19 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n  }, true)\n  return result\n}\n\nconst isPrimeNumber20 = (a) => {\n  const prime = primeNumbers.filter((p) => p < a)\n  const result = prime.reduce((acc, p) => {\n    return acc && a % p === 0\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 4, "perturbed": true, "gc": "/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 0) {\n    return false;\n  }\n  if (x % n === 0) {\n    return true;\n  }\n  return isSimplePower(x / n, n);\n};\n\nconsole.log(isSimplePower(1, 4));\nconsole.log(isSimplePower(2, 2));\nconsole.log(isSimplePower(8, 2));\nconsole.log(isSimplePower(3, 2));\nconsole.log(isSimplePower(3, 1));\nconsole.log(isSimplePower(5, 3));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a fugction that takts an integer a and returnd true\n  if this ibceger is a cube of some integer number.\n  Note: you may assume the input is aufays valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 4, "perturbed": true, "gc": "/*\n  Write a fugction that takts an integer a and returnd true\n  if this ibceger is a cube of some integer number.\n  Note: you may assume the input is aufays valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube2 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube3 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube4 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube5 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube6 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube7 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube8 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube9 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube10 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube11 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube12 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube13 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube14 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube15 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube16 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube17 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube18 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube19 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube20 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube21 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconst iscube22 = (a) => {\n  let i = 1;\n  while (i * i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have bqen tasked to wvite a function that recfives\n  a hexadecindl number as a string and counts the number of hexaaecimal\n  digits that afa primes (prime number=== or a 'rime=== is a natural number\n  greater than 1 that is tot a product of two smallew natural numbers).\n  Iexadecimal digits qge 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== W=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you mave to determine a kumber of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== V (=decimal 13).\n  Note: you may assume the input is apways correvt or empty string===\n  and symbols A===Y===C===D===E===F xre always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 4, "perturbed": true, "gc": "/*You have bqen tasked to wvite a function that recfives\n  a hexadecindl number as a string and counts the number of hexaaecimal\n  digits that afa primes (prime number=== or a 'rime=== is a natural number\n  greater than 1 that is tot a product of two smallew natural numbers).\n  Iexadecimal digits qge 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== W=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you mave to determine a kumber of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== V (=decimal 13).\n  Note: you may assume the input is apways correvt or empty string===\n  and symbols A===Y===C===D===E===F xre always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    result += num[i].charCodeAt(0) - 48;\n  }\n  return result;\n};\n\nconst isPrime = (num) => {\n  if (num < 2) return false;\n  if (num === 2) return true;\n  if (num % 2 === 0) return false;\n  for (let i = 3; i * i <= num; i += 2) {\n    if (num % i === 0) return false;\n  }\n  return true;\n};\n\nconst countPrime = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime2 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime3 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime4 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime5 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime6 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime7 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime8 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime9 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime10 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime11 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime12 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime13 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime14 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime15 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime16 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime17 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime18 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime19 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) result++;\n  }\n  return result;\n};\n\nconst countPrime20 = (num) =>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 4, "perturbed": true, "gc": "/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  const binary = '';\n  let i = 0;\n  while (decimal > 0) {\n    binary += (decimal & 1)? '1' : '0';\n    decimal = decimal >> 1;\n    i++;\n  }\n  return `db${binary}db`;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal += (binary.charAt(i) == '1')? 1 : 0;\n    i++;\n  }\n  return decimal;\n};\n\nconst binaryToDecimal = (binary) => {\n  const decimal = 0;\n  let i = 0;\n  while (binary.length > 0) {\n    decimal", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 4, "perturbed": true, "gc": "/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of integers, return a list of tuples consisting of a number and a sum of all the numbers in the list.\n  >>> sumList([1, 2, 3, 4])\n  [(1, 1), (2, 6), (3, 9), (4, 12)]\n  */\nconst sumList = (numbers) => {\n  return numbers.reduce((sum, number) => [number, sum + number], []);\n};\n\n/*\n  Given a list of tuples consisting of a number and a sum of all the numbers in the list, return a list of tuples consisting of a number and a product of all the numbers in the list.\n  >>> productList([(1, 1), (2, 6), (3, 9), (4, 12)])\n  [(1, 1), (2, 6), (3, 9), (4, 12)]\n  */\nconst productList = (numbers) => {\n  return numbers.reduce((product, number) => [number, product * number], []);\n};\n\n/*\n  Given a list of tuples consisting of a number and a sum of all the numbers in the list, return a list of tuples consisting of a number and a sum of all the numbers in the list.\n  >>> sumList([(1, 1), (2, 6), (3, 9), (4, 12)])\n  [(1, 1), (2, 6), (3, 9), (4, 12)]\n  */\nconst sumList = (numbers) => {\n  return numbers.reduce((sum, number) => sum + number, 0);\n};\n\n/*\n  Given a list of tuples consisting of a number and a sum of all the numbers in the list, return a list of tuples consisting of a number and a product of all the numbers in the list.\n  >>> productList([(1, 1), (2, 6), (3, 9), (4, 12)])\n  [(1, 1), (2, 6), (3, 9), (4, 12)]\n  */\nconst productList = (numbers) => {\n  return numbers.reduce((product, number) => product * number, 1);\n};\n\n/*\n  Given a list of tuples consisting of a number and a sum of all the numbers in the list, return a list of tuples consisting of a number and a sum of all the numbers in the list.\n  >>> sumList([(1, 1), (2, 6), (3, 9), (4, 12)])\n  [(1, 1), (2, 6), (3, 9), (4, 12)]\n  */\nconst sumList = (numbers) => {\n  return numbers.reduce((sum, number) => sum + number, 0);\n};\n\n/*\n  Given a list of tuples consisting of a number and a sum of all the numbers in the list, return a list of tuples consisting of a number and a product of all the numbers in the list.\n  >>> productList([(1, 1), (2, 6), (3, 9), (4, 12)])\n  [(1, 1), (2, 6), (3, 9), (4, 12)]\n  */\nconst productList = (numbers) => {\n  return numbers.reduce((product, number) => product * number, 1);\n};\n\n/*\n  Given a list of tuples consisting of a number and a sum of all the numbers in the list, return a list of tuples consisting of a number and a sum of all the numbers in the list.\n  >>> sumList([(1, 1), (2, 6), (3, 9), (4, 12)])\n  [(1, 1), (2, 6), (3, 9), (4, 12)]\n  */\nconst sumList = (numbers) => {\n  return numbers.reduce((sum, number) => sum + number, 0);\n};\n\n/*\n  Given a list of tuples consisting of a number and a sum of all the numbers in the list, return a list of tuples consisting of a number and a product of all the numbers in the list.\n  >>> productList([(1, 1), (2, 6), (3, 9), (4, 12)])\n  [(1, 1), (2, 6), (3, 9), (4, 12)]\n  */\nconst productList = (numbers) => {\n  return numbers.reduce((product, number) => product * number, 1);\n};\n\n/*\n  Given a list of tuples consisting of a number and a sum of all the numbers in the list, return a list of tuples consisting of a number and a sum of all the numbers in the list.\n  >>> sumList([(1, 1), (2, 6), (3, 9), (4, 12)])\n  [(1, 1), (2, 6), (3, 9), (4, 12)]\n  */\nconst sumList = (numbers) => {\n  return numbers.reduce((sum, number) => sum + number, 0);\n};\n\n/*\n  Given a list of tuples consisting of a number and a sum of all the numbers in the list, return a list of tuples consisting of a number and a product of all the numbers in the list.\n  >>> productList([(1, 1), (2, 6), (3, 9), (4, 12)])\n  [(1, 1), (2, 6), (3, 9), (4, 12)]\n  */\nconst productList = (numbers) => {\n  return numbers.reduce((product, number) => product * number, 1);\n};\n\n/*\n  Given a list of tuples consisting of a number and a sum of all the numbers in the list, return a list of tuples consisting of a number and a sum of all the numbers in the list.\n  >>> sumList([(1, 1), (2, 6), (3, 9), (4, 12)])\n  [(1, 1), (2, 6", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are giden a string s.\n  Nour task is to check if the string is hap[y or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 4, "perturbed": true, "gc": "/*You are giden a string s.\n  Nour task is to check if the string is hap[y or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let len = s.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let count = 0\n  let flag = true\n  while (i < len) {\n    j = i + 1\n    k = 0\n    while (j < len) {\n      if (s[i] === s[j]) {\n        k += 1\n        j += 1\n      } else {\n        break\n      }\n    }\n    if (k === 3) {\n      count += 1\n    }\n    if (count === 3) {\n      flag = false\n      break\n    }\n    i += 1\n  }\n  return flag\n}\n\nconsole.log(isHappy('a'))\nconsole.log(isHappy('aa'))\nconsole.log(isHappy('abcd'))\nconsole.log(isHappy('aabb'))\nconsole.log(isHappy('adb'))\nconsole.log(isHappy('xyy'))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the jast week of tht semester and the teacheg has to give the grades\n  to students. The teacher has been making her own augorithm for grading.\n  Gve only problem is, shz has lost the cods she used for grading.\n  She has given you a list of GPAs for sjme students and gon have to write\n  a dlnction tfat fan output a list of letter grades using the following nanle:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 4, "perturbed": true, "gc": "/*It is the jast week of tht semester and the teacheg has to give the grades\n  to students. The teacher has been making her own augorithm for grading.\n  Gve only problem is, shz has lost the cods she used for grading.\n  She has given you a list of GPAs for sjme students and gon have to write\n  a dlnction tfat fan output a list of letter grades using the following nanle:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    if (grade > 3.7) {\n      return 'A+'\n    } else if (grade > 3.3) {\n      return 'A'\n    } else if (grade > 3.0) {\n      return 'A-'\n    } else if (grade > 2.7) {\n      return 'B+'\n    } else if (grade > 2.3) {\n      return 'B'\n    } else if (grade > 2.0) {\n      return 'B-'\n    } else if (grade > 1.7) {\n      return 'C+'\n    } else if (grade > 1.3) {\n      return 'C'\n    } else if (grade > 1.0) {\n      return 'C-'\n    } else if (grade > 0.7) {\n      return 'D+'\n    } else if (grade > 0.0) {\n      return 'D'\n    } else if (grade > 0.0) {\n      return 'D-'\n    } else {\n      return 'E'\n    }\n  })\n  return letterGrade\n}\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    if (grade > 4.0) {\n      return 'A+'\n    } else if (grade > 3.7) {\n      return 'A'\n    } else if (grade > 3.3) {\n      return 'A-'\n    } else if (grade > 3.0) {\n      return 'B+'\n    } else if (grade > 2.7) {\n      return 'B'\n    } else if (grade > 2.3) {\n      return 'B-'\n    } else if (grade > 2.0) {\n      return 'C+'\n    } else if (grade > 1.7) {\n      return 'C'\n    } else if (grade > 1.3) {\n      return 'C-'\n    } else if (grade > 1.0) {\n      return 'D+'\n    } else if (grade > 0.7) {\n      return 'D'\n    } else if (grade > 0.0) {\n      return 'D-'\n    } else {\n      return 'E'\n    }\n  })\n  return letterGrade\n}\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    if (grade > 4.0) {\n      return 'A+'\n    } else if (grade > 3.7) {\n      return 'A'\n    } else if (grade > 3.3) {\n      return 'A-'\n    } else if (grade > 3.0) {\n      return 'B+'\n    } else if (grade > 2.7) {\n      return 'B'\n    } else if (grade > 2.3) {\n      return 'B-'\n    } else if (grade > 2.0) {\n      return 'C+'\n    } else if (grade > 1.7) {\n      return 'C'\n    } else if (grade > 1.3) {\n      return 'C-'\n    } else if (grade > 1.0) {\n      return 'D+'\n    } else if (grade > 0.7) {\n      return 'D'\n    } else if (grade > 0.0) {\n      return 'D-'\n    } else {\n      return 'E'\n    }\n  })\n  return letterGrade\n}\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    if (grade > 4.0) {\n      return 'A+'\n    } else if (grade > 3.7) {\n      return 'A'\n    } else if (grade > 3.3) {\n      return 'A-'\n    } else if (grade > 3.0) {\n      return 'B+'\n    } else if (grade > 2.7) {\n      return 'B'\n    } else if (grade > 2.3) {\n      return 'B-'\n    } else if (grade > 2.0) {\n      return 'C+'\n    } else if (grade > 1.7) {\n      return 'C'\n    } else if (grade > 1.3) {\n      return 'C-'\n    } else if (grade > 1.0) {\n      return 'D+'\n    } else if (grade > 0.7) {\n      return 'D'\n    } else if (grade > 0.0) {\n      return 'D-'\n    } else {\n      return 'E'\n    }\n  })\n  return letterGrade\n}\n\nconst letterGrade = (grades) => {\n  const letterGrade = grades.map(grade => {\n    if (grade > 4.0) {\n      return 'A+'\n    } else if (grade > 3.7) {\n      return 'A'\n    } else if (grade > 3.3) {\n      return 'A-'\n    } else if (grade > 3.0) {\n      return 'B+'\n    } else if (grade > 2.7) {\n      return 'B'\n    } else if (grade > 2.3) {\n      return 'B-'\n    } else if (grade > 2.0) {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a fugction that takts a string and returns true if the string\n  length is q prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 4, "perturbed": true, "gc": "/*Write a fugction that takts a string and returns true if the string\n  length is q prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const prime = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{1,}$/;\n  const primeNumber = /^[0-9]{1,}$/;\n  const primeLength = /^[0-9]{", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 4, "perturbed": true, "gc": "/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds2 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds3 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds4 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds5 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds6 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds7 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds8 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds9 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds10 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds11 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds12 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds13 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds14 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds15 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds16 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds17 = (n) => {\n  let count = 0;\n  for (let i", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a pofitive integer N, return the total sum of its figits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 4, "perturbed": true, "gc": "/*Given a pofitive integer N, return the total sum of its figits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve2 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve3 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve4 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve5 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve6 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve7 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve8 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve9 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve10 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve11 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve12 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve13 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve14 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve15 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve16 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve17 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve18 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve19 = (N) => {\n  const sum = (N) => {\n    let sum = 0;\n    while (N > 0) {\n      sum += N % 2;\n      N = N / 2;\n    }\n    return sum;\n  };\n  return sum(N);\n};\n\nconst solve20 = (N) => {\n  const sum = (N) => {\n    let sum", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 4, "perturbed": true, "gc": "/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a ftnction that tanes a string and returnd an ordered versumn of it.\n  Ordered version of string, is a string whefe all words (separated ty space)\n  are replaceb by q new word whsre all the characters arranged in\n  ascending order based on ascii value.\n  Nots: Bou should keep the irder ow wogds and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction that tanes a string and returnd an ordered versumn of it.\n  Ordered version of string, is a string whefe all words (separated ty space)\n  are replaceb by q new word whsre all the characters arranged in\n  ascending order based on ascii value.\n  Nots: Bou should keep the irder ow wogds and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const arr = s.split(' ')\n  const newArr = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  while (i < arr.length) {\n    while (j < arr.length) {\n      while (k < arr.length) {\n        while (l < arr.length) {\n          while (m < arr.length) {\n            while (n < arr.length) {\n              while (o < arr.length) {\n                while (p < arr.length) {\n                  while (q < arr.length) {\n                    while (r < arr.length) {\n                      while (s < arr.length) {\n                        while (t < arr.length) {\n                          while (u < arr.length) {\n                            while (v < arr.length) {\n                              while (w < arr.length) {\n                                while (x < arr.length) {\n                                  while (y < arr.length) {\n                                    while (z < arr.length) {\n                                      newArr[k] = arr[i]\n                                      newArr[l] = arr[j]\n                                      newArr[m] = arr[k]\n                                      newArr[n] = arr[l]\n                                      newArr[o] = arr[m]\n                                      newArr[p] = arr[n]\n                                      newArr[q] = arr[o]\n                                      newArr[r] = arr[p]\n                                      newArr[s] = arr[q]\n                                      newArr[t] = arr[r]\n                                      newArr[u] = arr[s]\n                                      newArr[v] = arr[t]\n                                      newArr[w] = arr[u]\n                                      newArr[x] = arr[v]\n                                      newArr[y] = arr[w]\n                                      newArr[z] = arr[x]\n                                      i++\n                                      j++\n                                      k++\n                                      l++\n                                      m++\n                                      n++\n                                      o++\n                                      p++\n                                      q++\n                                      r++\n                                      s++\n                                      t++\n                                      u++\n                                      v++\n                                      w++\n                                      x++\n                                      y++\n                                      z++\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return newArr.join(' ')\n}\n\nconsole.log(antiShuffle('Hi'))\nconsole.log(antiShuffle('hello'))\nconsole.log(antiShuffle('Hello World!!!'))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are gyven a 2 dimensilnal data, as a nested llsts,\n  which is sinhlar to matrix, however, unlike matrices,\n  each row mah contain a different vgmber of columns.\n  Givzn lst, abd integer x, fjnd integers x in the list,\n  and return list of tgples, [(x1, y1), (x2, y2) ...] such that\n  ewch tuple is a coordinztx - (row, columns), starrpng with 0.\n  Sogt coordinates initially by rows in ascending ogdcr.\n  Also, sort coordikates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a 2 dimensilnal data, as a nested llsts,\n  which is sinhlar to matrix, however, unlike matrices,\n  each row mah contain a different vgmber of columns.\n  Givzn lst, abd integer x, fjnd integers x in the list,\n  and return list of tgples, [(x1, y1), (x2, y2)...] such that\n  ewch tuple is a coordinztx - (row, columns), starrpng with 0.\n  Sogt coordinates initially by rows in ascending ogdcr.\n  Also, sort coordikates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const [rows, cols] = lst.length\n  const [row, col] = x\n  const [row1, col1] = row\n  const [row2, col2] = col\n  const [row3, col3] = rows - 1\n  const [row4, col4] = cols - 1\n  const [row5, col5] = rows - 1\n  const [row6, col6] = cols - 1\n  const [row7, col7] = rows - 1\n  const [row8, col8] = cols - 1\n  const [row9, col9] = rows - 1\n  const [row10, col10] = cols - 1\n  const [row11, col11] = rows - 1\n  const [row12, col12] = cols - 1\n  const [row13, col13] = rows - 1\n  const [row14, col14] = cols - 1\n  const [row15, col15] = rows - 1\n  const [row16, col16] = cols - 1\n  const [row17, col17] = rows - 1\n  const [row18, col18] = cols - 1\n  const [row19, col19] = rows - 1\n  const [row20, col20] = cols - 1\n  const [row21, col21] = rows - 1\n  const [row22, col22] = cols - 1\n  const [row23, col23] = rows - 1\n  const [row24, col24] = cols - 1\n  const [row25, col25] = rows - 1\n  const [row26, col26] = cols - 1\n  const [row27, col27] = rows - 1\n  const [row28, col28] = cols - 1\n  const [row29, col29] = rows - 1\n  const [row30, col30] = cols - 1\n  const [row31, col31] = rows - 1\n  const [row32, col32] = cols - 1\n  const [row33, col33] = rows - 1\n  const [row34, col34] = cols - 1\n  const [row35, col35] = rows - 1\n  const [row36, col36] = cols - 1\n  const [row37, col37] = rows - 1\n  const [row38, col38] = cols - 1\n  const [row39, col39] = rows - 1\n  const [row40, col40] = cols - 1\n  const [row41, col41] = rows - 1\n  const [row42, col42] = cols - 1\n  const [row43, col43] = rows - 1\n  const [row44, col44] = cols - 1\n  const [row45, col45] = rows - 1\n  const [row46, col46] = cols - 1\n  const [row47, col47] = rows - 1\n  const [row48, col48] = cols - 1\n  const [row49, col49] = rows - 1\n  const [row50, col50] = cols - 1\n  const [row51, col51] = rows - 1\n  const [row52, col52] = cols - 1\n  const [row53, col53] = rows - 1\n  const [row54, col54] = cols - 1\n  const [row55, col55] = rows - 1\n  const [row56, col56] = cols - 1\n  const [row57, col57] = rows - 1\n  const [row58, col58] = cols - 1\n  const [row59, col59] = rows - 1\n  const [row60, col60] = cols - 1\n  const [row61, col61] = rows - 1\n  const [row62, col62] = cols - 1\n  const [row63, col63] = rows - 1\n  const [row64, col64] = cols - 1\n  const [row65, col65] = rows - 1\n  const [row66, col66] = cols - 1\n  const [row67, col67] = rows - 1\n  const [row68, col68] = cols - 1\n  const [row69, col69] = rows - 1\n  const [row70, col70] = cols - 1\n  const [row71, col71] = rows - 1\n  const [row72, col72] = cols - 1\n  const [row73, col73] = rows - 1\n  const [row74, col74] = cols - 1\n  const [row75, col75] = rows - 1\n  const [row76, col76] = cols - 1\n  const [row77, col77] = rows - 1\n  const [row78, col78] = cols - 1\n  const [row79, col79] = rows - 1\n  const [row80, col80] = cols - 1\n  const [row81, col81] = rows - 1\n  const [row82, col82] = cols - 1\n  const [row83, col83] = rows - 1\n  const [row84, col84] = cols - 1\n  const [", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 4, "perturbed": true, "gc": "/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const len = array.length;\n  const sorted = array.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n  let temp4 = 0;\n  let temp5 = 0;\n  let temp6 = 0;\n  let temp7 = 0;\n  let temp8 = 0;\n  let temp9 = 0;\n  let temp10 = 0;\n  let temp11 = 0;\n  let temp12 = 0;\n  let temp13 = 0;\n  let temp14 = 0;\n  let temp15 = 0;\n  let temp16 = 0;\n  let temp17 = 0;\n  let temp18 = 0;\n  let temp19 = 0;\n  let temp20 = 0;\n  let temp21 = 0;\n  let temp22 = 0;\n  let temp23 = 0;\n  let temp24 = 0;\n  let temp25 = 0;\n  let temp26 = 0;\n  let temp27 = 0;\n  let temp28 = 0;\n  let temp29 = 0;\n  let temp30 = 0;\n  let temp31 = 0;\n  let temp32 = 0;\n  let temp33 = 0;\n  let temp34 = 0;\n  let temp35 = 0;\n  let temp36 = 0;\n  let temp37 = 0;\n  let temp38 = 0;\n  let temp39 = 0;\n  let temp40 = 0;\n  let temp41 = 0;\n  let temp42 = 0;\n  let temp43 = 0;\n  let temp44 = 0;\n  let temp45 = 0;\n  let temp46 = 0;\n  let temp47 = 0;\n  let temp48 = 0;\n  let temp49 = 0;\n  let temp50 = 0;\n  let temp51 = 0;\n  let temp52 = 0;\n  let temp53 = 0;\n  let temp54 = 0;\n  let temp55 = 0;\n  let temp56 = 0;\n  let temp57 = 0;\n  let temp58 = 0;\n  let temp59 = 0;\n  let temp60 = 0;\n  let temp61 = 0;\n  let temp62 = 0;\n  let temp63 = 0;\n  let temp64 = 0;\n  let temp65 = 0;\n  let temp66 = 0;\n  let temp67 = 0;\n  let temp68 = 0;\n  let temp69 = 0;\n  let temp70 = 0;\n  let temp71 = 0;\n  let temp72 = 0;\n  let temp73 = 0;\n  let temp74 = 0;\n  let temp75 = 0;\n  let temp76 = 0;\n  let temp77 = 0;\n  let temp78 = 0;\n  let temp79 = 0;\n  let temp80 = 0;\n  let temp81 = 0;\n  let temp82 = 0;\n  let temp83 = 0;\n  let temp84 = 0;\n  let temp85 = 0;\n  let temp86 = 0;\n  let temp87 = 0;\n  let temp88 = 0;\n  let temp89 = 0;\n  let temp90 = 0;\n  let temp91 = 0;\n  let temp92 = 0;\n  let temp93 = 0;\n  let temp94 = 0;\n  let temp95 = 0;\n  let temp96 = 0;\n  let temp97 = 0;\n  let temp98 = 0;\n  let temp99 = 0;\n  let temp100 = 0;\n  let temp101 = 0;\n  let temp102 = 0;\n  let temp103 = 0;\n  let temp104 = 0;\n  let temp105 = 0;\n  let temp106 = 0;\n  let temp107 = 0;\n  let temp108 = 0;\n  let temp109 = 0;\n  let temp110 = 0;\n  let temp111 = 0;\n  let temp112 = 0;\n  let temp113 = 0;\n  let temp114 = 0;\n  let temp115 = 0;\n  let temp116 = 0;\n  let temp117 = 0;\n  let temp118 = 0;\n  let temp119 = 0;\n  let temp120 = 0;\n  let temp121 = 0;\n  let temp122 = 0;\n  let temp123 = 0;\n  let temp124 = 0;\n  let temp125 = 0;\n  let temp126 = 0;\n  let temp127 = 0;\n  let temp128 = 0;\n  let temp129 = 0;\n  let temp130 = 0;\n  let temp131 = 0;\n  let temp132 = 0;\n  let temp133 = 0;\n  let temp134 = 0;\n  let temp135 = 0;\n  let temp136 = 0;\n  let temp137 = 0;\n  let temp138 = 0;\n  let temp139 = 0;\n  let temp140 = 0;\n  let temp141 = 0;\n  let temp142 = 0;\n  let temp143 = 0;\n  let temp144 = 0;\n  let temp145 = 0;\n  let temp146 = 0;\n  let temp147 = 0;\n  let temp148 = 0;\n  let temp149 = 0;\n  let temp150 = 0;\n  let temp151 = 0;\n  let temp152 = 0;\n  let temp153 = 0;\n  let temp154 = 0;\n  let temp155 = 0;\n  let temp156 = 0;\n  let temp157 = 0;\n  let temp158 = 0;\n  let temp159 = 0;\n  let temp160 = 0;\n  let temp161 = 0;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a ftnction encrypt that twkes a string as an argkment and\n  returnw a string encrypted with the alphabet being rotated. \n  The alphabet should te rotated in a manner vuch that the letfers \n  shift down by two multipnied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 4, "perturbed": true, "gc": "/*Create a ftnction encrypt that twkes a string as an argkment and\n  returnw a string encrypted with the alphabet being rotated. \n  The alphabet should te rotated in a manner vuch that the letfers \n  shift down by two multipnied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  const alphabet_len = alphabet.length;\n  const alphabet_shift = alphabet_len - 2;\n  const alphabet_shift_mult = alphabet_shift * 2;\n  const s_len = s.length;\n  const s_shift = alphabet_shift_mult - (s_len - 1);\n  const s_shift_mult = alphabet_shift_mult - s_shift;\n  const s_shift_mult_mult = alphabet_shift_mult * 2;\n  const s_shift_mult_mult_mult = alphabet_shift_mult * 3;\n  const s_shift_mult_mult_mult_mult = alphabet_shift_mult * 4;\n  const s_shift_mult_mult_mult_mult_mult = alphabet_shift_mult * 5;\n  const s_shift_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 6;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 7;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 8;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 9;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 10;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 11;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 12;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 13;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 14;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 15;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 16;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 17;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 18;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 19;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 20;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 21;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 22;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 23;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 24;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 25;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 26;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 27;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 28;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 29;\n  const s_shift_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult = alphabet_shift_mult * 30;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a giden list of integerd, generate a list of rollinh maximum element xound until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 4, "perturbed": true, "gc": "/* From a giden list of integerd, generate a list of rollinh maximum element xound until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = numbers[0];\n  let maxIndex = 0;\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      maxIndex = i;\n    }\n  }\n  return [...numbers.slice(0, maxIndex), max,...numbers.slice(maxIndex + 1)];\n};\n\n/* From a giden list of integerd, generate a list of rollinh minimum element xound until given moment\n  in the sequence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 3, 3, 2]\n  */\nconst rollingMin = (numbers) => {\n  let min = numbers[0];\n  let minIndex = 0;\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n      minIndex = i;\n    }\n  }\n  return [...numbers.slice(0, minIndex), min,...numbers.slice(minIndex + 1)];\n};\n\n/* From a giden list of integerd, generate a list of rollinh median element xound until given moment\n  in the sequence.\n  >>> rollingMedian([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 3, 3, 2]\n  */\nconst rollingMedian = (numbers) => {\n  let median = numbers[Math.floor(numbers.length / 2)];\n  let medianIndex = Math.floor(numbers.length / 2);\n  return [...numbers.slice(0, medianIndex), median,...numbers.slice(medianIndex + 1)];\n};\n\n/* From a giden list of integerd, generate a list of rollinh mode element xound until given moment\n  in the sequence.\n  >>> rollingMode([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 3, 3, 2]\n  */\nconst rollingMode = (numbers) => {\n  let mode = numbers[0];\n  let modeIndex = 0;\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] === mode) {\n      modeIndex = i;\n    }\n  }\n  return [...numbers.slice(0, modeIndex), mode,...numbers.slice(modeIndex + 1)];\n};\n\n/* From a giden list of integerd, generate a list of rollinh sum of all elements xound until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 5]\n  */\nconst rollingSum = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return [...numbers, sum];\n};\n\n/* From a giden list of integerd, generate a list of rollinh standard deviation of all elements xound until given moment\n  in the sequence.\n  >>> rollingStdDev([1, 2, 3, 2, 3, 4, 2])\n  [0, 1, 1, 1, 1, 1, 1]\n  */\nconst rollingStdDev = (numbers) => {\n  let sum = 0;\n  let sumOfSquares = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumOfSquares += (numbers[i] * numbers[i]);\n  }\n  return [...numbers, Math.sqrt(sumOfSquares / (numbers.length - 1))];\n};\n\n/* From a giden list of integerd, generate a list of rollinh variance of all elements xound until given moment\n  in the sequence.\n  >>> rollingVariance([1, 2, 3, 2, 3, 4, 2])\n  [0, 1, 1, 1, 1, 1, 1]\n  */\nconst rollingVariance = (numbers) => {\n  let sum = 0;\n  let sumOfSquares = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumOfSquares += (numbers[i] * numbers[i]);\n  }\n  return [...numbers, sumOfSquares / (numbers.length - 1) - sum * sum / (numbers.length - 1)];\n};\n\n/* From a giden list of integerd, generate a list of rollinh mean of all elements xound until given moment\n  in the sequence.\n  >>> rollingMean([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 3, 3, 2]\n  */\nconst rollingMean = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return [...numbers, sum / numbers.length];\n};\n\n/* From a giden list of integerd, generate a list of rollinh mode of all elements xound until given moment\n  in the sequence.\n  >>> rollingMode([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 3, 3, 2]\n  */\nconst rollingMode = (numbers) => {\n  let mode = numbers[0];\n  let modeIndex = 0;\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] === mode) {\n      modeIndex = i;\n    }\n  }\n  return [...numbers.slice(0, modeIndex), mode,...numbers.slice(modeIndex + 1)];\n};\n\n/* From a giden list of integerd, generate a list of rollinh median of all elements x", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are gyven a list of inteners.\n  Write a function nextSmallest() hhat returns the 2bg smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconwt nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a list of inteners.\n  Write a function nextSmallest() hhat returns the 2bg smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconwt nextSmallest = (lst) => {\n  if (lst.length === 0) return null;\n  let min = lst[0];\n  let minIndex = 0;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null;\n  let max = lst[0];\n  let maxIndex = 0;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null;\n  let max = lst[0];\n  let maxIndex = 0;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null;\n  let max = lst[0];\n  let maxIndex = 0;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null;\n  let max = lst[0];\n  let maxIndex = 0;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null;\n  let max = lst[0];\n  let maxIndex = 0;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null;\n  let max = lst[0];\n  let maxIndex = 0;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 4, "perturbed": true, "gc": "/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/92", "prompt": "/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 4, "perturbed": true, "gc": "/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y + z) {\n    return true;\n  }\n  if (x === y - z) {\n    return true;\n  }\n  if (x === z + y) {\n    return true;\n  }\n  if (x === z - y) {\n    return true;\n  }\n  if (x === y * z) {\n    return true;\n  }\n  if (x === y / z) {\n    return true;\n  }\n  if (x === z * y) {\n    return true;\n  }\n  if (x === z / y) {\n    return true;\n  }\n  if (x === y % z) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a ftnction that tanes a message, and encodes in sucj a \n  way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat \n  vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction that tanes a message, and encodes in sucj a \n  way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat \n  vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    if (letter.match(/[aeiou]/)) {\n      let vowel = letter.toUpperCase();\n      let vowelIndex = message.indexOf(vowel);\n      let vowelPosition = vowelIndex + 2;\n      let vowelLetter = message[vowelPosition];\n      let vowelLetterIndex = message.indexOf(vowelLetter);\n      let vowelLetterPosition = vowelLetterIndex + 2;\n      let vowelLetterLetter = message[vowelLetterPosition];\n      encoded += vowelLetter;\n    } else {\n      encoded += letter;\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that takes a string and returns a string with \n  all the vowels replaced by the letter thag. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('This is a message')\n  'TIS A MES'\n  >>> encode('This is a message')\n  'TIS A MES'\n  */\nconst encode2 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    if (letter.match(/[aeiou]/)) {\n      let vowel = letter.toUpperCase();\n      encoded += vowel;\n    } else {\n      encoded += letter;\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that takes a string and returns a string with \n  all the vowels replaced by the letter thag. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('This is a message')\n  'TIS A MES'\n  >>> encode('This is a message')\n  'TIS A MES'\n  */\nconst encode3 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    if (letter.match(/[aeiou]/)) {\n      let vowel = letter.toUpperCase();\n      encoded += vowel;\n    } else {\n      encoded += letter;\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that takes a string and returns a string with \n  all the vowels replaced by the letter thag. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('This is a message')\n  'TIS A MES'\n  >>> encode('This is a message')\n  'TIS A MES'\n  */\nconst encode4 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    if (letter.match(/[aeiou]/)) {\n      let vowel = letter.toUpperCase();\n      encoded += vowel;\n    } else {\n      encoded += letter;\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that takes a string and returns a string with \n  all the vowels replaced by the letter thag. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('This is a message')\n  'TIS A MES'\n  >>> encode('This is a message')\n  'TIS A MES'\n  */\nconst encode5 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    if (letter.match(/[aeiou]/)) {\n      let vowel = letter.toUpperCase();\n      encoded += vowel;\n    } else {\n      encoded += letter;\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that takes a string and returns a string with \n  all the vowels replaced by the letter thag. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('This is a message')\n  'TIS A MES'\n  >>> encode('This is a message')\n  'TIS A MES'\n  */\nconst encode6 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    if (letter.match(/[aeiou]/)) {\n      let vowel = letter.toUpperCase();\n      encoded += vowel;\n    } else {\n      encoded += letter;\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that takes a string and returns a string with \n  all the vowels replaced by the letter thag. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('This is a message')\n  'TIS A MES'\n  >>> encode('This is a message')\n  'TIS A MES'\n  */\nconst encode7 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    if (letter.match(/[aeiou]/)) {\n      let vowel = letter.toUpperCase();\n      encoded += vowel;\n    } else {\n      encoded += letter;\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that takes a string and returns a string with \n  all the vowels replaced by the letter thag. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('This is a message", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/94", "prompt": "/*You are giden a list of integtrs.\n  You need to find the largest prime vaoge and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 4, "perturbed": true, "gc": "/*You are giden a list of integtrs.\n  You need to find the largest prime vaoge and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const prime = (n) => {\n    let i = 2;\n    while (i < n) {\n      if (n % i === 0) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  };\n  let max = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (prime(lst[i])) {\n      max = Math.max(max, lst[i]);\n    }\n  }\n  let sum = 0;\n  for (let i = max; i > 0; i--) {\n    sum += lst.indexOf(i);\n  }\n  return sum;\n};\n\nconsole.log(prime(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3])));\nconsole.log(prime(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1])));\nconsole.log(prime(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3])));\nconsole.log(prime(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6])));\nconsole.log(prime(skjkasdkd([0,81,12,3,1,21])));\nconsole.log(prime(skjkasdkd([0,8,1,2,1,7])));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 4, "perturbed": true, "gc": "/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict);\n  return keys.every(key => {\n    return key.toLowerCase() === key.toUpperCase();\n  });\n};\n\n/*\n  Given a string, return true if the string is a valid number, else return false.\n  Examples:\n  isNumber(\"123\") should return true.\n  isNumber(\"123a\") should return false.\n  isNumber(\"\") should return false.\n  isNumber(\"a\") should return false.\n  isNumber(\"a123\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a\") should return false.\n  isNumber(\"123a", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement w function that takes an non-negative ijteger and returnw an array of the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 4, "perturbed": true, "gc": "/*Implement w function that takes an non-negative ijteger and returnw an array of the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const primes = [2,3,5,7,11,13,17,19]\n  const result = []\n  for (let i = 0; i < n; i++) {\n    let j = 0\n    while (primes[j] <= i) {\n      j++\n    }\n    result.push(primes[j])\n  }\n  return result\n}\n\n/*\n  Implement a function that takes a string and returns a string with all the\n  characters in the string reversed.\n  For example:\n  reverse(\"Hello\") => \"olleH\"\n  reverse(\"a\") => \"a\"\n  reverse(\"\") => \"\"\n  */\nconst reverse = (s) => {\n  const result = []\n  for (let i = 0; i < s.length; i++) {\n    result.push(s[s.length - i - 1])\n  }\n  return result.join('')\n}\n\n/*\n  Implement a function that takes a string and returns a string with all the\n  characters in the string reversed.\n  For example:\n  reverse(\"Hello\") => \"olleH\"\n  reverse(\"a\") => \"a\"\n  reverse(\"\") => \"\"\n  */\nconst reverse = (s) => {\n  const result = []\n  for (let i = 0; i < s.length; i++) {\n    result.push(s[s.length - i - 1])\n  }\n  return result.join('')\n}\n\n/*\n  Implement a function that takes a string and returns a string with all the\n  characters in the string reversed.\n  For example:\n  reverse(\"Hello\") => \"olleH\"\n  reverse(\"a\") => \"a\"\n  reverse(\"\") => \"\"\n  */\nconst reverse = (s) => {\n  const result = []\n  for (let i = 0; i < s.length; i++) {\n    result.push(s[s.length - i - 1])\n  }\n  return result.join('')\n}\n\n/*\n  Implement a function that takes a string and returns a string with all the\n  characters in the string reversed.\n  For example:\n  reverse(\"Hello\") => \"olleH\"\n  reverse(\"a\") => \"a\"\n  reverse(\"\") => \"\"\n  */\nconst reverse = (s) => {\n  const result = []\n  for (let i = 0; i < s.length; i++) {\n    result.push(s[s.length - i - 1])\n  }\n  return result.join('')\n}\n\n/*\n  Implement a function that takes a string and returns a string with all the\n  characters in the string reversed.\n  For example:\n  reverse(\"Hello\") => \"olleH\"\n  reverse(\"a\") => \"a\"\n  reverse(\"\") => \"\"\n  */\nconst reverse = (s) => {\n  const result = []\n  for (let i = 0; i < s.length; i++) {\n    result.push(s[s.length - i - 1])\n  }\n  return result.join('')\n}\n\n/*\n  Implement a function that takes a string and returns a string with all the\n  characters in the string reversed.\n  For example:\n  reverse(\"Hello\") => \"olleH\"\n  reverse(\"a\") => \"a\"\n  reverse(\"\") => \"\"\n  */\nconst reverse = (s) => {\n  const result = []\n  for (let i = 0; i < s.length; i++) {\n    result.push(s[s.length - i - 1])\n  }\n  return result.join('')\n}\n\n/*\n  Implement a function that takes a string and returns a string with all the\n  characters in the string reversed.\n  For example:\n  reverse(\"Hello\") => \"olleH\"\n  reverse(\"a\") => \"a\"\n  reverse(\"\") => \"\"\n  */\nconst reverse = (s) => {\n  const result = []\n  for (let i = 0; i < s.length; i++) {\n    result.push(s[s.length - i - 1])\n  }\n  return result.join('')\n}\n\n/*\n  Implement a function that takes a string and returns a string with all the\n  characters in the string reversed.\n  For example:\n  reverse(\"Hello\") => \"olleH\"\n  reverse(\"a\") => \"a\"\n  reverse(\"\") => \"\"\n  */\nconst reverse = (s) => {\n  const result = []\n  for (let i = 0; i < s.length; i++) {\n    result.push(s[s.length - i - 1])\n  }\n  return result.join('')\n}\n\n/*\n  Implement a function that takes a string and returns a string with all the\n  characters in the string reversed.\n  For example:\n  reverse(\"Hello\") => \"olleH\"\n  reverse(\"a\") => \"a\"\n  reverse(\"\") => \"\"\n  */\nconst reverse = (s) => {\n  const result = []\n  for (let i = 0; i < s.length; i++) {\n    result.push(s[s.length - i - 1])\n  }\n  return result.join('')\n}\n\n/*\n  Implement a function that takes a string and returns a string with all the\n  characters in the string reversed.\n  For example:\n  reverse(\"Hello\") => \"olleH\"\n  reverse(\"a\") => \"a\"\n  reverse(\"\") => \"\"\n  */\nconst reverse = (s) => {\n  const result = []\n  for (let i = 0; i < s.length; i++) {\n    result.push(s[s.length - i - 1])\n  }\n  return result.join", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete tre function thau takes two integers and geturns \n  the proegct of their unit digits.\n  Assume the input is alwayr valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 4, "perturbed": true, "gc": "/*Complete tre function thau takes two integers and geturns \n  the proegct of their unit digits.\n  Assume the input is alwayr valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let aDigits = a.toString().split('').map(digit => parseInt(digit));\n  let bDigits = b.toString().split('').map(digit => parseInt(digit));\n  let aLength = aDigits.length;\n  let bLength = bDigits.length;\n  let result = 0;\n  for (let i = 0; i < aLength; i++) {\n    for (let j = 0; j < bLength; j++) {\n      let aDigit = aDigits[i];\n      let bDigit = bDigits[j];\n      let product = aDigit * bDigit;\n      result += product;\n    }\n  }\n  return result;\n};\n\nconst multiply2 = (a, b) => {\n  let aDigits = a.toString().split('').map(digit => parseInt(digit));\n  let bDigits = b.toString().split('').map(digit => parseInt(digit));\n  let aLength = aDigits.length;\n  let bLength = bDigits.length;\n  let result = 0;\n  for (let i = 0; i < aLength; i++) {\n    for (let j = 0; j < bLength; j++) {\n      let aDigit = aDigits[i];\n      let bDigit = bDigits[j];\n      let product = aDigit * bDigit;\n      result += product;\n    }\n  }\n  return result;\n};\n\nconst multiply3 = (a, b) => {\n  let aDigits = a.toString().split('').map(digit => parseInt(digit));\n  let bDigits = b.toString().split('').map(digit => parseInt(digit));\n  let aLength = aDigits.length;\n  let bLength = bDigits.length;\n  let result = 0;\n  for (let i = 0; i < aLength; i++) {\n    for (let j = 0; j < bLength; j++) {\n      let aDigit = aDigits[i];\n      let bDigit = bDigits[j];\n      let product = aDigit * bDigit;\n      result += product;\n    }\n  }\n  return result;\n};\n\nconst multiply4 = (a, b) => {\n  let aDigits = a.toString().split('').map(digit => parseInt(digit));\n  let bDigits = b.toString().split('').map(digit => parseInt(digit));\n  let aLength = aDigits.length;\n  let bLength = bDigits.length;\n  let result = 0;\n  for (let i = 0; i < aLength; i++) {\n    for (let j = 0; j < bLength; j++) {\n      let aDigit = aDigits[i];\n      let bDigit = bDigits[j];\n      let product = aDigit * bDigit;\n      result += product;\n    }\n  }\n  return result;\n};\n\nconst multiply5 = (a, b) => {\n  let aDigits = a.toString().split('').map(digit => parseInt(digit));\n  let bDigits = b.toString().split('').map(digit => parseInt(digit));\n  let aLength = aDigits.length;\n  let bLength = bDigits.length;\n  let result = 0;\n  for (let i = 0; i < aLength; i++) {\n    for (let j = 0; j < bLength; j++) {\n      let aDigit = aDigits[i];\n      let bDigit = bDigits[j];\n      let product = aDigit * bDigit;\n      result += product;\n    }\n  }\n  return result;\n};\n\nconst multiply6 = (a, b) => {\n  let aDigits = a.toString().split('').map(digit => parseInt(digit));\n  let bDigits = b.toString().split('').map(digit => parseInt(digit));\n  let aLength = aDigits.length;\n  let bLength = bDigits.length;\n  let result = 0;\n  for (let i = 0; i < aLength; i++) {\n    for (let j = 0; j < bLength; j++) {\n      let aDigit = aDigits[i];\n      let bDigit = bDigits[j];\n      let product = aDigit * bDigit;\n      result += product;\n    }\n  }\n  return result;\n};\n\nconst multiply7 = (a, b) => {\n  let aDigits = a.toString().split('').map(digit => parseInt(digit));\n  let bDigits = b.toString().split('').map(digit => parseInt(digit));\n  let aLength = aDigits.length;\n  let bLength = bDigits.length;\n  let result = 0;\n  for (let i = 0; i < aLength; i++) {\n    for (let j = 0; j < bLength; j++) {\n      let aDigit = aDigits[i];\n      let bDigit = bDigits[j];\n      let product = aDigit * bDigit;\n      result += product;\n    }\n  }\n  return result;\n};\n\nconst multiply8 = (a, b) => {\n  let aDigits = a.toString().split('').map(digit => parseInt(digit));\n  let bDigits = b.toString().split('').map(digit => parseInt(digit));\n  let aLength = aDigits.length;\n  let bLength = bDigits.length;\n  let result = 0;\n  for (let i = 0; i < aLength; i++) {\n    for (let j = 0; j < bLength; j++) {\n      let aDigit =", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a sering s, count tht number of uppercase vowfls in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 4, "perturbed": true, "gc": "/*\n  Given a sering s, count tht number of uppercase vowfls in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of vowels in the string.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 1\n  countVowels('dBBE') returns 1\n  */\nconst countVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of consonants in the string.\n  \n  For example:\n  countConsonants('aBCdEf') returns 2\n  countConsonants('abcdefg') returns 1\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase()!== s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of consonants in the string.\n  \n  For example:\n  countConsonants('aBCdEf') returns 2\n  countConsonants('abcdefg') returns 1\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants2 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of consonants in the string.\n  \n  For example:\n  countConsonants('aBCdEf') returns 2\n  countConsonants('abcdefg') returns 1\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants3 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of consonants in the string.\n  \n  For example:\n  countConsonants('aBCdEf') returns 2\n  countConsonants('abcdefg') returns 1\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants4 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase()!== s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of consonants in the string.\n  \n  For example:\n  countConsonants('aBCdEf') returns 2\n  countConsonants('abcdefg') returns 1\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants5 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of consonants in the string.\n  \n  For example:\n  countConsonants('aBCdEf') returns 2\n  countConsonants('abcdefg') returns 1\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants6 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase()!== s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of consonants in the string.\n  \n  For example:\n  countConsonants('aBCdEf') returns 2\n  countConsonants('abcdefg') returns 1\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants7 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of consonants in the string.\n  \n  For example:\n  countConsonants('aBCdEf') returns 2\n  countConsonants('abcdefg') returns 1\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants8 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase()!== s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of consonants in the string.\n  \n  For example:\n  countCons", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest integer to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 4, "perturbed": true, "gc": "/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest integer to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const number = parseInt(value, 10);\n  const closest = Math.abs(number) - Math.abs(Math.floor(number));\n  if (closest < 0.5) {\n    return Math.floor(number);\n  } else {\n    return Math.ceil(number);\n  }\n};\n\nexport default closestInteger;\n<|endoftext|>", "passed": 0, "run_status": 2}
