{"task_id": "JavaScript/0", "prompt": "/* Check match if in given pass list of numbers, are any two numbers closer to each other than \n   given hold threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 1, "perturbed": true, "gc": "/* Check match if in given pass list of numbers, are any two numbers closer to each other than \n   given hold threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort((a, b) => a - b)\n  const diff = sorted[1] - sorted[0]\n  return diff < threshold\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements2 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort((a, b) => a - b)\n  const diff = sorted[1] - sorted[0]\n  return diff < threshold\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements3 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort((a, b) => a - b)\n  const diff = sorted[1] - sorted[0]\n  return diff < threshold\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements4 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort((a, b) => a - b)\n  const diff = sorted[1] - sorted[0]\n  return diff < threshold\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements5 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort((a, b) => a - b)\n  const diff = sorted[1] - sorted[0]\n  return diff < threshold\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements6 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort((a, b) => a - b)\n  const diff = sorted[1] - sorted[0]\n  return diff < threshold\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements7 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort((a, b) => a - b)\n  const diff = sorted[1] - sorted[0]\n  return diff < threshold\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements8 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort((a, b) => a - b)\n  const diff = sorted[1] - sorted[0]\n  return diff < threshold\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements9 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort((a, b) => a - b)\n  const diff = sorted[1] - sorted[0]\n  return diff < threshold\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements10 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort((a, b) => a - b)\n  const diff = sorted[1] - sorted[0]\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/1", "prompt": "/* Input input signal to this function routine is a string containing incorporate multiple groups of nested nest parentheses. Your goal finish is to \n   separate those group into separate freestanding strings and return the list of those. \n   Separate disjoined groups group are balanced (each open brace couple is properly closed) and not nested within each other \n   Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 1, "perturbed": true, "gc": "/* Input input signal to this function routine is a string containing incorporate multiple groups of nested nest parentheses. Your goal finish is to \n   separate those group into separate freestanding strings and return the list of those. \n   Separate disjoined groups group are balanced (each open brace couple is properly closed) and not nested within each other \n   Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.split('(');\n  const paren_groups_length = paren_groups.length;\n  const paren_groups_length_minus_one = paren_groups_length - 1;\n  const paren_groups_array = [];\n  let paren_groups_array_index = 0;\n  let paren_groups_array_index_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one = 0;\n  let paren_groups_array_index_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one_minus_one = 0;\n  while (paren_groups_array_index < paren_groups_length) {\n    paren_groups_array.push(paren_groups[paren_groups_array_index]);\n    paren_groups_array_index++;\n    if (paren_groups_array_index < paren_groups_length_minus_one) {\n      paren_groups_array.push(paren_groups[paren_groups_array_index]);\n      paren_groups_array_index++;\n      if (paren_groups_array_index < paren_groups_length_minus_one) {\n        paren_groups_array.push(paren_groups[paren_groups_array_index]);\n        paren_groups_array_index++;\n        if (paren_groups_array_index < paren_groups_length_minus_one) {\n          paren_groups_array.push(paren_groups[paren_groups_array_index]);\n          paren_groups_array_index++;\n          if (paren_groups_array_index < paren_groups_length_minus_one) {\n            paren_groups_array.push(paren_groups[paren_groups_array_index]);\n            paren_groups_array_index++;\n            if (paren_groups_array_index < paren_groups_length_minus_one) {\n              paren_groups_array.push(paren_groups[paren_groups_array_index]);\n              paren_groups_array_index++;\n              if (paren_groups_array_index < paren_groups_length_minus_one) {\n                paren_groups_array.push(paren_groups[paren_groups_array_index]);\n                paren_groups_array_index++;\n                if (paren_groups_array_index < paren_groups_length_minus_one) {\n                  paren_groups_array.push(paren_groups[paren_groups_array_index]);\n                  paren_groups_array_index++;\n                  if (paren_groups_array_index < paren_groups_length_minus_one) {\n                    paren_groups_array.push(paren_groups[paren_groups_array_index]);\n                    paren_groups_array_index++;\n                    if (paren_groups_array_index < paren_groups_length_minus_one) {\n                      paren_groups_array.push(paren_groups[paren_groups_array_index]);\n                      paren_groups_array_index++;\n                      if (paren_groups_array_index < paren_groups_length_minus_one) {\n                        paren_groups_array.push(paren_groups[paren_groups_array_index]);\n                        paren_groups_array_index++;\n                        if (paren_groups_array_index < paren_groups_length_minus_one) {\n                          paren_groups_array.push(paren_groups[paren_groups_array_index]);\n                          paren_groups_array_index++;\n                          if (paren_groups_array_index < paren_groups_length_minus_one) {\n                            paren_groups_array.push(paren_groups[paren", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').reverse().join('');\n  const palindrome = suffix + prefix;\n  return palindrome;\n}\n\n/* Test if a string is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').reverse().join('');\n  const palindrome = suffix + prefix;\n  return palindrome;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').reverse().join('');\n  const palindrome = suffix + prefix;\n  return palindrome;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').reverse().join('');\n  const palindrome = suffix + prefix;\n  return palindrome;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').reverse().join('');\n  const palindrome = suffix + prefix;\n  return palindrome;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').reverse().join('');\n  const palindrome = suffix + prefix;\n  return palindrome;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').reverse().join('');\n  const palindrome = suffix + prefix;\n  return palindrome;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').reverse().join('');\n  const pal", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given grant a positive integer n, you have to make seduce a pile atomic pile of n levels grade of stones. \n   The first inaugural level has n stones stone. \n   The number of stones gem in the next future level is: \n       - the next following odd leftover number if n is odd curious. \n       - the next even number if n is even. \n   Return the number of stones in each level in a list, where element at index exponent \n   i represents the number of stones in the level degree (i+1).\n\n   Examples model:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, you have to make seduce a pile atomic pile of n levels grade of stones. \n   The first inaugural level has n stones stone. \n   The number of stones gem in the next future level is: \n       - the next following odd leftover number if n is odd curious. \n       - the next even number if n is even. \n   Return the number of stones in each level in a list, where element at index exponent \n   i represents the number of stones in the level degree (i+1).\n\n   Examples model:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile2 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile3 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile4 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile5 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile6 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile7 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile8 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile9 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile10 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile11 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile12 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile13 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile14 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile15 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile16 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile17 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile18 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile19 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile20 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile21 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile22 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile23 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile24 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile25 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile26 = (n) => {\n  const pile = []\n  for (let i = 1; i <= n; i++) {\n    pile.push(i)\n  }\n  return pile\n}\n\nconst makeAPile27 = (n) => {", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given grant a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 1, "perturbed": true, "gc": "/*\n  You will be given grant a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will be given a string of words word separated by", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/102", "prompt": "/*This function affair takes lead two positive numbers phone number x and y and returns the \n   biggest bad even integer number that is in the range image [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 1, "perturbed": true, "gc": "/*This function affair takes lead two positive numbers phone number x and y and returns the \n   biggest bad even integer number that is in the range image [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const x1 = x - 1;\n  const y1 = y - 1;\n  const x2 = x + 1;\n  const y2 = y + 1;\n  const x3 = x - 2;\n  const y3 = y + 2;\n  const x4 = x + 2;\n  const y4 = y - 2;\n  const x5 = x - 3;\n  const y5 = y + 3;\n  const x6 = x + 3;\n  const y6 = y - 3;\n  const x7 = x - 4;\n  const y7 = y + 4;\n  const x8 = x + 4;\n  const y8 = y - 4;\n  const x9 = x - 5;\n  const y9 = y + 5;\n  const x10 = x + 5;\n  const y10 = y - 5;\n  const x11 = x - 6;\n  const y11 = y + 6;\n  const x12 = x + 6;\n  const y12 = y - 6;\n  const x13 = x - 7;\n  const y13 = y + 7;\n  const x14 = x + 7;\n  const y14 = y - 7;\n  const x15 = x - 8;\n  const y15 = y + 8;\n  const x16 = x + 8;\n  const y16 = y - 8;\n  const x17 = x - 9;\n  const y17 = y + 9;\n  const x18 = x + 9;\n  const y18 = y - 9;\n  const x19 = x - 10;\n  const y19 = y + 10;\n  const x20 = x + 10;\n  const y20 = y - 10;\n  const x21 = x - 11;\n  const y21 = y + 11;\n  const x22 = x + 11;\n  const y22 = y - 11;\n  const x23 = x - 12;\n  const y23 = y + 12;\n  const x24 = x + 12;\n  const y24 = y - 12;\n  const x25 = x - 13;\n  const y25 = y + 13;\n  const x26 = x + 13;\n  const y26 = y - 13;\n  const x27 = x - 14;\n  const y27 = y + 14;\n  const x28 = x + 14;\n  const y28 = y - 14;\n  const x29 = x - 15;\n  const y29 = y + 15;\n  const x30 = x + 15;\n  const y30 = y - 15;\n  const x31 = x - 16;\n  const y31 = y + 16;\n  const x32 = x + 16;\n  const y32 = y - 16;\n  const x33 = x - 17;\n  const y33 = y + 17;\n  const x34 = x + 17;\n  const y34 = y - 17;\n  const x35 = x - 18;\n  const y35 = y + 18;\n  const x36 = x + 18;\n  const y36 = y - 18;\n  const x37 = x - 19;\n  const y37 = y + 19;\n  const x38 = x + 19;\n  const y38 = y - 19;\n  const x39 = x - 20;\n  const y39 = y + 20;\n  const x40 = x + 20;\n  const y40 = y - 20;\n  const x41 = x - 21;\n  const y41 = y + 21;\n  const x42 = x + 21;\n  const y42 = y - 21;\n  const x43 = x - 22;\n  const y43 = y + 22;\n  const x44 = x + 22;\n  const y44 = y - 22;\n  const x45 = x - 23;\n  const y45 = y + 23;\n  const x46 = x + 23;\n  const y46 = y - 23;\n  const x47 = x - 24;\n  const y47 = y + 24;\n  const x48 = x + 24;\n  const y48 = y - 24;\n  const x49 = x - 25;\n  const y49 = y + 25;\n  const x50 = x + 25;\n  const y50 = y - 25;\n  const x51 = x - 26;\n  const y51 = y + 26;\n  const x52 = x + 26;\n  const y52 = y - 26;\n  const x53 = x - 27;\n  const y53 = y + 27;\n  const x54 = x + 27;\n  const y54 = y - 27;\n  const x55 = x - 28;\n  const y55 = y + 28;\n  const x56 = x + 28;\n  const y56 = y - 28;\n  const x57 = x - 29;\n  const y57 = y + 29;\n  const x58 = x + 29;\n  const y58 = y - 29;\n  const x59 = x - 30;\n  const y59 = y + 30;\n  const x60 = x + 30;\n  const y60 = y - 30;\n  const x61 = x - 31;\n  const y61 = y + 31;\n  const x62 = x + 31;\n  const y62 = y - 31;\n  const x63 = x - 32;\n  const y63 = y + 32;\n  const x64 = x + 32;\n  const y64 = y - 32;\n  const x65 = x - 33;\n  const y65 = y + 33;\n  const x66 = x + 33;\n  const y66 = y - 33;\n  const x67 = x - 34;\n  const y67 = y + 34;\n  const x68 = x + 34;\n  const y68 = y - 34;\n  const x69 = x - 35;\n  const y69 = y + 35;\n  const x70 = x + 35;\n  const y70 = y - 35;\n  const x71 = x - 36;\n  const y71 = y + 36;\n  const x72 = x + 36;\n  const", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given grant two positive integers integer n and m, and your task undertaking is to compute calculate the \n   average of the integers from n through m (including admit n and m). \n   Round the answer to the nearest cheeseparing integer and convert that to binary. \n   If n is greater great than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 1, "perturbed": true, "gc": "/*You are given grant two positive integers integer n and m, and your task undertaking is to compute calculate the \n   average of the integers from n through m (including admit n and m). \n   Round the answer to the nearest cheeseparing integer and convert that to binary. \n   If n is greater great than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  return roundedAvg.toString(2)\n}\n\nconsole.log(roundedAvg(1, 5))\nconsole.log(roundedAvg(7, 5))\nconsole.log(roundedAvg(10, 20))\nconsole.log(roundedAvg(20, 33))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive cocksure integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted in increasing increase order. \n  \n   For example model:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 1, "perturbed": true, "gc": "/*Given a list of positive cocksure integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted in increasing increase order. \n  \n   For example model:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const digits = []\n  for (let i = 0; i < x; i++) {\n    const digit = x % 10\n    if (digit % 2 === 0) {\n      digits.push(digit)\n    }\n    x = Math.floor(x / 10)\n  }\n  return digits\n}\n\nexport default uniqueDigits\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given grant an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse revoke the resulting result array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse revoke the resulting result array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return n\n    }\n    return reversed[i]\n  })\n  return result\n}\n\nconst byLength2 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength3 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength4 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength5 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength6 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength7 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength8 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength9 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength10 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength11 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength12 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength13 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength14 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = sorted.map((n, i) => {\n    if (n > 9) {\n      return reversed[i]\n    }\n    return n\n  })\n  return result\n}\n\nconst byLength15 = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement follow through the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element component at index i is the factorial of i if i is even \n   or the sum kernel of numbers from 1 to i otherwise differently. \n   i starts from 1. \n   the factorial of i is the multiplication generation of the numbers issue from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 1, "perturbed": true, "gc": "/* Implement follow through the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element component at index i is the factorial of i if i is even \n   or the sum kernel of numbers from 1 to i otherwise differently. \n   i starts from 1. \n   the factorial of i is the multiplication generation of the numbers issue from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(i * factorial(i - 1));\n    }\n  }\n  return result;\n};\n\nconst factorial = (n) => {\n  if (n === 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n};\n\nconst test = (n) => {\n  const result = f(n);\n  console.log(result);\n};\n\ntest(5);\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given grant a positive integer n, return a tuple that has the number issue of even and odd curious \n   integer palindromes palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, return a tuple that has the number issue of even and odd curious \n   integer palindromes palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let odd = 0, even = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      num = num % 10;\n      if (num % 2 === 0) {\n        even++;\n      } else {\n        odd++;\n      }\n    }\n  }\n  return [even, odd];\n};\n\nexport default evenOddPalindrome;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number issue of elements which has a sum kernel of digits > 0. \n   If a number act is negative, then its first beginning signed bless digit will be negative minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number issue of elements which has a sum kernel of digits > 0. \n   If a number act is negative, then its first beginning signed bless digit will be negative minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (sum > 0) {\n      count++;\n    }\n    sum -= arr[i];\n  }\n  return count;\n};\n\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\nconsole.log(countNums([-1, 1, 2]));\nconsole.log(countNums([1, 2, 3]));\nconsole.log(countNums([-1, 2, 3]));\nconsole.log(countNums([1, -2, 3]));\nconsole.log(countNums([-1, -2, 3]));\nconsole.log(countNums([1, 2, -3]));\nconsole.log(countNums([-1, 2, -3]));\nconsole.log(countNums([1, -2, -3]));\nconsole.log(countNums([-1, -2, -3]));\nconsole.log(countNums([1, 2, 3, 4]));\nconsole.log(countNums([-1, 2, 3, 4]));\nconsole.log(countNums([1, -2, 3, 4]));\nconsole.log(countNums([-1, -2, 3, 4]));\nconsole.log(countNums([1, 2, -3, 4]));\nconsole.log(countNums([-1, 2, -3, 4]));\nconsole.log(countNums([1, -2, -3, 4]));\nconsole.log(countNums([-1, -2, -3, 4]));\nconsole.log(countNums([1, 2, 3, -4]));\nconsole.log(countNums([-1, 2, 3, -4]));\nconsole.log(countNums([1, -2, 3, -4]));\nconsole.log(countNums([-1, -2, 3, -4]));\nconsole.log(countNums([1, 2, -3, -4]));\nconsole.log(countNums([-1, 2, -3, -4]));\nconsole.log(countNums([1, -2, -3, -4]));\nconsole.log(countNums([-1, -2, -3, -4]));\nconsole.log(countNums([1, 2, 3, 4, 5]));\nconsole.log(countNums([-1, 2, 3, 4, 5]));\nconsole.log(countNums([1, -2, 3, 4, 5]));\nconsole.log(countNums([-1, -2, 3, 4, 5]));\nconsole.log(countNums([1, 2, -3, 4, 5]));\nconsole.log(countNums([-1, 2, -3, 4, 5]));\nconsole.log(countNums([1, -2, -3, 4, 5]));\nconsole.log(countNums([-1, -2, -3, 4, 5]));\nconsole.log(countNums([1, 2, 3, -4, 5]));\nconsole.log(countNums([-1, 2, 3, -4, 5]));\nconsole.log(countNums([1, -2, 3, -4, 5]));\nconsole.log(countNums([-1, -2, 3, -4, 5]));\nconsole.log(countNums([1, 2, -3, -4, 5]));\nconsole.log(countNums([-1, 2, -3, -4, 5]));\nconsole.log(countNums([1, -2, -3, -4, 5]));\nconsole.log(countNums([-1, -2, -3, -4, 5]));\nconsole.log(countNums([1, 2, 3, 4, -5]));\nconsole.log(countNums([-1, 2, 3, 4, -5]));\nconsole.log(countNums([1, -2, 3, 4, -5]));\nconsole.log(countNums([-1, -2, 3, 4, -5]));\nconsole.log(countNums([1, 2, -3, 4, -5]));\nconsole.log(countNums([-1, 2, -3, 4, -5]));\nconsole.log(countNums([1, -2, -3, 4, -5]));\nconsole.log(countNums([-1, -2, -3, 4, -5]));\nconsole.log(countNums([1, 2, 3, -4, -5]));\nconsole.log(countNums([-1, 2, 3, -4, -5]));\nconsole.log(countNums([1, -2, 3, -4, -5]));\nconsole.log(countNums([-1, -2, 3, -4, -5]));\nconsole.log(countNums([1, 2, -3, -4, -5]));\nconsole.log(countNums([-1, 2, -3, -4, -5]));\nconsole.log(countNums([1, -2, -3, -4, -5]));\nconsole.log(countNums([-1, -2, -3, -4, -5]));\nconsole.log(countNums([1, 2, 3, 4, -6]));\nconsole.log(countNums([-1, 2, 3, 4, -6]));\nconsole.log(countNums([1, -2, 3, 4, -6]));\nconsole.log(countNums", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers integer arr[1], arr[2],... , arr[N].The\n   numbers phone number in the array will be randomly ordered. Your task undertaking is to determine if \n   it is possible potential to get an array sorted classify in non - decreasing order by performing do \n   the following operation mathematical process on the given feed array: \n       You are allowed to perform do right shift operation any number of times. \n  \n   One right shift operation process means shifting all elements of the array by one \n   position situation in the right direction steering. The last final element of the array will be moved to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain prevail the sorted array by performing the above operation \n   then return true else return false. \n   If the given array is empty then return true dependable. \n\n   Note: The given list is guaranteed undertake to have unique singular elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 1, "perturbed": true, "gc": "/*We have an array 'arr' of N integers integer arr[1], arr[2],..., arr[N].The\n   numbers phone number in the array will be randomly ordered. Your task undertaking is to determine if \n   it is possible potential to get an array sorted classify in non - decreasing order by performing do \n   the following operation mathematical process on the given feed array: \n       You are allowed to perform do right shift operation any number of times. \n  \n   One right shift operation process means shifting all elements of the array by one \n   position situation in the right direction steering. The last final element of the array will be moved to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain prevail the sorted array by performing the above operation \n   then return true else return false. \n   If the given array is empty then return true dependable. \n\n   Note: The given list is guaranteed undertake to have unique singular elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  const arrLength = arr.length;\n  if (arrLength === 0) {\n    return true;\n  }\n  let i = 0;\n  while (i < arrLength - 1) {\n    if (arr[i] > arr[i + 1]) {\n      const temp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = temp;\n      i = 0;\n    } else {\n      i++;\n    }\n  }\n  return arr[0] > arr[arrLength - 1];\n};\n\nconst moveOneBallTest = () => {\n  const arr = [3, 4, 5, 1, 2];\n  console.log(moveOneBall(arr));\n};\n\nmoveOneBallTest();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/11", "prompt": "/* Input input signal are two strings string a and b consisting only of 1s and 0s zero. \n   Perform binary XOR on these inputs input and return result also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 1, "perturbed": true, "gc": "/* Input input signal are two strings string a and b consisting only of 1s and 0s zero. \n   Perform binary XOR on these inputs input and return result also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\nexport default stringXor;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/110", "prompt": "/*In this problem trouble, you will implement enforce a function that takes remove two lists of numbers issue, \n   and determines whether it is possible potential to perform an exchange of elements component \n   between them to make lst1 a list of only even numbers numeral. \n   There is no limit terminus ad quem on the number of exchanged change elements between lst1 and lst2.\n   If it is possible to exchange elements between the lst1 and lst2 to make \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 1, "perturbed": true, "gc": "/*In this problem trouble, you will implement enforce a function that takes remove two lists of numbers issue, \n   and determines whether it is possible potential to perform an exchange of elements component \n   between them to make lst1 a list of only even numbers numeral. \n   There is no limit terminus ad quem on the number of exchanged change elements between lst1 and lst2.\n   If it is possible to exchange elements between the lst1 and lst2 to make \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  const len1 = lst1.length;\n  const len2 = lst2.length;\n  if (len1!== len2) {\n    return \"NO\";\n  }\n  const lst1_even = lst1.filter(x => x % 2 === 0);\n  const lst2_even = lst2.filter(x => x % 2 === 0);\n  if (lst1_even.length!== len1) {\n    return \"NO\";\n  }\n  if (lst2_even.length!== len2) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst test = [\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 5, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2, 3, 4],\n    [1, 2, 3, 4]\n  ],\n  [\n    [1, 2", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/111", "prompt": "/*Given a string bowed stringed instrument representing exemplify a space separated distinguish lowercase letters letter, return a dictionary \n   of the letter with the most repetition and containing contain the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 1, "perturbed": true, "gc": "/*Given a string bowed stringed instrument representing exemplify a space separated distinguish lowercase letters letter, return a dictionary \n   of the letter with the most repetition and containing contain the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]] += 1\n    }\n  }\n  return histogram\n}\n\n/*\nGiven a string, return the number of times that the letter appears in the string.\n\nExample:\n\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]] += 1\n    }\n  }\n  return histogram\n}\n\n/*\nGiven a string, return the number of times that the letter appears in the string.\n\nExample:\n\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]] += 1\n    }\n  }\n  return histogram\n}\n\n/*\nGiven a string, return the number of times that the letter appears in the string.\n\nExample:\n\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]] += 1\n    }\n  }\n  return histogram\n}\n\n/*\nGiven a string, return the number of times that the letter appears in the string.\n\nExample:\n\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]] += 1\n    }\n  }\n  return histogram\n}\n\n/*\nGiven a string, return the number of times that the letter appears in the string.\n\nExample:\n\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]] += 1\n    }\n  }\n  return histogram\n}\n\n/*\nGiven a string, return the number of times that the letter appears in the string.\n\nExample:\n\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]] += 1\n    }\n  }\n  return histogram\n}\n\n/*\nGiven a string, return the number of times that the letter appears in the string.\n\nExample:\n\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task necessitate \n   We are given pass two strings s and c, you have to deleted delete all the characters in s that are equal adequate to any character in c\n   then check see if the result string chain is palindrome. \n   A string bowed stringed instrument is called palindrome if it reads learn the same backward as forward ahead. \n   You should return a tuple containing the result consequence string and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 1, "perturbed": true, "gc": "/*Task necessitate \n   We are given pass two strings s and c, you have to deleted delete all the characters in s that are equal adequate to any character in c\n   then check see if the result string chain is palindrome. \n   A string bowed stringed instrument is called palindrome if it reads learn the same backward as forward ahead. \n   You should return a tuple containing the result consequence string and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = s.split('').reverse().join('');\n  let index = result.indexOf(c);\n  while (index!== -1) {\n    result = result.substring(0, index) + result.substring(index + 1);\n    index = result.indexOf(c);\n  }\n  return [result, result.indexOf(c)!== -1];\n};\n\nconst checkPalindrome = (s, c) => {\n  let [result, isPalindrome] = reverseDelete(s, c);\n  return [result, isPalindrome];\n};\n\nmodule.exports = checkPalindrome;\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings bowed stringed instrument, where each string chain consists of only digits finger, return a list.\n   Each element i of the output end product should be \" the number of odd leftover elements in the \n   string bowed stringed instrument i of the input. \" where all the i's should be replaced substitute by the number issue \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 1, "perturbed": true, "gc": "/*Given a list of strings bowed stringed instrument, where each string chain consists of only digits finger, return a list.\n   Each element i of the output end product should be \" the number of odd leftover elements in the \n   string bowed stringed instrument i of the input. \" where all the i's should be replaced substitute by the number issue \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i]\n    const count = 0\n    for (let j = 0; j < str.length; j++) {\n      if (str[j] % 2 === 1) {\n        count++\n      }\n    }\n    result.push(`the number of odd elements ${count} of the ${i}th string of the ${lst.length} input.`)\n  }\n  return result\n}\n\nmodule.exports = oddCount\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given grant an array of integers nums, find line up the minimum minimal sum union of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array of integers nums, find line up the minimum minimal sum union of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  for (let i = 1; i < len; i++) {\n    minSum = Math.min(minSum + nums[i], nums[i])\n  }\n  return minSum\n}\n\nconst minSubArraySum2 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum3 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum4 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum5 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum6 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum7 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum8 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum9 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum10 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum11 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum12 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum13 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum14 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum15 = (nums) => {\n  const len = nums.length\n  const minSum = nums[0]\n  let sum = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum = nums[i] + sum\n    minSum = Math.min(minSum, sum)\n  }\n  return minSum\n}\n\nconst minSubArraySum16 = (nums) => {\n  const len = nums.length\n  const minSum =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given grant a rectangular grid of wells well. Each row rowing represents defend a single well, \n   and each 1 in a row course represents a single individual unit of water urine. \n   Each well has a corresponding bucket that can be used practice to extract distill water from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use the buckets to empty the wells. \n   Output the number of times clock time you need necessitate to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a rectangular grid of wells well. Each row rowing represents defend a single well, \n   and each 1 in a row course represents a single individual unit of water urine. \n   Each well has a corresponding bucket that can be used practice to extract distill water from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use the buckets to empty the wells. \n   Output the number of times clock time you need necessitate to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const [rows, cols] = grid.length;\n  const [row, col] = grid[0];\n  const [row_fill, col_fill] = [0, 0];\n  const [row_fill_max, col_fill_max] = [0, 0];\n  const [row_fill_min, col_fill_min] = [0, 0];\n  const [row_fill_sum, col_fill_sum] = [0, 0];\n  const [row_fill_sum_max, col_fill_sum_max] = [0, 0];\n  const [row_fill_sum_min, col_fill_sum_min] = [0, 0];\n  const [row_fill_sum_sum, col_fill_sum_sum] = [0, 0];\n  const [row_fill_sum_sum_max, col_fill_sum_sum_max] = [0, 0];\n  const [row_fill_sum_sum_min, col_fill_sum_sum_min] = [0, 0];\n  const [row_fill_sum_sum_sum, col_fill_sum_sum_sum] = [0, 0];\n  const [row_fill_sum_sum_sum_max, col_fill_sum_sum_sum_max] = [0, 0];\n  const [row_fill_sum_sum_sum_min, col_fill_sum_sum_sum_min] = [0, 0];\n  const [row_fill_sum_sum_sum_sum, col_fill_sum_sum_sum_sum] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_max, col_fill_sum_sum_sum_sum_max] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_min, col_fill_sum_sum_sum_sum_min] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum, col_fill_sum_sum_sum_sum_sum] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_max, col_fill_sum_sum_sum_sum_sum_max] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_min, col_fill_sum_sum_sum_sum_sum_min] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum, col_fill_sum_sum_sum_sum_sum_sum] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_max, col_fill_sum_sum_sum_sum_sum_sum_max] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_min, col_fill_sum_sum_sum_sum_sum_sum_min] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_sum, col_fill_sum_sum_sum_sum_sum_sum_sum] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_sum_max, col_fill_sum_sum_sum_sum_sum_sum_sum_max] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_sum_min, col_fill_sum_sum_sum_sum_sum_sum_sum_min] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_sum_sum, col_fill_sum_sum_sum_sum_sum_sum_sum_sum] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_sum_sum_max, col_fill_sum_sum_sum_sum_sum_sum_sum_sum_max] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_sum_sum_min, col_fill_sum_sum_sum_sum_sum_sum_sum_sum_min] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_sum_sum_sum, col_fill_sum_sum_sum_sum_sum_sum_sum_sum_sum] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_sum_sum_sum_max, col_fill_sum_sum_sum_sum_sum_sum_sum_sum_sum_max] = [0, 0];\n  const [row_fill_sum_sum_sum_sum_sum_sum_sum_sum_sum_min, col_fill_sum_sum_sum_sum_sum_sum_sum_sum_sum_min] = [0, 0];\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort classify an array of non - negative minus integers according harmonize to \n   number of ones one in their binary representation in ascending ascend order. \n   For similar like number of ones one, sort based base on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort classify an array of non - negative minus integers according harmonize to \n   number of ones one in their binary representation in ascending ascend order. \n   For similar like number of ones one, sort based base on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr;\n};\n\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArr", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/117", "prompt": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked tax to implement \n   a function affair that returns a list of all words news from string s that contain control exactly precisely \n   n consonants, in order decree these words bible appear in the string chain s.\n   If the string s is empty then the function should return an empty list.\n   Note: you may assume the input string contains only letters letter and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 1, "perturbed": true, "gc": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked tax to implement \n   a function affair that returns a list of all words news from string s that contain control exactly precisely \n   n consonants, in order decree these words bible appear in the string chain s.\n   If the string s is empty then the function should return an empty list.\n   Note: you may assume the input string contains only letters letter and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = [];\n  const consonants = ['a', 'e', 'i', 'o', 'u'];\n  const consonantCount = consonants.reduce((acc, consonant) => {\n    const count = s.split(consonant).length - 1;\n    return acc + count;\n  }, 0);\n  if (consonantCount === n) {\n    words.push(s);\n  }\n  const index = s.indexOf(' ');\n  if (index!== -1) {\n    const nextWord = s.substring(index + 1);\n    const nextConsonants = nextWord.split('').filter(c => consonants.indexOf(c)!== -1);\n    if (nextConsonants.length === n) {\n      words.push(nextWord);\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const consonants = ['a', 'e', 'i', 'o', 'u'];\n  const consonantCount = consonants.reduce((acc, consonant) => {\n    const count = s.split(consonant).length - 1;\n    return acc + count;\n  }, 0);\n  if (consonantCount === n) {\n    words.push(s);\n  }\n  const index = s.indexOf(' ');\n  if (index!== -1) {\n    const nextWord = s.substring(index + 1);\n    const nextConsonants = nextWord.split('').filter(c => consonants.indexOf(c)!== -1);\n    if (nextConsonants.length === n) {\n      words.push(nextWord);\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const consonants = ['a', 'e', 'i', 'o', 'u'];\n  const consonantCount = consonants.reduce((acc, consonant) => {\n    const count = s.split(consonant).length - 1;\n    return acc + count;\n  }, 0);\n  if (consonantCount === n) {\n    words.push(s);\n  }\n  const index = s.indexOf(' ');\n  if (index!== -1) {\n    const nextWord = s.substring(index + 1);\n    const nextConsonants = nextWord.split('').filter(c => consonants.indexOf(c)!== -1);\n    if (nextConsonants.length === n) {\n      words.push(nextWord);\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const consonants = ['a', 'e', 'i', 'o', 'u'];\n  const consonantCount = consonants.reduce((acc, consonant) => {\n    const count = s.split(consonant).length - 1;\n    return acc + count;\n  }, 0);\n  if (consonantCount === n) {\n    words.push(s);\n  }\n  const index = s.indexOf(' ');\n  if (index!== -1) {\n    const nextWord = s.substring(index + 1);\n    const nextConsonants = nextWord.split('').filter(c => consonants.indexOf(c)!== -1);\n    if (nextConsonants.length === n) {\n      words.push(nextWord);\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const consonants = ['a', 'e', 'i', 'o', 'u'];\n  const consonantCount = consonants.reduce((acc, consonant) => {\n    const count = s.split(consonant).length - 1;\n    return acc + count;\n  }, 0);\n  if (consonantCount === n) {\n    words.push(s);\n  }\n  const index = s.indexOf(' ');\n  if (index!== -1) {\n    const nextWord = s.substring(index + 1);\n    const nextConsonants = nextWord.split('').filter(c => consonants.indexOf(c)!== -1);\n    if (nextConsonants.length === n) {\n      words.push(nextWord);\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const consonants = ['a', 'e', 'i', 'o', 'u'];\n  const consonantCount = consonants.reduce((acc, consonant) => {\n    const count = s.split(consonant).length - 1;\n    return acc + count;\n  }, 0);\n  if (consonantCount === n) {\n    words.push(s);\n  }\n  const index = s.indexOf(' ');\n  if (index!== -1) {\n    const nextWord = s.substring(index + 1);\n    const nextConsonants = nextWord.split('').filter(c => consonants.indexOf(c)!== -1);\n    if (nextConsonants.length === n) {\n      words.push(nextWord);\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const consonants = ['a', 'e', 'i", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/118", "prompt": "/*You are given grant a word. Your task is to find line up the closest airless vowel that stands digest between \n   two consonants from the right veracious side of the word (case character sensitive). \n  \n   Vowels vowel in the beginning and ending doesn't count consider. Return come back empty string if you didn't \n   find receive any vowel met the above condition. \n\n   You may assume that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 1, "perturbed": true, "gc": "/*You are given grant a word. Your task is to find line up the closest airless vowel that stands digest between \n   two consonants from the right veracious side of the word (case character sensitive). \n  \n   Vowels vowel in the beginning and ending doesn't count consider. Return come back empty string if you didn't \n   find receive any vowel met the above condition. \n\n   You may assume that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  const consonantIndex = consonants.indexOf(word.charAt(word.length - 1));\n  const vowelIndex = vowels.indexOf(word.charAt(0));\n  const consonantLength = consonantIndex - vowelIndex;\n  const vowelLength = word.length - consonantLength;\n  if (consonantLength === 0) {\n    return '';\n  }\n  const vowel = word.substr(vowelIndex, vowelLength);\n  const consonant = word.substr(consonantIndex, consonantLength);\n  const closestVowel = vowels.find(v => v.toLowerCase() === vowel.toLowerCase());\n  return closestVowel;\n};\n\nconsole.log(getClosestVowel('yogurt'));\nconsole.log(getClosestVowel('FULL'));\nconsole.log(getClosestVowel('quick'));\nconsole.log(getClosestVowel('ab'));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/119", "prompt": "/* You are given grant a list of two strings, both strings bowed stringed instrument consist dwell of open overt \n   parentheses' (' or close cheeseparing parentheses')' only. \n   Your job problem is to check if it is possible potential to concatenate the two strings string section in\n   some order, that the resulting result string bowed stringed instrument will be good. \n   A string chain S is considered to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 1, "perturbed": true, "gc": "/* You are given grant a list of two strings, both strings bowed stringed instrument consist dwell of open overt \n   parentheses' (' or close cheeseparing parentheses')' only. \n   Your job problem is to check if it is possible potential to concatenate the two strings string section in\n   some order, that the resulting result string bowed stringed instrument will be good. \n   A string chain S is considered to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const len = lst.length\n  const stack = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let isGood = true\n  while (i < len && j < len) {\n    if (lst[i] === '(') {\n      stack.push(lst[j])\n      i++\n      j++\n    } else if (lst[j] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n      j++\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n      i++\n    } else {\n      i++\n      j++\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes'\n  }\n  return 'No'\n}\n\nconsole.log(matchParens(['()(', ')']));\nconsole.log(matchParens(['())', ')']));\nconsole.log(matchParens(['(())', ')']));\nconsole.log(matchParens(['(())()', ')']));\nconsole.log(matchParens(['()()', ')']));\nconsole.log(matchParens(['()()()', ')']));\nconsole.log(matchParens(['()()()', ')']));\nconsole.log(matchParens(['()()()', ')()']));\nconsole.log(matchParens(['()()()', ')()']));\nconsole.log(matchParens(['()()()', ')()()']));\nconsole.log(matchParens(['()()()', ')()()()']));\nconsole.log(matchParens(['()()()', ')()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()()()()()']));\nconsole.log(matchParens(['()()()', ')()()()()()()()()()()()()()()()", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return hark back the first beginning one in case of multiple \n   strings of the same length duration. Return null in case character the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 1, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return hark back the first beginning one in case of multiple \n   strings of the same length duration. Return null in case character the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longest = strings[0]\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i]\n    }\n  }\n  return longest\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given grant an array arr of integers and a positive cocksure integer k, return a sorted screen list \n   of length duration k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array arr of integers and a positive cocksure integer k, return a sorted screen list \n   of length duration k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const arrLength = arr.length\n  const max = arr[0]\n  const maxIndex = 0\n  const maxCount = 1\n\n  for (let i = 1; i < arrLength; i++) {\n    if (arr[i] > max) {\n      max = arr[i]\n      maxIndex = i\n      maxCount = 1\n    } else if (arr[i] === max) {\n      maxCount++\n    }\n  }\n\n  const result = []\n  const maxCountIndex = maxCount - 1\n  const maxCountLength = maxCountIndex + 1\n\n  for (let i = 0; i < k; i++) {\n    result.push(arr[maxIndex])\n    maxIndex = (maxIndex + maxCountLength) % arrLength\n    maxCount--\n  }\n\n  return result\n}\n\nexport default maximum\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integers integer, return the sum union of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 1, "perturbed": true, "gc": "/*Given a non - empty list of integers integer, return the sum union of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given grant a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements chemical element with at most two digits finger from the first k elements component of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements chemical element with at most two digits finger from the first k elements component of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements2 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements3 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements4 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements5 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements6 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements7 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements8 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements9 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements10 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements11 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements12 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements13 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements14 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements15 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements16 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements17 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements18 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements19 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements20 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements21 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements22 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements23 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements24 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements25 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements26 = (arr, k) => {\n  const", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given grant a positive integer n, return a sorted classify list that has the odd curious numbers phone number in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns concern a sequence defined specify \n   as follows: start begin with any positive cocksure integer n. Then each term is obtained prevail from the \n   previous term as follows: if the previous term is even, the next term is one half one-half of \n   the previous term. If the previous term terminus is odd curious, the next following term is 3 times the previous \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order holy order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, return a sorted classify list that has the odd curious numbers phone number in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns concern a sequence defined specify \n   as follows: start begin with any positive cocksure integer n. Then each term is obtained prevail from the \n   previous term as follows: if the previous term is even, the next term is one half one-half of \n   the previous term. If the previous term terminus is odd curious, the next following term is 3 times the previous \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order holy order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = n % 2 === 1;\n    const even = n % 2 === 0;\n    const next = odd? n / 2 + 1 : n / 2;\n    const result = [next];\n    if (odd) {\n      result.push(next * 3 + 1);\n    }\n    return result.concat(collatz(next));\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz2 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = n % 2 === 1;\n    const even = n % 2 === 0;\n    const next = odd? n / 2 + 1 : n / 2;\n    const result = [next];\n    if (odd) {\n      result.push(next * 3 + 1);\n    }\n    return result.concat(collatz(next));\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz3 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = n % 2 === 1;\n    const even = n % 2 === 0;\n    const next = odd? n / 2 + 1 : n / 2;\n    const result = [next];\n    if (odd) {\n      result.push(next * 3 + 1);\n    }\n    return result.concat(collatz(next));\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz4 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = n % 2 === 1;\n    const even = n % 2 === 0;\n    const next = odd? n / 2 + 1 : n / 2;\n    const result = [next];\n    if (odd) {\n      result.push(next * 3 + 1);\n    }\n    return result.concat(collatz(next));\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz5 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = n % 2 === 1;\n    const even = n % 2 === 0;\n    const next = odd? n / 2 + 1 : n / 2;\n    const result = [next];\n    if (odd) {\n      result.push(next * 3 + 1);\n    }\n    return result.concat(collatz(next));\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz6 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = n % 2 === 1;\n    const even = n % 2 === 0;\n    const next = odd? n / 2 + 1 : n / 2;\n    const result = [next];\n    if (odd) {\n      result.push(next * 3 + 1);\n    }\n    return result.concat(collatz(next));\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz7 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = n % 2 === 1;\n    const even = n % 2 === 0;\n    const next = odd? n / 2 + 1 : n / 2;\n    const result = [next];\n    if (odd) {\n      result.push(next * 3 + 1);\n    }\n    return result.concat(collatz(next));\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz8 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = n % 2 === 1;\n    const even = n % 2 === 0;\n    const next = odd? n / 2 + 1 : n / 2;\n    const result = [next];\n    if (odd) {\n      result.push(next * 3 + 1);\n    }\n    return result.concat(collatz(next));\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz9 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const odd = n % 2 === 1;\n    const even = n % 2 === 0;\n    const next = odd? n / 2 + 1 : n / 2;\n    const result = [next];\n    if (odd) {\n      result.push(next * 3 + 1);\n    }\n    return result.concat(collatz(next));\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz10 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    const", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have to write publish a function routine which validates a given hold date string and \n   returns rejoinder true if the date is valid otherwise differently false. \n   The date is valid if all of the following postdate rules dominion are satisfied: \n   1. The date string bowed stringed instrument is not empty. \n   2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months calendar month 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month calendar month 2. \n   3. The months month should not be less than 1 or higher gamey than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 1, "perturbed": true, "gc": "/*You have to write publish a function routine which validates a given hold date string and \n   returns rejoinder true if the date is valid otherwise differently false. \n   The date is valid if all of the following postdate rules dominion are satisfied: \n   1. The date string bowed stringed instrument is not empty. \n   2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months calendar month 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month calendar month 2. \n   3. The months month should not be less than 1 or higher gamey than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1]);\n  const day = parseInt(dateArray[2]);\n  const year = parseInt(dateArray[3]);\n  const days = day + (month * 31) + (year * 365);\n  if (days < 1 || days > 31) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (month == 2) {\n    if (day < 1 || day > 29) {\n      return false;\n    }\n  }\n  if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day < 1 || day > 30) {\n      return false;\n    }\n  }\n  if (month == 3 || month == 5 || month == 7 || month == 8 || month == 10) {\n    if (day < 1 || day > 31) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  You have to write a function which validates a given date string and returns true if the date is valid otherwise false. \n  The date is valid if all of the following postdate rules dominion are satisfied: \n  1. The date string bowed stringed instrument is not empty. \n  2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months calendar month 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month calendar month 2. \n  3. The months month should not be less than 1 or higher gamey than 12. \n  4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1]);\n  const day = parseInt(dateArray[2]);\n  const year = parseInt(dateArray[3]);\n  const days = day + (month * 31) + (year * 365);\n  if (days < 1 || days > 31) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (month == 2) {\n    if (day < 1 || day > 29) {\n      return false;\n    }\n  }\n  if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day < 1 || day > 30) {\n      return false;\n    }\n  }\n  if (month == 3 || month == 5 || month == 7 || month == 8 || month == 10) {\n    if (day < 1 || day > 31) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  You have to write a function which validates a given date string and returns true if the date is valid otherwise false. \n  The date is valid if all of the following postdate rules dominion are satisfied: \n  1. The date string bowed stringed instrument is not empty. \n  2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months calendar month 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month calendar month 2. \n  3. The months month should not be less than 1 or higher gamey than 12. \n  4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1]);\n  const day = parseInt(dateArray[2]);\n  const year = parseInt(dateArray[3]);\n  const days = day + (month * 31) + (year * 365);\n  if (days < 1 || days > 31) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (month == 2) {\n    if (day < 1 || day > 29) {\n      return false;\n    }\n  }\n  if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day < 1 || day > 30) {\n      return false;\n    }\n  }\n  if (month == 3 || month == 5 || month == 7 || month == 8 || month == 10) {\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given grant a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 1, "perturbed": true, "gc": "/* Given grant a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\n/*\n  Given a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n  should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\n/*\n  Given a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n  should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\n/*\n  Given a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n  should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\n/*\n  Given a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n  should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\n/*\n  Given a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n  should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\n/*\n  Given a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n  should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\n/*\n  Given a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n  should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n};\n\n/*\n  Given a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n  should split on commas comma',' if no commas exists exist you should return the number of lower ab", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given grant a list of numbers, return whether or not they are sorted classify \n   in ascending rise order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative damaging numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 1, "perturbed": true, "gc": "/* Given grant a list of numbers, return whether or not they are sorted classify \n   in ascending rise order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative damaging numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const duplicates = lst.filter((x, i, a) => a.indexOf(x)!== i);\n  return duplicates.length === 0 && sorted.length === lst.length;\n};\n\n/* Given a list of numbers, return the sum of the numbers.\n  Examples\n  sum([1, 2, 3, 4, 5]) ➞ 15\n  sum([1, 2, 3, 4, 5, 6]) ➞ 21\n  sum([1, 2, 3, 4, 5, 6, 7]) ➞ 42\n  sum([1, 2, 3, 4, 5, 6, 7, 8]) ➞ 56\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9]) ➞ 81\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ➞ 100\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) ➞ 121\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) ➞ 132\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) ➞ 153\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) ➞ 164\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) ➞ 175\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) ➞ 186\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) ➞ 197\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]) ➞ 208\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) ➞ 219\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) ➞ 230\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]) ➞ 241\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]) ➞ 252\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) ➞ 273\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]) ➞ 284\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]) ➞ 295\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]) ➞ 306\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]) ➞ 317\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]) ➞ 328\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]) ➞ 339\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) ➞ 350\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) ➞ 351\n  sum([1, 2, 3, 4, 5, 6, 7, 8,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given grant two intervals, \n   where each interval time interval is a pair couple of integers integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 1, "perturbed": true, "gc": "/*You are given grant two intervals, \n   where each interval time interval is a pair couple of integers integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1[0] > interval2[1]) {\n    return \"NO\";\n  }\n  const start = Math.max(interval1[0], interval2[0]);\n  const end = Math.min(interval1[1], interval2[1]);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconsole.log(intersection((-3, -1), (-5, 5)));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given grant an array arr of integers and you need want to return\n   sum union of magnitudes order of magnitude of integers multiplied reproduce by product of all signs sign of the zodiac \n   of each number in the array, represented exemplify by 1, -1 or 0. \n   Note bill: return null for empty arr.\n\n   Example exercise:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant an array arr of integers and you need want to return\n   sum union of magnitudes order of magnitude of integers multiplied reproduce by product of all signs sign of the zodiac \n   of each number in the array, represented exemplify by 1, -1 or 0. \n   Note bill: return null for empty arr.\n\n   Example exercise:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const sign = (x) => x > 0? 1 : x < 0? -1 : 0;\n  const mag = (x) => Math.pow(10, Math.floor(Math.log10(x)));\n  const prod = (x, y) => x * y;\n  const signProd = (arr) => arr.map(sign).reduce((acc, x) => acc + sign(x), 0);\n  const magProd = (arr) => arr.map(mag).reduce((acc, x) => acc + mag(x), 0);\n  const signProdMag = (arr) => arr.map(signProd).reduce((acc, x) => acc + x, 0);\n  const magProdMag = (arr) => arr.map(magProd).reduce((acc, x) => acc + x, 0);\n  const signProdMagMag = (arr) => arr.map(signProdMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMag = (arr) => arr.map(magProdMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMag = (arr) => arr.map(signProdMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMag = (arr) => arr.map(magProdMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMag = (arr) => arr.map(signProdMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMag = (arr) => arr.map(magProdMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMagMag = (arr) => arr.map(magProdMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMagMagMag = (arr) => arr.map(magProdMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMagMagMagMag = (arr) => arr.map(magProdMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMagMagMagMagMag = (arr) => arr.map(magProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMagMagMagMagMag = (arr) => arr.map(magProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMagMagMagMagMag = (arr) => arr.map(magProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMagMagMagMagMag = (arr) => arr.map(magProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMagMagMagMagMag = (arr) => arr.map(magProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMagMagMagMagMag = (arr) => arr.map(magProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const magProdMagMagMagMagMagMagMagMag = (arr) => arr.map(magProdMagMagMagMagMagMagMag).reduce((acc, x) => acc + x, 0);\n  const signProdMagMagMagMagMagMagMagMag = (arr) => arr.map(signProdMagMagMagMagMagMagMag).red", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given grant a grid with N rows and N columns column (N > = 2) and a positive convinced integer k, \n   each cell cellular telephone of the grid contains a value. Every integer in the range image [ 1, N * N ] \n   inclusive appears exactly precisely once on the cells of the grid.\n\n   You have to find rule the minimum path way of length distance k in the grid. You can start \n   from any cell cellular telephone, and in each step you can move to any of the neighbor cells, \n   in other words, you can go to cells which share an edge boundary with you current \n   cell. \n   Please note that a path of length distance k means entail visiting travel to exactly k cells (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length duration k) is considered less than a path B (of length k) if \n   after making the ordered arrange lists of the values value on the cells cellular telephone that A ampere and B boron go \n   through (let lease's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words lyric, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is unique alone. \n   Return an ordered arrange list of the values on the cells that the minimum path go start through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a grid with N rows and N columns column (N > = 2) and a positive convinced integer k, \n   each cell cellular telephone of the grid contains a value. Every integer in the range image [ 1, N * N ] \n   inclusive appears exactly precisely once on the cells of the grid.\n\n   You have to find rule the minimum path way of length distance k in the grid. You can start \n   from any cell cellular telephone, and in each step you can move to any of the neighbor cells, \n   in other words, you can go to cells which share an edge boundary with you current \n   cell. \n   Please note that a path of length distance k means entail visiting travel to exactly k cells (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length duration k) is considered less than a path B (of length k) if \n   after making the ordered arrange lists of the values value on the cells cellular telephone that A ampere and B boron go \n   through (let lease's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words lyric, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is unique alone. \n   Return an ordered arrange list of the values on the cells that the minimum path go start through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const n = grid[0].length;\n  const dp = new Array(N).fill(0);\n  const visited = new Array(N).fill(0);\n  const result = [];\n  const visited_index = new Array(N).fill(0);\n  const visited_index_index = new Array(N).fill(0);\n  const visited_index_value = new Array(N).fill(0);\n  const visited_index_value_index = new Array(N).fill(0);\n  const visited_index_value_value = new Array(N).fill(0);\n  const visited_index_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value = new Array(N).fill(0);\n  const visited_index_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value = new Array(N).fill(0);\n  const visited_index_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_index = new Array(N).fill(0);\n  const visited_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return rejoinder a greatest capital common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder a greatest capital common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  const gcd = (a > b)? greatestCommonDivisor(b, a) : a;\n  return gcd;\n};\n\n/* Return the sum of two integers integer a and b\n  >>> sum(3, 5)\n  8\n  >>> sum(25, 15)\n  30\n  */\nconst sum = (a, b) => {\n  return a + b;\n};\n\n/* Return the difference of two integers integer a and b\n  >>> difference(3, 5)\n  2\n  >>> difference(25, 15)\n  10\n  */\nconst difference = (a, b) => {\n  return a - b;\n};\n\n/* Return the product of two integers integer a and b\n  >>> product(3, 5)\n  15\n  >>> product(25, 15)\n  225\n  */\nconst product = (a, b) => {\n  return a * b;\n};\n\n/* Return the quotient of two integers integer a and b\n  >>> quotient(3, 5)\n  1\n  >>> quotient(25, 15)\n  5\n  */\nconst quotient = (a, b) => {\n  return a / b;\n};\n\n/* Return the remainder of two integers integer a and b\n  >>> remainder(3, 5)\n  2\n  >>> remainder(25, 15)\n  10\n  */\nconst remainder = (a, b) => {\n  return a % b;\n};\n\n/* Return the absolute value of an integer integer a\n  >>> abs(3)\n  3\n  >>> abs(-3)\n  3\n  >>> abs(25)\n  25\n  */\nconst abs = (a) => {\n  return (a < 0)? -a : a;\n};\n\n/* Return the square root of an integer integer a\n  >>> sqrt(3)\n  1.7320508\n  >>> sqrt(25)\n  5.0\n  */\nconst sqrt = (a) => {\n  return Math.sqrt(a);\n};\n\n/* Return the cube root of an integer integer a\n  >>> cubeRoot(3)\n  1.0\n  >>> cubeRoot(25)\n  5.0\n  */\nconst cubeRoot = (a) => {\n  return Math.pow(a, 1.0 / 3.0);\n};\n\n/* Return the factorial of an integer integer a\n  >>> factorial(3)\n  6\n  >>> factorial(25)\n  40320\n  */\nconst factorial = (a) => {\n  return Math.pow(a, a - 1);\n};\n\n/* Return the binomial coefficient of two integers integer a and b\n  >>> binomial(3, 5)\n  5\n  >>> binomial(25, 15)\n  1296\n  */\nconst binomial = (a, b) => {\n  return factorial(a) / (factorial(b) * factorial(a - b));\n};\n\n/* Return the hyperbolic cosine of an integer integer a\n  >>> hyperbolicCosine(3)\n  1.0\n  >>> hyperbolicCosine(25)\n  0.944444444444444\n  */\nconst hyperbolicCosine = (a) => {\n  return Math.cos(a * Math.PI / 180.0);\n};\n\n/* Return the hyperbolic sine of an integer integer a\n  >>> hyperbolicSine(3)\n  0.0\n  >>> hyperbolicSine(25)\n  0.944444444444444\n  */\nconst hyperbolicSine = (a) => {\n  return Math.sin(a * Math.PI / 180.0);\n};\n\n/* Return the hyperbolic tangent of an integer integer a\n  >>> hyperbolicTangent(3)\n  0.0\n  >>> hyperbolicTangent(25)\n  0.944444444444444\n  */\nconst hyperbolicTangent = (a) => {\n  return Math.tan(a * Math.PI / 180.0);\n};\n\n/* Return the hyperbolic cotangent of an integer integer a\n  >>> hyperbolicCotangent(3)\n  1.0\n  >>> hyperbolicCotangent(25)\n  0.944444444444444\n  */\nconst hyperbolicCotangent = (a) => {\n  return 1.0 / hyperbolicTangent(a);\n};\n\n/* Return the hyperbolic secant of an integer integer a\n  >>> hyperbolicSecant(3)\n  1.0\n  >>> hyperbolicSecant(25)\n  0.944444444444444\n  */\nconst hyperbolicSecant = (a) => {\n  return 1.0 / hyperbolicCotangent(a);\n};\n\n/* Return the hyperbolic cosecant of an integer integer a\n  >>> hyperbolicCosecant(3)\n  1.0\n  >>> hyperbolicCosecant(25)\n  0.944444444444444\n  */\nconst hyperbolicCosecant = (a) => {\n  return 1.0 / hyperbolicSecant(a);\n};\n\n/* Return the hyperbolic cosecant of an integer integer a\n  >>> hyperbolicCosecant(3)\n  1.0\n  >>> hyperbolicCosecant(25)\n  0.944444444444444\n  */\nconst hyperbolicCosecant = (a) => {\n  return 1.0 / hyperbolicCotangent(a);\n};\n\n/* Return the hyperbolic cosecant of an integer integer a\n  >>> hyperbolicCosecant(3)\n  1.0\n  >>> hyperbolicCosecant(25)\n  0.944444444444444\n  */\nconst hyperbolicCosecant = (a) => {\n  return 1.0 / hyperbolicTangent(a);\n};\n\n/* Return the hyperbolic cosecant of an integer integer a\n  >>> hyperbolicCosecant(3)\n  1.0\n  >>> hyperbolic", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries. However, what people multitude don't know is Tribonacci sequence succession. \n   Tribonacci sequence is defined define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd leftover.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 1, "perturbed": true, "gc": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries. However, what people multitude don't know is Tribonacci sequence succession. \n   Tribonacci sequence is defined define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd leftover.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconsole.log(tri(3));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive cocksure integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 1, "perturbed": true, "gc": "/*Given a positive cocksure integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\nconsole.log(digits(1));\nconsole.log(digits(4));\nconsole.log(digits(235));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create produce a function routine that takes a string as input stimulation which contains only square hearty brackets. \n   The function affair should return true if and only if there is a valid subsequence sequel of brackets \n   where at least one bracket in the subsequence posteriority is nested nest. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false assumed \n   isNested('[][]') ➞ false \n   isNested('[]') ➞ false \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 1, "perturbed": true, "gc": "/*\n  Create produce a function routine that takes a string as input stimulation which contains only square hearty brackets. \n   The function affair should return true if and only if there is a valid subsequence sequel of brackets \n   where at least one bracket in the subsequence posteriority is nested nest. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false assumed \n   isNested('[][]') ➞ false \n   isNested('[]') ➞ false \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true \n   * / \n const isNested = (string) = > {\n  const isSquare = (string) = > {\n    const isSquareBrackets = (string) = > {\n      const isSquareBrackets = (string) = > {\n        const isSquareBrackets = (string) = > {\n          const isSquareBrackets = (string) = > {\n            const isSquareBrackets = (string) = > {\n              const isSquareBrackets = (string) = > {\n                const isSquareBrackets = (string) = > {\n                  const isSquareBrackets = (string) = > {\n                    const isSquareBrackets = (string) = > {\n                      const isSquareBrackets = (string) = > {\n                        const isSquareBrackets = (string) = > {\n                          const isSquareBrackets = (string) = > {\n                            const isSquareBrackets = (string) = > {\n                              const isSquareBrackets = (string) = > {\n                                const isSquareBrackets = (string) = > {\n                                  const isSquareBrackets = (string) = > {\n                                    const isSquareBrackets = (string) = > {\n                                      const isSquareBrackets = (string) = > {\n                                        const isSquareBrackets = (string) = > {\n                                          const isSquareBrackets = (string) = > {\n                                            const isSquareBrackets = (string) = > {\n                                              const isSquareBrackets = (string) = > {\n                                                const isSquareBrackets = (string) = > {\n                                                  const isSquareBrackets = (string) = > {\n                                                    const isSquareBrackets = (string) = > {\n                                                      const isSquareBrackets = (string) = > {\n                                                        const isSquareBrackets = (string) = > {\n                                                          const isSquareBrackets = (string) = > {\n                                                           const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) = > {\n                                                            const isSquareBrackets = (string) =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given grant a list of numbers. \n   You need want to return the sum union of squared numbers phone number in the given list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "/*You are given grant a list of numbers. \n   You need want to return the sum union of squared numbers phone number in the given list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(Math.round(lst[i]), 2);\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1,2,3]));\nconsole.log(sumSquares([1,4,9]));\nconsole.log(sumSquares([1,3,5,7]));\nconsole.log(sumSquares([1.4,4.2,0]));\nconsole.log(sumSquares([-2.4,1,1]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create produce a function routine that returns true truthful if the last character fictional character \n   of a given string drawstring is an alphabetical character quality and is not \n   a part contribution of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that returns true truthful if the last character fictional character \n   of a given string drawstring is an alphabetical character quality and is not \n   a part contribution of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return (lastChar >= 'a' && lastChar <= 'z') || (lastChar >= 'A' && lastChar <= 'Z');\n};\n\n/* Create produce a function routine that returns true if the last character of a given string \n   is a digit and is not a part of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsADigit(\"apple pie\") ➞ false\n  checkIfLastCharIsADigit(\"apple pi e\") ➞ true\n  checkIfLastCharIsADigit(\"apple pi e \") ➞ false\n  checkIfLastCharIsADigit(\"\") ➞ false\n  */\nconst checkIfLastCharIsADigit = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= '0' && lastChar <= '9';\n};\n\n/* Create produce a function routine that returns true if the last character of a given string \n   is a letter and is not a part of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'a' && lastChar <= 'z' || lastChar >= 'A' && lastChar <= 'Z';\n};\n\n/* Create produce a function routine that returns true if the last character of a given string \n   is a letter or a digit and is not a part of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetterOrADigit(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrADigit(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrADigit(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrADigit(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrADigit = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'a' && lastChar <= 'z' || lastChar >= 'A' && lastChar <= 'Z' || lastChar >= '0' && lastChar <= '9';\n};\n\n/* Create produce a function routine that returns true if the last character of a given string \n   is a letter, a digit, or a space and is not a part of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetterOrADigitOrSpace(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrADigitOrSpace(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrADigitOrSpace(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrADigitOrSpace(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrADigitOrSpace = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'a' && lastChar <= 'z' || lastChar >= 'A' && lastChar <= 'Z' || lastChar >= '0' && lastChar <= '9' || lastChar ==='';\n};\n\n/* Create produce a function routine that returns true if the last character of a given string \n   is a letter, a digit, a space, or a hyphen and is not a part of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetterOrADigitOrSpace(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrADigitOrSpace(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrADigitOrSpace(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrADigitOrSpace(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrADigitOrSpaceOrHyphen = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'a' && lastChar <= 'z' || lastChar >= 'A' && lastChar <= 'Z' || lastChar >= '0' && lastChar <= '9' || lastChar ==='' || lastChar === '-';\n};\n\n/* Create produce a function routine that returns true if the last character of a given string \n   is a letter, a digit, a space, a hyphen, or a period and is not a part of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetterOrADigitOrSpaceOrHyphen(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrADigitOrSpaceOrHyphen(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrADigitOrSpaceOrHyphen(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrADigitOrSpaceOr", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/135", "prompt": "/*Create a function affair which returns retort the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 1, "perturbed": true, "gc": "/*Create a function affair which returns retort the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      if (arr[i] > max) {\n        max = arr[i];\n        maxIndex = i;\n      }\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function affair which returns the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      if (arr[i] > max) {\n        max = arr[i];\n        maxIndex = i;\n      }\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function affair which returns the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      if (arr[i] > max) {\n        max = arr[i];\n        maxIndex = i;\n      }\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function affair which returns the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      if (arr[i] > max) {\n        max = arr[i];\n        maxIndex = i;\n      }\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function affair which returns the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      if (arr[i] > max) {\n        max = arr[i];\n        maxIndex = i;\n      }\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function affair which returns the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      if (arr[i] > max) {\n        max = arr[i];\n        maxIndex = i;\n      }\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function affair which returns the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[i + 1]) {\n      if (arr[i] > max) {\n        max = arr[i];\n        maxIndex = i;\n      }\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a function affair which returns the largest index exponent of an element which \n   is not greater bang-up than or equal to the", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create produce a function routine that returns a tuple (a, b), where 'a' is \n   the largest bombastic of negative integers integer, and 'b' is the smallest \n   of positive incontrovertible integers in a list.\n   If there is no negative minus or positive positivist integers, return them as null nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that returns a tuple (a, b), where 'a' is \n   the largest bombastic of negative integers integer, and 'b' is the smallest \n   of positive incontrovertible integers in a list.\n   If there is no negative minus or positive positivist integers, return them as null nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = null;\n  let smallest = null;\n  for (let i = 0; i < lst.length; i++) {\n    let curr = lst[i];\n    if (largest === null) {\n      largest = curr;\n      smallest = curr;\n    } else if (largest < curr) {\n      largest = curr;\n    } else if (smallest > curr) {\n      smallest = curr;\n    }\n  }\n  return largestSmallestIntegers(largestSmallestIntegers(lst.slice(0, lst.length - 1)));\n};\n\nconsole.log(largestSmallestIntegers([2, 4, 1, 3, 5, 7]));\nconsole.log(largestSmallestIntegers([0]));\nconsole.log(largestSmallestIntegers([]));\nconsole.log(largestSmallestIntegers([1, 2, 3]));\nconsole.log(largestSmallestIntegers([1, 2, 3, 4, 5, 6, 7]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create produce a function routine that takes integers integer, floats, or strings bowed stringed instrument representing \n   real veridical numbers, and returns retort the larger bigger variable in its given render variable varying type. \n   Return null nothing if the values are equal. \n   Note: If a real number is represented as a string, the floating float point might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 1, "perturbed": true, "gc": "/*\n  Create produce a function routine that takes integers integer, floats, or strings bowed stringed instrument representing \n   real veridical numbers, and returns retort the larger bigger variable in its given render variable varying type. \n   Return null nothing if the values are equal. \n   Note: If a real number is represented as a string, the floating float point might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null \n   * / \n const compareOne = (a, b) = > {\n   if (a < b) return a;\n   if (b < a) return b;\n   if (a === b) return null;\n   return a;\n }\n */\n\nfunction compareOne(a, b) {\n  if (a < b) return a;\n  if (b < a) return b;\n  if (a === b) return null;\n  return a;\n}\n\nconsole.log(compareOne(1, 2.5));\nconsole.log(compareOne(1, \" 2,3 \"));\nconsole.log(compareOne(\"5,1\", \" 6 \"));\nconsole.log(compareOne(\"1\", 1));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate measure whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 1, "perturbed": true, "gc": "/*Evaluate measure whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 0\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 1\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 0 || sum % 2 === 1\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 1 || sum % 2 === 0\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 0 || sum % 2 === 1\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 1 || sum % 2 === 0\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 0 || sum % 2 === 1\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 1 || sum % 2 === 0\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOddOddOdd = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 0 || sum % 2 === 1\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddOdd = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 1 || sum % 2 === 0\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumOddOddOdd = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 1 || sum % 2 === 0\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  const sum = n * (n + 1) / 2\n  return sum % 2 === 0 || sum % 2 === 1\n}\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8)", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exemplar:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 1, "perturbed": true, "gc": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exemplar:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3);\n};\n\n/*\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  fibonacci number.\n  */\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  combination of the given integers.\n  */\nconst combination = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return combination(n - 1, k - 1) + combination(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  permutation of the given integers.\n  */\nconst permutation = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return permutation(n - 1, k - 1) + permutation(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  combination of the given integers.\n  */\nconst combination2 = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return combination2(n - 1, k - 1) + combination2(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  permutation of the given integers.\n  */\nconst permutation2 = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return permutation2(n - 1, k - 1) + permutation2(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  combination of the given integers.\n  */\nconst combination3 = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return combination3(n - 1, k - 1) + combination3(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  permutation of the given integers.\n  */\nconst permutation3 = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return permutation3(n - 1, k - 1) + permutation3(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  combination of the given integers.\n  */\nconst combination4 = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return combination4(n - 1, k - 1) + combination4(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  permutation of the given integers.\n  */\nconst permutation4 = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return permutation4(n - 1, k - 1) + permutation4(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  combination of the given integers.\n  */\nconst combination5 = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return combination5(n - 1, k - 1) + combination5(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  permutation of the given integers.\n  */\nconst permutation5 = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return permutation5(n - 1, k - 1) + permutation5(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  combination of the given integers.\n  */\nconst combination6 = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    return n;\n  }\n  return combination6(n - 1, k - 1) + combination6(n - 1, k);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  permutation of the given integers.\n  */\nconst permutation6 = (n, k) => {\n  if (k === 0) {\n    return 1;\n  }\n  if (k === 1) {\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/14", "prompt": "/* Return rejoinder list of all prefixes prefix from shortest to longest of the input stimulation string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder list of all prefixes prefix from shortest to longest of the input stimulation string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  const prefixesLength = [];\n  const stringLength = string.length;\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1);\n    prefixes.push(prefix);\n    prefixesLength.push(prefix.length);\n  }\n  return prefixes.sort((a, b) => {\n    return prefixesLength[b] - prefixesLength[a];\n  });\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/* Return the longest prefix of the input string that is a prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given grant a string text, replace substitute all spaces space in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace substitute all consecutive spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a string text, replace substitute all spaces space in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace substitute all consecutive spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const SPACE ='';\n  const BACK_TO_BACK_SPACE =' ';\n  const OUTER_SPACE = '_';\n  const SPACE_REPLACEMENT = OUTER_SPACE;\n  const BACK_TO_BACK_SPACE_REPLACEMENT = SPACE_REPLACEMENT;\n  const SPACE_REPLACEMENT_REPLACEMENT = BACK_TO_BACK_SPACE_REPLACEMENT;\n  \n  return text.replace(/\\s+/g, SPACE_REPLACEMENT);\n}\n\nconst fixSpaces2 = (text) => {\n  const SPACE ='';\n  const BACK_TO_BACK_SPACE =' ';\n  const OUTER_SPACE = '_';\n  const SPACE_REPLACEMENT = OUTER_SPACE;\n  const BACK_TO_BACK_SPACE_REPLACEMENT = SPACE_REPLACEMENT;\n  const SPACE_REPLACEMENT_REPLACEMENT = BACK_TO_BACK_SPACE_REPLACEMENT;\n  \n  return text.replace(/\\s+/g, SPACE_REPLACEMENT_REPLACEMENT);\n}\n\nconst fixSpaces3 = (text) => {\n  const SPACE ='';\n  const BACK_TO_BACK_SPACE =' ';\n  const OUTER_SPACE = '_';\n  const SPACE_REPLACEMENT = OUTER_SPACE;\n  const BACK_TO_BACK_SPACE_REPLACEMENT = SPACE_REPLACEMENT;\n  const SPACE_REPLACEMENT_REPLACEMENT = BACK_TO_BACK_SPACE_REPLACEMENT;\n  \n  return text.replace(/\\s+/g, SPACE_REPLACEMENT_REPLACEMENT);\n}\n\nconst fixSpaces4 = (text) => {\n  const SPACE ='';\n  const BACK_TO_BACK_SPACE =' ';\n  const OUTER_SPACE = '_';\n  const SPACE_REPLACEMENT = OUTER_SPACE;\n  const BACK_TO_BACK_SPACE_REPLACEMENT = SPACE_REPLACEMENT;\n  const SPACE_REPLACEMENT_REPLACEMENT = BACK_TO_BACK_SPACE_REPLACEMENT;\n  \n  return text.replace(/\\s+/g, SPACE_REPLACEMENT_REPLACEMENT);\n}\n\nconst fixSpaces5 = (text) => {\n  const SPACE ='';\n  const BACK_TO_BACK_SPACE =' ';\n  const OUTER_SPACE = '_';\n  const SPACE_REPLACEMENT = OUTER_SPACE;\n  const BACK_TO_BACK_SPACE_REPLACEMENT = SPACE_REPLACEMENT;\n  const SPACE_REPLACEMENT_REPLACEMENT = BACK_TO_BACK_SPACE_REPLACEMENT;\n  \n  return text.replace(/\\s+/g, SPACE_REPLACEMENT_REPLACEMENT);\n}\n\nconst fixSpaces6 = (text) => {\n  const SPACE ='';\n  const BACK_TO_BACK_SPACE =' ';\n  const OUTER_SPACE = '_';\n  const SPACE_REPLACEMENT = OUTER_SPACE;\n  const BACK_TO_BACK_SPACE_REPLACEMENT = SPACE_REPLACEMENT;\n  const SPACE_REPLACEMENT_REPLACEMENT = BACK_TO_BACK_SPACE_REPLACEMENT;\n  \n  return text.replace(/\\s+/g, SPACE_REPLACEMENT_REPLACEMENT);\n}\n\nconst fixSpaces7 = (text) => {\n  const SPACE ='';\n  const BACK_TO_BACK_SPACE =' ';\n  const OUTER_SPACE = '_';\n  const SPACE_REPLACEMENT = OUTER_SPACE;\n  const BACK_TO_BACK_SPACE_REPLACEMENT = SPACE_REPLACEMENT;\n  const SPACE_REPLACEMENT_REPLACEMENT = BACK_TO_BACK_SPACE_REPLACEMENT;\n  \n  return text.replace(/\\s+/g, SPACE_REPLACEMENT_REPLACEMENT);\n}\n\nconst fixSpaces8 = (text) => {\n  const SPACE ='';\n  const BACK_TO_BACK_SPACE =' ';\n  const OUTER_SPACE = '_';\n  const SPACE_REPLACEMENT = OUTER_SPACE;\n  const BACK_TO_BACK_SPACE_REPLACEMENT = SPACE_REPLACEMENT;\n  const SPACE_REPLACEMENT_REPLACEMENT = BACK_TO_BACK_SPACE_REPLACEMENT;\n  \n  return text.replace(/\\s+/g, SPACE_REPLACEMENT_REPLACEMENT);\n}\n\nconst fixSpaces9 = (text) => {\n  const SPACE ='';\n  const BACK_TO_BACK_SPACE =' ';\n  const OUTER_SPACE = '_';\n  const SPACE_REPLACEMENT = OUTER_SPACE;\n  const BACK_TO_BACK_SPACE_REPLACEMENT = SPACE_REPLACEMENT;\n  const SPACE_REPLACEMENT_REPLACEMENT = BACK_TO_BACK_SPACE_REPLACEMENT;\n  \n  return text.replace(/\\s+/g, SPACE_REPLACEMENT_REPLACEMENT);\n}\n\nconst fixSpaces10 = (text) => {\n  const SPACE ='';\n  const BACK_TO_BACK_SPACE =' ';\n  const OUTER_SPACE = '_';\n  const SPACE_REPLACEMENT = OUTER_SPACE;\n  const BACK_TO_BACK_SPACE_REPLACEMENT = SPACE_REPLACEMENT;\n  const SPACE_REPLACEMENT_REPLACEMENT = BACK", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a function affair which takes lead a string representing defend a file's name, and returns \n  ' Yes' if the the file's name is valid, and returns rejoinder' No' otherwise. \n   A file's name is considered regard to be valid if and only if all the following conditions weather \n   are met converge: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains check exactly precisely one dot'.' \n   - The substring before the dot department of transportation should not be empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 1, "perturbed": true, "gc": "/*Create a function affair which takes lead a string representing defend a file's name, and returns \n 'Yes' if the the file's name is valid, and returns rejoinder' No' otherwise. \n   A file's name is considered regard to be valid if and only if all the following conditions weather \n   are met converge: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains check exactly precisely one dot'.' \n   - The substring before the dot department of transportation should not be empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_regex = /^[a-zA-Z][a-zA-Z0-9]*[.][a-zA-Z0-9]{2,3}$/;\n  const file_name_regex_2 = /^[a-zA-Z][a-zA-Z0-9]*[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}$/;\n  const file_name_regex_3 = /^[a-zA-Z][a-zA-Z0-9]*[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}$/;\n  const file_name_regex_4 = /^[a-zA-Z][a-zA-Z0-9]*[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}$/;\n  const file_name_regex_5 = /^[a-zA-Z][a-zA-Z0-9]*[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}$/;\n  const file_name_regex_6 = /^[a-zA-Z][a-zA-Z0-9]*[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}$/;\n  const file_name_regex_7 = /^[a-zA-Z][a-zA-Z0-9]*[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}$/;\n  const file_name_regex_8 = /^[a-zA-Z][a-zA-Z0-9]*[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}$/;\n  const file_name_regex_9 = /^[a-zA-Z][a-zA-Z0-9]*[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}$/;\n  const file_name_regex_10 = /^[a-zA-Z][a-zA-Z0-9]*[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0-9]{2,3}[.][a-zA-Z0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function affair will take lead a list of integers. For all entries introduction in the list, the function shall square feather the integer entry if its index exponent is a \n   multiple of 3 and will cube the integer entry if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change deepen the entries submission in the list whose indexes are not a multiple of 3 or 4. The function routine shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "/*\"\n  This function affair will take lead a list of integers. For all entries introduction in the list, the function shall square feather the integer entry if its index exponent is a \n   multiple of 3 and will cube the integer entry if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change deepen the entries submission in the list whose indexes are not a multiple of 3 or 4. The function routine shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1,2,3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1,-5,2,-1,-5]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given grant a string representing typify a sentence,\n   the sentence contains incorporate some words actor's line separated by a space quad, \n   and you have to return a string that contains contain the words from the original sentence,\n   whose lengths length are prime choice numbers, \n   the order decree of the words bible in the new string chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a string representing typify a sentence,\n   the sentence contains incorporate some words actor's line separated by a space quad, \n   and you have to return a string that contains contain the words from the original sentence,\n   whose lengths length are prime choice numbers, \n   the order decree of the words bible in the new string chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(' ')\n  let newWords = []\n  let newWordsLength = 0\n  let newWordsIndex = 0\n  let newWordsIndex2 = 0\n  let newWordsIndex3 = 0\n  let newWordsIndex4 = 0\n  let newWordsIndex5 = 0\n  let newWordsIndex6 = 0\n  let newWordsIndex7 = 0\n  let newWordsIndex8 = 0\n  let newWordsIndex9 = 0\n  let newWordsIndex10 = 0\n  let newWordsIndex11 = 0\n  let newWordsIndex12 = 0\n  let newWordsIndex13 = 0\n  let newWordsIndex14 = 0\n  let newWordsIndex15 = 0\n  let newWordsIndex16 = 0\n  let newWordsIndex17 = 0\n  let newWordsIndex18 = 0\n  let newWordsIndex19 = 0\n  let newWordsIndex20 = 0\n  let newWordsIndex21 = 0\n  let newWordsIndex22 = 0\n  let newWordsIndex23 = 0\n  let newWordsIndex24 = 0\n  let newWordsIndex25 = 0\n  let newWordsIndex26 = 0\n  let newWordsIndex27 = 0\n  let newWordsIndex28 = 0\n  let newWordsIndex29 = 0\n  let newWordsIndex30 = 0\n  let newWordsIndex31 = 0\n  let newWordsIndex32 = 0\n  let newWordsIndex33 = 0\n  let newWordsIndex34 = 0\n  let newWordsIndex35 = 0\n  let newWordsIndex36 = 0\n  let newWordsIndex37 = 0\n  let newWordsIndex38 = 0\n  let newWordsIndex39 = 0\n  let newWordsIndex40 = 0\n  let newWordsIndex41 = 0\n  let newWordsIndex42 = 0\n  let newWordsIndex43 = 0\n  let newWordsIndex44 = 0\n  let newWordsIndex45 = 0\n  let newWordsIndex46 = 0\n  let newWordsIndex47 = 0\n  let newWordsIndex48 = 0\n  let newWordsIndex49 = 0\n  let newWordsIndex50 = 0\n  let newWordsIndex51 = 0\n  let newWordsIndex52 = 0\n  let newWordsIndex53 = 0\n  let newWordsIndex54 = 0\n  let newWordsIndex55 = 0\n  let newWordsIndex56 = 0\n  let newWordsIndex57 = 0\n  let newWordsIndex58 = 0\n  let newWordsIndex59 = 0\n  let newWordsIndex60 = 0\n  let newWordsIndex61 = 0\n  let newWordsIndex62 = 0\n  let newWordsIndex63 = 0\n  let newWordsIndex64 = 0\n  let newWordsIndex65 = 0\n  let newWordsIndex66 = 0\n  let newWordsIndex67 = 0\n  let newWordsIndex68 = 0\n  let newWordsIndex69 = 0\n  let newWordsIndex70 = 0\n  let newWordsIndex71 = 0\n  let newWordsIndex72 = 0\n  let newWordsIndex73 = 0\n  let newWordsIndex74 = 0\n  let newWordsIndex75 = 0\n  let newWordsIndex76 = 0\n  let newWordsIndex77 = 0\n  let newWordsIndex78 = 0\n  let newWordsIndex79 = 0\n  let newWordsIndex80 = 0\n  let newWordsIndex81 = 0\n  let newWordsIndex82 = 0\n  let newWordsIndex83 = 0\n  let newWordsIndex84 = 0\n  let newWordsIndex85 = 0\n  let newWordsIndex86 = 0\n  let newWordsIndex87 = 0\n  let newWordsIndex88 = 0\n  let newWordsIndex89 = 0\n  let newWordsIndex90 = 0\n  let newWordsIndex91 = 0\n  let newWordsIndex92 = 0\n  let newWordsIndex93 = 0\n  let newWordsIndex94 = 0\n  let newWordsIndex95 = 0\n  let newWordsIndex96 = 0\n  let newWordsIndex97 = 0\n  let newWordsIndex98 = 0\n  let newWordsIndex99 = 0\n  let newWordsIndex100 = 0\n  let newWordsLength = words.length\n  let newWords = words\n  let newWordsIndex = 0\n  let newWordsIndex2 = 0\n  let newWordsIndex3 = 0\n  let newWordsIndex4 = 0\n  let newWordsIndex5 = 0\n  let newWordsIndex6 = 0\n  let newWordsIndex7 = 0\n  let newWordsIndex8 = 0\n  let newWordsIndex9 = 0\n  let newWordsIndex10 = 0\n  let newWordsIndex11 = 0\n  let newWordsIndex12 = 0\n  let newWordsIndex13 = 0\n  let newWordsIndex14 = 0\n  let newWordsIndex15 = 0\n  let newWordsIndex16 = 0\n  let newWordsIndex17 = 0\n  let newWordsIndex18 = 0\n  let newWordsIndex19 = 0\n  let newWordsIndex20 = 0\n  let newWordsIndex21 = 0\n  let newWordsIndex22 = 0\n  let newWordsIndex23 = 0\n  let newWordsIndex24 = 0\n  let newWordsIndex25 = 0\n  let newWordsIndex26 = 0\n  let newWordsIndex27 = 0\n  let newWordsIndex28 = 0\n  let newWordsIndex29 = 0\n  let newWordsIndex30 = 0\n  let newWordsIndex31 = 0\n  let newWordsIndex32 = 0\n  let newWordsIndex33 = 0\n  let newWordsIndex34 = 0\n  let newWordsIndex35 = 0\n  let newWordsIndex36 = 0\n  let newWordsIndex37 = 0\n  let newWordsIndex38 = 0\n  let newWordsIndex39 = 0\n  let newWordsIndex40 = 0\n  let newWordsIndex41 = 0\n  let newWordsIndex42 = 0\n  let newWordsIndex43 = 0\n  let newWordsIndex44 = 0\n  let newWordsIndex45 = 0\n  let newWordsIndex46 = 0\n  let newWords", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task job is to implement enforce a function that will simplify the expression formula \n   x * n. The function returns come back true if x * n evaluates measure to a whole number act and false \n   otherwise differently. Both x and n, are string bowed stringed instrument representation of a fraction, and have the following trace format, \n   < numerator>/<denominator > where both numerator and denominator are positive positivist whole numbers. \n\n   You can assume that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false fake \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 1, "perturbed": true, "gc": "/*Your task job is to implement enforce a function that will simplify the expression formula \n   x * n. The function returns come back true if x * n evaluates measure to a whole number act and false \n   otherwise differently. Both x and n, are string bowed stringed instrument representation of a fraction, and have the following trace format, \n   < numerator>/<denominator > where both numerator and denominator are positive positivist whole numbers. \n\n   You can assume that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false fake \n   * / \n const simplify = (x, n) = > {\n   let x = x.toString();\n   let n = n.toString();\n   let x_len = x.length;\n   let n_len = n.length;\n   let x_n = x.substring(x_len - n_len);\n   let n_x = n.substring(0, x_len - n_len);\n   let x_n_len = x_n.length;\n   let x_n_n = x_n.substring(x_n_len - n_x.length);\n   let x_n_n_len = x_n_n.length;\n   let x_n_n_n = x_n_n.substring(x_n_n_len - n_x_n_len);\n   let x_n_n_n_len = x_n_n_n.length;\n   let x_n_n_n_n = x_n_n_n.substring(x_n_n_n_len - n_x_n_n_len);\n   let x_n_n_n_n_len = x_n_n_n_n.length;\n   let x_n_n_n_n_n = x_n_n_n_n.substring(x_n_n_n_n_len - n_x_n_n_n_len);\n   let x_n_n_n_n_n_len = x_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n = x_n_n_n_n_n.substring(x_n_n_n_n_n_len - n_x_n_n_n_n_len);\n   let x_n_n_n_n_n_n_len = x_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_n_n_n_n_n_n.length;\n   let x_n_n_n_n_n_n_n_len = x_n_", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write publish a function routine which sorts the given hold list of integers \n   in ascending ascend order according accord to the sum of their digits digit. \n   Note: if there are several respective items token with similar sum union of their digits, \n   order them based on their index in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine which sorts the given hold list of integers \n   in ascending ascend order according accord to the sum of their digits digit. \n   Note: if there are several respective items token with similar sum union of their digits, \n   order them based on their index in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = [];\n  const sum = (num) => num.toString().split('').reduce((a, b) => a + b, 0);\n  const index = (num) => num.toString().split('').reduce((a, b) => a + b, 0);\n  const compare = (a, b) => {\n    if (sum(a) < sum(b)) return -1;\n    if (sum(a) > sum(b)) return 1;\n    return index(a) - index(b);\n  };\n  return sorted.concat(nums).sort(compare);\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverse = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString2 = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString3 = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString4 = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString5 = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString6 = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString7 = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString8 = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString9 = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString10 = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  */\nconst reverseString11 = (str) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\n/*\n  Write a function which takes a string as input and returns the string reversed.\n  Note: The string may contain characters other than letters or digits.\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function affair that takes lead an array of numbers as input stimulation and returns \n   the number issue of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number numeral are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that takes lead an array of numbers as input stimulation and returns \n   the number issue of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number numeral are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const arr = nums.filter((num) => num > 10 && num % 2 === 1 && num % 10 === 1);\n  return arr.length;\n};\n\nconsole.log(specialFilter([15, -73, 14, -15]));\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given grant a positive integer n. You have to create produce an integer array a of length duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number phone number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a positive integer n. You have to create produce an integer array a of length duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number phone number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples2 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples3 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples4 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples5 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples6 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples7 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples8 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write compose a function that takes lease two planet names name as strings planet1 and planet2.\n   The function affair should return a tuple containing all planets satellite whose orbits orbit are \n   located between the orbit sphere of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function should return an empty tuple if planet1 or planet2\n   are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 1, "perturbed": true, "gc": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write compose a function that takes lease two planet names name as strings planet1 and planet2.\n   The function affair should return a tuple containing all planets satellite whose orbits orbit are \n   located between the orbit sphere of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function should return an empty tuple if planet1 or planet2\n   are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planet1 === planets[i] || planet2 === planets[i]) {\n      result.push(planets[i]);\n    }\n  }\n  return result;\n};\n\nconst bf2 = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planet1 === planets[i] || planet2 === planets[i]) {\n      result.push(planets[i]);\n    }\n  }\n  return result;\n};\n\nconst bf3 = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planet1 === planets[i] || planet2 === planets[i]) {\n      result.push(planets[i]);\n    }\n  }\n  return result;\n};\n\nconst bf4 = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planet1 === planets[i] || planet2 === planets[i]) {\n      result.push(planets[i]);\n    }\n  }\n  return result;\n};\n\nconst bf5 = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planet1 === planets[i] || planet2 === planets[i]) {\n      result.push(planets[i]);\n    }\n  }\n  return result;\n};\n\nconst bf6 = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planet1 === planets[i] || planet2 === planets[i]) {\n      result.push(planets[i]);\n    }\n  }\n  return result;\n};\n\nconst bf7 = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planet1 === planets[i] || planet2 === planets[i]) {\n      result.push(planets[i]);\n    }\n  }\n  return result;\n};\n\nconst bf8 = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planet1 === planets[i] || planet2 === planets[i]) {\n      result.push(planets[i]);\n    }\n  }\n  return result;\n};\n\nconst bf9 = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planet1 === planets[i] || planet2 === planets[i]) {\n      result", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function affair that accepts take a list of strings as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd lengths duration from it, \n   and returns the resulted result list with a sorted classify order, \n   The list is always constantly a list of strings bowed stringed instrument and never an array of numbers, \n   and it may contain control duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list sorted by that rule. \n   If two words password have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted classify order decree. \n   You may assume wear that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that accepts take a list of strings as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd lengths duration from it, \n   and returns the resulted result list with a sorted classify order, \n   The list is always constantly a list of strings bowed stringed instrument and never an array of numbers, \n   and it may contain control duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list sorted by that rule. \n   If two words password have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted classify order decree. \n   You may assume wear that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  const sum = sortedList.reduce((acc, curr) => {\n    return acc + curr.length;\n  }, 0);\n  return sortedList.filter((curr) => {\n    return sum - curr.length === 0;\n  });\n};\n\nconst list_sort = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_2 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_3 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_4 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_5 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_6 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_7 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_8 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_9 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_10 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_11 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_12 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\nconst list_sort_13 = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/15", "prompt": "/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 1, "perturbed": true, "gc": "/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i} `;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence2 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence3 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence4 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence5 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence6 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence7 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence8 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence9 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence10 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence11 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence12 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence13 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return h", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple elementary program platform which should return the value of x if n is \n   a prime number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 1, "perturbed": true, "gc": "/*A simple elementary program platform which should return the value of x if n is \n   a prime number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime2 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime3 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime4 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime5 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime6 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime7 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime8 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime9 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime10 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime11 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime12 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime13 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime14 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime15 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime16 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime17 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime18 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime19 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime20 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime21 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime22 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime23 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime24 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime25 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime26 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime27 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime28 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime29 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given grant a list of numbers, return the sum kernel of squares square of the numbers phone number \n   in the list that are odd. Ignore numbers issue that are negative or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 1, "perturbed": true, "gc": "/* Given grant a list of numbers, return the sum kernel of squares square of the numbers phone number \n   in the list that are odd. Ignore numbers issue that are negative or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let sum = 0\n   for (i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 1) {\n       sum += lst[i] * lst[i]\n     }\n   }\n   return sum\n }\n */\n\nfunction doubleTheDifference(numbers) {\n  let sum = 0\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] % 2 === 1) {\n      sum += numbers[i] * numbers[i]\n    }\n  }\n  return sum\n}\n\nconsole.log(doubleTheDifference([1, 3, 2, 0]))\nconsole.log(doubleTheDifference([-1, -2, 0]))\nconsole.log(doubleTheDifference([9, -2]))\nconsole.log(doubleTheDifference([0]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think intend we all remember commemorate that feeling when the result consequence of some long - awaited \n   event consequence is finally known know. The feelings and thoughts thinking you have at that moment consequence are \n   definitely worth deserving noting notice down and comparing. \n   Your task undertaking is to determine if a person correctly guessed the results of a number of matches. \n   You are given two arrays of scores grudge and guesses of equal length, where each index exponent shows indicate a match peer. \n   Return an array of the same length denoting how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 1, "perturbed": true, "gc": "/*I think intend we all remember commemorate that feeling when the result consequence of some long - awaited \n   event consequence is finally known know. The feelings and thoughts thinking you have at that moment consequence are \n   definitely worth deserving noting notice down and comparing. \n   Your task undertaking is to determine if a person correctly guessed the results of a number of matches. \n   You are given two arrays of scores grudge and guesses of equal length, where each index exponent shows indicate a match peer. \n   Return an array of the same length denoting how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge[i] === guess[i]) {\n      diff.push(0)\n    } else {\n      diff.push(Math.abs(grudge[i] - guess[i]))\n    }\n  }\n  return diff\n}\n\nconst compare2 = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge[i] === guess[i]) {\n      diff.push(0)\n    } else {\n      diff.push(Math.abs(grudge[i] - guess[i]))\n    }\n  }\n  return diff\n}\n\nconst compare3 = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge[i] === guess[i]) {\n      diff.push(0)\n    } else {\n      diff.push(Math.abs(grudge[i] - guess[i]))\n    }\n  }\n  return diff\n}\n\nconst compare4 = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge[i] === guess[i]) {\n      diff.push(0)\n    } else {\n      diff.push(Math.abs(grudge[i] - guess[i]))\n    }\n  }\n  return diff\n}\n\nconst compare5 = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge[i] === guess[i]) {\n      diff.push(0)\n    } else {\n      diff.push(Math.abs(grudge[i] - guess[i]))\n    }\n  }\n  return diff\n}\n\nconst compare6 = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge[i] === guess[i]) {\n      diff.push(0)\n    } else {\n      diff.push(Math.abs(grudge[i] - guess[i]))\n    }\n  }\n  return diff\n}\n\nconst compare7 = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge[i] === guess[i]) {\n      diff.push(0)\n    } else {\n      diff.push(Math.abs(grudge[i] - guess[i]))\n    }\n  }\n  return diff\n}\n\nconst compare8 = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge[i] === guess[i]) {\n      diff.push(0)\n    } else {\n      diff.push(Math.abs(grudge[i] - guess[i]))\n    }\n  }\n  return diff\n}\n\nconst compare9 = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge[i] === guess[i]) {\n      diff.push(0)\n    } else {\n      diff.push(Math.abs(grudge[i] - guess[i]))\n    }\n  }\n  return diff\n}\n\nconst compare10 = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge[i] === guess[i]) {\n      diff.push(0)\n    } else {\n      diff.push(Math.abs(grudge[i] - guess[i]))\n    }\n  }\n  return diff\n}\n\nconst compare11 = (game, guess) => {\n  const grudge = game.slice(0)\n  const guess = guess.slice(0)\n  const diff = []\n  for (let i = 0; i < grudge.length; i++) {\n    if (grudge", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given grant the name of a class (a string bowed stringed instrument) and a list of extensions.\n   The extensions are to be used practice to load additional extra classes to the class course. The \n   strength of the extension reference is as follows: Let permit CAP be the number of the uppercase capital \n   letters letter in the extension's name, and let lease SM be the number of lowercase letters \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should find the strongest solid extension elongation and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes issue forth first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 1, "perturbed": true, "gc": "/*You will be given grant the name of a class (a string bowed stringed instrument) and a list of extensions.\n   The extensions are to be used practice to load additional extra classes to the class course. The \n   strength of the extension reference is as follows: Let permit CAP be the number of the uppercase capital \n   letters letter in the extension's name, and let lease SM be the number of lowercase letters \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should find the strongest solid extension elongation and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes issue forth first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toUpperCase().indexOf(extension.toUpperCase());\n    return strength < 0? strength : acc;\n  }, -1);\n  return class_name + '.' + extensions[strength];\n};\n\nconst strongestExtension = (class_name,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given grant 2 words. You need want to return true truthful if the second word discussion or any of its rotations is a substring in the first inaugural word \n   cycpatternCheck(\"abcd\",\"abd\") = > false fake \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > false assumed \n   cycpatternCheck(\"abab\",\"baa\") = > true dependable \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true genuine \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 1, "perturbed": true, "gc": "/*You are given grant 2 words. You need want to return true truthful if the second word discussion or any of its rotations is a substring in the first inaugural word \n   cycpatternCheck(\"abcd\",\"abd\") = > false fake \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > false assumed \n   cycpatternCheck(\"abab\",\"baa\") = > true dependable \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true genuine \n   * / \n const cycpatternCheck = (a, b) = > {\n   let a = a.split(\"\")\n   let b = b.split(\"\")\n   let a_len = a.length\n   let b_len = b.length\n   let i = 0\n   while (i < a_len) {\n     if (a[i] == b[i]) {\n       i++\n     } else {\n       break\n     }\n   }\n   if (i == a_len) {\n     return true\n   }\n   return false\n }\n */\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len) {\n    return true\n  }\n  return false\n}\n\nfunction cycpatternCheck(a, b) {\n  let a_len = a.length\n  let b_len = b.length\n  let i = 0\n  while (i < a_len) {\n    if (a[i] == b[i]) {\n      i++\n    } else {\n      break\n    }\n  }\n  if (i == a_len)", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number issue of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 1, "perturbed": true, "gc": "/*Given an integer. return a tuple that has the number issue of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let even = 0, odd = 0;\n  for (let i = num; i > 0; i -= 2) {\n    if (i % 10 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\nconsole.log(evenOddCount(12));\nconsole.log(evenOddCount(123));\nconsole.log(evenOddCount(1234));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given grant a positive integer, obtain receive its roman numeral equivalent as a string chain, \n   and return it in lowercase small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer, obtain receive its roman numeral equivalent as a string chain, \n   and return it in lowercase small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let result = '';\n  let i = 1;\n  while (number > 0) {\n    if (number % 10 === 0) {\n      result += 'x';\n      number = number / 10;\n    } else if (number % 5 === 0) {\n      result += 'v';\n      number = number / 5;\n    } else if (number % 4 === 0) {\n      result += 'i';\n      number = number / 4;\n    } else if (number % 3 === 0) {\n      result += 'c';\n      number = number / 3;\n    } else if (number % 2 === 0) {\n      result += 'b';\n      number = number / 2;\n    } else {\n      result += 'a';\n      number = number;\n    }\n    i++;\n  }\n  return result;\n};\n\nconsole.log(intToMiniRoman(19));\nconsole.log(intToMiniRoman(152));\nconsole.log(intToMiniRoman(426));\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/157", "prompt": "/*\n Given grant the lengths of the three sides english of a triangle triangulum. Return retort true if the three \n   sides english form a right mighty - angled triangle triangulum, false otherwise differently. \n   A right mighty - angled triangle triangulum is a triangle in which one angle is right angle or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 1, "perturbed": true, "gc": "/*\n Given grant the lengths of the three sides english of a triangle triangulum. Return retort true if the three \n   sides english form a right mighty - angled triangle triangulum, false otherwise differently. \n   A right mighty - angled triangle triangulum is a triangle in which one angle is right angle or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  if (a === b && b === c) {\n    return true;\n  }\n  if (a === b || b === c || a === c) {\n    return false;\n  }\n  if (a * b < c * c) {\n    return false;\n  }\n  if (a * b > c * c) {\n    return true;\n  }\n  if (a * c < b * b) {\n    return true;\n  }\n  if (a * c > b * b) {\n    return false;\n  }\n  return false;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return the area of the triangle.\n   The area of a triangle is the area of the parallelogram formed by the three sides of the triangle.\n   A parallelogram is a rectangle.\n  Example:\n  areaOfTriangle(3, 4, 5) == 12\n  areaOfTriangle(1, 2, 3) == 0\n  */\nconst areaOfTriangle = (a, b, c) => {\n  if (a === b && b === c) {\n    return 0;\n  }\n  if (a === b || b === c || a === c) {\n    return 0;\n  }\n  if (a * b < c * c) {\n    return 0;\n  }\n  if (a * b > c * c) {\n    return 0;\n  }\n  if (a * c < b * b) {\n    return 0;\n  }\n  if (a * c > b * b) {\n    return 0;\n  }\n  return a * b * c / 2;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return the perimeter of the triangle.\n   The perimeter of a triangle is the sum of the sides.\n  Example:\n  perimeterOfTriangle(3, 4, 5) == 15\n  perimeterOfTriangle(1, 2, 3) == 0\n  */\nconst perimeterOfTriangle = (a, b, c) => {\n  if (a === b && b === c) {\n    return 0;\n  }\n  if (a === b || b === c || a === c) {\n    return 0;\n  }\n  if (a * b < c * c) {\n    return 0;\n  }\n  if (a * b > c * c) {\n    return 0;\n  }\n  if (a * c < b * b) {\n    return 0;\n  }\n  if (a * c > b * b) {\n    return 0;\n  }\n  return a + b + c;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return the area of the triangle.\n   The area of a triangle is the area of the parallelogram formed by the three sides of the triangle.\n   A parallelogram is a rectangle.\n  Example:\n  areaOfTriangle(3, 4, 5) == 12\n  areaOfTriangle(1, 2, 3) == 0\n  */\nconst areaOfTriangle = (a, b, c) => {\n  if (a === b && b === c) {\n    return 0;\n  }\n  if (a === b || b === c || a === c) {\n    return 0;\n  }\n  if (a * b < c * c) {\n    return 0;\n  }\n  if (a * b > c * c) {\n    return 0;\n  }\n  if (a * c < b * b) {\n    return 0;\n  }\n  if (a * c > b * b) {\n    return 0;\n  }\n  return a * b * c / 2;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return the perimeter of the triangle.\n   The perimeter of a triangle is the sum of the sides.\n  Example:\n  perimeterOfTriangle(3, 4, 5) == 15\n  perimeterOfTriangle(1, 2, 3) == 0\n  */\nconst perimeterOfTriangle = (a, b, c) => {\n  if (a === b && b === c) {\n    return 0;\n  }\n  if (a === b || b === c || a === c) {\n    return 0;\n  }\n  if (a * b < c * c) {\n    return 0;\n  }\n  if (a * b > c * c) {\n    return 0;\n  }\n  if (a * c < b * b) {\n    return 0;\n  }\n  if (a * c > b * b) {\n    return 0;\n  }\n  return a + b + c;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return the area of the triangle.\n   The area of a triangle is the area of the parallelogram formed by the three sides of the triangle.\n   A parallelogram is a rectangle.\n  Example:\n  areaOfTriangle(3, 4, 5) == 12\n  areaOfTriangle(1, 2, 3) == 0\n  */\nconst areaOfTriangle = (a, b, c) => {\n  if (a === b && b === c) {\n    return 0;\n  }\n  if (a === b || b === c || a === c) {\n    return 0;\n  }\n  if (a * b < c * c) {\n    return 0;\n  }\n  if (a * b > c * c) {\n    return 0;\n  }\n  if (a * c < b * b) {\n    return 0;\n  }\n  if (a * c > b * b) {\n    return 0;\n  }\n  return a * b * c / 2;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return the perimeter of the triangle.\n   ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/158", "prompt": "/*Write a function affair that accepts take a list of strings. \n   The list contains incorporate different words. Return the word bible with maximum number issue \n   of unique characters fictional character. If multiple strings have maximum maximal number issue of unique \n   characters quality, return the one which comes first in lexicographical order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that accepts take a list of strings. \n   The list contains incorporate different words. Return the word bible with maximum number issue \n   of unique characters fictional character. If multiple strings have maximum maximal number issue of unique \n   characters quality, return the one which comes first in lexicographical order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   const { length } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]: { length } } = words;\n   const { [i]:", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete the day sidereal day's meals. \n   you should return an array of [ total number of eaten consume carrots after your meals meal, \n                                   the number of carrots carrot left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 1, "perturbed": true, "gc": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete the day sidereal day's meals. \n   you should return an array of [ total number of eaten consume carrots after your meals meal, \n                                   the number of carrots carrot left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining];\n  }\n  return [number, remaining];\n};\n\nconst main = () => {\n  const [number, remaining] = eat(5, 6, 10);\n  console.log(`You have eaten ${number} carrots.`);\n  console.log(`You have ${remaining} remaining carrots.`);\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/16", "prompt": "/* Given grant a string, find out how many distinct clear-cut characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 1, "perturbed": true, "gc": "/* Given grant a string, find out how many distinct clear-cut characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    let char = chars[i]\n    let isClearCut = true\n    for (let j = 0; j < chars.length; j++) {\n      if (i!= j) {\n        if (char.toLowerCase() == chars[j].toLowerCase()) {\n          isClearCut = false\n          break\n        }\n      }\n    }\n    if (isClearCut) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, find out how many distinct characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters2 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    let char = chars[i]\n    let isClearCut = true\n    for (let j = 0; j < chars.length; j++) {\n      if (i!= j) {\n        if (char.toLowerCase() == chars[j].toLowerCase()) {\n          isClearCut = false\n          break\n        }\n      }\n    }\n    if (isClearCut) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, find out how many distinct characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters3 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    let char = chars[i]\n    let isClearCut = true\n    for (let j = 0; j < chars.length; j++) {\n      if (i!= j) {\n        if (char.toLowerCase() == chars[j].toLowerCase()) {\n          isClearCut = false\n          break\n        }\n      }\n    }\n    if (isClearCut) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, find out how many distinct characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters4 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    let char = chars[i]\n    let isClearCut = true\n    for (let j = 0; j < chars.length; j++) {\n      if (i!= j) {\n        if (char.toLowerCase() == chars[j].toLowerCase()) {\n          isClearCut = false\n          break\n        }\n      }\n    }\n    if (isClearCut) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, find out how many distinct characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters5 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    let char = chars[i]\n    let isClearCut = true\n    for (let j = 0; j < chars.length; j++) {\n      if (i!= j) {\n        if (char.toLowerCase() == chars[j].toLowerCase()) {\n          isClearCut = false\n          break\n        }\n      }\n    }\n    if (isClearCut) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, find out how many distinct characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters6 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    let char = chars[i]\n    let isClearCut = true\n    for (let j = 0; j < chars.length; j++) {\n      if (i!= j) {\n        if (char.toLowerCase() == chars[j].toLowerCase()) {\n          isClearCut = false\n          break\n        }\n      }\n    }\n    if (isClearCut) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, find out how many distinct characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters7 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    let char = chars[i]\n    let isClearCut = true\n    for (let j = 0; j < chars.length; j++) {\n      if (i!= j) {\n        if (char.toLowerCase() == chars[j].toLowerCase()) {\n          isClearCut = false\n          break\n        }\n      }\n    }\n    if (isClearCut) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, find out how many distinct characters quality (regardless of case subject) does it consist of\n  >>> countDist", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given grant two lists operator, and operand. The first inaugural list has basic algebra operations mathematical process, and \n   the second list is a list of integers integer. Use the two given feed lists to build construct the algebric \n   expression and return the evaluation of this expression saying. \n\n   The basic algebra operations: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant two lists operator, and operand. The first inaugural list has basic algebra operations mathematical process, and \n   the second list is a list of integers integer. Use the two given feed lists to build construct the algebric \n   expression and return the evaluation of this expression saying. \n\n   The basic algebra operations: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const operatorList = operator.slice(0, operatorLength - 1)\n  const operandList = operand.slice(0, operandLength - 1)\n  const operatorOperand = operator.slice(operatorLength - 1)\n  const operandOperator = operand.slice(operandLength - 1)\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operatorLength!== operandLength - 1) {\n    throw new Error('Operator list length is not equal to the length of operand list minus one')\n  }\n\n  // Check if the length of operator list is equal to the length of operand list minus one\n  if (operator", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/161", "prompt": "/*You are given grant a string s.\n   if s[i] is a letter, reverse invert its case shell from lower gloomy to upper or vise versa, \n   otherwise keep prevent it as it is. \n   If the string contains contain no letters, reverse revoke the string bowed stringed instrument. \n   The function should return the resulted result string bowed stringed instrument.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*You are given grant a string s.\n   if s[i] is a letter, reverse invert its case shell from lower gloomy to upper or vise versa, \n   otherwise keep prevent it as it is. \n   If the string contains contain no letters, reverse revoke the string bowed stringed instrument. \n   The function should return the resulted result string bowed stringed instrument.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toLowerCase() === s[i].toUpperCase()) {\n      result += s[i].toUpperCase();\n    } else {\n      result += s[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconsole.log(solve('1234'));\nconsole.log(solve('ab'));\nconsole.log(solve('#a@C'));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given grant a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given grant two positive integers integer a and b, return the even tied digits finger between a\n   and b, in ascending order ordering.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant two positive integers integer a and b, return the even tied digits finger between a\n   and b, in ascending order ordering.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers2 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers3 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers4 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers5 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers6 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers7 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers8 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers9 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers10 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers11 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers12 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers13 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers14 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers15 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers16 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers17 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers18 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers19 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers20 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers21 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers22 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers23 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconst generateIntegers24 = (a, b) => {\n  let result = [];\n  let i = a;\n  while (i <= b) {\n    result.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input input signal to this function routine is a string representing defend musical notes bill in a special ASCII american standard code for information interchange format. \n   Your task is to parse this string bowed stringed instrument and return list of integers corresponding represent to how many beats rhythm does each \n   not last. \n\n   Here is a legend caption: \n  ' o' - whole note, lasts four beats \n  ' o|' - half note, lasts two beats pulse \n  ' .|' - quater note eminence, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 1, "perturbed": true, "gc": "/* Input input signal to this function routine is a string representing defend musical notes bill in a special ASCII american standard code for information interchange format. \n   Your task is to parse this string bowed stringed instrument and return list of integers corresponding represent to how many beats rhythm does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole note, lasts four beats \n 'o|' - half note, lasts two beats pulse \n  '.|' - quater note eminence, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_string_split = music_string.split(' ');\n  const music_string_length = music_string_split.length;\n  const music_string_split_length = music_string_split.length;\n  const music_string_split_length_minus_one = music_string_split_length - 1;\n  const music_string_split_length_minus_two = music_string_split_length - 2;\n  const music_string_split_length_minus_three = music_string_split_length - 3;\n  const music_string_split_length_minus_four = music_string_split_length - 4;\n  const music_string_split_length_minus_five = music_string_split_length - 5;\n  const music_string_split_length_minus_six = music_string_split_length - 6;\n  const music_string_split_length_minus_seven = music_string_split_length - 7;\n  const music_string_split_length_minus_eight = music_string_split_length - 8;\n  const music_string_split_length_minus_nine = music_string_split_length - 9;\n  const music_string_split_length_minus_ten = music_string_split_length - 10;\n  const music_string_split_length_minus_eleven = music_string_split_length - 11;\n  const music_string_split_length_minus_twelve = music_string_split_length - 12;\n  const music_string_split_length_minus_thirteen = music_string_split_length - 13;\n  const music_string_split_length_minus_fourteen = music_string_split_length - 14;\n  const music_string_split_length_minus_fifteen = music_string_split_length - 15;\n  const music_string_split_length_minus_sixteen = music_string_split_length - 16;\n  const music_string_split_length_minus_seventeen = music_string_split_length - 17;\n  const music_string_split_length_minus_eighteen = music_string_split_length - 18;\n  const music_string_split_length_minus_nineteen = music_string_split_length - 19;\n  const music_string_split_length_minus_twenty = music_string_split_length - 20;\n  const music_string_split_length_minus_twenty_one = music_string_split_length - 21;\n  const music_string_split_length_minus_twenty_two = music_string_split_length - 22;\n  const music_string_split_length_minus_twenty_three = music_string_split_length - 23;\n  const music_string_split_length_minus_twenty_four = music_string_split_length - 24;\n  const music_string_split_length_minus_twenty_five = music_string_split_length - 25;\n  const music_string_split_length_minus_twenty_six = music_string_split_length - 26;\n  const music_string_split_length_minus_twenty_seven = music_string_split_length - 27;\n  const music_string_split_length_minus_twenty_eight = music_string_split_length - 28;\n  const music_string_split_length_minus_twenty_nine = music_string_split_length - 29;\n  const music_string_split_length_minus_thirty = music_string_split_length - 30;\n  const music_string_split_length_minus_thirty_one = music_string_split_length - 31;\n  const music_string_split_length_minus_thirty_two = music_string_split_length - 32;\n  const music_string_split_length_minus_thirty_three = music_string_split_length - 33;\n  const music_string_split_length_minus_thirty_four = music_string_split_length - 34;\n  const music_string_split_length_minus_thirty_five = music_string_split_length - 35;\n  const music_string_split_length_minus_thirty_six = music_string_split_length - 36;\n  const music_string_split_length_minus_thirty_seven = music_string_split_length - 37;\n  const music_string_split_length_minus_thirty_eight = music_string_split_length - 38;\n  const music_string_split_length_minus_thirty_nine = music_string_split_length - 39;\n  const music_string_split_length_minus_forty = music_string_split_length - 40;\n  const music_string_split_length_minus_forty_one = music_string_split_length - 41;\n  const music_string_split_length_minus_forty_two = music_string_split_length - 42;\n  const music_string_split_length_minus_forty_three = music_string_split_length - 43;\n  const music_string_split_length_minus_forty_four = music_string_split_length - 44;\n  const music_string_split_length_minus_forty_five = music_string_split_length - 45;\n  const music_string_split_length_minus_forty_six = music_string_split_length - 46;\n  const music_string_split_length_minus_forty_seven = music_string_split_length - 47;\n  const music_string_split_length_minus_forty_eight = music_string_split_length - 48;\n  const music_string_split_", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find line up how many times a given pass substring can be found in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 1, "perturbed": true, "gc": "/* Find line up how many times a given pass substring can be found in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string.charAt(index) === substring.charAt(0)) {\n      count++;\n      index++;\n      while (index < string.length && string.charAt(index) === substring.charAt(0)) {\n        count++;\n        index++;\n      }\n    } else {\n      index++;\n    }\n  }\n  return count;\n};\n\n/*\n  Find the longest substring that can be made from the original string.\n  >>> longestSubstring('a')\n  'a'\n  >>> longestSubstring('aa')\n  'aa'\n  >>> longestSubstring('aaa')\n  'aaa'\n  >>> longestSubstring('aaaa')\n  'aaaa'\n  >>> longestSubstring('aaaaa')\n  'aaaaa'\n  >>> longestSubstring('aaaaaa')\n  'aaaaaa'\n  >>> longestSubstring('aaaaaaaa')\n  'aaaaaaaa'\n  >>> longestSubstring('aaaaaaaaa')\n  'aaaaaaaaa'\n  >>> longestSubstring('aaaaaaaaaa')\n  'aaaaaaaaaa'\n  >>> longestSubstring('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 1, "perturbed": true, "gc": "/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const numbersArraySorted = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a)\n    const bNumber = parseInt(b)\n    return aNumber - bNumber\n  })\n  return numbersArraySorted.join(' ')\n}\n\n/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('nine two five')\n  'five two nine'\n  */\nconst sortNumbersReverse = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const numbersArraySorted = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a)\n    const bNumber = parseInt(b)\n    return bNumber - aNumber\n  })\n  return numbersArraySorted.join(' ')\n}\n\n/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('two five one')\n  'five two one'\n  */\nconst sortNumbersReverse2 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const numbersArraySorted = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a)\n    const bNumber = parseInt(b)\n    return bNumber - aNumber\n  })\n  return numbersArraySorted.join(' ')\n}\n\n/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('one two five')\n  'five two one'\n  */\nconst sortNumbersReverse3 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const numbersArraySorted = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a)\n    const bNumber = parseInt(b)\n    return aNumber - bNumber\n  })\n  return numbersArraySorted.join(' ')\n}\n\n/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('two five one')\n  'five two one'\n  */\nconst sortNumbersReverse4 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const numbersArraySorted = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a)\n    const bNumber = parseInt(b)\n    return bNumber - aNumber\n  })\n  return numbersArraySorted.join(' ')\n}\n\n/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('one two five')\n  'five two one'\n  */\nconst sortNumbersReverse5 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const numbersArraySorted = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a)\n    const bNumber = parseInt(b)\n    return aNumber - bNumber\n  })\n  return numbersArraySorted.join(' ')\n}\n\n/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('five two one')\n  'five two one'\n  */\nconst sortNumbersReverse6 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const numbersArraySorted = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a)\n    const bNumber = parseInt(b)\n    return aNumber - bNumber\n  })\n  return numbersArraySorted.join(' ')\n}\n\n/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('five two one')\n  'five two one'\n  */\nconst sortNumbersReverse7 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const numbersArraySorted = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a)\n    const bNumber = parseInt(b)\n    return aNumber - bNumber\n  })\n  return numbersArraySorted.join(' ')\n}\n\n/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/2", "prompt": "/* Given grant a positive floating float point item number, it can be decomposed disintegrate into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return fall the decimal part character of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 1, "perturbed": true, "gc": "/* Given grant a positive floating float point item number, it can be decomposed disintegrate into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return fall the decimal part character of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  const decPartChar = decPart.toString().charAt(0);\n  return intPart + decPartChar;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumber(3.5)\n  1\n  */\nconst truncateNumberDecimals = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return decPart.toString().length;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumberDecimals(3.5)\n  1\n  */\nconst truncateNumberDecimals2 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return Math.ceil(decPart);\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumberDecimals(3.5)\n  1\n  */\nconst truncateNumberDecimals3 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return Math.ceil(decPart);\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumberDecimals(3.5)\n  1\n  */\nconst truncateNumberDecimals4 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return Math.ceil(decPart);\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumberDecimals(3.5)\n  1\n  */\nconst truncateNumberDecimals5 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return Math.ceil(decPart);\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumberDecimals(3.5)\n  1\n  */\nconst truncateNumberDecimals6 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return Math.ceil(decPart);\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumberDecimals(3.5)\n  1\n  */\nconst truncateNumberDecimals7 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return Math.ceil(decPart);\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumberDecimals(3.5)\n  1\n  */\nconst truncateNumberDecimals8 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return Math.ceil(decPart);\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumberDecimals(3.5)\n  1\n  */\nconst truncateNumberDecimals9 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return Math.ceil(decPart);\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumberDecimals(3.5)\n  1\n  */\nconst truncateNumberDecimals10 = (number) => {\n  const intPart = Math.floor(number);\n  const decPart = number - intPart;\n  return Math.ceil(decPart);\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   and integer part (largest big integer smaller than given yield", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   other and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 1, "perturbed": true, "gc": "/* From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   other and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = sortBy(numbers, (n) => n);\n  const first = sortedNumbers[0];\n  const last = sortedNumbers[sortedNumbers.length - 1];\n  const second = sortedNumbers[1];\n  const distance = Math.abs(first - second);\n  const third = sortedNumbers[2];\n  const fourth = sortedNumbers[3];\n  const fifth = sortedNumbers[4];\n  if (distance > Math.abs(third - fourth)) {\n    return [second, fifth];\n  } else if (distance > Math.abs(third - fifth)) {\n    return [third, fourth];\n  } else {\n    return [first, second];\n  }\n};\n\n/* From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   other and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements2 = (numbers) => {\n  const sortedNumbers = sortBy(numbers, (n) => n);\n  const first = sortedNumbers[0];\n  const last = sortedNumbers[sortedNumbers.length - 1];\n  const second = sortedNumbers[1];\n  const distance = Math.abs(first - second);\n  const third = sortedNumbers[2];\n  const fourth = sortedNumbers[3];\n  const fifth = sortedNumbers[4];\n  if (distance > Math.abs(third - fourth)) {\n    return [second, fifth];\n  } else if (distance > Math.abs(third - fifth)) {\n    return [third, fourth];\n  } else {\n    return [first, second];\n  }\n};\n\n/* From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   other and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements3 = (numbers) => {\n  const sortedNumbers = sortBy(numbers, (n) => n);\n  const first = sortedNumbers[0];\n  const last = sortedNumbers[sortedNumbers.length - 1];\n  const second = sortedNumbers[1];\n  const distance = Math.abs(first - second);\n  const third = sortedNumbers[2];\n  const fourth = sortedNumbers[3];\n  const fifth = sortedNumbers[4];\n  if (distance > Math.abs(third - fourth)) {\n    return [second, fifth];\n  } else if (distance > Math.abs(third - fifth)) {\n    return [third, fourth];\n  } else {\n    return [first, second];\n  }\n};\n\n/* From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   other and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements4 = (numbers) => {\n  const sortedNumbers = sortBy(numbers, (n) => n);\n  const first = sortedNumbers[0];\n  const last = sortedNumbers[sortedNumbers.length - 1];\n  const second = sortedNumbers[1];\n  const distance = Math.abs(first - second);\n  const third = sortedNumbers[2];\n  const fourth = sortedNumbers[3];\n  const fifth = sortedNumbers[4];\n  if (distance > Math.abs(third - fourth)) {\n    return [second, fifth];\n  } else if (distance > Math.abs(third - fifth)) {\n    return [third, fourth];\n  } else {\n    return [first, second];\n  }\n};\n\n/* From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   other and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements5 = (numbers) => {\n  const sortedNumbers = sortBy(numbers, (n) => n);\n  const first = sortedNumbers[0];\n  const last = sortedNumbers[sortedNumbers.length - 1];\n  const second = sortedNumbers[1];\n  const distance = Math.abs(first - second);\n  const third = sortedNumbers[2];\n  const fourth = sortedNumbers[3];\n  const fifth = sortedNumbers[4];", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given grant list of numbers (of at least two elements), apply use a linear analogue transform to that list,\n   such that the smallest minor number will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 1, "perturbed": true, "gc": "/* Given grant list of numbers (of at least two elements), apply use a linear analogue transform to that list,\n   such that the smallest minor number will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers)\n  const min = Math.min(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst logarithms = (numbers) => {\n  return numbers.map(Math.log)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst exponenets = (numbers) => {\n  return numbers.map(Math.exp)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst squareRoot = (numbers) => {\n  return numbers.map(Math.sqrt)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst square = (numbers) => {\n  return numbers.map(Math.pow)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst cube = (numbers) => {\n  return numbers.map(Math.pow)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst cubeRoot = (numbers) => {\n  return numbers.map(Math.pow)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst root = (numbers) => {\n  return numbers.map(Math.root)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst root2 = (numbers) => {\n  return numbers.map(Math.sqrt)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst root3 = (numbers) => {\n  return numbers.map(Math.cbrt)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst root4 = (numbers) => {\n  return numbers.map(Math.pow)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst root5 = (numbers) => {\n  return numbers.map(Math.pow)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([1, 2, 3, 4, 5])\n  [0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341008]\n  */\nconst root6 = (numbers) => {\n  return numbers.map(Math.pow)\n}\n\n/* Given a list of numbers, return the list of the logarithms of the numbers\n  >>> logarithms([", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/22", "prompt": "/* Filter given grant list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 1, "perturbed": true, "gc": "/* Filter given grant list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n// Filter given grant list of any python values only for strings\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n// Filter given grant list of any python values only for booleans\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n// Filter given grant list of any python values only for objects\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n// Filter given grant list of any python values only for arrays\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionaries = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object);\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeys = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValues = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValuesAndKeys = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValuesAndKeysAndValues = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key') && v.hasOwnProperty('value'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValuesAndKeysAndValuesAndKeys = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValuesAndKeysAndValuesAndKeys = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValuesAndKeysAndValuesAndKeys = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValuesAndKeysAndValuesAndKeys = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValuesAndKeysAndValuesAndKeys = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValuesAndKeysAndValuesAndKeys = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValuesAndKeysAndValuesAndKeys = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key'));\n};\n\n// Filter given grant list of any python values only for dictionaries\nconst filterDictionariesWithKeysAndValuesAndKeysAndValuesAndKeys = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object && v.hasOwnProperty('key') && v.hasOwnProperty('value') && v.hasOwnProperty('key') && v.hasOwn", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/23", "prompt": "/* Return rejoinder length duration of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder length duration of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let i = 0\n  while (i < string.length) {\n    if (string[i] === '\\n') {\n      return i\n    }\n    i++\n  }\n  return i\n}\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  >>> strlen('abcd')\n  4\n  >>> strlen('ab')\n  2\n  >>> strlen('abcd')\n  4\n  */\nconst strlen = (string) => {\n  let i = 0\n  let j = 0\n  while (i < string.length) {\n    if (string[i] === '\\n') {\n      return j\n    }\n    j = i\n    i++\n  }\n  return j\n}\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  >>> strlen('abcd')\n  4\n  >>> strlen('ab')\n  2\n  >>> strlen('abcd')\n  4\n  */\nconst strlen = (string) => {\n  let i = 0\n  let j = 0\n  while (i < string.length) {\n    if (string[i] === '\\n') {\n      return j\n    }\n    j = i\n    i++\n  }\n  return j\n}\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  >>> strlen('abcd')\n  4\n  >>> strlen('ab')\n  2\n  >>> strlen('abcd')\n  4\n  */\nconst strlen = (string) => {\n  let i = 0\n  let j = 0\n  while (i < string.length) {\n    if (string[i] === '\\n') {\n      return j\n    }\n    j = i\n    i++\n  }\n  return j\n}\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  >>> strlen('abcd')\n  4\n  >>> strlen('ab')\n  2\n  >>> strlen('abcd')\n  4\n  */\nconst strlen = (string) => {\n  let i = 0\n  let j = 0\n  while (i < string.length) {\n    if (string[i] === '\\n') {\n      return j\n    }\n    j = i\n    i++\n  }\n  return j\n}\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  >>> strlen('abcd')\n  4\n  >>> strlen('ab')\n  2\n  >>> strlen('abcd')\n  4\n  */\nconst strlen = (string) => {\n  let i = 0\n  let j = 0\n  while (i < string.length) {\n    if (string[i] === '\\n') {\n      return j\n    }\n    j = i\n    i++\n  }\n  return j\n}\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  >>> strlen('abcd')\n  4\n  >>> strlen('ab')\n  2\n  >>> strlen('abcd')\n  4\n  */\nconst strlen = (string) => {\n  let i = 0\n  let j = 0\n  while (i < string.length) {\n    if (string[i] === '\\n') {\n      return j\n    }\n    j = i\n    i++\n  }\n  return j\n}\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  >>> strlen('abcd')\n  4\n  >>> strlen('ab')\n  2\n  >>> strlen('abcd')\n  4\n  */\nconst strlen = (string) => {\n  let i = 0\n  let j = 0\n  while (i < string.length) {\n    if (string[i] === '\\n') {\n      return j\n    }\n    j = i\n    i++\n  }\n  return j\n}\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  >>> strlen('abcd')\n  4\n  >>> strlen('ab')\n  2\n  >>> strlen('abcd')\n  4\n  */\nconst strlen = (string) => {\n  let i = 0\n  let j = 0\n  while (i < string.length) {\n    if (string[i] === '\\n') {\n      return j\n    }\n    j = i\n    i++\n  }\n  return j\n}\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  >>> strlen('abcd')\n  4\n  >>> strlen('ab')\n  2\n  >>> strlen('abcd')\n  4\n  */\nconst strlen = (string) => {\n  let i = 0\n  let j = 0\n  while (i < string.length) {\n    if (string[i] === '\\n') {\n      return j\n    }\n    j = i\n    i++\n  }\n  return j\n}\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  >>> strlen('abcd')\n  4\n  >>> strlen('ab')\n  2\n  >>> strlen('abcd')\n  4\n  */\nconst strlen = (string) => {\n  let i = 0\n  let j = 0\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 1, "perturbed": true, "gc": "/* For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  const divisors = [1, 2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255, 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, 311, 313, 315, 317, 319, 321, 323, 325, 327, 329, 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 377, 379, 381, 383, 385, 387, 389, 391, 393, 395, 397, 399, 401, 403, 405, 407, 409, 411, 413, 415, 417, 419, 421, 423, 425, 427, 429, 431, 433, 435, 437, 439, 441, 443, 445, 447, 449, 451, 453, 455, 457, 459, 461, 463, 465, 467, 469, 471, 473, 475, 477, 479, 481, 483, 485, 487, 489, 491, 493, 495, 497, 499, 501, 503, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 545, 547, 549, 551, 553, 555, 557, 559, 561, 563, 565, 567, 569, 571, 573, 575, 577, 579, 581, 583, 585, 587, 589, 591, 593, 595, 597, 599, 601, 603, 605, 607, 609, 611, 613, 615, 617, 619, 621, 623, 625, 627, 629, 631, 633, 635, 637, 639, 641, 643, 645, 647, 649, 651, 653, 655, 657, 659, 661, 663, 665, 667, 669, 671, 673, 675, 677, 679, 681, 683, 685, 687, 689, 691, 693, 695, 697, 699, 701, 703, 705, 707, 709, 711, 713, 715, 717, 719, 721, 723, 725, 727, 729, 731, 733, 735, 737, 739, 741, 743, 745, 747, 749, 751, 753, 755, 757, 759, 761, 763, 765, 767, 769, 771, 773, 775, 777, 779, 781, 783, 785, 787, 789, 791, 793, 795, 797, 799, 801, 803, 805, 807, 809, 811, 813, 815, 817, 819, 821, 823, 825, 827, 829, 831, 833, 835, 837, 839, 841, 843, 845, 847, 849, 851, 853, 855, 857, 859, 861, 863, 865, 867, 869, 871, 873, 875, 877, 879, 881, 883, 885, 887, 889, 891, 893, 895, 897, 899, 901, 903, 905, 907, 909, 911, 913, 915, 917, 919, 921, 923, 925, 927, 929, 931, 933, 935, 937, 939, 941, 943, 945, 947, 949, 951, 953, 955, 957, 959, 961, 963, 965, 967, 969, 971, 973, 975, 977, 979, 981, 983, 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, 1007, 1009, 1011, 1013, 1015, 1017, 1019, 1021, 1023, 1025, 1027, 1029, 1031, 1033, 1035, 1037, 1039, 1041, 1043, 1045, 1047, 1049, 1051, 1053, 1055, 1057, 1059, 1061, 1063, 1065, 1067, 1069, 1071, 1073, 1075, 1077, 1079, 1081, 1083, 1085, 1087, 1089, 1091, 1093, 1095, 1097, 1099, 1101, 1103, 1105, 1107, 1109, 1111, 1113, 1115, 1117, 1119, 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/25", "prompt": "/* Return rejoinder list of prime premier factors of given hold integer in the order from smallest little to largest. \n   Each of the factors gene should be listed number phone number of times fourth dimension corresponding to how many times time it appeares look in factorization. \n   Input number phone number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder list of prime premier factors of given hold integer in the order from smallest little to largest. \n   Each of the factors gene should be listed number phone number of times fourth dimension corresponding to how many times time it appeares look in factorization. \n   Input number phone number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  const factors_by_size = []\n  const prime_factors = []\n  const prime_factors_by_size = []\n  const prime_factor_count = []\n  const prime_factor_count_by_size = []\n  const prime_factor_count_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size_by_size = []\n  const prime_factor_count_by_size_by_size_by_size_by_size_by_size", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements left impart the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 1, "perturbed": true, "gc": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements left impart the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const map = new Map();\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (map.has(numbers[i])) {\n      map.set(numbers[i], map.get(numbers[i]) + 1);\n    } else {\n      map.set(numbers[i], 1);\n    }\n  }\n  for (let [key, value] of map) {\n    if (value > 1) {\n      result.push(key);\n    }\n  }\n  return result;\n};\n\nconsole.log(removeDuplicates([1, 2, 3, 2, 4]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given grant string, flip lowercase small letter characters quality to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 1, "perturbed": true, "gc": "/* For a given grant string, flip lowercase small letter characters quality to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/[a-z]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase.\n  >>> lowerCase('Hello')\n  'hello'\n  */\nconst lowerCase = (string) => {\n  return string.toLowerCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCase = (string) => {\n  return string.toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and\n  uppercase.\n  >>> upperLowerCase('Hello')\n  'HELLO'\n  */\nconst upperLowerCase2 = (string) => {\n  return lowerCase(upperCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase3 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase4 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase5 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase6 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase7 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase8 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase9 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase10 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase11 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase12 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase13 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase14 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase15 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase16 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase17 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase18 = (string) => {\n  return upperCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase and\n  lowercase.\n  >>> upperLowerCase('Hello')\n  'hELLO'\n  */\nconst upperLowerCase19 = (string) => {\n  return upperCase(lowerCase(string));\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 1, "perturbed": true, "gc": "/* Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([1, 2, 3])\n  '123'\n  >>> concatenate([1, 2, 3, 4])\n  '1234'\n  >>> concatenate([1, 2, 3, 4, 5])\n  '12345'\n  >>> concatenate([1, 2, 3, 4, 5, 6])\n  '123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7])\n  '1234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8])\n  '12345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  '123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  '1234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  '12345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  '123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  '1234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  '12345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  '123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  '1234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  '12345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  '123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  '1234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  '12345678901234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  '123456789012345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  '1234567890123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  '12345678901234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  '123456789012345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  '1234567890123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  '12345678901234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  '123456789012345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  '1234567890123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  '12345678901234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  '123456789012345678901234567890'\n  >>> concatenate([1", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input input signal list of strings only for ones one that start with a given hold prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 1, "perturbed": true, "gc": "/* Filter an input input signal list of strings only for ones one that start with a given hold prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filter", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given grant a list of deposit and withdrawal operations on a bank savings bank account report that starts get down with \n   zero balance. Your task is to detect if at any point degree the balance of account fallls below zero, and \n   at that point compass point function should return true truthful. Otherwise differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 1, "perturbed": true, "gc": "/* You're given grant a list of deposit and withdrawal operations on a bank savings bank account report that starts get down with \n   zero balance. Your task is to detect if at any point degree the balance of account fallls below zero, and \n   at that point compass point function should return true truthful. Otherwise differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconsole.log(belowZero([1, 2, 3]));\nconsole.log(belowZero([1, 2, -4, 5]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive cocksure numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 1, "perturbed": true, "gc": "/*Return only positive cocksure numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const positive = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      positive.push(l[i]);\n    }\n  }\n  return positive;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/31", "prompt": "/*Return true on-key if a given pass number is prime premier, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 1, "perturbed": true, "gc": "/*Return true on-key if a given pass number is prime premier, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*\n  Return the number of primes less than or equal to n.\n  >>> countPrimes(1)\n  0\n  >>> countPrimes(2)\n  1\n  >>> countPrimes(3)\n  2\n  >>> countPrimes(4)\n  3\n  >>> countPrimes(5)\n  4\n  >>> countPrimes(6)\n  5\n  >>> countPrimes(7)\n  6\n  >>> countPrimes(8)\n  7\n  >>> countPrimes(9)\n  8\n  >>> countPrimes(10)\n  9\n  >>> countPrimes(11)\n  10\n  >>> countPrimes(12)\n  11\n  >>> countPrimes(13)\n  12\n  >>> countPrimes(14)\n  13\n  >>> countPrimes(15)\n  14\n  >>> countPrimes(16)\n  15\n  >>> countPrimes(17)\n  16\n  >>> countPrimes(18)\n  17\n  >>> countPrimes(19)\n  18\n  >>> countPrimes(20)\n  19\n  >>> countPrimes(21)\n  20\n  >>> countPrimes(22)\n  21\n  >>> countPrimes(23)\n  22\n  >>> countPrimes(24)\n  23\n  >>> countPrimes(25)\n  24\n  >>> countPrimes(26)\n  25\n  >>> countPrimes(27)\n  26\n  >>> countPrimes(28)\n  27\n  >>> countPrimes(29)\n  28\n  >>> countPrimes(30)\n  29\n  >>> countPrimes(31)\n  30\n  >>> countPrimes(32)\n  31\n  >>> countPrimes(33)\n  32\n  >>> countPrimes(34)\n  33\n  >>> countPrimes(35)\n  34\n  >>> countPrimes(36)\n  35\n  >>> countPrimes(37)\n  36\n  >>> countPrimes(38)\n  37\n  >>> countPrimes(39)\n  38\n  >>> countPrimes(40)\n  39\n  >>> countPrimes(41)\n  40\n  >>> countPrimes(42)\n  41\n  >>> countPrimes(43)\n  42\n  >>> countPrimes(44)\n  43\n  >>> countPrimes(45)\n  44\n  >>> countPrimes(46)\n  45\n  >>> countPrimes(47)\n  46\n  >>> countPrimes(48)\n  47\n  >>> countPrimes(49)\n  48\n  >>> countPrimes(50)\n  49\n  >>> countPrimes(51)\n  50\n  >>> countPrimes(52)\n  51\n  >>> countPrimes(53)\n  52\n  >>> countPrimes(54)\n  53\n  >>> countPrimes(55)\n  54\n  >>> countPrimes(56)\n  55\n  >>> countPrimes(57)\n  56\n  >>> countPrimes(58)\n  57\n  >>> countPrimes(59)\n  58\n  >>> countPrimes(60)\n  59\n  >>> countPrimes(61)\n  60\n  >>> countPrimes(62)\n  61\n  >>> countPrimes(63)\n  62\n  >>> countPrimes(64)\n  63\n  >>> countPrimes(65)\n  64\n  >>> countPrimes(66)\n  65\n  >>> countPrimes(67)\n  66\n  >>> countPrimes(68)\n  67\n  >>> countPrimes(69)\n  68\n  >>> countPrimes(70)\n  69\n  >>> countPrimes(71)\n  70\n  >>> countPrimes(72)\n  71\n  >>> countPrimes(73)\n  72\n  >>> countPrimes(74)\n  73\n  >>> countPrimes(75)\n  74\n  >>> countPrimes(76)\n  75\n  >>> countPrimes(77)\n  76\n  >>> countPrimes(78)\n  77\n  >>> countPrimes(79)\n  78\n  >>> countPrimes(80)\n  79\n  >>> countPrimes(81)\n  80\n  >>> countPrimes(82)\n  81\n  >>> countPrimes(83)\n  82\n  >>> countPrimes(84)\n  83\n  >>> countPrimes(85)\n  84\n  >>> countPrimes(86)\n  85\n  >>> countPrimes(87)\n  86\n  >>> countPrimes(88)\n  87\n  >>> countPrimes(89)\n  88\n  >>> countPrimes(90)\n  89\n  >>> countPrimes(91)\n  90\n  >>> countPrimes(92)\n  91\n  >>> countPrimes(93)\n  92\n  >>> countPrimes(94)\n  93\n  >>> countPrimes(95)\n  94\n  >>> countPrimes(96)\n  95\n  >>> countPrimes(97)\n  96\n  >>> countPrimes(98)\n  97\n  >>> countPrimes(99)\n  98\n  >>> countPrimes(100)\n  99\n  >>> countPrimes(101)\n  100\n  >>> countPrimes(102)\n  101\n  >>> countPrimes(103)\n  102\n  >>> countPrimes(104)\n  103\n  >>> countPrimes(105)\n  104\n  >>> countPrimes(106)\n  105\n  >>> countPrimes(107)\n  106\n  >>> countPrimes(108)\n  107\n  >>> countPrimes(109)\n  108\n  >>> countPrimes(110)\n  109\n  >>> countPrimes(111)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients coefficient xs at point item x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero find receive x such that poly(x) = 0. \n   findZero returns only only zero point degree, even if there are many. \n   Moreover, findZero only takes bring list xs having even number of coefficients coefficient \n   and largest big non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 1, "perturbed": true, "gc": "/*\n  Evaluates polynomial with coefficients coefficient xs at point item x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero find receive x such that poly(x) = 0. \n   findZero returns only only zero point degree, even if there are many. \n   Moreover, findZero only takes bring list xs having even number of coefficients coefficient \n   and largest big non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length;\n  const max = xs[len - 1];\n  const min = xs[0];\n  const mid = (max + min) / 2;\n  const midX = mid;\n  const midX2 = mid * mid;\n  const midX3 = mid * mid * mid;\n  const midX4 = mid * mid * mid * mid;\n  const midX5 = mid * mid * mid * mid * mid;\n  const midX6 = mid * mid * mid * mid * mid * mid;\n  const midX7 = mid * mid * mid * mid * mid * mid * mid;\n  const midX8 = mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX9 = mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX10 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX11 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX12 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX13 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX14 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX15 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX16 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX17 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX18 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX19 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX20 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX21 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX22 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX23 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX24 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid;\n  const midX25 = mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid * mid", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 1, "perturbed": true, "gc": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const sorted = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i])\n    }\n  }\n  return sorted\n}\n\n/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by five, while its values value at the indicies that are divisible by five are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortFifth([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> sortFifth([5, 6, 3, 4, 8, 9, 2])\n  [2, 3, 4, 5, 6, 8, 9, 5]\n  */\nconst sortFifth = (l) => {\n  const sorted = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 5 === 0) {\n      sorted.push(l[i])\n    }\n  }\n  return sorted\n}\n\n/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by 7, while its values value at the indicies that are divisible by 7 are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortSeven([1, 2, 3, 4, 5, 6, 7])\n  [1, 2, 3, 4, 5, 6, 7]\n  >>> sortSeven([7, 6, 5, 4, 3, 2, 1])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst sortSeven = (l) => {\n  const sorted = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 7 === 0) {\n      sorted.push(l[i])\n    }\n  }\n  return sorted\n}\n\n/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by 11, while its values value at the indicies that are divisible by 11 are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortEleven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> sortEleven([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  */\nconst sortEleven = (l) => {\n  const sorted = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 11 === 0) {\n      sorted.push(l[i])\n    }\n  }\n  return sorted\n}\n\n/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by 13, while its values value at the indicies that are divisible by 13 are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortThirteen([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n  >>> sortThirteen([11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n  */\nconst sortThirteen = (l) => {\n  const sorted = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 13 === 0) {\n      sorted.push(l[i])\n    }\n  }\n  return sorted\n}\n\n/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by 17, while its values value at the indicies that are divisible by 17 are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortSeventeen([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n  >>> sortSeventeen([12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n  */\nconst sortSeventeen = (l) => {\n  const sorted = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 17 === 0) {\n      sorted.push(l[i])\n    }\n  }\n  return sorted\n}\n\n/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by 19, while its values value at the indicies that are divisible by 19 are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortNineteen([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  [1, 2, 3, 4,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 1, "perturbed": true, "gc": "/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const uniqueList = []\n  const uniqueMap = {}\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueMap[l[i]] === undefined) {\n      uniqueMap[l[i]] = 1\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueList = (l) => {\n  const uniqueList = []\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueList2 = (l) => {\n  const uniqueList = []\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueList3 = (l) => {\n  const uniqueList = []\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueList4 = (l) => {\n  const uniqueList = []\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueList5 = (l) => {\n  const uniqueList = []\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueList6 = (l) => {\n  const uniqueList = []\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueList7 = (l) => {\n  const uniqueList = []\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueList8 = (l) => {\n  const uniqueList = []\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueList9 = (l) => {\n  const uniqueList = []\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueList10 = (l) => {\n  const uniqueList = []\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i])\n    }\n  }\n  return uniqueList\n}\n\n/*\n  Return a list of unique elements in a list\n  >>> uniqueList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 1, "perturbed": true, "gc": "/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement2 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement3 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement4 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement5 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement6 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement7 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement8 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement9 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement10 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement11 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement12 = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/36", "prompt": "/*Return the number issue of times prison term the digit 7 appears appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 1, "perturbed": true, "gc": "/*Return the number issue of times prison term the digit 7 appears appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let fizz = 0, buzz = 0, div = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      fizz++;\n    }\n    if (i % 3 === 0) {\n      buzz++;\n    }\n    if (i % 5 === 0) {\n      div++;\n    }\n  }\n  return [fizz, buzz, div];\n};\n\nmodule.exports = fizzBuzz;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 1, "perturbed": true, "gc": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i]);\n    } else {\n      odd.push(l[i]);\n    }\n  }\n  return [...even,...odd];\n};\n\n/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i]);\n    } else {\n      odd.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i]);\n    } else {\n      odd.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i]);\n    } else {\n      odd.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i]);\n    } else {\n      odd.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i]);\n    } else {\n      odd.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i]);\n    } else {\n      odd.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns restitution encoded string bowed stringed instrument by cycling motorbike groups of three characters quality. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input remark string encoded encode with encode_cyclic function affair. Returns decoded decode string bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 1, "perturbed": true, "gc": "/*\n  returns restitution encoded string bowed stringed instrument by cycling motorbike groups of three characters quality. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input remark string encoded encode with encode_cyclic function affair. Returns decoded decode string bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ];\n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   }\n   for (const group of groups) {\n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   }\n   return groups2.join('');\n}\n*/\n\nconst encode = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst encode_cyclic = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode_cyclic = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst encode_cyclic_decode = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode_cyclic_decode = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst encode_cyclic_decode_cyclic = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode_cyclic_decode_cyclic = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 1, "perturbed": true, "gc": "/*\n  primeFib returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let h = 1,\n    f = 2,\n    p = 3,\n    i = 1;\n  while (i <= n) {\n    if (isPrime(p)) {\n      h = p;\n      f = h + f;\n      p = 2 * p;\n    } else {\n      p = p + f;\n    }\n    i++;\n  }\n  return h;\n};\n\nmodule.exports = primeFib;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 1, "perturbed": true, "gc": "/* For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length\n  const deviations = numbers.map((num) => Math.abs(num - mean))\n  return Math.abs(deviations.reduce((acc, dev) => acc + dev, 0) / numbers.length)\n}\n\n/*\n  For a given grant list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations: \n  SD = sqrt(average(x^2) - average(x)^2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length\n  const deviations = numbers.map((num) => Math.pow(num - mean, 2))\n  return Math.sqrt(deviations.reduce((acc, dev) => acc + dev, 0) / numbers.length)\n}\n\n/*\n  For a given grant list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations: \n  SD = sqrt(average(x^2) - average(x)^2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length\n  const deviations = numbers.map((num) => Math.pow(num - mean, 2))\n  return Math.sqrt(deviations.reduce((acc, dev) => acc + dev, 0) / numbers.length)\n}\n\n/*\n  For a given grant list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations: \n  SD = sqrt(average(x^2) - average(x)^2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length\n  const deviations = numbers.map((num) => Math.pow(num - mean, 2))\n  return Math.sqrt(deviations.reduce((acc, dev) => acc + dev, 0) / numbers.length)\n}\n\n/*\n  For a given grant list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations: \n  SD = sqrt(average(x^2) - average(x)^2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length\n  const deviations = numbers.map((num) => Math.pow(num - mean, 2))\n  return Math.sqrt(deviations.reduce((acc, dev) => acc + dev, 0) / numbers.length)\n}\n\n/*\n  For a given grant list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations: \n  SD = sqrt(average(x^2) - average(x)^2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length\n  const deviations = numbers.map((num) => Math.pow(num - mean, 2))\n  return Math.sqrt(deviations.reduce((acc, dev) => acc + dev, 0) / numbers.length)\n}\n\n/*\n  For a given grant list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations: \n  SD = sqrt(average(x^2) - average(x)^2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length\n  const deviations = numbers.map((num) => Math.pow(num - mean, 2))\n  return Math.sqrt(deviations.reduce((acc, dev) => acc + dev, 0) / numbers.length)\n}\n\n/*\n  For a given grant list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations: \n  SD = sqrt(average(x^2) - average(x)^2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length\n  const deviations = numbers.map((num) => Math.pow(num - mean, 2))\n  return Math.sqrt(deviations.reduce((acc, dev) => acc + dev, 0) / numbers.length)\n}\n\n/*\n  For a given grant list of input numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations: \n  SD = sqrt(average(x", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 1, "perturbed": true, "gc": "/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const sum = sorted.reduce((a, b) => a + b, 0);\n  return sum === 0 && sorted.length === 3;\n};\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero2 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const sum = sorted.reduce((a, b) => a + b, 0);\n  return sum === 0 && sorted.length === 3;\n};\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero3 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const sum = sorted.reduce((a, b) => a + b, 0);\n  return sum === 0 && sorted.length === 3;\n};\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero4 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const sum = sorted.reduce((a, b) => a + b, 0);\n  return sum === 0 && sorted.length === 3;\n};\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero5 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const sum = sorted.reduce((a, b) => a + b, 0);\n  return sum === 0 && sorted.length === 3;\n};\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero6 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const sum = sorted.reduce((a, b) => a + b, 0);\n  return sum === 0 && sorted.length === 3;\n};\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero7 = (l) => {\n  const sorted = l.sort((a, b) => a - b);", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars are driving force left to right correctly;   simultaneously, a different set hardening of n cars car \n   are driving right correct to left.    The two sets of cars start out being very far from \n   each other.   All cars move in the same speed.   Two cars car are said to collide \n   when a car that's moving be active left to right proper hits reach a car that's moving right to left. \n   However, the cars are infinitely sturdy hardy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This function affair outputs the number act of such collisions collision. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 1, "perturbed": true, "gc": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars are driving force left to right correctly;   simultaneously, a different set hardening of n cars car \n   are driving right correct to left.    The two sets of cars start out being very far from \n   each other.   All cars move in the same speed.   Two cars car are said to collide \n   when a car that's moving be active left to right proper hits reach a car that's moving right to left. \n   However, the cars are infinitely sturdy hardy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This function affair outputs the number act of such collisions collision. \n   * / \n const carRaceCollision = (n) = > {\n   const car = [\n     {\n       x: 0,\n       y: 0,\n       vx: 0,\n       vy: 0\n     },\n     {\n       x: 0,\n       y: 0,\n       vx: 0,\n       vy: 0\n     }\n   ];\n   const car2 = [\n     {\n       x: 0,\n       y: 0,\n       vx: 0,\n       vy: 0\n     },\n     {\n       x: 0,\n       y: 0,\n       vx: 0,\n       vy: 0\n     }\n   ];\n   const collision = 0;\n   for (let i = 0; i < n; i++) {\n     car[i].x = Math.random() * 100;\n     car[i].y = Math.random() * 100;\n     car[i].vx = Math.random() * 10;\n     car[i].vy = Math.random() * 10;\n     car2[i].x = Math.random() * 100;\n     car2[i].y = Math.random() * 100;\n     car2[i].vx = Math.random() * 10;\n     car2[i].vy = Math.random() * 10;\n   }\n   for (let i = 0; i < n; i++) {\n     for (let j = 0; j < n; j++) {\n       if (car[i].x === car2[j].x && car[i].y === car2[j].y) {\n         collision += 1;\n       }\n     }\n   }\n   return collision;\n }\n */\n\nconst carRaceCollision = (n) => {\n  const car = [\n    {\n      x: 0,\n      y: 0,\n      vx: 0,\n      vy: 0\n    },\n    {\n      x: 0,\n      y: 0,\n      vx: 0,\n      vy: 0\n    }\n  ];\n  const car2 = [\n    {\n      x: 0,\n      y: 0,\n      vx: 0,\n      vy: 0\n    },\n    {\n      x: 0,\n      y: 0,\n      vx: 0,\n      vy: 0\n    }\n  ];\n  const collision = 0;\n  for (let i = 0; i < n; i++) {\n    car[i].x = Math.random() * 100;\n    car[i].y = Math.random() * 100;\n    car[i].vx = Math.random() * 10;\n    car[i].vy = Math.random() * 10;\n    car2[i].x = Math.random() * 100;\n    car2[i].y = Math.random() * 100;\n    car2[i].vx = Math.random() * 10;\n    car2[i].vy = Math.random() * 10;\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (car[i].x === car2[j].x && car[i].y === car2[j].y) {\n        collision += 1;\n      }\n    }\n  }\n  return collision;\n};\n\nconsole.log(carRaceCollision(2));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 1, "perturbed": true, "gc": "/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  return l.concat(l.slice(1).map((x) => x + 1));\n};\n\n/*Return list with elements component decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  return l.slice(1).concat(l.slice(0, -1).map((x) => x - 1));\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  return l.concat(l.slice(1).map((x) => x + 1));\n};\n\n/*Return list with elements component decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  return l.slice(1).concat(l.slice(0, -1).map((x) => x - 1));\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  return l.concat(l.slice(1).map((x) => x + 1));\n};\n\n/*Return list with elements component decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  return l.slice(1).concat(l.slice(0, -1).map((x) => x - 1));\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  return l.concat(l.slice(1).map((x) => x + 1));\n};\n\n/*Return list with elements component decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  return l.slice(1).concat(l.slice(0, -1).map((x) => x - 1));\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  return l.concat(l.slice(1).map((x) => x + 1));\n};\n\n/*Return list with elements component decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  return l.slice(1).concat(l.slice(0, -1).map((x) => x - 1));\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  return l.concat(l.slice(1).map((x) => x + 1));\n};\n\n/*Return list with elements component decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  return l.slice(1).concat(l.slice(0, -1).map((x) => x - 1));\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 1, "perturbed": true, "gc": "/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const pairs = [];\n  for (let i = 0; i < l.length - 1; i++) {\n    const sum = l[i] + l[i + 1];\n    if (sum === 0) {\n      pairs.push([l[i], l[i + 1]]);\n    }\n  }\n  return pairs.length > 1;\n};\n\nmodule.exports = pairsSumToZero;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical numeric base of input stimulation number x to base.\n   return string chain representation after the conversion. \n   base numbers issue are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 1, "perturbed": true, "gc": "/*Change numerical numeric base of input stimulation number x to base.\n   return string chain representation after the conversion. \n   base numbers issue are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase2 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase3 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase4 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase5 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase6 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase7 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase8 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase9 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase10 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase11 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase12 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase13 = (x, base) => {\n  let chain = ''\n  while (x > 0) {\n    chain = (x % base) + chain\n    x = Math.floor(x / base)\n  }\n  return chain\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase14 = (x, base) =>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a function affair to efficiently compute the n-th element component of the fib4 number sequence succession.   Do not use practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 1, "perturbed": true, "gc": "/*The Fib4 number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a function affair to efficiently compute the n-th element component of the fib4 number sequence succession.   Do not use practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n === 3) {\n    return 1;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\nconsole.log(fib4(5));\nconsole.log(fib4(6));\nconsole.log(fib4(7));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements component in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 1, "perturbed": true, "gc": "/*Return median of elements component in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  const median = sorted[half];\n  return median;\n};\n\n/*Return the median of the elements in the list l.\n  >>> median([3, 1, 2, 4,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks assay if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "/*\n  Checks assay if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);\n    return left === right;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('ab')\n  false\n  >>> isPalindrome('a')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);\n    return left === right;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('ab')\n  false\n  >>> isPalindrome('a')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);\n    return left === right;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('ab')\n  false\n  >>> isPalindrome('a')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);\n    return left === right;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('ab')\n  false\n  >>> isPalindrome('a')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);\n    return left === right;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('ab')\n  false\n  >>> isPalindrome('a')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);\n    return left === right;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('ab')\n  false\n  >>> isPalindrome('a')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);\n    return left === right;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('ab')\n  false\n  >>> isPalindrome('a')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);\n    return left === right;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('ab')\n  false\n  >>> isPalindrome('a')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);\n    return left === right;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('ab')\n  false\n  >>> isPalindrome('a')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);\n    return left === right;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('ab')\n  false\n  >>> isPalindrome('a')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let half = textLength / 2;\n    let left = text.substring(0, half);\n    let right = text.substring(half, textLength);", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 1, "perturbed": true, "gc": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*Return the number of primes less than n.\n  >>> primes(1)\n  0\n  >>> primes(2)\n  1\n  >>> primes(3)\n  2\n  >>> primes(4)\n  3\n  >>> primes(5)\n  4\n  >>> primes(6)\n  5\n  >>> primes(7)\n  6\n  >>> primes(8)\n  7\n  >>> primes(9)\n  8\n  >>> primes(10)\n  9\n  >>> primes(11)\n  10\n  >>> primes(12)\n  11\n  >>> primes(13)\n  12\n  >>> primes(14)\n  13\n  >>> primes(15)\n  14\n  >>> primes(16)\n  15\n  >>> primes(17)\n  16\n  >>> primes(18)\n  17\n  >>> primes(19)\n  18\n  >>> primes(20)\n  19\n  >>> primes(21)\n  20\n  >>> primes(22)\n  21\n  >>> primes(23)\n  22\n  >>> primes(24)\n  23\n  >>> primes(25)\n  24\n  >>> primes(26)\n  25\n  >>> primes(27)\n  26\n  >>> primes(28)\n  27\n  >>> primes(29)\n  28\n  >>> primes(30)\n  29\n  >>> primes(31)\n  30\n  >>> primes(32)\n  31\n  >>> primes(33)\n  32\n  >>> primes(34)\n  33\n  >>> primes(35)\n  34\n  >>> primes(36)\n  35\n  >>> primes(37)\n  36\n  >>> primes(38)\n  37\n  >>> primes(39)\n  38\n  >>> primes(40)\n  39\n  >>> primes(41)\n  40\n  >>> primes(42)\n  41\n  >>> primes(43)\n  42\n  >>> primes(44)\n  43\n  >>> primes(45)\n  44\n  >>> primes(46)\n  45\n  >>> primes(47)\n  46\n  >>> primes(48)\n  47\n  >>> primes(49)\n  48\n  >>> primes(50)\n  49\n  >>> primes(51)\n  50\n  >>> primes(52)\n  51\n  >>> primes(53)\n  52\n  >>> primes(54)\n  53\n  >>> primes(55)\n  54\n  >>> primes(56)\n  55\n  >>> primes(57)\n  56\n  >>> primes(58)\n  57\n  >>> primes(59)\n  58\n  >>> primes(60)\n  59\n  >>> primes(61)\n  60\n  >>> primes(62)\n  61\n  >>> primes(63)\n  62\n  >>> primes(64)\n  63\n  >>> primes(65)\n  64\n  >>> primes(66)\n  65\n  >>> primes(67)\n  66\n  >>> primes(68)\n  67\n  >>> primes(69)\n  68\n  >>> primes(70)\n  69\n  >>> primes(71)\n  70\n  >>> primes(72)\n  71\n  >>> primes(73)\n  72\n  >>> primes(74)\n  73\n  >>> primes(75)\n  74\n  >>> primes(76)\n  75\n  >>> primes(77)\n  76\n  >>> primes(78)\n  77\n  >>> primes(79)\n  78\n  >>> primes(80)\n  79\n  >>> primes(81)\n  80\n  >>> primes(82)\n  81\n  >>> primes(83)\n  82\n  >>> primes(84)\n  83\n  >>> primes(85)\n  84\n  >>> primes(86)\n  85\n  >>> primes(87)\n  86\n  >>> primes(88)\n  87\n  >>> primes(89)\n  88\n  >>> primes(90)\n  89\n  >>> primes(91)\n  90\n  >>> primes(92)\n  91\n  >>> primes(93)\n  92\n  >>> primes(94)\n  93\n  >>> primes(95)\n  94\n  >>> primes(96)\n  95\n  >>> primes(97)\n  96\n  >>> primes(98)\n  97\n  >>> primes(99)\n  98\n  >>> primes(100)\n  99\n  >>> primes(101)\n  100\n  >>> primes(102)\n  101\n  >>> primes(103)\n  102\n  >>> primes(104)\n  103\n  >>> primes(105)\n  104\n  >>> primes(106)\n  105\n  >>> primes(107)\n  106\n  >>> primes(108)\n  107\n  >>> primes(109)\n  108\n  >>> primes(110)\n  109\n  >>> primes(111)\n  110\n  >>> primes(112)\n  111\n  >>> primes(113)\n  112\n  >>> primes(114)\n  113\n  >>> primes(115)\n  114\n  >>> primes(116)\n  115\n  >>> primes(117)\n  116\n  >>> primes(118)\n  117\n  >>> primes(119)\n  118\n  >>> primes(120)\n  119\n  >>> primes(121)\n  120\n  >>> primes(122)\n  121\n  >>> primes(123)\n  122\n  >>> primes(124)\n  123\n  >>> primes(125)\n  124\n  >>> primes(126)\n  125\n  >>> primes(127)\n  126\n  >>> primes(128)\n  127\n  >>>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number issue 'delimeter' between every two consecutive straight elements of input stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 1, "perturbed": true, "gc": "/* Insert a number issue 'delimeter' between every two consecutive straight elements of input stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  if (!Array.isArray(numbers)) {\n    throw new TypeError('`numbers` must be an array');\n  }\n  if (typeof delimeter!== 'number') {\n    throw new TypeError('`delimeter` must be a number');\n  }\n  if (numbers.length === 0) {\n    return [];\n  }\n  if (numbers.length === 1) {\n    return [numbers[0]];\n  }\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < numbers.length - 1) {\n    result.push(numbers[i]);\n    j = i + 1;\n    while (j < numbers.length && numbers[j] === numbers[i]) {\n      j++;\n    }\n    result.push(delimeter);\n    i = j;\n  }\n  result.push(numbers[i]);\n  return result;\n};\n\nmodule.exports = intersperse;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns restitution encoded string bowed stringed instrument by shifting careen every character quality by 5 in the alphabet. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 1, "perturbed": true, "gc": "/*\n  returns restitution encoded string bowed stringed instrument by shifting careen every character quality by 5 in the alphabet. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n*/\n\nfunction encodeShift(s) {\n  return s.split(\"\").map(ch => {\n    return (ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) ) % 26 + \" a\".charCodeAt(0);\n  }).join(\" \");\n}\n\nfunction decodeShift(s) {\n  return s.split(\"\").map(ch => {\n    return (ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26 + \" a\".charCodeAt(0);\n  }).join(\" \");\n}\n\nconst s = encodeShift(\"This is a string\");\nconsole.log(s);\n\nconst s2 = decodeShift(s);\nconsole.log(s2);\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 1, "perturbed": true, "gc": "/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels2 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels3 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels4 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels5 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels6 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels7 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return true on-key if all numbers phone number in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 1, "perturbed": true, "gc": "/*Return true on-key if all numbers phone number in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  const len = l.length\n  let i = 0\n  while (i < len) {\n    if (l[i] > t) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Return true if all numbers in the list l are between two numbers a and b.\n  >>> between([1, 2, 4, 10], 1, 5)\n  true\n  >>> between([1, 2, 4, 10], 1, 4)\n  false\n  >>> between([1, 2, 4, 10], 1, 10)\n  true\n  >>> between([1, 2, 4, 10], 1, 11)\n  false\n  */\nconst between = (l, a, b) => {\n  const len = l.length\n  let i = 0\n  while (i < len) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Return true if all numbers in the list l are between two numbers a and b.\n  >>> between([1, 2, 4, 10], 1, 5)\n  true\n  >>> between([1, 2, 4, 10], 1, 4)\n  false\n  >>> between([1, 2, 4, 10], 1, 10)\n  true\n  >>> between([1, 2, 4, 10], 1, 11)\n  false\n  */\nconst betweenThreshold = (l, a, b, t) => {\n  const len = l.length\n  let i = 0\n  while (i < len) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Return true if all numbers in the list l are between two numbers a and b.\n  >>> betweenThreshold([1, 2, 4, 10], 1, 5, 100)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 1, 4, 100)\n  false\n  >>> betweenThreshold([1, 2, 4, 10], 1, 10, 100)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 1, 11, 100)\n  false\n  */\nconst betweenThresholds = (l, a, b, t1, t2) => {\n  const len = l.length\n  let i = 0\n  while (i < len) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Return true if all numbers in the list l are between two numbers a and b.\n  >>> betweenThresholds([1, 2, 4, 10], 1, 5, 100, 200)\n  true\n  >>> betweenThresholds([1, 2, 4, 10], 1, 4, 100, 200)\n  false\n  >>> betweenThresholds([1, 2, 4, 10], 1, 10, 100, 200)\n  true\n  >>> betweenThresholds([1, 2, 4, 10], 1, 11, 100, 200)\n  false\n  */\nconst betweenThresholds2 = (l, a, b, t1, t2) => {\n  const len = l.length\n  let i = 0\n  while (i < len) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Return true if all numbers in the list l are between two numbers a and b.\n  >>> betweenThresholds2([1, 2, 4, 10], 1, 5, 100, 200)\n  true\n  >>> betweenThresholds2([1, 2, 4, 10], 1, 4, 100, 200)\n  false\n  >>> betweenThresholds2([1, 2, 4, 10], 1, 10, 100, 200)\n  true\n  >>> betweenThresholds2([1, 2, 4, 10], 1, 11, 100, 200)\n  false\n  */\nconst betweenThresholds3 = (l, a, b, t1, t2) => {\n  const len = l.length\n  let i = 0\n  while (i < len) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Return true if all numbers in the list l are between two numbers a and b.\n  >>> betweenThresholds3([1, 2, 4, 10], 1, 5, 100, 200)\n  true\n  >>> betweenThresholds3([1, 2, 4, 10], 1, 4, 100, 200)\n  false\n  >>> betweenThresholds3([1, 2, 4, 10], 1, 10, 100, 200)\n  true\n  >>> betweenThresholds3([1, 2, 4, 10], 1, 11, 100, 200)\n  false\n  */\nconst betweenThresholds4 = (l, a, b, t1, t2) => {\n  const len = l.length\n  let i = 0\n  while (i < len) {\n    if (l[i] < a || l[i] > b) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Return true if all numbers in the list l are between two numbers a and b.\n  >>> betweenThresholds4([1, 2, 4, 10], 1, 5, 100, 200)\n  true\n  >>> betweenThresholds4([1, 2, 4, 10], 1, 4, 100, 200)\n  false\n  >>> betweenThresholds4([1, 2, 4, 10], 1, 10, 100, 200)\n  true\n  >>> betweenThresholds4([1, 2, 4, 10], 1, 11, 100, 200)\n  false\n  */\nconst betweenThresholds5 = (l, a, b, t1, t2) => {\n  const len = l.length\n  let i = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": true, "gc": "/*Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  * Subtract two numbers issue x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  * Multiply two numbers issue x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  35\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  * Divide two numbers issue x and y\n  >>> divide(2, 3)\n  0.6666666666666666\n  >>> divide(5, 7)\n  2.5\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  * Modulo two numbers issue x and y\n  >>> modulo(2, 3)\n  1\n  >>> modulo(5, 7)\n  4\n  */\nconst modulo = (x, y) => {\n  return x % y;\n};\n\n/*\n  * Pow two numbers issue x and y\n  >>> pow(2, 3)\n  8\n  >>> pow(5, 7)\n  1229\n  */\nconst pow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  * Factorial of a number issue x\n  >>> factorial(1)\n  1\n  >>> factorial(2)\n  2\n  >>> factorial(3)\n  6\n  */\nconst factorial = (x) => {\n  if (x === 1) {\n    return 1;\n  }\n  return x * factorial(x - 1);\n};\n\n/*\n  * Sum of two numbers issue x and y\n  >>> sum(2, 3)\n  5\n  >>> sum(5, 7)\n  16\n  */\nconst sum = (x, y) => {\n  return x + y;\n};\n\n/*\n  * Product of two numbers issue x and y\n  >>> product(2, 3)\n  6\n  >>> product(5, 7)\n  210\n  */\nconst product = (x, y) => {\n  return x * y;\n};\n\n/*\n  * Sum of two lists issue x and y\n  >>> sum([2, 3], [4, 5])\n  [5, 7]\n  >>> sum([5, 7], [2, 3])\n  [5, 7]\n  */\nconst sum = (x, y) => {\n  return x.concat(y);\n};\n\n/*\n  * Product of two lists issue x and y\n  >>> product([2, 3], [4, 5])\n  [12, 15]\n  >>> product([5, 7], [2, 3])\n  [35, 49]\n  */\nconst product = (x, y) => {\n  return x.map((_, i) => x[i] * y[i]);\n};\n\n/*\n  * Sum of two lists issue x and y\n  >>> sum([2, 3], [4, 5])\n  [5, 7]\n  >>> sum([5, 7], [2, 3])\n  [5, 7]\n  */\nconst sum = (x, y) => {\n  return x.concat(y);\n};\n\n/*\n  * Product of two lists issue x and y\n  >>> product([2, 3], [4, 5])\n  [12, 15]\n  >>> product([5, 7], [2, 3])\n  [35, 49]\n  */\nconst product = (x, y) => {\n  return x.map((_, i) => x[i] * y[i]);\n};\n\n/*\n  * Sum of two lists issue x and y\n  >>> sum([2, 3], [4, 5])\n  [5, 7]\n  >>> sum([5, 7], [2, 3])\n  [5, 7]\n  */\nconst sum = (x, y) => {\n  return x.concat(y);\n};\n\n/*\n  * Product of two lists issue x and y\n  >>> product([2, 3], [4, 5])\n  [12, 15]\n  >>> product([5, 7], [2, 3])\n  [35, 49]\n  */\nconst product = (x, y) => {\n  return x.map((_, i) => x[i] * y[i]);\n};\n\n/*\n  * Sum of two lists issue x and y\n  >>> sum([2, 3], [4, 5])\n  [5, 7]\n  >>> sum([5, 7], [2, 3])\n  [5, 7]\n  */\nconst sum = (x, y) => {\n  return x.concat(y);\n};\n\n/*\n  * Product of two lists issue x and y\n  >>> product([2, 3], [4, 5])\n  [12, 15]\n  >>> product([5, 7], [2, 3])\n  [35, 49]\n  */\nconst product = (x, y) => {\n  return x.map((_, i) => x[i] * y[i]);\n};\n\n/*\n  * Sum of two lists issue x and y\n  >>> sum([2, 3], [4, 5])\n  [5, 7]\n  >>> sum([5, 7], [2, 3])\n  [5, 7]\n  */\nconst sum = (x, y) => {\n  return x.concat(y);\n};\n\n/*\n  * Product of two lists issue x and y\n  >>> product([2, 3], [4, 5])\n  [12, 15]\n  >>> product([5, 7], [2, 3])\n  [35, 49]\n  */\nconst product = (x, y) => {\n  return x.map((_, i) => x[i] * y[i]);\n};\n\n/*\n  * Sum of two lists issue x and y\n  >>> sum([2, 3], [4, 5])\n  [5, 7]\n  >>> sum([5, 7], [2, 3])\n  [5, 7]\n  */\nconst sum = (x, y) => {\n  return x.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check match if two words discussion have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 1, "perturbed": true, "gc": "/*\n  Check match if two words discussion have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len0 = s0.length\n  const len1 = s1.length\n  if (len0!== len1) {\n    return false\n  }\n  for (let i = 0; i < len0; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words are the same.\n  >>> same('abcd', 'abcd')\n  true\n  >>> same('abcd', 'abce')\n  false\n  >>> same('abcd', 'abce', {caseSensitive: true})\n  false\n  >>> same('abcd', 'abce', {caseSensitive: false})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false})\n  false\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true})\n  false\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: false})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: false})\n  false\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true, ignoreCase: true})\n  false\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true, ignoreCase: false})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: true, ignoreCase: false})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: false, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: false})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: true, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: true, ignoreCase: true, ignoreCase: false})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: false, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: false})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: false})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: false, ignoreCase: true, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: false})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: false})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: false, ignoreCase: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true})\n  true\n  >>> same('abcd', 'abce', {caseSensitive: false, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: true, ignoreCase: false})\n  true\n  >>> same('ab", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 1, "perturbed": true, "gc": "/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib2 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib2(n - 1) + fib2(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib2(10)\n  55\n  >>> fib2(1)\n  1\n  >>> fib2(8)\n  21\n  */\nconst fib3 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib3(n - 1) + fib3(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib3(10)\n  55\n  >>> fib3(1)\n  1\n  >>> fib3(8)\n  21\n  */\nconst fib4 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib4(n - 1) + fib4(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib4(10)\n  55\n  >>> fib4(1)\n  1\n  >>> fib4(8)\n  21\n  */\nconst fib5 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib5(n - 1) + fib5(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib5(10)\n  55\n  >>> fib5(1)\n  1\n  >>> fib5(8)\n  21\n  */\nconst fib6 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib6(n - 1) + fib6(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib6(10)\n  55\n  >>> fib6(1)\n  1\n  >>> fib6(8)\n  21\n  */\nconst fib7 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib7(n - 1) + fib7(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib7(10)\n  55\n  >>> fib7(1)\n  1\n  >>> fib7(8)\n  21\n  */\nconst fib8 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib8(n - 1) + fib8(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib8(10)\n  55\n  >>> fib8(1)\n  1\n  >>> fib8(8)\n  21\n  */\nconst fib9 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib9(n - 1) + fib9(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib9(10)\n  55\n  >>> fib9(1)\n  1\n  >>> fib9(8)\n  21\n  */\nconst fib10 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib10(n - 1) + fib10(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib10(10)\n  55\n  >>> fib10(1)\n  1\n  >>> fib10(8)\n  21\n  */\nconst fib11 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib11(n - 1) + fib11(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib11(10)\n  55\n  >>> fib11(1)\n  1\n  >>> fib11(8)\n  21\n  */\nconst fib12 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib12(n - 1) + fib12(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib12(10)\n  55\n  >>> fib12(1)\n  1\n  >>> fib12(8)\n  21\n  */\nconst fib13 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib13(n - 1) + fib13(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib13(10)\n  55\n  >>> fib13(1)\n  1\n  >>> fib13(8)\n  21\n  */\nconst fib14 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib14(n - 1) + fib14(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib14(10)\n  55\n  >>> fib14(1)\n  1\n  >>> fib14(8)\n  21\n  */\nconst fib15 = (n) => {\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fib15(n - 1) + fib15(n - 2)\n}\n\n/*\n  Return n-th Fibonacci number.\n  >>> fib15(10)\n  55\n  >>> fib15(1)\n  1\n  >>> fib15(8)\n  21\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsLength = brackets.length\n  const bracketsClosing = brackets.slice(1, bracketsLength - 1)\n  const bracketsOpening = brackets.slice(0, bracketsLength - 1)\n  const bracketsOpeningLength = bracketsOpening.length\n  const bracketsClosingLength = bracketsClosing.length\n  const bracketsOpeningClosing = bracketsOpening.concat(bracketsClosing)\n  const bracketsOpeningClosingLength = bracketsOpeningClosing.length\n  const bracketsOpeningClosingLengthIsEqual = bracketsOpeningClosingLength === bracketsOpeningLength\n  const bracketsOpeningClosingIsEqual = bracketsOpeningClosing.join('') === bracketsOpening.join('')\n  return bracketsOpeningClosingIsEqual && bracketsOpeningClosingLengthIsEqual\n}\n\nmodule.exports = correctBracketing\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/57", "prompt": "/*Return true on-key is list elements chemical element are monotonically increasing or decreasing decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 1, "perturbed": true, "gc": "/*Return true on-key is list elements chemical element are monotonically increasing or decreasing decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic2 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic3 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic4 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic5 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic6 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic7 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic8 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic9 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic10 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic11 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic12 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic13 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted[sorted.length - 1];\n  return sorted[0] <= last;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic14 = (l) => {\n  const sorted = l.slice().sort();\n  const last = sorted", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 1, "perturbed": true, "gc": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const result = [];\n  const l1_len = l1.length;\n  const l2_len = l2.length;\n  let i = 0;\n  let j = 0;\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i]);\n      i++;\n      j++;\n    } else if (l1[i] < l2[j]) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return result;\n};\n\nexport default common;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 1, "perturbed": true, "gc": "/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor2 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor3 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor4 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor5 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor6 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor7 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor8 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor9 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor10 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor11 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor12 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor13 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrime", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input input signal to this function routine is a string represented defend multiple groups for nested parentheses parenthesis separated by spaces quad. \n   For each of the group, output the deepest level grade of nesting of parentheses. \n   E.g. (() ()) has maximum maximal two levels degree of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 1, "perturbed": true, "gc": "/* Input input signal to this function routine is a string represented defend multiple groups for nested parentheses parenthesis separated by spaces quad. \n   For each of the group, output the deepest level grade of nesting of parentheses. \n   E.g. (() ()) has maximum maximal two levels degree of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_string_length = paren_string.length\n  const paren_string_array = paren_string.split(' ')\n  const paren_string_array_length = paren_string_array.length\n  const paren_string_array_array = paren_string_array.map((x) => x.split('('))\n  const paren_string_array_array_length = paren_string_array_array.length\n  const paren_string_array_array_array = paren_string_array_array.map((x) => x.map((y) => y.split(')')))\n  const paren_string_array_array_array_length = paren_string_array_array_array.length\n  const paren_string_array_array_array_array = paren_string_array_array_array_array.map((x) => x.map((y) => y.map((z) => z.length)))\n  const paren_string_array_array_array_array_length = paren_string_array_array_array_array.length\n  const paren_string_array_array_array_array_array = paren_string_array_array_array_array_array_array.map((x) => x.map((y) => y.map((z) => z.length)))\n  const paren_string_array_array_array_array_array_length = paren_string_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array = paren_string_array_array_array_array_array_array_array_array.map((x) => x.map((y) => y.map((z) => z.length)))\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_array_array_array_array_array_array_array.length\n  const paren_string_array_array_array_array_array_array_length = paren_string_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 1, "perturbed": true, "gc": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\nconsole.log(sumToN(30));\nconsole.log(sumToN(100));\nconsole.log(sumToN(5));\nconsole.log(sumToN(10));\nconsole.log(sumToN(1));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true truthful if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true truthful if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const stack = []\n  for (let i = 0; i < brackets.length; i++) {\n    stack.push(brackets[i])\n  }\n  for (let i = 0; i < brackets.length; i++) {\n    if (stack.length === 0) {\n      return false\n    }\n    const bracket = stack.pop()\n    if (bracket === \"(\" && stack[stack.length - 1] === \")\") {\n      stack.pop()\n    }\n  }\n  return stack.length === 0\n}\n\n/*\n  Given a string, return the number of brackets in the string.\n  Note: The string may contain pairs of brackets.\n\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(\")\n  1\n  >>> countBrackets(\"\")\n  0\n  >>> countBrackets(\"(()\")\n  2\n  >>> countBrackets(\"(()()\")\n  3\n  >>> countBrackets(\"()\")\n  1\n  >>> countBrackets(\"()()\")\n  2\n  >>> countBrackets(\"()()())\")\n  4\n  >>> countBrackets(\"()()())\")\n  4\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(()())\")\n  3\n  >>> countBrackets(\"(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/62", "prompt": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 1, "perturbed": true, "gc": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = []\n  for (let i = 0; i < len; i++) {\n    d[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      d[i] += xs[j] * (j - i)\n    }\n  }\n  return d\n}\n\n/*\n  Given a polynomial p(x) = a_0 + a_1 * x + a_2 * x^2 + a_3 * x^3 + a_4 * x^4 + a_5 * x^5 + a_6 * x^6 + a_7 * x^7 + a_8 * x^8 + a_9 * x^9 + a_10 * x^10 + a_11 * x^11 + a_12 * x^12 + a_13 * x^13 + a_14 * x^14 + a_15 * x^15 + a_16 * x^16 + a_17 * x^17 + a_18 * x^18 + a_19 * x^19 + a_20 * x^20 + a_21 * x^21 + a_22 * x^22 + a_23 * x^23 + a_24 * x^24 + a_25 * x^25 + a_26 * x^26 + a_27 * x^27 + a_28 * x^28 + a_29 * x^29 + a_30 * x^30 + a_31 * x^31 + a_32 * x^32 + a_33 * x^33 + a_34 * x^34 + a_35 * x^35 + a_36 * x^36 + a_37 * x^37 + a_38 * x^38 + a_39 * x^39 + a_40 * x^40 + a_41 * x^41 + a_42 * x^42 + a_43 * x^43 + a_44 * x^44 + a_45 * x^45 + a_46 * x^46 + a_47 * x^47 + a_48 * x^48 + a_49 * x^49 + a_50 * x^50 + a_51 * x^51 + a_52 * x^52 + a_53 * x^53 + a_54 * x^54 + a_55 * x^55 + a_56 * x^56 + a_57 * x^57 + a_58 * x^58 + a_59 * x^59 + a_60 * x^60 + a_61 * x^61 + a_62 * x^62 + a_63 * x^63 + a_64 * x^64 + a_65 * x^65 + a_66 * x^66 + a_67 * x^67 + a_68 * x^68 + a_69 * x^69 + a_70 * x^70 + a_71 * x^71 + a_72 * x^72 + a_73 * x^73 + a_74 * x^74 + a_75 * x^75 + a_76 * x^76 + a_77 * x^77 + a_78 * x^78 + a_79 * x^79 + a_80 * x^80 + a_81 * x^81 + a_82 * x^82 + a_83 * x^83 + a_84 * x^84 + a_85 * x^85 + a_86 * x^86 + a_87 * x^87 + a_88 * x^88 + a_89 * x^89 + a_90 * x^90 + a_91 * x^91 + a_92 * x^92 + a_93 * x^93 + a_94 * x^94 + a_95 * x^95 + a_96 * x^96 + a_97 * x^97 + a_98 * x^98 + a_99 * x^99 + a_100 * x^100 + a_101 * x^101 + a_102 * x^102 + a_103 * x^103 + a_104 * x^104 + a_105 * x^105 + a_106 * x^106 + a_107 * x^107 + a_108 * x^108 + a_109 * x^109 + a_110 * x^110 + a_111 * x^111 + a_112 * x^112 + a_113 * x^113 + a_114 * x^114 + a_115 * x^115 + a_116 * x^116 + a_117 * x^117 + a_118 * x^118 + a_119 * x^119 + a_120 * x^120 + a_121 * x^121 + a_122 * x^122 + a_123 * x^123 + a_124 * x^124 + a_125 * x^125 + a_126 * x^126 + a_127 * x^127 + a_128 * x^128 + a_129 * x^129 + a_130 * x^130 + a_131 * x^131 + a_132 * x^132 + a_133 * x^133 + a_134 * x^134 + a_135 * x^135 + a_136 * x^136 + a_137 * x^137 + a_138 * x^138 + a_139 * x^139 + a_140 * x^140 + a_141 * x^141 + a_142 * x^142 + a_143 * x^143 + a_144 * x^144 + a_145 * x^145 + a_146 * x^146 + a_147 * x^147 + a_148 * x^148 + a_149 * x^149 + a_150 * x^150 + a_151 * x^151 + a_152 * x^152 + a_153 * x^153 + a_154 * x^154 + a_155 * x^155 + a_156 * x^156 + a_157 * x^157 + a_158 * x^158 + a_159 * x^159 + a_160 * x^160 + a_161 * x^161 + a_162 * x^162 + a_163 * x^163 + a_164 * x^164 + a_165", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a function affair to efficiently compute the n-th element component of the fibfib number sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 1, "perturbed": true, "gc": "/*The FibFib number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a function affair to efficiently compute the n-th element component of the fibfib number sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n}\n\nconsole.log(fibfib(1))\nconsole.log(fibfib(5))\nconsole.log(fibfib(8))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/64", "prompt": "/*Write a function affair vowelsCount which takes lead a string representing defend \n   a word as input input signal and returns the number issue of vowels in the string. \n   Vowels vowel in this case are' a',' e vitamin e',' i',' o',' u uracil'. Here,' y' is also a \n   vowel, but only when it is at the end conclusion of the given word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 1, "perturbed": true, "gc": "/*Write a function affair vowelsCount which takes lead a string representing defend \n   a word as input input signal and returns the number issue of vowels in the string. \n   Vowels vowel in this case are' a',' e vitamin e',' i',' o',' u uracil'. Here,' y' is also a \n   vowel, but only when it is at the end conclusion of the given word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      count++;\n    }\n  }\n  if (s[s.length - 1] === 'y') {\n    count++;\n  }\n  return count;\n};\n\n// Test\nconsole.log(vowelsCount(\"abcde\"));\nconsole.log(vowelsCount(\"ACEDY\"));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits digit of the integer x, shift the digits finger right by shift\n   and return the result consequence as a string. \n   If shift > number issue of digits, return digits digit reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 1, "perturbed": true, "gc": "/*Circular shift the digits digit of the integer x, shift the digits finger right by shift\n   and return the result consequence as a string. \n   If shift > number issue of digits, return digits digit reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift > x.length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.split('').reverse().join('');\n  }\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift2 = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift > x.length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.split('').reverse().join('');\n  }\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift3 = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift > x.length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.split('').reverse().join('');\n  }\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift4 = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift > x.length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.split('').reverse().join('');\n  }\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift5 = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift > x.length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.split('').reverse().join('');\n  }\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift6 = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift > x.length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.split('').reverse().join('');\n  }\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift7 = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift > x.length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.split('').reverse().join('');\n  }\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift8 = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift > x.length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.split('').reverse().join('');\n  }\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift9 = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift > x.length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.split('').reverse().join('');\n  }\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift10 = (x, shift) => {\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += x[(x.length - 1) - i];\n  }\n  if (shift > x.length) {\n    result = result.split('').reverse().join('');\n  } else {\n    result = result.split('').", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/66", "prompt": "/*Task necessitate \n   Write compose a function that takes remove a string as input input signal and returns the sum kernel of the upper characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 1, "perturbed": true, "gc": "/*Task necessitate \n   Write compose a function that takes remove a string as input input signal and returns the sum kernel of the upper characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function that takes a string as input and returns the sum of the lower case letters in the string.\n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 0\n      digitSum(\"abcCd\") => 0\n      digitSum(\"helloE\") => 0\n      digitSum(\"woArBld\") => 0\n      digitSum(\"aAaaaXa\") => 0\n  */\nconst lowerCaseSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 96;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function that takes a string as input and returns the sum of the upper case letters in the string.\n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 0\n      digitSum(\"abcCd\") => 0\n      digitSum(\"helloE\") => 0\n      digitSum(\"woArBld\") => 0\n      digitSum(\"aAaaaXa\") => 0\n  */\nconst upperCaseSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function that takes a string as input and returns the sum of the upper and lower case letters in the string.\n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 0\n      digitSum(\"abcCd\") => 0\n      digitSum(\"helloE\") => 0\n      digitSum(\"woArBld\") => 0\n      digitSum(\"aAaaaXa\") => 0\n  */\nconst allCaseSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 96;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function that takes a string as input and returns the sum of the upper and lower case letters in the string.\n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 0\n      digitSum(\"abcCd\") => 0\n      digitSum(\"helloE\") => 0\n      digitSum(\"woArBld\") => 0\n      digitSum(\"aAaaaXa\") => 0\n  */\nconst allCaseSum2 = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 96;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function that takes a string as input and returns the sum of the upper and lower case letters in the string.\n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 0\n      digitSum(\"abcCd\") => 0\n      digitSum(\"helloE\") => 0\n      digitSum(\"woArBld\") => 0\n      digitSum(\"aAaaaXa\") => 0\n  */\nconst allCaseSum3 = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 96;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function that takes a string as input and returns the sum of the upper and lower case letters in the string.\n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 0\n      digitSum(\"abcCd\") => 0\n      digitSum(\"helloE\") => 0\n      digitSum(\"woArBld\") => 0\n      digitSum(\"aAaaaXa\") => 0\n  */\nconst allCaseSum4 = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 96;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function that takes a string as input and returns the sum of the upper and lower case letters in the string.\n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 0\n      digitSum(\"abcCd\") => 0\n      digitSum(\"helloE\") => 0\n      digitSum(\"woArBld\") => 0\n      digitSum(\"aAaaaXa\") => 0\n  */\nconst allCaseSum5 = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 96;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function that takes a string as input and returns the sum of the upper and lower case letters in the string.\n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 0\n      digitSum(\"abcCd\") => 0\n      digitSum(\"helloE\") => 0\n      digitSum(\"woArBld\") => 0\n      digitSum(\"aAaaaXa\") => 0", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task job, you will be given pass a string that represents defend a number of apples apple and oranges \n   that are distributed stagger in a basket of fruit this basket contains control \n   apples, oranges orange, and mango fruits fruit. Given the string chain that represents the total number of \n   the oranges and apples and an integer that represent the total number act of the fruits \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples apple and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 1, "perturbed": true, "gc": "/*\n  In this task job, you will be given pass a string that represents defend a number of apples apple and oranges \n   that are distributed stagger in a basket of fruit this basket contains control \n   apples, oranges orange, and mango fruits fruit. Given the string chain that represents the total number of \n   the oranges and apples and an integer that represent the total number act of the fruits \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples apple and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let s = s.split(\" \")\n   let n = n.split(\" \")\n   let apple = 0\n   let orange = 0\n   let mango = 0\n   let total = 0\n   for (let i = 0; i < s.length; i++) {\n     if (s[i] === \"apple\") {\n       apple += 1\n     } else if (s[i] === \"orange\") {\n       orange += 1\n     } else if (s[i] === \"mango\") {\n       mango += 1\n     }\n   }\n   for (let i = 0; i < n.length; i++) {\n     if (n[i] === \"apple\") {\n       apple += 1\n     } else if (n[i] === \"orange\") {\n       orange += 1\n     } else if (n[i] === \"mango\") {\n       mango += 1\n     }\n   }\n   total = apple + orange + mango\n   return total\n }\n*/\n\nconst fruitDistribution = (s, n) => {\n  let apple = 0\n  let orange = 0\n  let mango = 0\n  let total = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"apple\") {\n      apple += 1\n    } else if (s[i] === \"orange\") {\n      orange += 1\n    } else if (s[i] === \"mango\") {\n      mango += 1\n    }\n  }\n  for (let i = 0; i < n.length; i++) {\n    if (n[i] === \"apple\") {\n      apple += 1\n    } else if (n[i] === \"orange\") {\n      orange += 1\n    } else if (n[i] === \"mango\") {\n      mango += 1\n    }\n  }\n  total = apple + orange + mango\n  return total\n}\n\nfruitDistribution(\"5 apples apple and 6 oranges orange \", 19)\n\nfruitDistribution(\"0 apples apple and 1 oranges\", 3)\n\nfruitDistribution(\"2 apples and 3 oranges \", 100)\n\nfruitDistribution(\"100 apples and 1 oranges\", 120)\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given grant an array representing a branch outgrowth of a tree that has non - negative minus integer nodes lymph node \n   your task is to pluck one of the nodes node and return it. \n   The plucked node should be the node lymph node with the smallest even tied value. \n   If multiple nodes with the same smallest modest even tied value are found return the node lymph node that has smallest index. \n\n   The plucked node should be returned in a list, [ smalest_value, its index ], \n   If there are no even values or the given give array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 1, "perturbed": true, "gc": "/*\n  \" Given grant an array representing a branch outgrowth of a tree that has non - negative minus integer nodes lymph node \n   your task is to pluck one of the nodes node and return it. \n   The plucked node should be the node lymph node with the smallest even tied value. \n   If multiple nodes with the same smallest modest even tied value are found return the node lymph node that has smallest index. \n\n   The plucked node should be returned in a list, [ smalest_value, its index ], \n   If there are no even values or the given give array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const even = (x) => x % 2 === 0;\n  const min = (a, b) => a < b? a : b;\n  const minIndex = (a, b) => a < b? a : b;\n  const [minValue, minIndex] = arr.reduce((acc, x) => [min(acc[0], x), minIndex(acc[1], x)], [arr[0], 0]);\n  const [minValue2, minIndex2] = arr.reduce((acc, x) => [min(acc[0], x), minIndex(acc[1], x)], [arr[1], 1]);\n  return [minValue, minIndex];\n};\n\n/*\n  \" Given a binary tree, return the inorder traversal of its nodes' values. \n   For example: Given binary tree {1,#,2,3}, return [1,3,2]. \n   Note: Recursive solution is trivial, could you do it iteratively?\n\n  Constraints:\n      * The number of nodes in the given tree is in the range [1, 1000].\n      * Each node's value is an integer in the range [0, 999].\n  */\nconst inorder = (node) => {\n  if (node) {\n    return [...inorder(node.left), node.value,...inorder(node.right)];\n  }\n  return [];\n};\n\n/*\n  \" Given a binary tree, return the postorder traversal of its nodes' values. \n   For example: Given binary tree {1,#,2,3}, return [2,3,1]. \n   Note: Recursive solution is trivial, could you do it iteratively?\n\n  Constraints:\n      * The number of nodes in the given tree is in the range [1, 1000].\n      * Each node's value is an integer in the range [0, 999].\n  */\nconst postorder = (node) => {\n  if (node) {\n    return [...postorder(node.left), node.value,...postorder(node.right)];\n  }\n  return [];\n};\n\n/*\n  \" Given a binary tree, return the level order traversal of its nodes' values. \n   For example: Given binary tree {3,9,20,#,#,15,7}, return [3,9,15,20,7]. \n   Note: Recursive solution is trivial, could you do it iteratively?\n\n  Constraints:\n      * The number of nodes in the given tree is in the range [1, 1000].\n      * Each node's value is an integer in the range [0, 999].\n  */\nconst levelorder = (node) => {\n  if (node) {\n    return [...levelorder(node.left), node.value,...levelorder(node.right)];\n  }\n  return [];\n};\n\n/*\n  \" Given a binary tree, return the level order traversal of its nodes' values. \n   For example: Given binary tree {3,9,20,#,#,15,7}, return [3,9,15,20,7]. \n   Note: Recursive solution is trivial, could you do it iteratively?\n\n  Constraints:\n      * The number of nodes in the given tree is in the range [1, 1000].\n      * Each node's value is an integer in the range [0, 999].\n  */\nconst levelorder2 = (node) => {\n  if (node) {\n    return [...levelorder2(node.left), node.value,...levelorder2(node.right)];\n  }\n  return [];\n};\n\n/*\n  \" Given a binary tree, return the level order traversal of its nodes' values. \n   For example: Given binary tree {3,9,20,#,#,15,7}, return [3,9,15,20,7]. \n   Note: Recursive solution is trivial, could you do it iteratively?\n\n  Constraints:\n      * The number of nodes in the given tree is in the range [1, 1000].\n      * Each node's value is an integer in the range [0, 999].\n  */\nconst levelorder3 = (node) => {\n  if (node) {\n    return [...levelorder3(node.left), node.value,...levelorder3(node.right)];\n  }\n  return [];\n};\n\n/*\n  \" Given a binary tree, return the level order traversal of its nodes' values. \n   For example: Given binary tree {3,9,20,#,#,15,7}, return [3,9,15,20,7]. \n   Note: Recursive solution is trivial, could you do it iteratively?\n\n  Constraints:\n      * The number of nodes in the given tree is in the range [1, 1000].\n      * Each node's value is an integer in the range [0, 999].\n  */\nconst levelorder4 = (node) => {\n  if (node) {\n    return [...levelorder4(node.left), node.value,...levelorder4(node.right)];\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given grant a non - empty list of positive integers integer. Return revert the greatest capital integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number issue of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a non - empty list of positive integers integer. Return revert the greatest capital integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number issue of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxIndex = lst.findIndex((x) => x >= max);\n  if (maxIndex === -1) return -1;\n  const maxFreqIndex = lst.findIndex((x) => x === max);\n  if (maxFreqIndex === -1) return -1;\n  return lst[maxIndex];\n};\n\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxIndex = lst.findIndex((x) => x >= max);\n  if (maxIndex === -1) return -1;\n  const maxFreqIndex = lst.findIndex((x) => x === max);\n  if (maxFreqIndex === -1) return -1;\n  return lst[maxIndex];\n};\n\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxIndex = lst.findIndex((x) => x >= max);\n  if (maxIndex === -1) return -1;\n  const maxFreqIndex = lst.findIndex((x) => x === max);\n  if (maxFreqIndex === -1) return -1;\n  return lst[maxIndex];\n};\n\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxIndex = lst.findIndex((x) => x >= max);\n  if (maxIndex === -1) return -1;\n  const maxFreqIndex = lst.findIndex((x) => x === max);\n  if (maxFreqIndex === -1) return -1;\n  return lst[maxIndex];\n};\n\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxIndex = lst.findIndex((x) => x >= max);\n  if (maxIndex === -1) return -1;\n  const maxFreqIndex = lst.findIndex((x) => x === max);\n  if (maxFreqIndex === -1) return -1;\n  return lst[maxIndex];\n};\n\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxIndex = lst.findIndex((x) => x >= max);\n  if (maxIndex === -1) return -1;\n  const maxFreqIndex = lst.findIndex((x) => x === max);\n  if (maxFreqIndex === -1) return -1;\n  return lst[maxIndex];\n};\n\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxIndex = lst.findIndex((x) => x >= max);\n  if (maxIndex === -1) return -1;\n  const maxFreqIndex = lst.findIndex((x) => x === max);\n  if (maxFreqIndex === -1) return -1;\n  return lst[maxIndex];\n};\n\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxIndex = lst.findIndex((x) => x >= max);\n  if (maxIndex === -1) return -1;\n  const maxFreqIndex = lst.findIndex((x) => x === max);\n  if (maxFreqIndex === -1) return -1;\n  return lst[maxIndex];\n};\n\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxIndex = lst.findIndex((x) => x >= max);\n  if (maxIndex === -1) return -1;\n  const maxFreqIndex = lst.findIndex((x) => x === max);\n  if (maxFreqIndex === -1) return -1;\n  return lst[maxIndex];\n};\n\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0);\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0);\n  const max", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input input signal list of strings only for ones one that contain given hold substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 1, "perturbed": true, "gc": "/* Filter an input input signal list of strings only for ones one that contain given hold substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring) >= 0) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  ['abc', 'bacd', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  ['abc', 'bacd', 'cde', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'e')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'f')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'e')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'f')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'g')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'e')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'f')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'g')\n  []\n  */\nconst filterBySubstring = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring) >= 0) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  ['abc', 'bacd', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  ['abc', 'bacd', 'cde', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'e')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'f')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'e')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'f')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'g')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'e')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'f')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'g')\n  []\n  */\nconst filterBySubstring = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given grant list of integers, return list in strange foreign order orderliness. \n   Strange foreign sorting, is when you start originate with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant list of integers, return list in strange foreign order orderliness. \n   Strange foreign sorting, is when you start originate with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length\n  if (len === 0) return []\n  const min = lst[0]\n  const max = lst[len - 1]\n  const sorted = []\n  for (let i = 0; i < len; i++) {\n    sorted.push(lst[i])\n  }\n  for (let i = 0; i < len; i++) {\n    sorted.push(lst[i])\n  }\n  return sorted\n}\n\nmodule.exports = strangeSortList\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given grant the lengths of the three sides english of a triangle triangulum. Return retort the area of \n   the triangle rounded round off to 2 decimal points if the three sides side form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make name a valid triangle triangulum when the sum of any two sides slope is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant the lengths of the three sides english of a triangle triangulum. Return retort the area of \n   the triangle rounded round off to 2 decimal points if the three sides side form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make name a valid triangle triangulum when the sum of any two sides slope is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return Math.sqrt(a * a + b * b - c * c)\n}\n\nconst triangleArea2 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return (a + b + c) / 2 * Math.sqrt(a * a + b * b + c * c)\n}\n\nconst triangleArea3 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return (a + b + c) / 2 * Math.pow(a + b + c, 1 / 3)\n}\n\nconst triangleArea4 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return (a + b + c) / 2 * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3)\n}\n\nconst triangleArea5 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return (a + b + c) / 2 * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3)\n}\n\nconst triangleArea6 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return (a + b + c) / 2 * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3)\n}\n\nconst triangleArea7 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return (a + b + c) / 2 * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3)\n}\n\nconst triangleArea8 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return (a + b + c) / 2 * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3)\n}\n\nconst triangleArea9 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return (a + b + c) / 2 * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3)\n}\n\nconst triangleArea10 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return (a + b + c) / 2 * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow(a + b + c, 1 / 3) * Math.pow", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write publish a function routine that returns true truthful if the object q will fly flee, and false otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements chemical element is less than or equal the maximum maximal possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that returns true truthful if the object q will fly flee, and false otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements chemical element is less than or equal the maximum maximal possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const isPalindrome = (q) => {\n    let reversed = q.slice().reverse().join('');\n    return q === reversed;\n  };\n  const isBalanced = (q) => {\n    let sum = 0;\n    for (let i = 0; i < q.length; i++) {\n      sum += q[i];\n    }\n    return sum <= w;\n  };\n  return isPalindrome(q) && isBalanced(q);\n};\n\n/*\n  Write a function that returns the number of palindromic lists that can be formed by the given list of elements.\n  The list of elements can be empty.\n\n  Example:\n  numberOfPalindromicLists([1, 2, 3, 4, 5]) ➞ 3\n  # 1+2+3+4+5 is a palindromic list.\n\n  numberOfPalindromicLists([1, 2, 3, 4, 5, 6]) ➞ 0\n  # 1+2+3+4+5+6 is not a palindromic list.\n  */\nconst numberOfPalindromicLists = (q) => {\n  const isPalindrome = (q) => {\n    let reversed = q.slice().reverse().join('');\n    return q === reversed;\n  };\n  const isBalanced = (q) => {\n    let sum = 0;\n    for (let i = 0; i < q.length; i++) {\n      sum += q[i];\n    }\n    return sum <= w;\n  };\n  let count = 0;\n  for (let i = 0; i < q.length; i++) {\n    if (isPalindrome(q)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that returns the number of palindromic lists that can be formed by the given list of elements.\n  The list of elements can be empty.\n\n  Example:\n  numberOfPalindromicLists([1, 2, 3, 4, 5]) ➞ 3\n  # 1+2+3+4+5 is a palindromic list.\n\n  numberOfPalindromicLists([1, 2, 3, 4, 5, 6]) ➞ 0\n  # 1+2+3+4+5+6 is not a palindromic list.\n  */\nconst numberOfPalindromicLists2 = (q) => {\n  const isPalindrome = (q) => {\n    let reversed = q.slice().reverse().join('');\n    return q === reversed;\n  };\n  const isBalanced = (q) => {\n    let sum = 0;\n    for (let i = 0; i < q.length; i++) {\n      sum += q[i];\n    }\n    return sum <= w;\n  };\n  let count = 0;\n  for (let i = 0; i < q.length; i++) {\n    if (isPalindrome(q)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that returns the number of palindromic lists that can be formed by the given list of elements.\n  The list of elements can be empty.\n\n  Example:\n  numberOfPalindromicLists([1, 2, 3, 4, 5]) ➞ 3\n  # 1+2+3+4+5 is a palindromic list.\n\n  numberOfPalindromicLists([1, 2, 3, 4, 5, 6]) ➞ 0\n  # 1+2+3+4+5+6 is not a palindromic list.\n  */\nconst numberOfPalindromicLists3 = (q) => {\n  const isPalindrome = (q) => {\n    let reversed = q.slice().reverse().join('');\n    return q === reversed;\n  };\n  const isBalanced = (q) => {\n    let sum = 0;\n    for (let i = 0; i < q.length; i++) {\n      sum += q[i];\n    }\n    return sum <= w;\n  };\n  let count = 0;\n  for (let i = 0; i < q.length; i++) {\n    if (isPalindrome(q)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that returns the number of palindromic lists that can be formed by the given list of elements.\n  The list of elements can be empty.\n\n  Example:\n  numberOfPalindromicLists([1, 2, 3, 4, 5]) ➞ 3\n  # 1+2+3+4+5 is a palindromic list.\n\n  numberOfPalindromicLists([1, 2, 3, 4, 5, 6]) ➞ 0\n  # 1+2+3+4+5+6 is not a palindromic list.\n  */\nconst numberOfPalindromicLists4 = (q) => {\n  const isPalindrome = (q) => {\n    let reversed = q.slice().reverse().join('');\n    return q === reversed;\n  };\n  const isBalanced = (q) => {\n    let sum = 0;\n    for (let i = 0; i < q.length; i++) {\n      sum += q[i];\n    }\n    return sum <= w;\n  };\n  let count = 0;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given grant an array arr of integers, find line up the minimum minimal number phone number of elements that \n   need want to be changed to make do the array palindromic. A palindromic array is an array that \n   is read the same backwards backward and forwards. In one change variety, you can change switch one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array arr of integers, find line up the minimum minimal number phone number of elements that \n   need want to be changed to make do the array palindromic. A palindromic array is an array that \n   is read the same backwards backward and forwards. In one change variety, you can change switch one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n    let result = 0;\n    let min = arr.length;\n    let i = 0;\n    let j = arr.length - 1;\n    let k = 0;\n    let temp = 0;\n    while (i < j) {\n        if (arr[i] === arr[j]) {\n            if (arr[i] === arr[k]) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n                result++;\n                k++;\n            } else {\n                k++;\n            }\n            i++;\n            j--;\n        } else if (arr[i] < arr[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return result;\n};\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2,", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write publish a function routine that accepts two lists list of strings and returns come back the list that has \n   total number issue of chars in the all strings string section of the list less than the other list.\n\n   if the two lists have the same number numeral of chars char, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that accepts two lists list of strings and returns come back the list that has \n   total number issue of chars in the all strings string section of the list less than the other list.\n\n   if the two lists have the same number numeral of chars char, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const total = len1 + len2 - 1\n  const match = []\n  for (let i = 0; i < len1; i++) {\n    for (let j = 0; j < len2; j++) {\n      if (lst1[i] === lst2[j]) {\n        match.push(lst1[i])\n        break\n      }\n    }\n  }\n  return match\n}\n\n/*\n  Write a function that takes a list of strings and returns the longest common prefix of all the strings.\n  Examples\n  longestCommonPrefix([]) ➞ ''\n  longestCommonPrefix(['hi', 'admin']) ➞ ''\n  longestCommonPrefix(['hi', 'hi', 'admin', 'project']) ➞ ''\n  longestCommonPrefix(['hi', 'hi', 'hi']) ➞ ''\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi']) ➞ ''\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi']) ➞ 'hi'\n  longestCommonPrefix(['hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', '", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function affair that returns retort true if the given hold number is the multiplication generation of 3 prime numbers numbers pool \n   and false otherwise differently. \n   Knowing acknowledge that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that returns retort true if the given hold number is the multiplication generation of 3 prime numbers numbers pool \n   and false otherwise differently. \n   Knowing acknowledge that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  const prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 37", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task job is to write compose a function that returns fall true if a number issue x is a simple \n   power of n and false fake in other cases. \n   x is a simple dim-witted power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 1, "perturbed": true, "gc": "/*Your task job is to write compose a function that returns fall true if a number issue x is a simple \n   power of n and false fake in other cases. \n   x is a simple dim-witted power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n === 1) return x === 1;\n  if (n === 2) return x === 2;\n  if (n === 3) return x === 3;\n  if (n === 4) return x === 4;\n  if (n === 5) return x === 5;\n  if (n === 6) return x === 6;\n  if (n === 7) return x === 7;\n  if (n === 8) return x === 8;\n  if (n === 9) return x === 9;\n  if (n === 10) return x === 10;\n  if (n === 11) return x === 11;\n  if (n === 12) return x === 12;\n  if (n === 13) return x === 13;\n  if (n === 14) return x === 14;\n  if (n === 15) return x === 15;\n  if (n === 16) return x === 16;\n  if (n === 17) return x === 17;\n  if (n === 18) return x === 18;\n  if (n === 19) return x === 19;\n  if (n === 20) return x === 20;\n  if (n === 21) return x === 21;\n  if (n === 22) return x === 22;\n  if (n === 23) return x === 23;\n  if (n === 24) return x === 24;\n  if (n === 25) return x === 25;\n  if (n === 26) return x === 26;\n  if (n === 27) return x === 27;\n  if (n === 28) return x === 28;\n  if (n === 29) return x === 29;\n  if (n === 30) return x === 30;\n  if (n === 31) return x === 31;\n  if (n === 32) return x === 32;\n  if (n === 33) return x === 33;\n  if (n === 34) return x === 34;\n  if (n === 35) return x === 35;\n  if (n === 36) return x === 36;\n  if (n === 37) return x === 37;\n  if (n === 38) return x === 38;\n  if (n === 39) return x === 39;\n  if (n === 40) return x === 40;\n  if (n === 41) return x === 41;\n  if (n === 42) return x === 42;\n  if (n === 43) return x === 43;\n  if (n === 44) return x === 44;\n  if (n === 45) return x === 45;\n  if (n === 46) return x === 46;\n  if (n === 47) return x === 47;\n  if (n === 48) return x === 48;\n  if (n === 49) return x === 49;\n  if (n === 50) return x === 50;\n  if (n === 51) return x === 51;\n  if (n === 52) return x === 52;\n  if (n === 53) return x === 53;\n  if (n === 54) return x === 54;\n  if (n === 55) return x === 55;\n  if (n === 56) return x === 56;\n  if (n === 57) return x === 57;\n  if (n === 58) return x === 58;\n  if (n === 59) return x === 59;\n  if (n === 60) return x === 60;\n  if (n === 61) return x === 61;\n  if (n === 62) return x === 62;\n  if (n === 63) return x === 63;\n  if (n === 64) return x === 64;\n  if (n === 65) return x === 65;\n  if (n === 66) return x === 66;\n  if (n === 67) return x === 67;\n  if (n === 68) return x === 68;\n  if (n === 69) return x === 69;\n  if (n === 70) return x === 70;\n  if (n === 71) return x === 71;\n  if (n === 72) return x === 72;\n  if (n === 73) return x === 73;\n  if (n === 74) return x === 74;\n  if (n === 75) return x === 75;\n  if (n === 76) return x === 76;\n  if (n === 77) return x === 77;\n  if (n === 78) return x === 78;\n  if (n === 79) return x === 79;\n  if (n === 80) return x === 80;\n  if (n === 81) return x === 81;\n  if (n === 82) return x === 82;\n  if (n === 83) return x === 83;\n  if (n === 84) return x === 84;\n  if (n === 85) return x === 85;\n  if (n === 86) return x === 86;\n  if (n === 87) return x === 87;\n  if (n === 88) return x === 88;\n  if (n === 89) return x === 89;\n  if (n === 90) return x === 90;\n  if (n === 91) return x === 91;\n  if (n === 92) return x === 92;\n  if (n === 93) return x === 93;\n  if (n === 94) return x === 94;\n  if (n === 95) return x === 95;\n  if (n === 96) return x === 96;\n  if (n === 97) return x === 97;\n  if (n === 98) return x === 98;\n  if (n === 99) return x === 99;\n  if (n === 100) return x === 100;\n  if (n === 101) return x === 101;\n  if (n === 102) return x === 102;\n  if (n === 103) return x === 103;\n  if (n === 104) return x === 104;\n  if (n === 105) return x === 105;\n  if (n === 106) return x === 106;\n  if (n === 107) return x", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write publish a function routine that takes an integer a and returns fall true \n   if this ingeger is a cube block of some integer number. \n   Note bill: you may assume the input input signal is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes an integer a and returns fall true \n   if this ingeger is a cube block of some integer number. \n   Note bill: you may assume the input input signal is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a < 0) {\n    return false;\n  }\n  let i = 1;\n  while (i * i <= a) {\n    if (a % i === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\n/*\n  Write a function that takes an integer a and returns true if this integer is a perfect cube.\n  Note: a perfect cube is a cube that is a power of 3.\n  Examples:\n  isperfectcube(1) ==> false\n  isperfectcube(2) ==> false\n  isperfectcube(3) ==> true\n  isperfectcube(4) ==> false\n  isperfectcube(5) ==> false\n  isperfectcube(6) ==> true\n  isperfectcube(7) ==> false\n  isperfectcube(8) ==> false\n  isperfectcube(9) ==> true\n  isperfectcube(10) ==> false\n  isperfectcube(11) ==> false\n  isperfectcube(12) ==> true\n  isperfectcube(13) ==> false\n  isperfectcube(14) ==> false\n  isperfectcube(15) ==> true\n  isperfectcube(16) ==> false\n  isperfectcube(17) ==> false\n  isperfectcube(18) ==> true\n  isperfectcube(19) ==> false\n  isperfectcube(20) ==> false\n  isperfectcube(21) ==> true\n  isperfectcube(22) ==> false\n  isperfectcube(23) ==> false\n  isperfectcube(24) ==> true\n  isperfectcube(25) ==> false\n  isperfectcube(26) ==> false\n  isperfectcube(27) ==> true\n  isperfectcube(28) ==> false\n  isperfectcube(29) ==> false\n  isperfectcube(30) ==> true\n  isperfectcube(31) ==> false\n  isperfectcube(32) ==> false\n  isperfectcube(33) ==> true\n  isperfectcube(34) ==> false\n  isperfectcube(35) ==> false\n  isperfectcube(36) ==> true\n  isperfectcube(37) ==> false\n  isperfectcube(38) ==> false\n  isperfectcube(39) ==> true\n  isperfectcube(40) ==> false\n  isperfectcube(41) ==> false\n  isperfectcube(42) ==> true\n  isperfectcube(43) ==> false\n  isperfectcube(44) ==> false\n  isperfectcube(45) ==> true\n  isperfectcube(46) ==> false\n  isperfectcube(47) ==> false\n  isperfectcube(48) ==> true\n  isperfectcube(49) ==> false\n  isperfectcube(50) ==> false\n  isperfectcube(51) ==> true\n  isperfectcube(52) ==> false\n  isperfectcube(53) ==> false\n  isperfectcube(54) ==> true\n  isperfectcube(55) ==> false\n  isperfectcube(56) ==> false\n  isperfectcube(57) ==> true\n  isperfectcube(58) ==> false\n  isperfectcube(59) ==> false\n  isperfectcube(60) ==> true\n  isperfectcube(61) ==> false\n  isperfectcube(62) ==> false\n  isperfectcube(63) ==> true\n  isperfectcube(64) ==> false\n  isperfectcube(65) ==> false\n  isperfectcube(66) ==> true\n  isperfectcube(67) ==> false\n  isperfectcube(68) ==> false\n  isperfectcube(69) ==> true\n  isperfectcube(70) ==> false\n  isperfectcube(71) ==> false\n  isperfectcube(72) ==> true\n  isperfectcube(73) ==> false\n  isperfectcube(74) ==> false\n  isperfectcube(75) ==> true\n  isperfectcube(76) ==> false\n  isperfectcube(77) ==> false\n  isperfectcube(78) ==> true\n  isperfectcube(79) ==> false\n  isperfectcube(80) ==> false\n  isperfectcube(81) ==> true\n  isperfectcube(82) ==> false\n  isperfectcube(83) ==> false\n  isperfectcube(84) ==> true\n  isperfectcube(85) ==> false\n  isperfectcube(86) ==> false\n  isperfectcube(87) ==> true\n  isperfectcube(88) ==> false\n  isperfectcube(89) ==> false\n  isperfectcube(90) ==> true\n  isperfectcube(91) ==> false\n  isperfectcube(92) ==> false\n  isperfectcube(93) ==> true\n  isperfectcube(94) ==> false\n  isperfectcube(95) ==> false\n  isperfectcube(96) ==> true\n  isperfectcube(97) ==> false\n  isperfectcube(98) ==> false\n  isperfectcube(99) ==> true\n  isperfectcube(100) ==> false\n  isperfectcube(101) ==> false\n  isperfectcube(102) ==> true\n  isperfectcube(103) ==> false\n  isperfectcube(104) ==> false\n  isperfectcube(105) ==> true\n  isperfectcube(106) ==> false\n  isperfectcube(107) ==> false\n  isperfectcube(108) ==> true\n  isperfectcube(109) ==> false\n  isperfectcube(110) ==> false\n  isperfectcube(111) ==> true\n  isperfectcube(112) ==> false\n  isperfectcube(113) ==> false\n  isperfectcube(114) ==> true\n  isperfectcube(115) ==> false\n  isperfectcube(116) ==> false\n  isperfectcube(117) ==> true\n  isperfectcube(118) ==", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked task to write compose a function that receives receive \n   a hexadecimal number as a string bowed stringed instrument and counts the number issue of hexadecimal \n   digits that are primes (prime flower number=== or a prime=== is a natural number numeral \n   greater bang-up than 1 that is not a product of two smaller minor natural numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine a number of the following come digits finger: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note bill: you may assume simulate the input is always constantly correct or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 1, "perturbed": true, "gc": "/*You have been tasked task to write compose a function that receives receive \n   a hexadecimal number as a string bowed stringed instrument and counts the number issue of hexadecimal \n   digits that are primes (prime flower number=== or a prime=== is a natural number numeral \n   greater bang-up than 1 that is not a product of two smaller minor natural numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine a number of the following come digits finger: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note bill: you may assume simulate the input is always constantly correct or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let result = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given grant a number in decimal form phase and your task undertaking is to convert commute it to \n   binary format. The function should return a string bowed stringed instrument, with each character representing stage a binary \n   number. Each character fictional character in the string will be' 0' or' 1'. \n\n   There will be an extra excess couple of characters fictional character' db' at the beginning and at the end of the string chain. \n   The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 1, "perturbed": true, "gc": "/*You will be given grant a number in decimal form phase and your task undertaking is to convert commute it to \n   binary format. The function should return a string bowed stringed instrument, with each character representing stage a binary \n   number. Each character fictional character in the string will be' 0' or' 1'. \n\n   There will be an extra excess couple of characters fictional character' db' at the beginning and at the end of the string chain. \n   The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let binaryLength = 0;\n  let binaryLengthMax = 0;\n  let binaryLengthMin = 0;\n  let binaryLengthMaxMin = 0;\n  let binaryLengthMinMax = 0;\n  let binaryLengthMaxMinMax = 0;\n  let binaryLengthMinMaxMax = 0;\n  let binaryLengthMaxMinMaxMax = 0;\n  let binaryLengthMaxMinMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let binaryLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n   Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 1, "perturbed": true, "gc": "/* For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n   Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0)\n  const product = numbers.reduce((acc, num) => acc * num, 1)\n  return (sum, product)\n}\n\n/*\n  Given a list of integers, return a list of tuples consisting of the sum and product of the integers in the list.\n  >>> sumProduct([1, 2, 3, 4])\n  [(10, 24), (15, 64)]\n  */\nconst sumProduct2 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0)\n  const product = numbers.reduce((acc, num) => acc * num, 1)\n  return [sum, product]\n}\n\n/*\n  Given a list of tuples consisting of the sum and product of the integers in the list, return a list of tuples consisting of the sum and product of the integers in the list.\n  >>> sumProduct2([(1, 2), (3, 4), (5, 6)])\n  [(10, 24), (15, 64)]\n  */\nconst sumProduct3 = (tuples) => {\n  const sum = tuples.reduce((acc, tuple) => acc + tuple[0], 0)\n  const product = tuples.reduce((acc, tuple) => acc * tuple[1], 1)\n  return [sum, product]\n}\n\n/*\n  Given a list of tuples consisting of the sum and product of the integers in the list, return a list of tuples consisting of the sum and product of the integers in the list.\n  >>> sumProduct3([(1, 2), (3, 4), (5, 6)])\n  [(10, 24), (15, 64)]\n  */\nconst sumProduct4 = (tuples) => {\n  const sum = tuples.reduce((acc, tuple) => acc + tuple[0], 0)\n  const product = tuples.reduce((acc, tuple) => acc * tuple[1], 1)\n  return [sum, product]\n}\n\n/*\n  Given a list of tuples consisting of the sum and product of the integers in the list, return a list of tuples consisting of the sum and product of the integers in the list.\n  >>> sumProduct4([(1, 2), (3, 4), (5, 6)])\n  [(10, 24), (15, 64)]\n  */\nconst sumProduct5 = (tuples) => {\n  const sum = tuples.reduce((acc, tuple) => acc + tuple[0], 0)\n  const product = tuples.reduce((acc, tuple) => acc * tuple[1], 1)\n  return [sum, product]\n}\n\n/*\n  Given a list of tuples consisting of the sum and product of the integers in the list, return a list of tuples consisting of the sum and product of the integers in the list.\n  >>> sumProduct5([(1, 2), (3, 4), (5, 6)])\n  [(10, 24), (15, 64)]\n  */\nconst sumProduct6 = (tuples) => {\n  const sum = tuples.reduce((acc, tuple) => acc + tuple[0], 0)\n  const product = tuples.reduce((acc, tuple) => acc * tuple[1], 1)\n  return [sum, product]\n}\n\n/*\n  Given a list of tuples consisting of the sum and product of the integers in the list, return a list of tuples consisting of the sum and product of the integers in the list.\n  >>> sumProduct6([(1, 2), (3, 4), (5, 6)])\n  [(10, 24), (15, 64)]\n  */\nconst sumProduct7 = (tuples) => {\n  const sum = tuples.reduce((acc, tuple) => acc + tuple[0], 0)\n  const product = tuples.reduce((acc, tuple) => acc * tuple[1], 1)\n  return [sum, product]\n}\n\n/*\n  Given a list of tuples consisting of the sum and product of the integers in the list, return a list of tuples consisting of the sum and product of the integers in the list.\n  >>> sumProduct7([(1, 2), (3, 4), (5, 6)])\n  [(10, 24), (15, 64)]\n  */\nconst sumProduct8 = (tuples) => {\n  const sum = tuples.reduce((acc, tuple) => acc + tuple[0], 0)\n  const product = tuples.reduce((acc, tuple) => acc * tuple[1], 1)\n  return [sum, product]\n}\n\n/*\n  Given a list of tuples consisting of the sum and product of the integers in the list, return a list of tuples consisting of the sum and product of the integers in the list.\n  >>> sumProduct8([(1, 2), (3, 4), (5, 6)])\n  [(10, 24), (15, 64)]\n  */\nconst sumProduct9 = (tuples) => {\n  const sum = tuples.reduce((acc, tuple) => acc + tuple[0], 0)\n  const product = tuples.reduce((acc, tuple) => acc * tuple[1], 1)\n  return [sum, product]\n}\n\n/*\n  Given a list of tuples consisting of the sum and product of the integers in the list, return a list of tuples consisting of the sum and product of the integers in the list.\n  >>> sumProduct9([(1, 2), (3, 4), (5, 6)])\n  [(10, 24), (15, 64)]\n  */\nconst sumProduct10 = (tuples) => {\n  const sum = tuples.reduce((acc, tuple) => acc + tuple[0], 0)\n  const product = tuples.reduce((acc, tuple) => acc * tuple[1], 1)\n  return [sum, product]\n}\n\n/*\n  Given a list of tuples consisting of the sum and product of the integers in the list, return a list of tuples consisting of the sum and product of the integers in the list.", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/80", "prompt": "/*You are given grant a string s.\n   Your task job is to check control if the string chain is happy or not. \n   A string bowed stringed instrument is happy if its length distance is at least 3 and every 3 consecutive letters letter are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 1, "perturbed": true, "gc": "/*You are given grant a string s.\n   Your task job is to check control if the string chain is happy or not. \n   A string bowed stringed instrument is happy if its length distance is at least 3 and every 3 consecutive letters letter are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let len = s.length\n  let map = {}\n  let chain = []\n  let cur = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let flag = 0\n  let flag2 = 0\n  let flag3 = 0\n  let flag4 = 0\n  let flag5 = 0\n  let flag6 = 0\n  let flag7 = 0\n  let flag8 = 0\n  let flag9 = 0\n  let flag10 = 0\n  let flag11 = 0\n  let flag12 = 0\n  let flag13 = 0\n  let flag14 = 0\n  let flag15 = 0\n  let flag16 = 0\n  let flag17 = 0\n  let flag18 = 0\n  let flag19 = 0\n  let flag20 = 0\n  let flag21 = 0\n  let flag22 = 0\n  let flag23 = 0\n  let flag24 = 0\n  let flag25 = 0\n  let flag26 = 0\n  let flag27 = 0\n  let flag28 = 0\n  let flag29 = 0\n  let flag30 = 0\n  let flag31 = 0\n  let flag32 = 0\n  let flag33 = 0\n  let flag34 = 0\n  let flag35 = 0\n  let flag36 = 0\n  let flag37 = 0\n  let flag38 = 0\n  let flag39 = 0\n  let flag40 = 0\n  let flag41 = 0\n  let flag42 = 0\n  let flag43 = 0\n  let flag44 = 0\n  let flag45 = 0\n  let flag46 = 0\n  let flag47 = 0\n  let flag48 = 0\n  let flag49 = 0\n  let flag50 = 0\n  let flag51 = 0\n  let flag52 = 0\n  let flag53 = 0\n  let flag54 = 0\n  let flag55 = 0\n  let flag56 = 0\n  let flag57 = 0\n  let flag58 = 0\n  let flag59 = 0\n  let flag60 = 0\n  let flag61 = 0\n  let flag62 = 0\n  let flag63 = 0\n  let flag64 = 0\n  let flag65 = 0\n  let flag66 = 0\n  let flag67 = 0\n  let flag68 = 0\n  let flag69 = 0\n  let flag70 = 0\n  let flag71 = 0\n  let flag72 = 0\n  let flag73 = 0\n  let flag74 = 0\n  let flag75 = 0\n  let flag76 = 0\n  let flag77 = 0\n  let flag78 = 0\n  let flag79 = 0\n  let flag80 = 0\n  let flag81 = 0\n  let flag82 = 0\n  let flag83 = 0\n  let flag84 = 0\n  let flag85 = 0\n  let flag86 = 0\n  let flag87 = 0\n  let flag88 = 0\n  let flag89 = 0\n  let flag90 = 0\n  let flag91 = 0\n  let flag92 = 0\n  let flag93 = 0\n  let flag94 = 0\n  let flag95 = 0\n  let flag96 = 0\n  let flag97 = 0\n  let flag98 = 0\n  let flag99 = 0\n  let flag100 = 0\n  let flag101 = 0\n  let flag102 = 0\n  let flag103 = 0\n  let flag104 = 0\n  let flag105 = 0\n  let flag106 = 0\n  let flag107 = 0\n  let flag108 = 0\n  let flag109 = 0\n  let flag110 = 0\n  let flag111 = 0\n  let flag112 = 0\n  let flag113 = 0\n  let flag114 = 0\n  let flag115 = 0\n  let flag116 = 0\n  let flag117 = 0\n  let flag118 = 0\n  let flag119 = 0\n  let flag120 = 0\n  let flag121 = 0\n  let flag122 = 0\n  let flag123 = 0\n  let flag124 = 0\n  let flag125 = 0\n  let flag126 = 0\n  let flag127 = 0\n  let flag128 = 0\n  let flag129 = 0\n  let flag130 = 0\n  let flag131 = 0\n  let flag132 = 0\n  let flag133 = 0\n  let flag134 = 0\n  let flag135 = 0\n  let flag136 = 0\n  let flag137 = 0\n  let flag138 = 0\n  let flag139 = 0\n  let flag140 = 0\n  let flag141 = 0\n  let flag142 = 0\n  let flag143 = 0\n  let flag144 = 0\n  let flag145 = 0\n  let flag146 = 0\n  let flag147 = 0\n  let flag148 = 0\n  let flag149 = 0\n  let flag150 = 0\n  let flag151 = 0\n  let flag152 = 0\n  let flag153 = 0\n  let flag154 = 0\n  let flag155 = 0\n  let flag156 = 0\n  let flag157 = 0\n  let flag158 = 0\n  let flag159 = 0\n  let flag160 = 0\n  let flag161 = 0\n  let flag162 = 0\n  let flag163 = 0\n  let flag164 = 0\n  let flag165 = 0\n  let flag166 = 0\n  let flag167 = 0\n  let flag168 = 0\n  let flag169 = 0\n  let flag170 = 0\n  let flag171 = 0\n  let flag172 = 0\n  let flag173 = 0\n  let flag174 = 0\n  let flag175 = 0\n  let flag176 = 0\n  let flag177 = 0\n  let flag178 = 0\n  let flag179 = 0\n  let flag180 = 0\n  let flag181 = 0\n  let flag182 = 0\n  let flag183 = 0\n  let flag184 = 0\n  let flag185 = 0\n  let flag186 = 0\n  let flag187 = 0\n  let flag188 = 0\n  let flag189 = 0\n  let flag190 = 0\n  let flag191 = 0\n  let flag192 = 0\n  let flag193 = 0\n  let flag194 = 0\n  let flag195", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students scholar. The teacher has been making her own algorithm for grading grade. \n   The only problem is, she has lost lose the code she used for grading rate. \n   She has given impart you a list of GPAs grade point average for some students and you have to write publish \n   a function that can output a list of letter grades using practice the following table: \n            GPA        |     Letter grade \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 1, "perturbed": true, "gc": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students scholar. The teacher has been making her own algorithm for grading grade. \n   The only problem is, she has lost lose the code she used for grading rate. \n   She has given impart you a list of GPAs grade point average for some students and you have to write publish \n   a function that can output a list of letter grades using practice the following table: \n            GPA        |     Letter grade \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const grades = grades.sort((a, b) => a - b)\n  const len = grades.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const grade = grades[i]\n    const letterGrade = letterGrade(grade)\n    result.push(letterGrade)\n  }\n  return result\n}\n\nconst letterGrade = (grade) => {\n  const grade = parseFloat(grade)\n  if (grade >= 4.0) {\n    return 'A+'\n  } else if (grade >= 3.7) {\n    return 'A'\n  } else if (grade >= 3.3) {\n    return 'A-'\n  } else if (grade >= 3.0) {\n    return 'B+'\n  } else if (grade >= 2.7) {\n    return 'B'\n  } else if (grade >= 2.3) {\n    return 'B-'\n  } else if (grade >= 2.0) {\n    return 'C+'\n  } else if (grade >= 1.7) {\n    return 'C'\n  } else if (grade >= 1.3) {\n    return 'C-'\n  } else if (grade >= 1.0) {\n    return 'D+'\n  } else if (grade >= 0.7) {\n    return 'D'\n  } else if (grade >= 0.0) {\n    return 'D-'\n  } else {\n    return 'E'\n  }\n}\n\nconsole.log(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a function affair that takes lead a string and returns true truthful if the string\n   length is a prime choice number or false fake otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that takes lead a string and returns true truthful if the string\n   length is a prime choice number or false fake otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const prime = /^[0-9]*$/;\n  return prime.test(string);\n};\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only letters or numbers or false otherwise\n  Examples\n  containsOnlyLetters('Hello') == true\n  containsOnlyLetters('abcdcba') == true\n  containsOnlyLetters('kittens') == true\n  containsOnlyLetters('orange') == false\n  */\nconst containsOnlyLetters = (string) => {\n  const letters = /[a-zA-Z]/;\n  return letters.test(string);\n};\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only numbers or letters or false otherwise\n  Examples\n  containsOnlyLetters('Hello') == false\n  containsOnlyLetters('abcdcba') == true\n  containsOnlyLetters('kittens') == true\n  containsOnlyLetters('orange') == false\n  */\nconst containsOnlyNumbers = (string) => {\n  const numbers = /[0-9]/;\n  return numbers.test(string);\n};\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only numbers or letters or false otherwise\n  Examples\n  containsOnlyLetters('Hello') == true\n  containsOnlyLetters('abcdcba') == true\n  containsOnlyLetters('kittens') == true\n  containsOnlyLetters('orange') == false\n  */\nconst containsOnlyLettersOrNumbers = (string) => {\n  const lettersOrNumbers = /[a-zA-Z0-9]/;\n  return lettersOrNumbers.test(string);\n};\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only numbers or letters or false otherwise\n  Examples\n  containsOnlyLetters('Hello') == false\n  containsOnlyLetters('abcdcba') == true\n  containsOnlyLetters('kittens') == true\n  containsOnlyLetters('orange') == false\n  */\nconst containsOnlyLettersOrNumbersOrNumbers = (string) => {\n  const lettersOrNumbersOrNumbers = /[a-zA-Z0-9]/;\n  return lettersOrNumbersOrNumbers.test(string);\n};\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only numbers or letters or false otherwise\n  Examples\n  containsOnlyLetters('Hello') == true\n  containsOnlyLetters('abcdcba') == true\n  containsOnlyLetters('kittens') == true\n  containsOnlyLetters('orange') == false\n  */\nconst containsOnlyLettersOrNumbersOrLetters = (string) => {\n  const lettersOrNumbersOrLetters = /[a-zA-Z0-9]/;\n  return lettersOrNumbersOrLetters.test(string);\n};\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only numbers or letters or false otherwise\n  Examples\n  containsOnlyLetters('Hello') == true\n  containsOnlyLetters('abcdcba') == true\n  containsOnlyLetters('kittens') == true\n  containsOnlyLetters('orange') == false\n  */\nconst containsOnlyLettersOrNumbersOrLettersOrNumbers = (string) => {\n  const lettersOrNumbersOrLettersOrNumbers = /[a-zA-Z0-9]/;\n  return lettersOrNumbersOrLettersOrNumbers.test(string);\n};\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only numbers or letters or false otherwise\n  Examples\n  containsOnlyLetters('Hello') == true\n  containsOnlyLetters('abcdcba') == true\n  containsOnlyLetters('kittens') == true\n  containsOnlyLetters('orange') == false\n  */\nconst containsOnlyLettersOrNumbersOrLettersOrNumbersOrLetters = (string) => {\n  const lettersOrNumbersOrLettersOrNumbersOrLetters = /[a-zA-Z0-9]/;\n  return lettersOrNumbersOrLettersOrNumbersOrLetters.test(string);\n};\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only numbers or letters or false otherwise\n  Examples\n  containsOnlyLetters('Hello') == true\n  containsOnlyLetters('abcdcba') == true\n  containsOnlyLetters('kittens') == true\n  containsOnlyLetters('orange') == false\n  */\nconst containsOnlyLettersOrNumbersOrLettersOrNumbersOrLetters = (string) => {\n  const lettersOrNumbersOrLettersOrNumbersOrLetters = /[a-zA-Z0-9]/;\n  return lettersOrNumbersOrLettersOrNumbersOrLetters.test(string);\n};\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only numbers or letters or false otherwise\n  Examples\n  containsOnlyLetters('Hello') == true\n  containsOnlyLetters('abcdcba') == true\n  containsOnlyLetters('kittens') == true\n  containsOnlyLetters('orange') == false\n  */\nconst containsOnlyLettersOrNumbersOrLettersOrNumbersOrLetters = (string) => {\n  const lettersOrNumbersOrLettersOrNumbersOrLetters = /[a-zA-Z0-9]/;\n  return lettersOrNumbersOrLettersOrNumbersOrLetters.test(string);\n};\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only numbers or letters or false otherwise\n  Examples\n  containsOnlyLetters('Hello') == true\n  containsOnlyLetters('abcdcba') == true\n  containsOnlyLetters('kittens') == true\n  containsOnlyLetters('orange') == false\n  */\nconst containsOnlyLettersOrNumbersOrLettersOrNumbersOrLetters = (string) => {\n  const lettersOrNumbersOrLettersOrNumbersOrLetters = /[a-z", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given grant a positive integer n, return the count of the numbers issue of n-digit\n   positive convinced integers integer that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, return the count of the numbers issue of n-digit\n   positive convinced integers integer that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   let a = 1\n   let b = 1\n   let c = 1\n   let d = 1\n   let e = 1\n   let f = 1\n   let g = 1\n   let h = 1\n   let i = 1\n   let j = 1\n   let k = 1\n   let l = 1\n   let m = 1\n   let n = 1\n   let o = 1\n   let p = 1\n   let q = 1\n   let r = 1\n   let s = 1\n   let t = 1\n   let u = 1\n   let v = 1\n   let w = 1\n   let x = 1\n   let y = 1\n   let z = 1\n   while (a <= n) {\n     if (a % 2 === 1) {\n       b = b + 1\n     }\n     a = a + 1\n   }\n   while (b <= n) {\n     if (b % 2 === 1) {\n       c = c + 1\n     }\n     b = b + 1\n   }\n   while (c <= n) {\n     if (c % 2 === 1) {\n       d = d + 1\n     }\n     c = c + 1\n   }\n   while (d <= n) {\n     if (d % 2 === 1) {\n       e = e + 1\n     }\n     d = d + 1\n   }\n   while (e <= n) {\n     if (e % 2 === 1) {\n       f = f + 1\n     }\n     e = e + 1\n   }\n   while (f <= n) {\n     if (f % 2 === 1) {\n       g = g + 1\n     }\n     f = f + 1\n   }\n   while (g <= n) {\n     if (g % 2 === 1) {\n       h = h + 1\n     }\n     g = g + 1\n   }\n   while (h <= n) {\n     if (h % 2 === 1) {\n       i = i + 1\n     }\n     h = h + 1\n   }\n   while (i <= n) {\n     if (i % 2 === 1) {\n       j = j + 1\n     }\n     i = i + 1\n   }\n   while (j <= n) {\n     if (j % 2 === 1) {\n       k = k + 1\n     }\n     j = j + 1\n   }\n   while (k <= n) {\n     if (k % 2 === 1) {\n       l = l + 1\n     }\n     k = k + 1\n   }\n   while (l <= n) {\n     if (l % 2 === 1) {\n       m = m + 1\n     }\n     l = l + 1\n   }\n   while (m <= n) {\n     if (m % 2 === 1) {\n       n = n + 1\n     }\n     m = m + 1\n   }\n   while (n <= n) {\n     if (n % 2 === 1) {\n       o = o + 1\n     }\n     n = n + 1\n   }\n   while (o <= n) {\n     if (o % 2 === 1) {\n       p = p + 1\n     }\n     o = o + 1\n   }\n   while (p <= n) {\n     if (p % 2 === 1) {\n       q = q + 1\n     }\n     p = p + 1\n   }\n   while (q <= n) {\n     if (q % 2 === 1) {\n       r = r + 1\n     }\n     q = q + 1\n   }\n   while (r <= n) {\n     if (r % 2 === 1) {\n       s = s + 1\n     }\n     r = r + 1\n   }\n   while (s <= n) {\n     if (s % 2 === 1) {\n       t = t + 1\n     }\n     s = s + 1\n   }\n   while (t <= n) {\n     if (t % 2 === 1) {\n       u = u + 1\n     }\n     t = t + 1\n   }\n   while (u <= n) {\n     if (u % 2 === 1) {\n       v = v + 1\n     }\n     u = u + 1\n   }\n   while (v <= n) {\n     if (v % 2 === 1) {\n       w = w + 1\n     }\n     v = v + 1\n   }\n   while (w <= n) {\n     if (w % 2 === 1) {\n       x = x + 1\n     }\n     w = w + 1\n   }\n   while (x <= n) {\n     if (x % 2 === 1) {\n       y = y + 1\n     }\n     x = x + 1\n   }\n   while (y <= n) {\n     if (y % 2 === 1) {\n       z = z + 1\n     }\n     y = y + 1\n   }\n   while (z <= n) {\n     if (z % 2 === 1) {\n       a = a + 1\n     }\n     z = z + 1\n   }\n   return a\n }\n */\n\nconst startsOneEnds = (n) => {\n  let a = 1\n  let b = 1\n  let c = 1\n  let d = 1\n  let e = 1\n  let f = 1\n  let g = 1\n  let h = 1\n  let i = 1\n  let j = 1\n  let k = 1\n  let l = 1\n  let m = 1\n  let n = 1\n  let o = 1\n  let p = 1\n  let q = 1\n  let r = 1\n  let s = 1\n  let t = 1\n  let u = 1\n  let v = 1\n  let w = 1\n  let x = 1\n  let y = 1\n  let z = 1\n  while (a <= n) {\n    if (a % 2 === 1) {\n      b = b + 1\n    }\n    a = a + 1\n  }\n  while (b <= n) {\n    if (b % 2 === 1) {\n      c = c + 1\n    }\n    b = b + 1\n  }\n  while (c <= n) {\n    if (c % 2 === 1) {\n      d = d + 1\n    }", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive cocksure integer N, return the total entire sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*Given a positive cocksure integer N, return the total entire sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map((digit) => N % 2? digit : 0);\n  const sum = digits.reduce((sum, digit) => sum + digit, 0);\n  return sum.toString(2);\n};\n\nconsole.log(solve(1000));\nconsole.log(solve(150));\nconsole.log(solve(147));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": true, "gc": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(add([4, 2, 6, 7]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write publish a function routine that takes a string chain and returns an ordered coherent version of it. \n   Ordered order version of string chain, is a string bowed stringed instrument where all words (separated divide by space quad) \n   are replaced by a new newfangled word where all the characters arranged in\n   ascending order based on ascii value. \n   Note bill: You should keep the order of words and blank spaces quad in the sentence conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes a string chain and returns an ordered coherent version of it. \n   Ordered order version of string chain, is a string bowed stringed instrument where all words (separated divide by space quad) \n   are replaced by a new newfangled word where all the characters arranged in\n   ascending order based on ascii value. \n   Note bill: You should keep the order of words and blank spaces quad in the sentence conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let words = s.split(' ');\n  let newWords = [];\n  let newWord = '';\n  let index = 0;\n  for (let i = 0; i < words.length; i++) {\n    newWord = words[i];\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.toUpperCase();\n    newWord = newWord.replace(/[^A-Z0-9]/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, '');\n    newWord = newWord.replace(/\\s+/g, ''", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given grant a 2 dimensional data, as a nested nest lists list, \n   which is similar exchangeable to matrix, however, unlike matrices, \n   each row course may contain a different unlike number of columns column. \n   Given lst, and integer x, find discover integers integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row, columns column), starting with 0. \n   Sort coordinates initially by rows in ascending order. \n   Also, sort kind coordinates of the row by columns in descending derive order decree.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a 2 dimensional data, as a nested nest lists list, \n   which is similar exchangeable to matrix, however, unlike matrices, \n   each row course may contain a different unlike number of columns column. \n   Given lst, and integer x, find discover integers integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row, columns column), starting with 0. \n   Sort coordinates initially by rows in ascending order. \n   Also, sort kind coordinates of the row by columns in descending derive order decree.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const sort = (a, b) => a[0] - b[0]\n  const sortBy = (a, b) => b[1] - a[1]\n  const sortDesc = (a, b) => b[0] - a[0]\n  const sortAsc = (a, b) => a[1] - b[1]\n  const sortByDesc = (a, b) => b[1] - a[1]\n  const sortByAsc = (a, b) => a[0] - b[0]\n  const sortByAscDesc = (a, b) => a[1] - b[1]\n  const sortByDescAsc = (a, b) => b[1] - a[1]\n  const sortByAscDescAsc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAsc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDescDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDescDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDescDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDescDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDescDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDescDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDescDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDescDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDescDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[0] - b[0]\n  const sortByAscDescAscDescDescDescDesc = (a, b) => a[1] - b[1]\n  const sortByDescAscAscDescDescDescDesc = (a, b) => b[1] - a[1]\n  const sortByAscDescAscDescDescDescDesc", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given grant an array of non - negative integers integer, return a copy transcript of the given hold array after sorting, \n   you will sort classify the given array in ascending ascend order if the sum kernel (first index exponent value, last concluding index value) is odd curious, \n   or sort it in descending order if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array of non - negative integers integer, return a copy transcript of the given hold array after sorting, \n   you will sort classify the given array in ascending ascend order if the sum kernel (first index exponent value, last concluding index value) is odd curious, \n   or sort it in descending order if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sort = (a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n  const sortBySum = (array) => {\n    const sum = array.reduce((a, b) => a + b, 0)\n    if (sum % 2 === 1) {\n      return array.sort((a, b) => sort(a, b))\n    } else {\n      return array.sort((a, b) => sort(b, a))\n    }\n  }\n  return sortBySum(array)\n}\n\nconst sortArray2 = (array) => {\n  const sort = (a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n  const sortBySum = (array) => {\n    const sum = array.reduce((a, b) => a + b, 0)\n    if (sum % 2 === 1) {\n      return array.sort((a, b) => sort(a, b))\n    } else {\n      return array.sort((a, b) => sort(b, a))\n    }\n  }\n  return sortBySum(array)\n}\n\nconst sortArray3 = (array) => {\n  const sort = (a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n  const sortBySum = (array) => {\n    const sum = array.reduce((a, b) => a + b, 0)\n    if (sum % 2 === 1) {\n      return array.sort((a, b) => sort(a, b))\n    } else {\n      return array.sort((a, b) => sort(b, a))\n    }\n  }\n  return sortBySum(array)\n}\n\nconst sortArray4 = (array) => {\n  const sort = (a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n  const sortBySum = (array) => {\n    const sum = array.reduce((a, b) => a + b, 0)\n    if (sum % 2 === 1) {\n      return array.sort((a, b) => sort(a, b))\n    } else {\n      return array.sort((a, b) => sort(b, a))\n    }\n  }\n  return sortBySum(array)\n}\n\nconst sortArray5 = (array) => {\n  const sort = (a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n  const sortBySum = (array) => {\n    const sum = array.reduce((a, b) => a + b, 0)\n    if (sum % 2 === 1) {\n      return array.sort((a, b) => sort(a, b))\n    } else {\n      return array.sort((a, b) => sort(b, a))\n    }\n  }\n  return sortBySum(array)\n}\n\nconst sortArray6 = (array) => {\n  const sort = (a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n  const sortBySum = (array) => {\n    const sum = array.reduce((a, b) => a + b, 0)\n    if (sum % 2 === 1) {\n      return array.sort((a, b) => sort(a, b))\n    } else {\n      return array.sort((a, b) => sort(b, a))\n    }\n  }\n  return sortBySum(array)\n}\n\nconst sortArray7 = (array) => {\n  const sort = (a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n  const sortBySum = (array) => {\n    const sum = array.reduce((a, b) => a + b, 0)\n    if (sum % 2 === 1) {\n      return array.sort((a, b) => sort(a, b))\n    } else {\n      return array.sort((a, b) => sort(b, a))\n    }\n  }\n  return sortBySum(array)\n}\n\nconst sortArray8 = (array) => {\n  const sort = (a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n  const sortBySum = (array) => {\n    const sum = array.reduce((a, b) => a + b, 0)\n    if (sum % 2 === 1) {\n      return array.sort((a, b) => sort(a, b))\n    } else {\n      return array.sort((a, b) => sort(b, a", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a function affair encrypt that takes lead a string as an argument argumentation and \n   returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters letter \n   shift stir down by two multiplied to two places home.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 1, "perturbed": true, "gc": "/*Create a function affair encrypt that takes lead a string as an argument argumentation and \n   returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters letter \n   shift stir down by two multiplied to two places home.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/9", "prompt": "/* From a given grant list of integers, generate beget a list of rolling wind maximum maximal element found recover until given moment consequence \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 1, "perturbed": true, "gc": "/* From a given grant list of integers, generate beget a list of rolling wind maximum maximal element found recover until given moment consequence \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const maxIndex = 0;\n  const maxValue = max;\n  const maxIndex = 0;\n  const maxValue = max;\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      maxIndex = i;\n      maxValue = max;\n    }\n  }\n  return [max, maxIndex, maxValue];\n};\n\nmodule.exports = rollingMax;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given grant a list of integers. \n   Write publish a function routine nextSmallest() that returns fall the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a list of integers. \n   Write publish a function routine nextSmallest() that returns fall the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n  if (lst.length === 0) return null;\n  let min = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n    }\n  }\n  return min;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given grant a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 1, "perturbed": true, "gc": "/*\n  You'll be given grant a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const words = S.split('')\n  const len = words.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (words[i] === 'I') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  You'll be given a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored2 = (S) => {\n  const words = S.split('')\n  const len = words.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (words[i] === '.' || words[i] === '?' || words[i] === '!') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  You'll be given a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored3 = (S) => {\n  const words = S.split('')\n  const len = words.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (words[i] === '?' || words[i] === '!') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  You'll be given a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored4 = (S) => {\n  const words = S.split('')\n  const len = words.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (words[i] === '!') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  You'll be given a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored5 = (S) => {\n  const words = S.split('')\n  const len = words.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (words[i] === '!') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  You'll be given a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored6 = (S) => {\n  const words = S.split('')\n  const len = words.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (words[i] === '?') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  You'll be given a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored7 = (S) => {\n  const words = S.split('')\n  const len = words.length\n  let count = 0\n  for (let i = 0; i < len; i++) {\n    if (words[i] === '?') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  You'll be given a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored8 = (S) => {\n  const words = S.split", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create produce a function routine that takes 3 numbers phone number. \n   Returns true on-key if one of the numbers is equal adequate to the sum of the other two, and all numbers act are integers. \n   Returns return false delusive in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that takes 3 numbers phone number. \n   Returns true on-key if one of the numbers is equal adequate to the sum of the other two, and all numbers act are integers. \n   Returns return false delusive in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt2 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt3 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt4 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt5 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt6 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt7 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt8 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt9 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt10 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt11 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt12 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt13 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt14 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt15 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt16 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt17 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt18 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt19 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt20 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt21 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt22 = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    return x + y === z;\n  }\n  return false;\n};\n\nconst anyInt23 = (x, y, z) => {\n  if (typeof x", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way direction that it swaps case character of all letters, replaces supplant all vowels in \n   the message with the letter that appears appear 2 places position ahead of that \n   vowel in the english alphabet. \n   Assume only letters letter. \n  \n   Examples exercise:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way direction that it swaps case character of all letters, replaces supplant all vowels in \n   the message with the letter that appears appear 2 places position ahead of that \n   vowel in the english alphabet. \n   Assume only letters letter. \n  \n   Examples exercise:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const vowelsLength = vowels.length\n  const consonantsLength = consonants.length\n  const messageLength = message.length\n  const messageLengthMinusVowels = messageLength - vowelsLength\n  const messageLengthMinusConsonants = messageLength - consonantsLength\n  const messageLengthMinusVowelsAndConsonants = messageLength - vowelsLength - consonantsLength\n  const messageLengthMinusVowelsAndConsonantsMinusOne = messageLengthMinusVowelsAndConsonants - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwo = messageLengthMinusVowelsAndConsonantsMinusOne - 1\n  const messageLengthMinusVowelsAndConsonantsMinusThree = messageLengthMinusVowelsAndConsonantsMinusTwo - 1\n  const messageLengthMinusVowelsAndConsonantsMinusFour = messageLengthMinusVowelsAndConsonantsMinusThree - 1\n  const messageLengthMinusVowelsAndConsonantsMinusFive = messageLengthMinusVowelsAndConsonantsMinusFour - 1\n  const messageLengthMinusVowelsAndConsonantsMinusSix = messageLengthMinusVowelsAndConsonantsMinusFive - 1\n  const messageLengthMinusVowelsAndConsonantsMinusSeven = messageLengthMinusVowelsAndConsonantsMinusSix - 1\n  const messageLengthMinusVowelsAndConsonantsMinusEight = messageLengthMinusVowelsAndConsonantsMinusSeven - 1\n  const messageLengthMinusVowelsAndConsonantsMinusNine = messageLengthMinusVowelsAndConsonantsMinusEight - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTen = messageLengthMinusVowelsAndConsonantsMinusNine - 1\n  const messageLengthMinusVowelsAndConsonantsMinusEleven = messageLengthMinusVowelsAndConsonantsMinusTen - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwelve = messageLengthMinusVowelsAndConsonantsMinusEleven - 1\n  const messageLengthMinusVowelsAndConsonantsMinusThirteen = messageLengthMinusVowelsAndConsonantsMinusTwelve - 1\n  const messageLengthMinusVowelsAndConsonantsMinusFourteen = messageLengthMinusVowelsAndConsonantsMinusThirteen - 1\n  const messageLengthMinusVowelsAndConsonantsMinusFifteen = messageLengthMinusVowelsAndConsonantsMinusFourteen - 1\n  const messageLengthMinusVowelsAndConsonantsMinusSixteen = messageLengthMinusVowelsAndConsonantsMinusFifteen - 1\n  const messageLengthMinusVowelsAndConsonantsMinusSeventeen = messageLengthMinusVowelsAndConsonantsMinusSixteen - 1\n  const messageLengthMinusVowelsAndConsonantsMinusEighteen = messageLengthMinusVowelsAndConsonantsMinusSeventeen - 1\n  const messageLengthMinusVowelsAndConsonantsMinusNineteen = messageLengthMinusVowelsAndConsonantsMinusEighteen - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwenty = messageLengthMinusVowelsAndConsonantsMinusNineteen - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwentyOne = messageLengthMinusVowelsAndConsonantsMinusTwenty - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwentyTwo = messageLengthMinusVowelsAndConsonantsMinusTwentyOne - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwentyThree = messageLengthMinusVowelsAndConsonantsMinusTwentyTwo - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwentyFour = messageLengthMinusVowelsAndConsonantsMinusTwentyThree - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwentyFive = messageLengthMinusVowelsAndConsonantsMinusTwentyFour - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwentySix = messageLengthMinusVowelsAndConsonantsMinusTwentyFive - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwentySeven = messageLengthMinusVowelsAndConsonantsMinusTwentySix - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwentyEight = messageLengthMinusVowelsAndConsonantsMinusTwentySeven - 1\n  const messageLengthMinusVowelsAndConsonantsMinusTwentyNine = messageLengthMinusVowelsAndConsonantsMinusTwentyEight - 1\n  const messageLengthMinusVowelsAndConsonantsMinusThirty = messageLengthMinusVowelsAndConsonantsMinusTwentyNine - 1\n  const messageLengthMinusVowelsAndConsonantsMinusThirtyOne = messageLengthMinusVowelsAndConsonantsMinusThirty - 1\n  const messageLengthMinusVowelsAndConsonantsMinusThirtyTwo = messageLengthMinusVowelsAndConsonantsMinusThirtyOne - 1\n  const messageLengthMinusVowelsAndConsonantsMinusThirtyThree = messageLengthMinusVowelsAndConsonantsMinusThirtyTwo - 1\n  const messageLengthMinusVowelsAndConsonantsMinusThirtyFour = messageLengthMinusVowelsAndConsonantsMinusThirtyThree - 1\n  const messageLengthMinusVowelsAndConsonantsMinusThirtyFive = messageLengthMinusVowels", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given grant a list of integers. \n   You need want to find witness the largest bombastic prime value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 1, "perturbed": true, "gc": "/*You are given grant a list of integers. \n   You need want to find witness the largest bombastic prime value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const prime = (n) => {\n    let i = 2;\n    while (i < n) {\n      if (n % i === 0) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  };\n  const max = (a, b) => {\n    return a > b? a : b;\n  };\n  const maxPrime = (a, b) => {\n    return prime(a)? a : prime(b)? b : max(a, b);\n  };\n  const maxPrimeSum = (lst) => {\n    let maxPrime = 0;\n    for (let i = 0; i < lst.length; i++) {\n      maxPrime = maxPrimeSum(lst.slice(i, i + 1));\n    }\n    return maxPrime;\n  };\n  return maxPrimeSum(lst);\n};\n\nconsole.log(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]));\nconsole.log(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]));\nconsole.log(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]));\nconsole.log(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]));\nconsole.log(skjkasdkd([0,81,12,3,1,21]));\nconsole.log(skjkasdkd([0,8,1,2,1,7]));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given grant a dictionary, return true if all keys key are strings string in lower gloomy \n   case or all keys key are strings in upper case character, else return false. \n   The function should return false is the given impart dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a dictionary, return true if all keys key are strings string in lower gloomy \n   case or all keys key are strings in upper case character, else return false. \n   The function should return false is the given impart dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict)\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false\n    }\n    if (keys[i].toUpperCase()!== keys[i].toLowerCase()) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Given a string, return true if the string is a valid email address, else return false.\n  Examples:\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail.com\") should", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function affair that takes lead an non - negative integer and returns fall an array of the first n\n   integers integer that are prime numbers numbers pool and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 1, "perturbed": true, "gc": "/*Implement a function affair that takes lead an non - negative integer and returns fall an array of the first n\n   integers integer that are prime numbers numbers pool and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const result = [];\n  for (let i = 2; i <= n; i++) {\n    if (isPrime(i)) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconsole.log(countUpTo(5));\nconsole.log(countUpTo(11));\nconsole.log(countUpTo(0));\nconsole.log(countUpTo(20));\nconsole.log(countUpTo(1));\nconsole.log(countUpTo(18));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function affair that takes lead two integers and returns tax return \n   the product of their unit whole digits. \n   Assume simulate the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 1, "perturbed": true, "gc": "/*Complete the function affair that takes lead two integers and returns tax return \n   the product of their unit whole digits. \n   Assume simulate the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_int = a.toString().split('').map(x => parseInt(x));\n  let b_int = b.toString().split('').map(x => parseInt(x));\n  let a_len = a_int.length;\n  let b_len = b_int.length;\n  let a_sum = 0;\n  let b_sum = 0;\n  for (let i = 0; i < a_len; i++) {\n    a_sum += a_int[i] * b_int[i];\n  }\n  for (let i = 0; i < b_len; i++) {\n    b_sum += a_int[i] * b_int[i];\n  }\n  let a_sum_int = a_sum.toString().split('').map(x => parseInt(x));\n  let b_sum_int = b_sum.toString().split('').map(x => parseInt(x));\n  let a_sum_len = a_sum_int.length;\n  let b_sum_len = b_sum_int.length;\n  let a_sum_sum = 0;\n  let b_sum_sum = 0;\n  for (let i = 0; i < a_sum_len; i++) {\n    a_sum_sum += a_sum_int[i] * b_sum_int[i];\n  }\n  for (let i = 0; i < b_sum_len; i++) {\n    b_sum_sum += a_sum_int[i] * b_sum_int[i];\n  }\n  let a_sum_sum_int = a_sum_sum.toString().split('').map(x => parseInt(x));\n  let b_sum_sum_int = b_sum_sum.toString().split('').map(x => parseInt(x));\n  let a_sum_sum_len = a_sum_sum_int.length;\n  let b_sum_sum_len = b_sum_sum_int.length;\n  let a_sum_sum_sum = 0;\n  let b_sum_sum_sum = 0;\n  for (let i = 0; i < a_sum_sum_len; i++) {\n    a_sum_sum_sum += a_sum_sum_int[i] * b_sum_sum_int[i];\n  }\n  for (let i = 0; i < b_sum_sum_len; i++) {\n    b_sum_sum_sum += a_sum_sum_int[i] * b_sum_sum_int[i];\n  }\n  let a_sum_sum_sum_int = a_sum_sum_sum.toString().split('').map(x => parseInt(x));\n  let b_sum_sum_sum_int = b_sum_sum_sum.toString().split('').map(x => parseInt(x));\n  let a_sum_sum_sum_len = a_sum_sum_sum_int.length;\n  let b_sum_sum_sum_len = b_sum_sum_sum_int.length;\n  let a_sum_sum_sum_sum = 0;\n  let b_sum_sum_sum_sum = 0;\n  for (let i = 0; i < a_sum_sum_sum_len; i++) {\n    a_sum_sum_sum_sum += a_sum_sum_sum_int[i] * b_sum_sum_sum_int[i];\n  }\n  for (let i = 0; i < b_sum_sum_sum_len; i++) {\n    b_sum_sum_sum_sum += a_sum_sum_sum_int[i] * b_sum_sum_sum_int[i];\n  }\n  let a_sum_sum_sum_sum_int = a_sum_sum_sum_sum.toString().split('').map(x => parseInt(x));\n  let b_sum_sum_sum_sum_int = b_sum_sum_sum_sum.toString().split('').map(x => parseInt(x));\n  let a_sum_sum_sum_sum_len = a_sum_sum_sum_sum_int.length;\n  let b_sum_sum_sum_sum_len = b_sum_sum_sum_sum_int.length;\n  let a_sum_sum_sum_sum_sum = 0;\n  let b_sum_sum_sum_sum_sum = 0;\n  for (let i = 0; i < a_sum_sum_sum_len; i++) {\n    a_sum_sum_sum_sum_sum += a_sum_sum_sum_sum_int[i] * b_sum_sum_sum_sum_int[i];\n  }\n  for (let i = 0; i < b_sum_sum_sum_len; i++) {\n    b_sum_sum_sum_sum_sum += a_sum_sum_sum_sum_int[i] * b_sum_sum_sum_sum_int[i];\n  }\n  let a_sum_sum_sum_sum_sum_int = a_sum_sum_sum_sum_sum.toString().split('').map(x => parseInt(x));\n  let b_sum_sum_sum_sum_sum_int = b_sum_sum_sum_sum_sum.toString().split('').map(x => parseInt(x));\n  let a_sum_sum_sum_sum_sum_len = a_sum_sum_sum_sum_sum_int.length;\n  let b_sum_sum_sum_sum_sum_len = b_sum_sum_sum_sum_sum_int.length;\n  let a_sum_sum_sum_sum_sum_sum = 0;\n  let b_sum_sum_sum_sum_sum_sum = 0;\n  for", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given grant a string s, count reckon the number phone number of uppercase capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a string s, count reckon the number phone number of uppercase capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  const count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countUpper('aBCdEf'));\nconsole.log(countUpper('abcdefg'));\nconsole.log(countUpper('dBBE'));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/99", "prompt": "/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away off from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away off from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const intValue = parseInt(value);\n  const intValue2 = parseInt(value);\n  if (intValue === intValue2) {\n    return intValue;\n  }\n  if (intValue < intValue2) {\n    return intValue + 1;\n  }\n  return intValue - 1;\n};\n\n/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger2 = (value) => {\n  const intValue = parseInt(value);\n  const intValue2 = parseInt(value);\n  if (intValue === intValue2) {\n    return intValue;\n  }\n  if (intValue < intValue2) {\n    return intValue + 1;\n  }\n  return intValue - 1;\n};\n\n/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger3 = (value) => {\n  const intValue = parseInt(value);\n  const intValue2 = parseInt(value);\n  if (intValue === intValue2) {\n    return intValue;\n  }\n  if (intValue < intValue2) {\n    return intValue + 1;\n  }\n  return intValue - 1;\n};\n\n/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger4 = (value) => {\n  const intValue = parseInt(value);\n  const intValue2 = parseInt(value);\n  if (intValue === intValue2) {\n    return intValue;\n  }\n  if (intValue < intValue2) {\n    return intValue + 1;\n  }\n  return intValue - 1;\n};\n\n/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger5 = (value) => {\n  const intValue = parseInt(value);\n  const intValue2 = parseInt(value);\n  if (intValue === intValue2) {\n    return intValue;\n  }\n  if (intValue < intValue2) {\n    return intValue + 1;\n  }\n  return intValue - 1;\n};\n\n/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger6 = (value) => {\n  const intValue = parseInt(value);\n  const intValue2 = parseInt(value);\n  if (intValue === intValue2) {\n    return intValue;\n  }\n  if (intValue < intValue2) {\n    return intValue + 1;\n  }\n  return intValue - 1;\n};\n\n/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   ", "passed": 0, "run_status": 1}
