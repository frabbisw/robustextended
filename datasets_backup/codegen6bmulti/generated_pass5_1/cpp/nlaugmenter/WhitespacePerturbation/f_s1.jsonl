{"task_id": "CPP/0", "prompt": "/*\nCheck ifi n gi ven ve c tor of  numbers,  are any two numberscloser to eacho ther than\ngiven thr eshold.\n>>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n*/\n#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\nbool has_close_elements(vector<float> numbers, float threshold){\n", "canonical_solution": "    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    vector<float> a={1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert (has_close_elements(a, 0.3)==true);\n    assert (has_close_elements(a, 0.05) == false);\n\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95) == true);\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8) ==false);\n    assert (has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5) == false);\n    \n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (has_close_elements({1.0, 2.0, 3.0}, 0.5) == false && \"failure 1\");\n    assert (has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3) && \"failure 2\") ;\n}\n", "entry_point": "has_close_elements", "seed": 1, "perturbed": true, "gc": "/*\nCheck ifi n gi ven ve c tor of  numbers,  are any two numberscloser to eacho ther than\ngiven thr eshold.\n>>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n*/\n#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\nbool has_close_elements(vector<float> numbers, float threshold){\n\tint i, j;\n\tfor(i = 0; i < numbers.size()-1; i++){\n\t\tfor(j = i+1; j < numbers.size(); j++){\n\t\t\tif(fabs(numbers[i] - numbers[j]) < threshold){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tvector<float> numbers;\n\tfloat threshold;\n\twhile(scanf(\"%f\", &threshold)!= EOF){\n\t\tint i;\n\t\tfor(i = 0; i < 3; i++){\n\t\t\tscanf(\"%f\", &numbers[i]);\n\t\t}\n\t\tif(has_close_elements(numbers, threshold)){\n\t\t\tprintf(\"true\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"false\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/1", "prompt": "/*\nInput tot hisfuncti o n is a  string c ontaining multiple gr oups of nestedp arentheses. Your go al is toseparate tho se group int o  separate strin gs and ret u rn the vector ofthose.\nSepa ra te groups are balanced  (each open brace is properly clos ed) and not nested w ithin  each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n{\"()\", \"(())\", \"(()())\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> separate_paren_groups(string paren_string){\n", "canonical_solution": "    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){  \n    assert (issame(separate_paren_groups(\"(()()) ((())) () ((())()())\"),{\"(()())\", \"((()))\", \"()\", \"((())()())\"}));\n    assert (issame(separate_paren_groups(\"() (()) ((())) (((())))\"), {\"()\", \"(())\", \"((()))\", \"(((())))\" }));\n    assert (issame(separate_paren_groups(\"(()(())((())))\") ,{ \"(()(())((())))\" }));\n    assert (issame(separate_paren_groups(\"( ) (( )) (( )( ))\") ,{\"()\", \"(())\", \"(()())\"}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){  \n    assert (issame(separate_paren_groups(\"( ) (( )) (( )( ))\") ,{\"()\", \"(())\", \"(()())\"}));\n}\n", "entry_point": "separate_paren_groups", "seed": 1, "perturbed": true, "gc": "/*\nInput tot hisfuncti o n is a  string c ontaining multiple gr oups of nestedp arentheses. Your go al is toseparate tho se group int o  separate strin gs and ret u rn the vector ofthose.\nSepa ra te groups are balanced  (each open brace is properly clos ed) and not nested w ithin  each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n{\"()\", \"(())\", \"(()())\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> separate_paren_groups(string paren_string){\n\tvector<string> groups;\n\tstring group;\n\tint level = 0;\n\tfor(int i = 0; i < paren_string.length(); i++){\n\t\tif(paren_string[i] == '('){\n\t\t\tlevel++;\n\t\t\tgroup.push_back(paren_string[i]);\n\t\t}\n\t\telse if(paren_string[i] == ')'){\n\t\t\tlevel--;\n\t\t\tif(level == 0){\n\t\t\t\tgroups.push_back(group);\n\t\t\t\tgroup.clear();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tgroup.push_back(paren_string[i]);\n\t\t\t}\n\t\t}\n\t\telse if(level == 0){\n\t\t\tgroups.push_back(group);\n\t\t\tgroup.clear();\n\t\t\tgroup.push_back(paren_string[i]);\n\t\t}\n\t}\n\treturn groups;\n}\nint main(){\n\tstring paren_string;\n\tcin >> paren_string;\n\tvector<string> groups = separate_paren_groups(paren_string);\n\tfor(int i = 0; i < groups.size(); i++){\n\t\tcout << groups[i] << endl;\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/10", "prompt": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string str){\n    //Test if given string is a palindrome \n    string s(str.rbegin(),str.rend());\n    return s==str;\n}\nstring make_palindrome(string str){\n    /*\n    Find thes hort est pa l indrom e that be gins with a suppliedstring. \n    Al g orithm idea is simp le: - Find the longes t postfix of supplied string  that is a palindrome. \n   - Append to  t he end of the string r everse of a string prefix that com es before the palind romic  suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n", "canonical_solution": "   int i;\n   for (i=0;i<str.length();i++)\n   {\n        string rstr=str.substr(i);\n        if (is_palindrome(rstr))\n        {\n            string nstr;\n            nstr=str.substr(0,i);\n            string n2str(nstr.rbegin(),nstr.rend());\n            return str+n2str;\n        }\n   }\n   string n2str(str.rbegin(),str.rend());\n   return str+n2str;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (make_palindrome(\"\") == \"\");\n    assert (make_palindrome(\"x\") == \"x\");\n     assert (make_palindrome(\"xyz\") == \"xyzyx\");\n     assert (make_palindrome(\"xyx\") == \"xyx\") ;\n     assert (make_palindrome(\"jerry\") == \"jerryrrej\");\n}\n\n\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool is_palindrome(string str){\n    string s(str.rbegin(),str.rend());\n    return s==str;\n}\nstring make_palindrome(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (make_palindrome(\"\") == \"\");\n    assert (make_palindrome(\"cat\") == \"catac\");\n     assert (make_palindrome(\"cata\") == \"catac\");\n}\n", "entry_point": "make_palindrome", "seed": 1, "perturbed": true, "gc": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string str){\n    //Test if given string is a palindrome \n    string s(str.rbegin(),str.rend());\n    return s==str;\n}\nstring make_palindrome(string str){\n    /*\n    Find thes hort est pa l indrom e that be gins with a suppliedstring. \n    Al g orithm idea is simp le: - Find the longes t postfix of supplied string  that is a palindrome. \n   - Append to  t he end of the string r everse of a string prefix that com es before the palind romic  suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    string s(str.rbegin(),str.rend());\n    string s2=s;\n    int i=0;\n    while(i<s.size()/2){\n        s2.insert(i,s[i]);\n        i++;\n    }\n    return s2;\n}\nint main(){\n    string str;\n    while(cin>>str){\n        if(is_palindrome(str)){\n            cout<<str<<endl;\n        }\n        else{\n            cout<<make_palindrome(str)<<endl;\n        }\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/100", "prompt": "/*\nGiven a po siti ve int e ger n,  you have  to make a pile of nlevels of stone s .\nThe first level h as n stones.\nThe numb er of stones in the next lev el is:\n  - the next odd number if n i sodd.\n    - the next ev en number if n is even.\nReturn the number ofstones in  each  level in a vector ,  where element at index\ni represents the  number of stones in the lev el (i+1).\n\nExamples:\n>>> make_a_pile(3)\n{3, 5, 7}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> make_a_pile(int n){\n", "canonical_solution": "    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(make_a_pile(3) , {3, 5, 7}));\n    assert (issame(make_a_pile(4) , {4,6,8,10}));\n    assert (issame(make_a_pile(5) , {5, 7, 9, 11, 13}));\n    assert (issame(make_a_pile(6) , {6, 8, 10, 12, 14, 16}));\n    assert (issame(make_a_pile(8) , {8, 10, 12, 14, 16, 18, 20, 22}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(make_a_pile(3) , {3, 5, 7}));\n}\n", "entry_point": "make_a_pile", "seed": 1, "perturbed": true, "gc": "/*\nGiven a po siti ve int e ger n,  you have  to make a pile of nlevels of stone s.\nThe first level h as n stones.\nThe numb er of stones in the next lev el is:\n  - the next odd number if n i sodd.\n    - the next ev en number if n is even.\nReturn the number ofstones in  each  level in a vector,  where element at index\ni represents the  number of stones in the lev el (i+1).\n\nExamples:\n>>> make_a_pile(3)\n{3, 5, 7}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> make_a_pile(int n){\n    vector<int> pile;\n    int i, j, k;\n    for(i=1; i<=n; i++){\n        pile.push_back(0);\n    }\n    for(i=1; i<=n; i++){\n        for(j=0; j<i; j++){\n            pile[j] += pile[j+1];\n        }\n    }\n    return pile;\n}\n\nint main(){\n    int n;\n    printf(\"Enter the number of stones in the pile: \");\n    scanf(\"%d\", &n);\n    vector<int> pile = make_a_pile(n);\n    for(int i=0; i<pile.size(); i++){\n        printf(\"%d \", pile[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/101", "prompt": "/*\nYou willb e gi ven as tringof wordsseparated by commas o r spaces. Yourt ask is\nto split the  string into words an d return av e ctor of the wor ds.\n\nFor example:\nwords_string(\"Hi, my name is John\") == {\"Hi\", \"my\", \"name\", \"is\", \"John\"}\nwords_string(\"One, two, three, four, five, six\") == {\"One\", 'two\", 'three\", \"four\", \"five\", 'six\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> words_string(string s){\n", "canonical_solution": "    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(words_string(\"Hi, my name is John\") , {\"Hi\", \"my\", \"name\", \"is\", \"John\"}));\n    assert (issame(words_string(\"One, two, three, four, five, six\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"Hi, my name\") , {\"Hi\", \"my\", \"name\"}));\n    assert (issame(words_string(\"One,, two, three, four, five, six,\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"\") , {}));\n    assert (issame(words_string(\"ahmed     , gamal\") , {\"ahmed\", \"gamal\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(words_string(\"Hi, my name is John\") , {\"Hi\", \"my\", \"name\", \"is\", \"John\"}));\n    assert (issame(words_string(\"One, two, three, four, five, six\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n}\n", "entry_point": "words_string", "seed": 1, "perturbed": true, "gc": "/*\nYou willb e gi ven as tringof wordsseparated by commas o r spaces. Yourt ask is\nto split the  string into words an d return av e ctor of the wor ds.\n\nFor example:\nwords_string(\"Hi, my name is John\") == {\"Hi\", \"my\", \"name\", \"is\", \"John\"}\nwords_string(\"One, two, three, four, five, six\") == {\"One\", 'two\", 'three\", \"four\", \"five\",'six\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> words_string(string s){\n\tvector<string> v;\n\tstring word;\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s[i]==''|| s[i]==',' || s[i]=='\\0'){\n\t\t\tif(word.length()>0){\n\t\t\t\tv.push_back(word);\n\t\t\t\tword.clear();\n\t\t\t}\n\t\t\tif(s[i]=='\\0')\n\t\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tword+=s[i];\n\t\t}\n\t}\n\tif(word.length()>0)\n\t\tv.push_back(word);\n\treturn v;\n}\nint main(){\n\tstring s;\n\twhile(cin>>s){\n\t\tvector<string> v=words_string(s);\n\t\tfor(int i=0;i<v.size();i++)\n\t\t\tcout<<v[i]<<\" \";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/102", "prompt": "/*\nThis funct iontakest wo pos itive num bers x and y and retu rns the\nbiggest even integer number  that isin the range  [x, y] incl u sive.If \nthere 's no such number, then thefunction sh ou ld return -1.\n\nFor example:\nchoose_num(12, 15) = 14\nchoose_num(13, 12) = -1\n*/\n#include<stdio.h>\nusing namespace std;\nint choose_num(int x,int y){\n", "canonical_solution": "    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (choose_num(12, 15) == 14);\n    assert (choose_num(13, 12) == -1);\n    assert (choose_num(33, 12354) == 12354);\n    assert (choose_num(5234, 5233) == -1);\n    assert (choose_num(6, 29) == 28);\n    assert (choose_num(27, 10) == -1);\n    assert (choose_num(7, 7) == -1);\n    assert (choose_num(546, 546) == 546);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (choose_num(12, 15) == 14);\n    assert (choose_num(13, 12) == -1);\n}\n", "entry_point": "choose_num", "seed": 1, "perturbed": true, "gc": "/*\nThis funct iontakest wo pos itive num bers x and y and retu rns the\nbiggest even integer number  that isin the range  [x, y] incl u sive.If \nthere's no such number, then thefunction sh ou ld return -1.\n\nFor example:\nchoose_num(12, 15) = 14\nchoose_num(13, 12) = -1\n*/\n#include<stdio.h>\nusing namespace std;\nint choose_num(int x,int y){\n    int i,j,k;\n    if(x>y){\n        k=x;\n        x=y;\n        y=k;\n    }\n    if(x%2==0){\n        for(i=x;i<=y;i+=2){\n            if(i%2==0){\n                return i;\n            }\n        }\n    }else{\n        for(i=x;i<=y;i+=2){\n            if(i%2!=0){\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nint main(){\n    int x,y;\n    while(scanf(\"%d%d\",&x,&y)!=EOF){\n        printf(\"%d\\n\",choose_num(x,y));\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/103", "prompt": "/*\nYou are gi ventwo po s itiveintegersn and m, and your tas k is to compute the\naverage of theintegersfrom n throu gh m (includ i ng n and m). \nR ound the a n swer to the nearest integer( sm aller one) and convert  that to binary.If n is greater t han m, return \"-1\".\nExample:\nrounded_avg(1, 5) => \"11\"\nrounded_avg(7, 5) => \"-1\"\nrounded_avg(10, 20) => \"1111\"\nrounded_avg(20, 33) => \"11010\"\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nstring rounded_avg(int n,int m){\n", "canonical_solution": "    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (rounded_avg(1, 5) == \"11\");\n    assert (rounded_avg(7, 13) == \"1010\");\n    assert (rounded_avg(964,977) == \"1111001010\");\n    assert (rounded_avg(996,997) == \"1111100100\");\n    assert (rounded_avg(560,851) == \"1011000001\");  \n    assert (rounded_avg(185,546) == \"101101101\");\n    assert (rounded_avg(362,496) == \"110101101\");\n    assert (rounded_avg(350,902) == \"1001110010\");\n    assert (rounded_avg(197,233) == \"11010111\");\n    assert (rounded_avg(7, 5) == \"-1\");\n    assert (rounded_avg(5, 1) == \"-1\");\n    assert (rounded_avg(5, 5) == \"101\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (rounded_avg(1, 5) == \"11\");\n    assert (rounded_avg(7, 5) == \"-1\");\n    assert (rounded_avg(10,20) == \"1111\");\n    assert (rounded_avg(20,33) == \"11010\");\n}\n", "entry_point": "rounded_avg", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi ventwo po s itiveintegersn and m, and your tas k is to compute the\naverage of theintegersfrom n throu gh m (includ i ng n and m). \nR ound the a n swer to the nearest integer( sm aller one) and convert  that to binary.If n is greater t han m, return \"-1\".\nExample:\nrounded_avg(1, 5) => \"11\"\nrounded_avg(7, 5) => \"-1\"\nrounded_avg(10, 20) => \"1111\"\nrounded_avg(20, 33) => \"11010\"\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nstring rounded_avg(int n,int m){\n\tint i,j,k,l,sum=0,temp,temp2;\n\tstring s;\n\tif(n>m){\n\t\treturn \"-1\";\n\t}\n\telse{\n\t\tfor(i=n;i<=m;i++){\n\t\t\tsum+=i;\n\t\t}\n\t\ttemp=sum/m;\n\t\ttemp2=temp;\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(temp2%2==1){\n\t\t\t\ts=s+\"1\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts=s+\"0\";\n\t\t\t}\n\t\t\ttemp2=temp2/2;\n\t\t}\n\t\treturn s;\n\t}\n}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tcout<<rounded_avg(n,m);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/104", "prompt": "/*\nGiven a ve ctor  of po s itiveintegersx. return a sorted ve ctor of all \nel e ments that hasn't a ny even digit.\n\nNote:  Returned ve c tor should be s orted in i n creasing order.\nFor example :\n>>> unique_digits({15, 33, 1422, 1})\n{1, 15, 33}\n>>> unique_digits({152, 323, 1422, 10})\n{}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> unique_digits(vector<int> x){\n", "canonical_solution": "    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique_digits({15, 33, 1422, 1}) , {1, 15, 33}));\n    assert (issame(unique_digits({152, 323, 1422, 10}) , {}));\n    assert (issame(unique_digits({12345, 2033, 111, 151}) , {111, 151}));\n    assert (issame(unique_digits({135, 103, 31}) , {31, 135}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique_digits({15, 33, 1422, 1}) , {1, 15, 33}));\n    assert (issame(unique_digits({152, 323, 1422, 10}) , {}));\n}\n", "entry_point": "unique_digits", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ve ctor  of po s itiveintegersx. return a sorted ve ctor of all \nel e ments that hasn't a ny even digit.\n\nNote:  Returned ve c tor should be s orted in i n creasing order.\nFor example :\n>>> unique_digits({15, 33, 1422, 1})\n{1, 15, 33}\n>>> unique_digits({152, 323, 1422, 10})\n{}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> unique_digits(vector<int> x){\n\tvector<int> y;\n\tfor(int i=0;i<x.size();i++){\n\t\tint d=x[i]%10;\n\t\tif(d%2==0)\n\t\t\ty.push_back(x[i]);\n\t}\n\tsort(y.begin(),y.end());\n\treturn y;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> x(n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\tvector<int> y=unique_digits(x);\n\tfor(int i=0;i<y.size();i++)\n\t\tprintf(\"%d \",y[i]);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/105", "prompt": "/*\nGiven a ve ctor  of in t egers,  sort the  integers that are be tween 1 and 9 i n clusive,\nreverse th e resulting vector, a nd then repl a ce each digit b y its corr e sponding name from\n\"One\", \"T wo \", \"Three\", \"Four\", \"F ive\", \"Six\", \"Seven\", \"Eight\", \"Ni ne\".\n\nFor example:\n  arr = {2, 1, 1, 4, 5, 8, 2, 3}   \n        -> sort arr -> {1, 1, 2, 2, 3, 4, 5, 8} \n        -> reverse arr -> {8, 5, 4, 3, 2, 2, 1, 1}\n  return {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n\n  If the vector is empty, return an empty vector:\n  arr = {}\n  return {}\n\n  If the vector has any strange number ignore it:\n  arr = {1, -1 , 55} \n        -> sort arr -> {-1, 1, 55}\n        -> reverse arr -> {55, 1, -1}\n  return = {\"One\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nvector<string> by_length(vector<int> arr){\n", "canonical_solution": "    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(by_length({2, 1, 1, 4, 5, 8, 2, 3}) , {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}));\n    assert (issame(by_length({}) , {}));\n    assert (issame(by_length({1, -1 , 55}) , {\"One\"}));\n    assert (issame(by_length({1, -1, 3, 2}) , {\"Three\", \"Two\", \"One\"}));\n    assert (issame(by_length({9, 4, 8}) , {\"Nine\", \"Eight\", \"Four\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(by_length({2, 1, 1, 4, 5, 8, 2, 3}) , {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}));\n    assert (issame(by_length({}) , {}));\n    assert (issame(by_length({1, -1 , 55}) , {\"One\"}));\n}\n", "entry_point": "by_length", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ve ctor  of in t egers,  sort the  integers that are be tween 1 and 9 i n clusive,\nreverse th e resulting vector, a nd then repl a ce each digit b y its corr e sponding name from\n\"One\", \"T wo \", \"Three\", \"Four\", \"F ive\", \"Six\", \"Seven\", \"Eight\", \"Ni ne\".\n\nFor example:\n  arr = {2, 1, 1, 4, 5, 8, 2, 3}   \n        -> sort arr -> {1, 1, 2, 2, 3, 4, 5, 8} \n        -> reverse arr -> {8, 5, 4, 3, 2, 2, 1, 1}\n  return {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n\n  If the vector is empty, return an empty vector:\n  arr = {}\n  return {}\n\n  If the vector has any strange number ignore it:\n  arr = {1, -1, 55} \n        -> sort arr -> {-1, 1, 55}\n        -> reverse arr -> {55, 1, -1}\n  return = {\"One\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nvector<string> by_length(vector<int> arr){\n\tvector<string> res;\n\tmap<int, string> m;\n\tfor(int i = 0; i < arr.size(); i++){\n\t\tm[arr[i]] = \"\";\n\t}\n\tfor(int i = 0; i < arr.size(); i++){\n\t\tm[arr[i]] += \" \";\n\t}\n\tfor(map<int, string>::iterator it = m.begin(); it!= m.end(); it++){\n\t\tres.push_back(it->second);\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> arr(n);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &arr[i]);\n\t}\n\tvector<string> res = by_length(arr);\n\tfor(int i = 0; i < res.size(); i++){\n\t\tprintf(\"%s\\n\", res[i].c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/106", "prompt": "/*\nImplementthefuncti o n f th at takesn as a parameter,\nand  returns a vect o r of size n, such t hat the value of theelement ati n dex iis the fa ctorial of i if i is even\nor the sum of  n umbers from 1 to i oth erwise.\ni startsfrom 1.\nthe facto rial of i is the mul tipli cation of the numb e rs from 1 to i (1 * 2 * ... * i).\nExample:\nf(5) == {1, 2, 6, 24, 15}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> f(int n){\n", "canonical_solution": "    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(f(5) , {1, 2, 6, 24, 15}));\n    assert (issame(f(7) , {1, 2, 6, 24, 15, 720, 28}));\n    assert (issame(f(1) , {1}));\n    assert (issame(f(3) , {1, 2, 6}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(f(5) , {1, 2, 6, 24, 15}));\n}\n", "entry_point": "f", "seed": 1, "perturbed": true, "gc": "/*\nImplementthefuncti o n f th at takesn as a parameter,\nand  returns a vect o r of size n, such t hat the value of theelement ati n dex iis the fa ctorial of i if i is even\nor the sum of  n umbers from 1 to i oth erwise.\ni startsfrom 1.\nthe facto rial of i is the mul tipli cation of the numb e rs from 1 to i (1 * 2 *... * i).\nExample:\nf(5) == {1, 2, 6, 24, 15}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> f(int n){\n\tvector<int> v;\n\tfor(int i=1;i<=n;i++){\n\t\tv.push_back(i);\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tv.push_back(v[j-1]*i);\n\t\t}\n\t}\n\treturn v;\n}\nint main(){\n\tint n;\n\tprintf(\"Enter the number of elements in the vector\\n\");\n\tscanf(\"%d\",&n);\n\tprintf(\"The factorial of %d is %d\\n\",n,f(n).back());\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/107", "prompt": "/*\nGiven a po siti ve int e ger n,  return a  vector that has thenumber of evena nd odd\ninteger pali ndromes that fall wit hin the rang e (1, n), inclusi ve.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 10^3\n    2. returned vector has the number of even and odd integer palindromes respectively.\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> even_odd_palindrome(int n){\n", "canonical_solution": "    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_palindrome(123) , {8, 13}));\n    assert (issame(even_odd_palindrome(12) , {4, 6}));\n    assert (issame(even_odd_palindrome(3) , {1, 2}));\n    assert (issame(even_odd_palindrome(63) , {6, 8}));\n    assert (issame(even_odd_palindrome(25) , {5, 6}));\n    assert (issame(even_odd_palindrome(19) , {4, 6}));\n    assert (issame(even_odd_palindrome(9) , {4, 5}));\n    assert (issame(even_odd_palindrome(1) , {0, 1}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_palindrome(12) , {4, 6}));\n    assert (issame(even_odd_palindrome(3) , {1, 2}));\n}\n", "entry_point": "even_odd_palindrome", "seed": 1, "perturbed": true, "gc": "/*\nGiven a po siti ve int e ger n,  return a  vector that has thenumber of evena nd odd\ninteger pali ndromes that fall wit hin the rang e (1, n), inclusi ve.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 10^3\n    2. returned vector has the number of even and odd integer palindromes respectively.\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> even_odd_palindrome(int n){\n    vector<int> v;\n    for(int i = 1; i <= n; i++){\n        int j = n - i;\n        if(i % 2 == 0){\n            v.push_back(i);\n        }\n        if(j % 2 == 0){\n            v.push_back(j);\n        }\n    }\n    return v;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> v = even_odd_palindrome(n);\n    for(int i = 0; i < v.size(); i++){\n        printf(\"%d \", v[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/108", "prompt": "/*\nWrite a fu ncti on cou n t_nums  which ta kes a vector of integ ers and returns the number of eleme nts which has a sum o f digits >0 . \nIf anumber is  negative, then its first signed digitwi ll be negative:\ne.g. - 123 has signed digits -1, 2, and 3 .\n>>> count_nums({}) == 0\n>>> count_nums({-1, 11, -11}) == 1\n>>> count_nums({1, 1, 2}) == 3\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint count_nums(vector<int> n){\n", "canonical_solution": "    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_nums({}) == 0);\n    assert (count_nums({-1, -2, 0}) == 0);\n    assert (count_nums({1, 1, 2, -2, 3, 4, 5}) == 6);\n    assert (count_nums({1, 6, 9, -6, 0, 1, 5}) == 5);\n    assert (count_nums({1, 100, 98, -7, 1, -1}) == 4);\n    assert (count_nums({12, 23, 34, -45, -56, 0}) == 5);\n    assert (count_nums({-0, 1}) == 1);\n    assert (count_nums({1}) == 1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_nums({}) == 0);\n    assert (count_nums({-1, 11, -11}) == 1);\n    assert (count_nums({1, 1, 2}) == 3);\n}\n", "entry_point": "count_nums", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on cou n t_nums  which ta kes a vector of integ ers and returns the number of eleme nts which has a sum o f digits >0. \nIf anumber is  negative, then its first signed digitwi ll be negative:\ne.g. - 123 has signed digits -1, 2, and 3.\n>>> count_nums({}) == 0\n>>> count_nums({-1, 11, -11}) == 1\n>>> count_nums({1, 1, 2}) == 3\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint count_nums(vector<int> n){\n\tint i, j, k, count = 0;\n\tfor(i = 0; i < n.size(); i++){\n\t\tfor(j = 0; j < n.size(); j++){\n\t\t\tfor(k = 0; k < n.size(); k++){\n\t\t\t\tif(n[i] + n[j] + n[k] > 0){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\nint main(){\n\tint n, i;\n\tvector<int> n_v;\n\twhile(scanf(\"%d\", &n)!= EOF){\n\t\tfor(i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &n_v[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", count_nums(n_v));\n\t}\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/109", "prompt": "/*\nWe have avect or \"ar r \" of N  integers  arr[1], arr[2], ...,  arr[N].The\nnum b ers in the vector w ill be randomly order ed. Your tas k  is to determin e if\nit is possible to get a vector sor te d in non-decreasing or der by performing \nthe following o peration on the give nvec tor:\n    You are a l lowedto perform right shift operation a ny number of times.\n\nOne rig ht shift operation means  shifting allelements of the v ector by one\nposition in the r ight direction. The last eleme ntof the vector will be moved to\nthe s tarting pos ition in the vect or i.e. 0th index. \n\nIf it is po ssible  to obtainthe sorted vector by p erforming the above operation\nthenreturn true else returnfalse.\nIf th e given v ect ori s empty then return true.\n\nNote: The give n vecto risguaranteed to have unique elements .\n\nFor Example:\n\nmove_one_ball({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool move_one_ball(vector<int> arr){\n", "canonical_solution": "    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (move_one_ball({3, 4, 5, 1, 2})==true);\n    assert (move_one_ball({3, 5, 10, 1, 2})==true);\n    assert (move_one_ball({4, 3, 1, 2})==false);\n    assert (move_one_ball({3, 5, 4, 1, 2})==false);\n    assert (move_one_ball({})==true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (move_one_ball({3, 4, 5, 1, 2})==true);\n    assert (move_one_ball({3, 5, 4, 1, 2})==false);\n}\n", "entry_point": "move_one_ball", "seed": 1, "perturbed": true, "gc": "/*\nWe have avect or \"ar r \" of N  integers  arr[1], arr[2],...,  arr[N].The\nnum b ers in the vector w ill be randomly order ed. Your tas k  is to determin e if\nit is possible to get a vector sor te d in non-decreasing or der by performing \nthe following o peration on the give nvec tor:\n    You are a l lowedto perform right shift operation a ny number of times.\n\nOne rig ht shift operation means  shifting allelements of the v ector by one\nposition in the r ight direction. The last eleme ntof the vector will be moved to\nthe s tarting pos ition in the vect or i.e. 0th index. \n\nIf it is po ssible  to obtainthe sorted vector by p erforming the above operation\nthenreturn true else returnfalse.\nIf th e given v ect ori s empty then return true.\n\nNote: The give n vecto risguaranteed to have unique elements.\n\nFor Example:\n\nmove_one_ball({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool move_one_ball(vector<int> arr){\n    int n=arr.size();\n    if(n==0)\n        return true;\n    int i=0;\n    int j=n-1;\n    while(i<j){\n        if(arr[i]>arr[j]){\n            swap(arr[i],arr[j]);\n            i++;\n            j--;\n        }\n        else\n            break;\n    }\n    return true;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> arr(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&arr[i]);\n    }\n    if(move_one_ball(arr))\n        printf(\"True\\n\");\n    else\n        printf(\"False\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/11", "prompt": "/*\nInput aretwostring s  a and  b consis ting only of 1s and 0 s.\nPerform bina r y XOR on these inpu ts and return resultalso as a st r ing.\n>>> string_xor(\"010\", \"110\")\n\"100\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring string_xor(string a,string b){\n", "canonical_solution": "    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_xor(\"111000\", \"101010\") == \"010010\");\n     assert (string_xor(\"1\", \"1\") == \"0\");\n    assert (string_xor(\"0101\", \"0000\") == \"0101\");\n\n}\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_xor(\"010\", \"110\") == \"100\");\n}\n", "entry_point": "string_xor", "seed": 1, "perturbed": true, "gc": "/*\nInput aretwostring s  a and  b consis ting only of 1s and 0 s.\nPerform bina r y XOR on these inpu ts and return resultalso as a st r ing.\n>>> string_xor(\"010\", \"110\")\n\"100\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring string_xor(string a,string b){\n    string c;\n    for(int i=0;i<a.size();i++){\n        c.push_back(a[i]^b[i]);\n    }\n    return c;\n}\nint main(){\n    string a,b;\n    while(cin>>a>>b){\n        cout<<string_xor(a,b)<<endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/110", "prompt": "/*\nIn this pr oble m, you will i mplementa function that takes  two vectors of numbers,\nand determ ines whether it is po ssible to pe r form an exchang e of eleme n ts\nbetween them to make lst1  a  vector of only even n umbers.\nThere isno limit on the n umber of exchanged e lemen ts between lst1 an d  lst2.\nIf it is possible to exchange ele ments betweenthe lst1 and l st2 to make\nall the elem ents of lst1 t o be even, return \"YES\".\nOtherwise, return \"NO\" .\nFor example:\nexchange({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring exchange(vector<int> lst1,vector<int> lst2){\n", "canonical_solution": "    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    assert (exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n    assert (exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == \"YES\" );\n    assert (exchange({5, 7, 3}, {2, 6, 4}) == \"YES\");\n    assert (exchange({5, 7, 3}, {2, 6, 3}) == \"NO\" );\n    assert (exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == \"NO\");\n    assert (exchange({100, 200}, {200, 200}) == \"YES\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    assert (exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n}\n", "entry_point": "exchange", "seed": 1, "perturbed": true, "gc": "/*\nIn this pr oble m, you will i mplementa function that takes  two vectors of numbers,\nand determ ines whether it is po ssible to pe r form an exchang e of eleme n ts\nbetween them to make lst1  a  vector of only even n umbers.\nThere isno limit on the n umber of exchanged e lemen ts between lst1 an d  lst2.\nIf it is possible to exchange ele ments betweenthe lst1 and l st2 to make\nall the elem ents of lst1 t o be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring exchange(vector<int> lst1,vector<int> lst2){\n\tint i,j,k,l,m,n,x,y;\n\tvector<int> temp;\n\tfor(i=0;i<lst1.size();i++){\n\t\tfor(j=0;j<lst2.size();j++){\n\t\t\tif(lst1[i]==lst2[j]){\n\t\t\t\ttemp.push_back(lst1[i]);\n\t\t\t\tlst1.erase(lst1.begin()+i);\n\t\t\t\tlst2.erase(lst2.begin()+j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(lst1.size()==0){\n\t\treturn \"YES\";\n\t}\n\telse{\n\t\treturn \"NO\";\n\t}\n}\nint main(){\n\tint t,n,i,j,k,l,m,x,y;\n\tvector<int> lst1,lst2;\n\tstring s;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&lst1.push_back(i));\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&lst2.push_back(i));\n\t\t}\n\t\ts=exchange(lst1,lst2);\n\t\tif(s==\"YES\"){\n\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/111", "prompt": "/*\nGiven a st ring  repre s enting  a spaceseparated lowercase l etters, returna  map\nof the letterwith themost repetit ion and cont a iningthe corre sponding c o unt.\nIf several letters have  t he same occurrence, re turn all of them.\n\nExample:\nhistogram(\"a b c\") == {{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}\nhistogram(\"a b b a\") == {{\"a\", 2}, {\"b\", 2}}\nhistogram(\"a b c a b\") == {{\"a\", 2}, {\"b\", 2}}\nhistogram(\"b b b b a\") == {{\"b\", 4}}\nhistogram(\"\") == {}\n\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nmap<char,int> histogram(string test){\n", "canonical_solution": "    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\nint main(){\n    assert (issame(histogram(\"a b b a\") , {{'a',2},{'b', 2}}));\n    assert (issame(histogram(\"a b c a b\") , {{'a', 2},{'b', 2}}));\n    assert (issame(histogram(\"a b c d g\") , {{'a', 1}, {'b', 1}, {'c', 1}, {'d', 1}, {'g', 1}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"b b b b a\") , {{'b', 4}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"\") , {}));\n    assert (issame(histogram(\"a\") , {{'a', 1}}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(histogram(\"a b b a\") , {{'a',2},{'b', 2}}));\n    assert (issame(histogram(\"a b c a b\") , {{'a', 2},{'b', 2}}));\n    assert (issame(histogram(\"a b c\") , {{'a', 1},{'b', 1},{'c', 1}}));\n    assert (issame(histogram(\"b b b b a\") , {{'b', 4}}));\n    assert (issame(histogram(\"\") , {}));\n}\n", "entry_point": "histogram", "seed": 1, "perturbed": true, "gc": "/*\nGiven a st ring  repre s enting  a spaceseparated lowercase l etters, returna  map\nof the letterwith themost repetit ion and cont a iningthe corre sponding c o unt.\nIf several letters have  t he same occurrence, re turn all of them.\n\nExample:\nhistogram(\"a b c\") == {{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}\nhistogram(\"a b b a\") == {{\"a\", 2}, {\"b\", 2}}\nhistogram(\"a b c a b\") == {{\"a\", 2}, {\"b\", 2}}\nhistogram(\"b b b b a\") == {{\"b\", 4}}\nhistogram(\"\") == {}\n\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nmap<char,int> histogram(string test){\n\tmap<char,int> hist;\n\tfor(int i=0;i<test.size();i++){\n\t\thist[test[i]]++;\n\t}\n\treturn hist;\n}\nint main(){\n\tstring test;\n\tcin>>test;\n\tmap<char,int> hist=histogram(test);\n\tfor(map<char,int>::iterator it=hist.begin();it!=hist.end();it++){\n\t\tcout<<it->first<<\" \"<<it->second<<endl;\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/112", "prompt": "/*\nTask\nWe ar e gi ven tw o  strin gs s andc, you have to delete d all the chara c ters in s that areequal toany characte r in c\nthenc heck if the res ult string is palindrome.\nAstring is c al led palindrome if it r eads the same backward as forward. You should return a  vect or containing ther esultstring and \"True\"/\"False\" for thecheck.\nExample\nFor s = \"abcde\", c = \"ae\", the result should be (\"bcd\",\"False\")\nFor s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",\"False\")\nFor s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",\"True\")\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> reverse_delete(string s,string c){\n", "canonical_solution": "    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(reverse_delete(\"abcde\",\"ae\") , {\"bcd\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdef\", \"b\") , {\"acdef\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"ab\") , {\"cdedc\",\"True\"}));\n    assert (issame(reverse_delete(\"dwik\",\"w\") , {\"dik\",\"False\"}));\n    assert (issame(reverse_delete(\"a\",\"a\") , {\"\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"v\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"vabba\",\"v\") , {\"abba\",\"True\"}));\n    assert (issame(reverse_delete(\"mamma\", \"mia\") , {\"\", \"True\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(reverse_delete(\"abcde\",\"ae\") , {\"bcd\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdef\", \"b\") , {\"acdef\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"ab\") , {\"cdedc\",\"True\"}));\n}\n", "entry_point": "reverse_delete", "seed": 1, "perturbed": true, "gc": "/*\nTask\nWe ar e gi ven tw o  strin gs s andc, you have to delete d all the chara c ters in s that areequal toany characte r in c\nthenc heck if the res ult string is palindrome.\nAstring is c al led palindrome if it r eads the same backward as forward. You should return a  vect or containing ther esultstring and \"True\"/\"False\" for thecheck.\nExample\nFor s = \"abcde\", c = \"ae\", the result should be (\"bcd\",\"False\")\nFor s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",\"False\")\nFor s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",\"True\")\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> reverse_delete(string s,string c){\n\tvector<string> res;\n\tint i = 0;\n\tint j = 0;\n\tint len = s.size();\n\twhile(i < len){\n\t\tif(s[i] == c[j]){\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse{\n\t\t\tif(j == c.size()){\n\t\t\t\tres.push_back(s.substr(i,len-i));\n\t\t\t\ti = len;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tstring s,c;\n\tcin>>s>>c;\n\tvector<string> res = reverse_delete(s,c);\n\tfor(int i = 0;i < res.size();i++){\n\t\tcout<<res[i]<<endl;\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "CPP/113", "prompt": "/*\nGiven a ve ctor  of st r ings,where eac h string consists ofonly digits, re t urn a vector.\nEachelement i of the outp ut should be 'the number ofodd elemen t s in the\nstring i of the inp ut .\" where all the i's s hould be replaced by the number\nof odd digits in the i 'th s tring of the input . \n\n>>> odd_count({\"1234567\"})\n{'the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n>>> odd_count({\"3\",\"11111111\"})\n{'the number of odd elements 1n the str1ng 1 of the 1nput.\",\n 'the number of odd elements 8n the str8ng 8 of the 8nput.\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\nvector<string> odd_count(vector<string> lst){\n", "canonical_solution": "    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}));\n    assert (issame(odd_count({\"3\",\"11111111\"}) , {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}));\n    assert (issame(odd_count({\"271\", \"137\", \"314\"}) , {\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n    }));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}));\n    assert (issame(odd_count({\"3\",\"11111111\"}) , {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}));\n}\n", "entry_point": "odd_count", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ve ctor  of st r ings,where eac h string consists ofonly digits, re t urn a vector.\nEachelement i of the outp ut should be 'the number ofodd elemen t s in the\nstring i of the inp ut.\" where all the i's s hould be replaced by the number\nof odd digits in the i 'th s tring of the input. \n\n>>> odd_count({\"1234567\"})\n{'the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n>>> odd_count({\"3\",\"11111111\"})\n{'the number of odd elements 1n the str1ng 1 of the 1nput.\",\n 'the number of odd elements 8n the str8ng 8 of the 8nput.\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\nvector<string> odd_count(vector<string> lst){\n\tmap<string,int> m;\n\tfor(int i=0;i<lst.size();i++){\n\t\tstring s=lst[i];\n\t\tint count=0;\n\t\tfor(int j=0;j<s.size();j++){\n\t\t\tif(s[j]%2==1)\n\t\t\t\tcount++;\n\t\t}\n\t\tm[s]=count;\n\t}\n\tvector<string> res;\n\tfor(int i=0;i<lst.size();i++){\n\t\tstring s=lst[i];\n\t\tint count=m[s];\n\t\tstringstream ss;\n\t\tss<<count;\n\t\tres.push_back(ss.str());\n\t}\n\treturn res;\n}\nint main(){\n\tvector<string> v;\n\tv.push_back(\"1234567\");\n\tv.push_back(\"311111111\");\n\tv.push_back(\"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "passed": 0, "run_status": 2}
{"task_id": "CPP/114", "prompt": "/*\nGiven a ve ctor  of in t egersnums, fin d the minimum sum ofany non-empty s u b-vector\nof nums.\nExample\nminSubArraySum({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum({-1, -2, -3}) == -6\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nlong long minSubArraySum(vector<long long> nums){\n", "canonical_solution": "    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (minSubArraySum({2, 3, 4, 1, 2, 4}) == 1);\n    assert (minSubArraySum({-1, -2, -3}) == -6);\n    assert (minSubArraySum({-1, -2, -3, 2, -10}) == -14);\n    assert (minSubArraySum({-9999999999999999}) == -9999999999999999);\n    assert (minSubArraySum({0, 10, 20, 1000000}) == 0);\n    assert (minSubArraySum({-1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({100, -1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({10, 11, 13, 8, 3, 4}) == 3);\n    assert (minSubArraySum({100, -33, 32, -1, 0, -2}) == -33);\n    assert (minSubArraySum({-10}) == -10);\n    assert (minSubArraySum({7}) == 7);\n    assert (minSubArraySum({1, -1}) == -1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (minSubArraySum({2, 3, 4, 1, 2, 4}) == 1);\n    assert (minSubArraySum({-1, -2, -3}) == -6);\n}\n", "entry_point": "minSubArraySum", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ve ctor  of in t egersnums, fin d the minimum sum ofany non-empty s u b-vector\nof nums.\nExample\nminSubArraySum({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum({-1, -2, -3}) == -6\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nlong long minSubArraySum(vector<long long> nums){\n\tlong long minSum = 0;\n\tlong long sum = 0;\n\tfor(int i = 0; i < nums.size(); i++){\n\t\tsum = 0;\n\t\tfor(int j = i; j < nums.size(); j++){\n\t\t\tsum += nums[j];\n\t\t\tif(sum < 0){\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\tif(sum > minSum){\n\t\t\t\tminSum = sum;\n\t\t\t}\n\t\t}\n\t}\n\treturn minSum;\n}\nint main(){\n\tvector<long long> nums;\n\tlong long sum = 0;\n\tlong long minSum = 0;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%lld\", &nums[i]);\n\t}\n\tminSum = minSubArraySum(nums);\n\tprintf(\"%lld\\n\", minSum);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/115", "prompt": "/*\nYou are gi vena rect a ngular  grid ofwells. Each row repre sents a singlew ell,\nand each 1 ina row represents a si ngle unit of water.\nEach wel l has a co r responding bucket that can b eused to extract waterfrom it, \nand all buckets have the same capacity.\nYour  task  is to use the buc k ets to empty the wells.\nOutput the numbe roftimes you need to lower  the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid{:,1}.length <= 10^2\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint max_fill(vector<vector<int>> grid,int capacity){\n", "canonical_solution": "    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (max_fill({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    assert (max_fill({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    assert (max_fill({{0,0,0}, {0,0,0}}, 5) == 0);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 2) == 4);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 9) == 2);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (max_fill({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    assert (max_fill({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    assert (max_fill({{0,0,0}, {0,0,0}}, 5) == 0);\n}\n", "entry_point": "max_fill", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena rect a ngular  grid ofwells. Each row repre sents a singlew ell,\nand each 1 ina row represents a si ngle unit of water.\nEach wel l has a co r responding bucket that can b eused to extract waterfrom it, \nand all buckets have the same capacity.\nYour  task  is to use the buc k ets to empty the wells.\nOutput the numbe roftimes you need to lower  the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid{:,1}.length <= 10^2\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint max_fill(vector<vector<int>> grid,int capacity){\n    int i,j,k,max_fill=0;\n    for(i=0;i<grid.size();i++){\n        for(j=0;j<grid[i].size();j++){\n            k=grid[i][j];\n            if(k==0){\n                continue;\n            }\n            if(k>capacity){\n                continue;\n            }\n            if(k>max_fill){\n                max_fill=k;\n            }\n        }\n    }\n    return max_fill;\n}\nint main(){\n    int n,i,j,k,capacity,max_fill;\n    vector<vector<int>> grid;\n    while(scanf(\"%d\",&n)!=EOF){\n        grid.clear();\n        for(i=0;i<n;i++){\n            vector<int> row;\n            for(j=0;j<n;j++){\n                scanf(\"%d\",&k);\n                row.push_back(k);\n            }\n            grid.push_back(row);\n        }\n        scanf(\"%d\",&capacity);\n        max_fill=max_fill(grid,capacity);\n        printf(\"%d\\n\",max_fill);\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/116", "prompt": "/*\nIn this Ka ta,you ha v e to s ort a vec tor of non-negative i ntegers accordi n g to\nnumber of ones  in their binary repr esentationi n  ascending orde r.\nFor sim i lar number of ones, sort bas ed  on decimal value.\n\nIt  must be implemented like this:\n>>> sort_vector({1, 5, 2, 3, 4}) == {1, 2, 3, 4, 5}\n>>> sort_vector({-2, -3, -4, -5, -6}) == {-6, -5, -4, -3, -2}\n>>> sort_vector({1, 0, 2, 3, 4}) == {0, 1, 2, 3, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_array(vector<int> arr){\n", "canonical_solution": "    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({1,5,2,3,4}) , {1, 2, 4, 3, 5}));\n    assert (issame(sort_array({-2,-3,-4,-5,-6}) , {-4, -2, -6, -5, -3}));\n    assert (issame(sort_array({1,0,2,3,4}) , {0, 1, 2, 4, 3}));\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({2,5,77,4,5,3,5,7,2,3,4}) , {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77}));\n    assert (issame(sort_array({3,6,44,12,32,5}) , {32, 3, 5, 6, 12, 44}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({1,5,2,3,4}) , {1, 2, 4, 3, 5}));\n    assert (issame(sort_array({-2,-3,-4,-5,-6}) , {-4, -2, -6, -5, -3}));\n    assert (issame(sort_array({1,0,2,3,4}) , {0, 1, 2, 4, 3}));\n}\n", "entry_point": "sort_array", "seed": 1, "perturbed": true, "gc": "/*\nIn this Ka ta,you ha v e to s ort a vec tor of non-negative i ntegers accordi n g to\nnumber of ones  in their binary repr esentationi n  ascending orde r.\nFor sim i lar number of ones, sort bas ed  on decimal value.\n\nIt  must be implemented like this:\n>>> sort_vector({1, 5, 2, 3, 4}) == {1, 2, 3, 4, 5}\n>>> sort_vector({-2, -3, -4, -5, -6}) == {-6, -5, -4, -3, -2}\n>>> sort_vector({1, 0, 2, 3, 4}) == {0, 1, 2, 3, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_array(vector<int> arr){\n    vector<int> res;\n    for(int i=0;i<arr.size();i++){\n        int temp = arr[i];\n        int j = i;\n        while(temp>0){\n            if(temp%2==1){\n                temp = temp/2;\n                res.push_back(j);\n            }\n            else{\n                j++;\n                temp = temp/2;\n            }\n        }\n    }\n    return res;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> arr(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&arr[i]);\n    }\n    vector<int> res = sort_array(arr);\n    for(int i=0;i<res.size();i++){\n        printf(\"%d \",res[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/117", "prompt": "/*\nGiven a st ring  s and a natu ral numbe r n, you have been ta sked to impleme n t \na function thatreturns a vector of a ll words fro m  string s thatcontain ex a ctly \nn consonants, in order  t hese words appear in t he string s.\nIf the string s is em pty then the functio nsho uld return an empt y  vector.\nNote: you may assume the inputstring contains only letters  and spaces.\nExamples:\nselect_words(\"Mary had a little lamb\", 4) ==> {\"little\"}\nselect_words(\"Mary had a little lamb\", 3) ==> {\"Mary\", \"lamb\"}\nselect_words('simple white space\", 2) ==> {}\nselect_words(\"Hello world\", 4) ==> {\"world\"}\nselect_words(\"Uncle sam\", 3) ==> {\"Uncle\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> select_words(string s,int n){\n", "canonical_solution": "    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(select_words(\"Mary had a little lamb\", 4) , {\"little\"}   ));\n    assert (issame(select_words(\"Mary had a little lamb\", 3) , {\"Mary\", \"lamb\"} ));\n    assert (issame(select_words(\"simple white space\", 2) , {}     ));\n    assert (issame(select_words(\"Hello world\", 4) , {\"world\"}  ));\n    assert (issame(select_words(\"Uncle sam\", 3) , {\"Uncle\"}));\n    assert (issame(select_words(\"\", 4) , {}));\n    assert (issame(select_words(\"a b c d e f\", 1) , {\"b\", \"c\", \"d\", \"f\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(select_words(\"Mary had a little lamb\", 4) , {\"little\"}   ));\n    assert (issame(select_words(\"Mary had a little lamb\", 3) , {\"Mary\", \"lamb\"} ));\n    assert (issame(select_words(\"simple white space\", 2) , {}     ));\n    assert (issame(select_words(\"Hello world\", 4) , {\"world\"}  ));\n    assert (issame(select_words(\"Uncle sam\", 3) , {\"Uncle\"}));\n}\n", "entry_point": "select_words", "seed": 1, "perturbed": true, "gc": "/*\nGiven a st ring  s and a natu ral numbe r n, you have been ta sked to impleme n t \na function thatreturns a vector of a ll words fro m  string s thatcontain ex a ctly \nn consonants, in order  t hese words appear in t he string s.\nIf the string s is em pty then the functio nsho uld return an empt y  vector.\nNote: you may assume the inputstring contains only letters  and spaces.\nExamples:\nselect_words(\"Mary had a little lamb\", 4) ==> {\"little\"}\nselect_words(\"Mary had a little lamb\", 3) ==> {\"Mary\", \"lamb\"}\nselect_words('simple white space\", 2) ==> {}\nselect_words(\"Hello world\", 4) ==> {\"world\"}\nselect_words(\"Uncle sam\", 3) ==> {\"Uncle\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> select_words(string s,int n){\n    vector<string> v;\n    int i=0,j=0;\n    while(i<s.length()){\n        while(j<s.length() && s[j]!=' '){\n            j++;\n        }\n        string temp=s.substr(i,j-i);\n        if(temp.length()>=n){\n            v.push_back(temp);\n        }\n        i=j+1;\n        j=i;\n    }\n    return v;\n}\nint main(){\n    string s;\n    int n;\n    cin>>s>>n;\n    vector<string> v=select_words(s,n);\n    for(int i=0;i<v.size();i++){\n        cout<<v[i]<<endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/118", "prompt": "/*\nYou are gi vena word .  Yourtask is t o find the closest vo wel that stands between \ntwo conson ants from the right s ide of thew o rd (case sensit ive).\n\nVow e ls in the beginning and endi ng  doesn't count. Return  empty string ifyou didn't\nfind a ny vowel met the abo ve co ndition. \n\nYou may assume that the given string contains En glish letter only.\n\nExample:\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring get_closest_vowel(string word){\n", "canonical_solution": "    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_closest_vowel(\"yogurt\") == \"u\");\n    assert (get_closest_vowel(\"full\") == \"u\");\n    assert (get_closest_vowel(\"easy\") == \"\");\n    assert (get_closest_vowel(\"eAsy\") == \"\");\n    assert (get_closest_vowel(\"ali\") == \"\");\n    assert (get_closest_vowel(\"bad\") == \"a\");\n    assert (get_closest_vowel(\"most\") ==\"o\");\n    assert (get_closest_vowel(\"ab\") == \"\");\n    assert (get_closest_vowel(\"ba\") == \"\");\n    assert (get_closest_vowel(\"quick\") == \"\");\n    assert (get_closest_vowel(\"anime\") == \"i\");\n    assert (get_closest_vowel(\"Asia\") == \"\");\n    assert (get_closest_vowel(\"Above\") == \"o\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_closest_vowel(\"yogurt\") == \"u\");\n    assert (get_closest_vowel(\"FULL\") == \"U\");\n    assert (get_closest_vowel(\"ab\") == \"\");\n    assert (get_closest_vowel(\"quick\") == \"\");\n}\n", "entry_point": "get_closest_vowel", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena word.  Yourtask is t o find the closest vo wel that stands between \ntwo conson ants from the right s ide of thew o rd (case sensit ive).\n\nVow e ls in the beginning and endi ng  doesn't count. Return  empty string ifyou didn't\nfind a ny vowel met the abo ve co ndition. \n\nYou may assume that the given string contains En glish letter only.\n\nExample:\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring get_closest_vowel(string word){\n\tint len = word.length();\n\tint i = 0;\n\tint j = len - 1;\n\twhile(i < j){\n\t\twhile(i < len && word[i]!= 'a' && word[i]!= 'e' && word[i]!= 'i' && word[i]!= 'o' && word[i]!= 'u' && word[i]!= 'y'){\n\t\t\ti++;\n\t\t}\n\t\twhile(j >= 0 && word[j]!= 'a' && word[j]!= 'e' && word[j]!= 'i' && word[j]!= 'o' && word[j]!= 'u' && word[j]!= 'y'){\n\t\t\tj--;\n\t\t}\n\t\tif(i < j){\n\t\t\tswap(word[i],word[j]);\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\treturn word;\n}\nint main(){\n\tstring word;\n\tcin >> word;\n\tcout << get_closest_vowel(word);\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/119", "prompt": "/*\nYou are gi vena vect o r of t wo string s, both strings consi st of open\npare n theses '(' or close  parentheses ')' only .\nYour jobi s  to check if it  is possib l e to concatenatethe two str in gs in\nsome order, that  the resulting string will be good .\nA stringS is cons idere d to be good if an d  onlyif all parentheses in S\nare balanc ed. For example: the string \"(())()\" is good, while the string\n\"())\" is not.\nReturn \"Yes\" if there's a way to make a good string, and return \"No\" otherwise.\n\nExamples:\nmatch_parens({\"()(\", \")\"}) == \"Yes\"\nmatch_parens({\")\", \")\"}) == \"No\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring match_parens(vector<string> lst){\n", "canonical_solution": "    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (match_parens({\"()(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \")\"}) == \"No\");\n    assert (match_parens({\"(()(())\", \"())())\"}) == \"No\");\n    assert (match_parens({\")())\", \"(()()(\"}) == \"Yes\");\n    assert (match_parens({\"(())))\", \"(()())((\"}) == \"Yes\");\n    assert (match_parens({\"()\", \"())\"}) == \"No\");\n    assert (match_parens({\"(()(\", \"()))()\"}) == \"Yes\");\n    assert (match_parens({\"((((\", \"((())\"}) == \"No\");\n    assert (match_parens({\")(()\", \"(()(\"}) == \"No\");\n    assert (match_parens({\")(\", \")(\"}) == \"No\");\n    assert (match_parens({\"(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \"(\"}) == \"Yes\" );\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (match_parens({\"()(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \")\"}) == \"No\");\n}\n", "entry_point": "match_parens", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena vect o r of t wo string s, both strings consi st of open\npare n theses '(' or close  parentheses ')' only.\nYour jobi s  to check if it  is possib l e to concatenatethe two str in gs in\nsome order, that  the resulting string will be good.\nA stringS is cons idere d to be good if an d  onlyif all parentheses in S\nare balanc ed. For example: the string \"(())()\" is good, while the string\n\"())\" is not.\nReturn \"Yes\" if there's a way to make a good string, and return \"No\" otherwise.\n\nExamples:\nmatch_parens({\"()(\", \")\"}) == \"Yes\"\nmatch_parens({\")\", \")\"}) == \"No\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring match_parens(vector<string> lst){\n\tstring s = \"\";\n\tfor(int i = 0; i < lst.size(); i++){\n\t\tif(lst[i].size() == 0)\n\t\t\tcontinue;\n\t\tif(lst[i][0] == '(')\n\t\t\ts += \"(\";\n\t\telse if(lst[i][lst[i].size() - 1] == ')')\n\t\t\ts += \")\";\n\t\telse\n\t\t\ts += lst[i];\n\t}\n\treturn s;\n}\nint main(){\n\tvector<string> lst = { \"()\", \"()()\", \"()()()\", \"()()()()\", \"()()()()()\", \"()()()()()()\" };\n\tstring s = match_parens(lst);\n\tif(s == \"Yes\")\n\t\tprintf(\"Yes\\n\");\n\telse\n\t\tprintf(\"No\\n\");\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/12", "prompt": "/*\nOut of vec torof str i ngs, r eturn the  longest one. Returnthe first one i n  case of multiple\ns trings of the same le ngth. Return None in case th e input ve c tor is empty.\n>>> longest({})\n\n>>> longest({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring longest(vector<string> strings){\n", "canonical_solution": "    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (longest({}) == \"\");\n    assert (longest({\"x\", \"y\", \"z\"}) == \"x\");\n    assert (longest({\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"}) == \"zzzz\");\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (longest({}) == \"\");\n    assert (longest({\"a\", \"b\", \"c\"}) == \"a\");\n    assert (longest({\"a\", \"bb\", \"ccc\"}) == \"ccc\");\n}\n", "entry_point": "longest", "seed": 1, "perturbed": true, "gc": "/*\nOut of vec torof str i ngs, r eturn the  longest one. Returnthe first one i n  case of multiple\ns trings of the same le ngth. Return None in case th e input ve c tor is empty.\n>>> longest({})\n\n>>> longest({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring longest(vector<string> strings){\n    if(strings.size() == 0)\n        return \"\";\n    string longest = strings[0];\n    for(int i = 1; i < strings.size(); i++){\n        if(strings[i].size() > longest.size())\n            longest = strings[i];\n    }\n    return longest;\n}\n\nint main(){\n    vector<string> strings;\n    strings.push_back(\"a\");\n    strings.push_back(\"bb\");\n    strings.push_back(\"ccc\");\n    strings.push_back(\"dddd\");\n    strings.push_back(\"eeeee\");\n    strings.push_back(\"ffffff\");\n    strings.push_back(\"gggggg\");\n    strings.push_back(\"hhhhhh\");\n    strings.push_back(\"iiiiii\");\n    strings.push_back(\"jjjjjj\");\n    strings.push_back(\"kkkkkk\");\n    strings.push_back(\"llllll\");\n    strings.push_back(\"mmmmmm\");\n    strings.push_back(\"nnnnnn\");\n    strings.push_back(\"ooooooo\");\n    strings.push_back(\"pppppp\");\n    strings.push_back(\"qqqqqq\");\n    strings.push_back(\"rrrrrr\");\n    strings.push_back(\"ssssss\");\n    strings.push_back(\"tttttt\");\n    strings.push_back(\"uuuuuu\");\n    strings.push_back(\"vvvvvv\");\n    strings.push_back(\"wwwwww\");\n    strings.push_back(\"xxxxxx\");\n    strings.push_back(\"yyyyyy\");\n    strings.push_back(\"zzzzzz\");\n    strings.push_back(\"aaaaaa\");\n    strings.push_back(\"bbbbbb\");\n    strings.push_back(\"cccccc\");\n    strings.push_back(\"dddddd\");\n    strings.push_back(\"eeeeee\");\n    strings.push_back(\"ffffff\");\n    strings.push_back(\"gggggg\");\n    strings.push_back(\"hhhhhh\");\n    strings.push_back(\"iiiiii\");\n    strings.push_back(\"jjjjjj\");\n    strings.push_back(\"kkkkkk\");\n    strings.push_back(\"llllll\");\n    strings.push_back(\"mmmmmm\");\n    strings.push_back(\"nnnnnn\");\n    strings.push_back(\"ooooooo\");\n    strings.push_back(\"pppppp\");\n    strings.push_back(\"qqqqqq\");\n    strings.push_back(\"rrrrrr\");\n    strings.push_back(\"ssssss\");\n    strings.push_back(\"tttttt\");\n    strings.push_back(\"uuuuuu\");\n    strings.push_back(\"vvvvvv\");\n    strings.push_back(\"wwwwww\");\n    strings.push_back(\"xxxxxx\");\n    strings.push_back(\"yyyyyy\");\n    strings.push_back(\"zzzzzz\");\n    strings.push_back(\"aaaaaa\");\n    strings.push_back(\"bbbbbb\");\n    strings.push_back(\"cccccc\");\n    strings.push_back(\"dddddd\");\n    strings.push_back(\"eeeeee\");\n    strings.push_back(\"ffffff\");\n    strings.push_back(\"gggggg\");\n    strings.push_back(\"hhhhhh\");\n    strings.push_back(\"iiiiii\");\n    strings.push_back(\"jjjjjj\");\n    strings.push_back(\"kkkkkk\");\n    strings.push_back(\"llllll\");\n    strings.push_back(\"mmmmmm\");\n    strings.push_back(\"nnnnnn\");\n    strings.push_back(\"ooooooo\");\n    strings.push_back(\"pppppp\");\n    strings.push_back(\"qqqqqq\");\n    strings.push_back(\"rrrrrr\");\n    strings.push_back(\"ssssss\");\n    strings.push_back(\"tttttt\");\n    strings.push_back(\"uuuuuu\");\n    strings.push_back(\"vvvvvv\");\n    strings.push_back(\"wwwwww\");\n    strings.push_back(\"xxxxxx\");\n    strings.push_back(\"yyyyyy\");\n    strings.push_back(\"zzzzzz\");\n    strings.push_back(\"aaaaaa\");\n    strings.push_back(\"bbbbbb\");\n    strings.push_back(\"cccccc\");\n    strings.push_back(\"dddddd\");\n    strings.push_back(\"eeeeee\");\n    strings.push_back(\"ffffff\");\n    strings.push_back(\"gggggg\");\n    strings.push_back(\"hhhhhh\");\n    strings.push_back(\"iiiiii\");\n    strings.push_back(\"jjjjjj\");\n    strings.push_back(\"kkkkkk\");\n    strings.push_back(\"llllll\");\n    strings.push_back(\"mmmmmm\");\n    strings.push_back(\"nnnnnn\");\n    strings.push_back(\"ooooooo\");\n    strings.push_back(\"pppppp\");\n    strings.push_back(\"qqqqqq\");\n    strings.push_back(\"rrrrrr\");\n    strings.push_back(\"ssssss\");\n    strings.push_back(\"tttttt\");\n    strings.push_back(\"uuuuuu\");\n    strings.push_back(\"vvvvvv\");\n    strings.push_back(\"wwwwww\");\n    strings.push_back(\"xxxxxx\");\n    strings.push_back(\"yyyyyy\");\n    strings.push_back(\"zzzzzz\");\n    strings.push_back(\"aaaaaa\");\n    strings.push_back(\"bbbbbb\");\n    strings.push_back(\"cccccc\");\n    strings.push_back(\"dddddd\");\n    strings.push_back(\"eeeeee\");\n    strings.push_back(\"ffffff\");\n    strings.push_back(\"gggggg\");\n    strings.push_back(\"hhhhhh\");", "passed": 1, "run_status": 0}
{"task_id": "CPP/120", "prompt": "/*\nGiven a ve ctor  arr o f  integ ers and a  positive integer k,return a sorted vector \nof length k  with the maximum k n umbers in ar r .\n\nExample 1:\n\n    Input: arr = {-3, -4, 5}, k = 3\n    Output: {-4, -3, 5}\n\nExample 2:\n\n    Input: arr = {4, -4, 4}, k = 2\n    Output: {4, 4}\n\nExample 3:\n\n    Input: arr = {-3, 2, 1, 2, -1, -2, 1}, k = 1\n    Output: {2}\n\nNote:\n    1. The length of the vector will be in the range of {1, 1000}.\n    2. The elements in the vector will be in the range of {-1000, 1000}.\n    3. 0 <= k <= len(arr)\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> maximum(vector<int> arr,int k){\n", "canonical_solution": "    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(maximum({-3, -4, 5}, 3) , {-4, -3, 5}));\n    assert (issame(maximum({4, -4, 4}, 2) , {4, 4}));\n    assert (issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1) , {2}));\n    assert (issame(maximum({123, -123, 20, 0 , 1, 2, -3}, 3) , {2, 20, 123}));\n    assert (issame(maximum({-123, 20, 0 , 1, 2, -3}, 4) , {0, 1, 2, 20}));\n    assert (issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7) , {-13, -8, 0, 0, 3, 5, 15}));\n    assert (issame(maximum({-1, 0, 2, 5, 3, -10}, 2) , {3, 5}));\n    assert (issame(maximum({1, 0, 5, -7}, 1) , {5}));\n    assert (issame(maximum({4, -4}, 2) , {-4, 4}));\n    assert (issame(maximum({-10, 10}, 2) , {-10, 10}));\n    assert (issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(maximum({-3, -4, 5}, 3) , {-4, -3, 5}));\n    assert (issame(maximum({4, -4, 4}, 2) , {4, 4}));\n    assert (issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1) , {2}));\n}\n", "entry_point": "maximum", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ve ctor  arr o f  integ ers and a  positive integer k,return a sorted vector \nof length k  with the maximum k n umbers in ar r.\n\nExample 1:\n\n    Input: arr = {-3, -4, 5}, k = 3\n    Output: {-4, -3, 5}\n\nExample 2:\n\n    Input: arr = {4, -4, 4}, k = 2\n    Output: {4, 4}\n\nExample 3:\n\n    Input: arr = {-3, 2, 1, 2, -1, -2, 1}, k = 1\n    Output: {2}\n\nNote:\n    1. The length of the vector will be in the range of {1, 1000}.\n    2. The elements in the vector will be in the range of {-1000, 1000}.\n    3. 0 <= k <= len(arr)\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> maximum(vector<int> arr,int k){\n    vector<int> res;\n    int i = 0;\n    while(i < k){\n        res.push_back(arr[i]);\n        i++;\n    }\n    return res;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> arr(n);\n    for(int i = 0;i < n;i++){\n        scanf(\"%d\",&arr[i]);\n    }\n    int k;\n    scanf(\"%d\",&k);\n    vector<int> res = maximum(arr,k);\n    for(int i = 0;i < res.size();i++){\n        printf(\"%d \",res[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/121", "prompt": "/*\nGiven a no n-em pty ve c tor of  integers , return the sum of a ll of the odd e l ements that are ineven positions.\n\n\nExamples\nsolution({5, 8, 7, 1}) ==> 12\nsolution({3, 3, 3, 3, 3}) ==> 9\nsolution({30, 13, 24, 321}) ==>0\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint solutions(vector<int> lst){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solutions({5, 8, 7, 1})    == 12);\n    assert (solutions({3, 3, 3, 3, 3}) == 9);\n    assert (solutions({30, 13, 24, 321}) == 0);\n    assert (solutions({5, 9}) == 5);\n    assert (solutions({2, 4, 8}) == 0);\n    assert (solutions({30, 13, 23, 32}) == 23);\n    assert (solutions({3, 13, 2, 9}) == 3);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solutions({5, 8, 7, 1})    == 12);\n    assert (solutions({3, 3, 3, 3, 3}) == 9);\n    assert (solutions({30, 13, 24, 321}) == 0);\n}\n", "entry_point": "solutions", "seed": 1, "perturbed": true, "gc": "/*\nGiven a no n-em pty ve c tor of  integers, return the sum of a ll of the odd e l ements that are ineven positions.\n\n\nExamples\nsolution({5, 8, 7, 1}) ==> 12\nsolution({3, 3, 3, 3, 3}) ==> 9\nsolution({30, 13, 24, 321}) ==>0\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint solutions(vector<int> lst){\n\tint sum = 0;\n\tfor(int i=0;i<lst.size();i++){\n\t\tif(i%2==0){\n\t\t\tsum+=lst[i];\n\t\t}\n\t}\n\treturn sum;\n}\nint main(){\n\tvector<int> lst;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tlst.push_back(x);\n\t}\n\tprintf(\"%d\\n\",solutions(lst));\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/122", "prompt": "/*\nGiven a no n-em pty ve c tor of  integers  arr and an integer k , return\nthe su m  of the elements wi th at most two digits  from the fi r st k elements o f arr.\n\nExample:\n\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add_elements(vector<int> arr,int k){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add_elements({1,-2,-3,41,57,76,87,88,99}, 3) == -4);\n    assert (add_elements({111,121,3,4000,5,6}, 2) == 0);\n    assert (add_elements({11,21,3,90,5,6,7,8,9}, 4) == 125);\n    assert (add_elements({111,21,3,4000,5,6,7,8,9}, 4) == 24);\n    assert (add_elements({1}, 1) == 1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add_elements({111,21,3,4000,5,6,7,8,9}, 4) == 24);\n}\n", "entry_point": "add_elements", "seed": 1, "perturbed": true, "gc": "/*\nGiven a no n-em pty ve c tor of  integers  arr and an integer k, return\nthe su m  of the elements wi th at most two digits  from the fi r st k elements o f arr.\n\nExample:\n\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add_elements(vector<int> arr,int k){\n    int sum = 0;\n    for(int i=0;i<k;i++){\n        sum += arr[i];\n    }\n    return sum;\n}\nint main(){\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    vector<int> arr(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&arr[i]);\n    }\n    int sum = add_elements(arr,k);\n    printf(\"%d\",sum);\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/123", "prompt": "/*\nGiven a po siti ve int e ger n,  return a  sorted vector that h as the odd numb e rs in collatz seque nce.\n\nThe Collatz con jecture isa conjecture in m athematics that concerns a sequence def in ed\nas follows: start w ith any positiveinteger n. Then e ach term is obtained  from  the \nprevious ter m  as follows: if the previous term is eve n, the next term is one half  of \nthe previous term.If the previou s term is odd, th e next term is 3 timesthe pre vious\nterm plus 1. The conject ure  is that no matter what value of n,the sequenc e will always rea ch 1.\n\nNote: \n    1. Collatz(1)is {1} .\n    2. returned vector sorted i n increasing order.\n\nFor example:\nget_odd_collatz(5) returns {1, 5} // The collatz sequence for 5 is {5, 16, 8, 4, 2, 1}, so the odd numbers are only 1, and 5.\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> get_odd_collatz(int n){\n", "canonical_solution": "    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_odd_collatz(14) , {1, 5, 7, 11, 13, 17}));\n    assert (issame(get_odd_collatz(5) , {1, 5}));\n    assert (issame(get_odd_collatz(12) , {1, 3, 5}));\n    assert (issame(get_odd_collatz(1) , {1}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_odd_collatz(5) , {1, 5}));\n}\n", "entry_point": "get_odd_collatz", "seed": 1, "perturbed": true, "gc": "/*\nGiven a po siti ve int e ger n,  return a  sorted vector that h as the odd numb e rs in collatz seque nce.\n\nThe Collatz con jecture isa conjecture in m athematics that concerns a sequence def in ed\nas follows: start w ith any positiveinteger n. Then e ach term is obtained  from  the \nprevious ter m  as follows: if the previous term is eve n, the next term is one half  of \nthe previous term.If the previou s term is odd, th e next term is 3 timesthe pre vious\nterm plus 1. The conject ure  is that no matter what value of n,the sequenc e will always rea ch 1.\n\nNote: \n    1. Collatz(1)is {1}.\n    2. returned vector sorted i n increasing order.\n\nFor example:\nget_odd_collatz(5) returns {1, 5} // The collatz sequence for 5 is {5, 16, 8, 4, 2, 1}, so the odd numbers are only 1, and 5.\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> get_odd_collatz(int n){\n    vector<int> odd_numbers;\n    odd_numbers.push_back(1);\n    int i = 1;\n    while(i < n){\n        if(i % 2 == 0){\n            i = i / 2;\n        }else{\n            i = 3 * i + 1;\n        }\n        odd_numbers.push_back(i);\n    }\n    return odd_numbers;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> odd_numbers = get_odd_collatz(n);\n    for(int i = 0; i < odd_numbers.size(); i++){\n        printf(\"%d \", odd_numbers[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "CPP/124", "prompt": "/*\nYou havet o wr ite af unctio n which v alidates a given date  string and\nret u rns true if the dat e is valid otherwisefalse.\nThed a te isvalid ifall of the following rules are satisfie d: \n1. The date string is  not empty.\n2. The number of daysis not less than 1 o rhig her than 31 days f o r months 1,3,5,7,8,10,12. And the number  ofdays is not less than 1or higher than 30 days f or months 4,6, 9,11. And, the nu mber of days is not less than1 or higher than 29 for the mo nth  2.\n3. The months should not be less  than 1 orhigher than 12.\n4 . The date should be in the form at: mm -dd-yyyy\n\nfor example: \nvalid_date(\"03-11-2000\") => true\n\nvalid_date(\"15-01-2012\") => false\n\nvalid_date(\"04-0-2040\") => false\n\nvalid_date(\"06-04-2020\") => true\n\nvalid_date(\"06/04/2020\") => false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool valid_date(string date){\n", "canonical_solution": "    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (valid_date(\"03-11-2000\") == true);\n    assert (valid_date(\"15-01-2012\") == false);\n    assert (valid_date(\"04-0-2040\") == false);\n    assert (valid_date(\"06-04-2020\") == true);\n    assert (valid_date(\"01-01-2007\") == true);\n    assert (valid_date(\"03-32-2011\") == false);\n    assert (valid_date(\"\") == false);\n    assert (valid_date(\"04-31-3000\") == false);\n    assert (valid_date(\"06-06-2005\") == true);\n    assert (valid_date(\"21-31-2000\") == false);\n    assert (valid_date(\"04-12-2003\") == true);\n    assert (valid_date(\"04122003\") == false);\n    assert (valid_date(\"20030412\") == false);\n    assert (valid_date(\"2003-04\") == false);\n    assert (valid_date(\"2003-04-12\") == false);\n    assert (valid_date(\"04-2003\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (valid_date(\"03-11-2000\") == true);\n    assert (valid_date(\"15-01-2012\") == false);\n    assert (valid_date(\"04-0-2040\") == false);\n    assert (valid_date(\"06-04-2020\") == true);\n    assert (valid_date(\"06/04/2020\") == false);\n}\n", "entry_point": "valid_date", "seed": 1, "perturbed": true, "gc": "/*\nYou havet o wr ite af unctio n which v alidates a given date  string and\nret u rns true if the dat e is valid otherwisefalse.\nThed a te isvalid ifall of the following rules are satisfie d: \n1. The date string is  not empty.\n2. The number of daysis not less than 1 o rhig her than 31 days f o r months 1,3,5,7,8,10,12. And the number  ofdays is not less than 1or higher than 30 days f or months 4,6, 9,11. And, the nu mber of days is not less than1 or higher than 29 for the mo nth  2.\n3. The months should not be less  than 1 orhigher than 12.\n4. The date should be in the form at: mm -dd-yyyy\n\nfor example: \nvalid_date(\"03-11-2000\") => true\n\nvalid_date(\"15-01-2012\") => false\n\nvalid_date(\"04-0-2040\") => false\n\nvalid_date(\"06-04-2020\") => true\n\nvalid_date(\"06/04/2020\") => false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool valid_date(string date){\n\tint month,day,year;\n\tint days[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n\tint days_month[12]={31,31,28,31,30,31,30,31,31,30,31,30};\n\tint year_month[12]={0,0,0,0,0,0,0,0,0,0,0,0};\n\tint i,j;\n\tint len=date.length();\n\tif(len==0)\n\t\treturn false;\n\tfor(i=0;i<len;i++){\n\t\tif(date[i]<'0'||date[i]>'9')\n\t\t\treturn false;\n\t}\n\tmonth=date[0]-'0';\n\tday=date[2]-'0';\n\tyear=date[4]-'0';\n\tif(month<1||month>12)\n\t\treturn false;\n\tif(day<1||day>31)\n\t\treturn false;\n\tif(day>days_month[month-1])\n\t\treturn false;\n\tif(year<0||year>2099)\n\t\treturn false;\n\tif(month==2&&year%4==0&&year%100!=0||month==2&&year%400==0)\n\t\tdays[1]=29;\n\telse\n\t\tdays[1]=days[month];\n\tif(month==1||month==3||month==5||month==7||month==8||month==10||month==12)\n\t\tdays[1]=31;\n\telse\n\t\tdays[1]=days[month];\n\tif(month==4||month==6||month==9||month==11)\n\t\tdays[1]=30;\n\telse\n\t\tdays[1]=31;\n\tfor(i=0;i<12;i++){\n\t\tif(month==i+1){\n\t\t\tyear_month[i]=year;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=0;i<12;i++){\n\t\tif(month==i+1&&year_month[i]==year){\n\t\t\tfor(j=1;j<=day;j++){\n\t\t\t\tif(j>days[i])\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\nint main(){\n\tstring date;\n\twhile(cin>>date){\n\t\tif(valid_date(date))\n\t\t\tcout<<\"valid\"<<endl;\n\t\telse\n\t\t\tcout<<\"invalid\"<<endl;\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/125", "prompt": "/*\nGiven a st ring  of wo r ds, re turn a ve ctor of words split o n whitespace, i f  no whitespaces exi sts in the text you\ns hould splito n commas ',' if  no commas exists you should return a v ec tor with one element,the number of lower-case letters w ith odd order in the \nalph abet, ord(\"a\") = 0 ,  ord(\"b\") = 1, ... ord(\"z\") = 25\nExamples\nsplit_words(\"Hello world!\")  {\"Hello\", \"world!\"}\nsplit_words(\"Hello,world!\")  {\"Hello\", \"world!\"}\nsplit_words(\"abcdef\") == {\"3\"} \n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> split_words(string txt){\n", "canonical_solution": "    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(split_words(\"Hello world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello,world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello world,!\") , {\"Hello\",\"world,!\"}));\n    assert (issame(split_words(\"Hello,Hello,world !\") , {\"Hello,Hello,world\",\"!\"}));\n    assert (issame(split_words(\"abcdef\") , {\"3\"}));\n    assert (issame(split_words(\"aaabb\") , {\"2\"}));\n    assert (issame(split_words(\"aaaBb\") , {\"1\"}));\n    assert (issame(split_words(\"\") ,{\"0\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(split_words(\"Hello world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello,world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"abcdef\") , {\"3\"}));\n}\n", "entry_point": "split_words", "seed": 1, "perturbed": true, "gc": "/*\nGiven a st ring  of wo r ds, re turn a ve ctor of words split o n whitespace, i f  no whitespaces exi sts in the text you\ns hould splito n commas ',' if  no commas exists you should return a v ec tor with one element,the number of lower-case letters w ith odd order in the \nalph abet, ord(\"a\") = 0,  ord(\"b\") = 1,... ord(\"z\") = 25\nExamples\nsplit_words(\"Hello world!\")  {\"Hello\", \"world!\"}\nsplit_words(\"Hello,world!\")  {\"Hello\", \"world!\"}\nsplit_words(\"abcdef\") == {\"3\"} \n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> split_words(string txt){\n\tvector<string> res;\n\tstring s;\n\tfor(int i = 0; i < txt.size(); i++){\n\t\tif(txt[i] ==''){\n\t\t\tif(s.size() > 0){\n\t\t\t\tres.push_back(s);\n\t\t\t\ts.clear();\n\t\t\t}\n\t\t}else{\n\t\t\ts += txt[i];\n\t\t}\n\t}\n\tif(s.size() > 0){\n\t\tres.push_back(s);\n\t}\n\treturn res;\n}\nint main(){\n\tstring txt = \"Hello world!\";\n\tvector<string> res = split_words(txt);\n\tfor(int i = 0; i < res.size(); i++){\n\t\tprintf(\"%s\\n\", res[i].c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/126", "prompt": "/*\nGiven a ve ctor  of nu m bers,return wh ether or not they are  sorted\nin asce n ding order. If vect or has more than 1 du plicate oft h e same\nnumber,return fal s e. Assume no negative number sand only integers.\n\nExamples\nis_sorted({5})  true\nis_sorted({1, 2, 3, 4, 5})  true\nis_sorted({1, 3, 2, 4, 5})  false\nis_sorted({1, 2, 3, 4, 5, 6})  true\nis_sorted({1, 2, 3, 4, 5, 6, 7})  true\nis_sorted({1, 3, 2, 4, 5, 6, 7})  false\nis_sorted({1, 2, 2, 3, 3, 4})  true\nis_sorted({1, 2, 2, 2, 3, 4})  false\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool is_sorted(vector<int> lst){\n", "canonical_solution": "    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_sorted({5}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5}) == false);\n    assert (is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert (is_sorted({}) == true);\n    assert (is_sorted({1}) == true);\n    assert (is_sorted({3, 2, 1}) == false);\n    assert (is_sorted({1, 2, 2, 2, 3, 4}) == false);\n    assert (is_sorted({1, 2, 3, 3, 3, 4}) == false);\n    assert (is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert (is_sorted({1, 2, 3, 4}) == true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_sorted({5}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5}) == false);\n    assert (is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert (is_sorted({1, 2, 2, 2, 3, 4}) == false);\n    assert (is_sorted({1, 2, 2, 3, 3, 4}) == true);\n}\n", "entry_point": "is_sorted", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ve ctor  of nu m bers,return wh ether or not they are  sorted\nin asce n ding order. If vect or has more than 1 du plicate oft h e same\nnumber,return fal s e. Assume no negative number sand only integers.\n\nExamples\nis_sorted({5})  true\nis_sorted({1, 2, 3, 4, 5})  true\nis_sorted({1, 3, 2, 4, 5})  false\nis_sorted({1, 2, 3, 4, 5, 6})  true\nis_sorted({1, 2, 3, 4, 5, 6, 7})  true\nis_sorted({1, 3, 2, 4, 5, 6, 7})  false\nis_sorted({1, 2, 2, 3, 3, 4})  true\nis_sorted({1, 2, 2, 2, 3, 4})  false\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool is_sorted(vector<int> lst){\n    int i = 0;\n    while(i<lst.size()-1){\n        if(lst[i]>lst[i+1]){\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> lst(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&lst[i]);\n    }\n    if(is_sorted(lst)){\n        printf(\"true\");\n    }\n    else{\n        printf(\"false\");\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/127", "prompt": "/*\nYou are gi ventwo in t ervals ,\nwhere e ach interval is a pai r of integers. For example, interval = (start, end) = (1, 2).\nThe given intervals are closed which means that the interval (start, end)\nincludes both start and end.\nFor each given interval, it is assumed that its start is less or equal its end.\nYour task is to determine whether the length of intersection of these two \nintervals is a prime number.\nExample, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\nwhich its length is 1, which not a prime number.\nIf the length of the intersection is a prime number, return \"YES\",\notherwise, return \"NO\".\nIf the two intervals don't intersect, return \"NO\".\n\n\n{input/output} samples:\nintersection({1, 2}, {2, 3}) ==> \"NO\"\nintersection({-1, 1}, {0, 4}) ==> \"NO\"\nintersection({-3, -1}, {-5, 5}) ==> \"YES\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring intersection( vector<int> interval1,vector<int> interval2){\n", "canonical_solution": "    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (intersection({1, 2}, {2, 3}) == \"NO\");\n    assert (intersection({-1, 1}, {0, 4}) == \"NO\");\n    assert (intersection({-3, -1}, {-5, 5}) == \"YES\");\n    assert (intersection({-2, 2}, {-4, 0}) == \"YES\");\n    assert (intersection({-11, 2}, {-1, -1}) == \"NO\");\n    assert (intersection({1, 2}, {3, 5}) == \"NO\");\n    assert (intersection({1, 2}, {1, 2}) == \"NO\");\n    assert (intersection({-2, -2}, {-3, -2}) == \"NO\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (intersection({1, 2}, {2, 3}) == \"NO\");\n    assert (intersection({-1, 1}, {0, 4}) == \"NO\");\n    assert (intersection({-3, -1}, {-5, 5}) == \"YES\");\n}\n", "entry_point": "intersection", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi ventwo in t ervals,\nwhere e ach interval is a pai r of integers. For example, interval = (start, end) = (1, 2).\nThe given intervals are closed which means that the interval (start, end)\nincludes both start and end.\nFor each given interval, it is assumed that its start is less or equal its end.\nYour task is to determine whether the length of intersection of these two \nintervals is a prime number.\nExample, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\nwhich its length is 1, which not a prime number.\nIf the length of the intersection is a prime number, return \"YES\",\notherwise, return \"NO\".\nIf the two intervals don't intersect, return \"NO\".\n\n\n{input/output} samples:\nintersection({1, 2}, {2, 3}) ==> \"NO\"\nintersection({-1, 1}, {0, 4}) ==> \"NO\"\nintersection({-3, -1}, {-5, 5}) ==> \"YES\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int start1 = interval1[0];\n    int end1 = interval1[1];\n    int start2 = interval2[0];\n    int end2 = interval2[1];\n    if(start1 > end2 || start2 > end1){\n        return \"NO\";\n    }\n    int start = max(start1,start2);\n    int end = min(end1,end2);\n    int length = end - start + 1;\n    if(length < 2){\n        return \"NO\";\n    }\n    int i = 2;\n    while(i < length){\n        if(i % 2 == 0){\n            return \"NO\";\n        }\n        i++;\n    }\n    return \"YES\";\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> interval1(n);\n    vector<int> interval2(n);\n    for(int i = 0;i < n;i++){\n        scanf(\"%d\",&interval1[i]);\n    }\n    for(int i = 0;i < n;i++){\n        scanf(\"%d\",&interval2[i]);\n    }\n    string result = intersection(interval1,interval2);\n    if(result == \"NO\"){\n        printf(\"NO\");\n    }else{\n        printf(\"%s\",result.c_str());\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/128", "prompt": "/*\nYou are gi vena vect o r arrof intege rs and you need to re turn\nsum of mag n itudes of integersmultiplied by product  of all sign s \nof each number  in the ve c tor, representedby 1, -1 or  0 .\nNote: return -32768for empty arr.\n\nExample:\n>>> prod_signs({1, 2, 2, -4}) == -9\n>>> prod_signs({0, 1}) == 0\n>>> prod_signs({}) == -32768\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint prod_signs(vector<int> arr){\n", "canonical_solution": "    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prod_signs({1, 2, 2, -4}) == -9);\n    assert (prod_signs({0, 1}) == 0);\n    assert (prod_signs({1, 1, 1, 2, 3, -1, 1}) == -10);\n    assert (prod_signs({}) == -32768);\n    assert (prod_signs({2, 4,1, 2, -1, -1, 9}) == 20);\n    assert (prod_signs({-1, 1, -1, 1}) == 4);\n    assert (prod_signs({-1, 1, 1, 1}) == -4);\n    assert (prod_signs({-1, 1, 1, 0}) == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prod_signs({1, 2, 2, -4}) == -9);\n    assert (prod_signs({0, 1}) == 0);\n    assert (prod_signs({}) == -32768);\n}\n", "entry_point": "prod_signs", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena vect o r arrof intege rs and you need to re turn\nsum of mag n itudes of integersmultiplied by product  of all sign s \nof each number  in the ve c tor, representedby 1, -1 or  0.\nNote: return -32768for empty arr.\n\nExample:\n>>> prod_signs({1, 2, 2, -4}) == -9\n>>> prod_signs({0, 1}) == 0\n>>> prod_signs({}) == -32768\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint prod_signs(vector<int> arr){\n\tint sum = 0;\n\tint sign = 0;\n\tfor(int i = 0; i < arr.size(); i++){\n\t\tif(arr[i] == 0){\n\t\t\treturn -32768;\n\t\t}\n\t\tif(arr[i] == 1){\n\t\t\tsign = 1;\n\t\t}\n\t\tif(arr[i] == -1){\n\t\t\tsign = -1;\n\t\t}\n\t\tsum = sum + sign*arr[i];\n\t}\n\treturn sum;\n}\nint main(){\n\tvector<int> arr;\n\tint n;\n\twhile(scanf(\"%d\", &n)!= EOF){\n\t\tarr.push_back(n);\n\t}\n\tprintf(\"%d\\n\", prod_signs(arr));\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/129", "prompt": "/*\nGiven a gr id w ith Nr ows an d N colum ns (N >= 2) and a pos itive integer k ,  \neach cell of thegrid contains a value . Every inte g er inthe range  {1, N * N } \ninclusive appears exactly o nc e on the cells of thegrid.\n\nYou have to find the minimu m path of length k i nthe  grid. You can sta r t\nfrom any cell, andin each step you ca nmove to anyof the neighbo r cells,\nin other words,  you can go to  cells which shar e an edge with you current\ncel l.\nPlease note that a path oflen gth k means visiting exactly k cells  (not\nneces sarily distinct). \nYou CANNOT go off the grid.\nA p ath A(of lengthk) is considered lessthan a path B (of length k) ifafte r makingthe ordered vec tors of thevalues on th e ce lls that Aand B go\nthrough (let'scall t hem lst _A an d lst_B), lst_A is lexicographical ly less\nthan lst_B, in other words, there exist an integer i ndex i (1 <= i <= k)\nsuch t hat ls t_A[i] < lst_B[i] and for any j (1 <= j < i)we have\nlst_A[j] = lst _B[j].It is guaranteed that the answer is unique.Return an ordered vector of the values on the cells thatt heminimum  pathgo thr o ugh.\n\nExamples:\n\n    Input: grid = { {1,2,3}, {4,5,6}, {7,8,9}}, k = 3\n    Output: {1, 2, 1}\n\n    Input: grid = { {5,9,3}, {4,1,6}, {7,8,2}}, k = 1\n    Output: {1}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> minPath(vector<vector<int>> grid, int k){\n", "canonical_solution": "    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1}));\n    assert (issame(minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1) , {1}));\n    assert (issame(minPath({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4) , {1, 2, 1, 2}));\n    assert (issame(minPath({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7) , {1, 10, 1, 10, 1, 10, 1}));\n    assert (issame(minPath({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5) , {1, 7, 1, 7, 1}));\n    assert (issame(minPath({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9) , {1, 6, 1, 6, 1, 6, 1, 6, 1}));\n    assert (issame(minPath({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12) , {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6}));\n    assert (issame(minPath({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8) , {1, 3, 1, 3, 1, 3, 1, 3}));\n    assert (issame(minPath({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8) , {1, 5, 1, 5, 1, 5, 1, 5}));\n    assert (issame(minPath({{1, 2}, {3, 4}}, 10) , {1, 2, 1, 2, 1, 2, 1, 2, 1, 2}));\n    assert (issame(minPath({{1, 3}, {3, 2}}, 10) , {1, 3, 1, 3, 1, 3, 1, 3, 1, 3}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1}));\n    assert (issame(minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1) , {1}));\n}\n", "entry_point": "minPath", "seed": 1, "perturbed": true, "gc": "/*\nGiven a gr id w ith Nr ows an d N colum ns (N >= 2) and a pos itive integer k,  \neach cell of thegrid contains a value. Every inte g er inthe range  {1, N * N } \ninclusive appears exactly o nc e on the cells of thegrid.\n\nYou have to find the minimu m path of length k i nthe  grid. You can sta r t\nfrom any cell, andin each step you ca nmove to anyof the neighbo r cells,\nin other words,  you can go to  cells which shar e an edge with you current\ncel l.\nPlease note that a path oflen gth k means visiting exactly k cells  (not\nneces sarily distinct). \nYou CANNOT go off the grid.\nA p ath A(of lengthk) is considered lessthan a path B (of length k) ifafte r makingthe ordered vec tors of thevalues on th e ce lls that Aand B go\nthrough (let'scall t hem lst _A an d lst_B), lst_A is lexicographical ly less\nthan lst_B, in other words, there exist an integer i ndex i (1 <= i <= k)\nsuch t hat ls t_A[i] < lst_B[i] and for any j (1 <= j < i)we have\nlst_A[j] = lst _B[j].It is guaranteed that the answer is unique.Return an ordered vector of the values on the cells thatt heminimum  pathgo thr o ugh.\n\nExamples:\n\n    Input: grid = { {1,2,3}, {4,5,6}, {7,8,9}}, k = 3\n    Output: {1, 2, 1}\n\n    Input: grid = { {5,9,3}, {4,1,6}, {7,8,2}}, k = 1\n    Output: {1}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int n = grid.size();\n    vector<int> path(k);\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i == 0){\n                dp[i][j] = grid[i][j];\n            }else{\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + grid[i][j];\n            }\n        }\n    }\n    for(int i = k - 1; i >= 0; i--){\n        path[i] = dp[n - 1][i];\n    }\n    return path;\n}\nint main(){\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    vector<vector<int>> grid(n, vector<int>(n));\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    vector<int> path = minPath(grid, k);\n    for(int i = 0; i < k; i++){\n        printf(\"%d \", path[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/13", "prompt": "/*\nReturn ag reat est co m mon di visor oftwo integers a and b\n>>> greatest_common_divisor(3, 5)\n1\n>>> greatest_common_divisor(25, 15)\n5\n*/\n#include<stdio.h>\nusing namespace std;\nint greatest_common_divisor(int a, int b){\n", "canonical_solution": "    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (greatest_common_divisor(3, 7) == 1);\n     assert (greatest_common_divisor(10, 15) == 5);\n      assert (greatest_common_divisor(49, 14) == 7);\n     assert (greatest_common_divisor(144, 60) == 12);\n}\n", "declaration": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (greatest_common_divisor(3, 5) == 1);\n     assert (greatest_common_divisor(25, 15) == 5);\n}\n", "entry_point": "greatest_common_divisor", "seed": 1, "perturbed": true, "gc": "/*\nReturn ag reat est co m mon di visor oftwo integers a and b\n>>> greatest_common_divisor(3, 5)\n1\n>>> greatest_common_divisor(25, 15)\n5\n*/\n#include<stdio.h>\nusing namespace std;\nint greatest_common_divisor(int a, int b){\n\tint i, j;\n\twhile(b!=0){\n\t\ti = a;\n\t\tj = b;\n\t\ta = b;\n\t\tb = i%j;\n\t}\n\treturn a;\n}\nint main(){\n\tint a, b;\n\tprintf(\"Enter two integers\\n\");\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"The gcd of %d and %d is %d\\n\", a, b, greatest_common_divisor(a, b));\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/130", "prompt": "/*\nEveryonek nows  Fibon a cci se quence, i t was studied deeplyby mathematicia n s in \nthe last coup le centuries. However , what peopl e  don't know isTribonacci sequence.\nTribonacci sequenc eis defined by the recu rrence:\ntri(1) =3\ntri(n) = 1 + n/ 2, if n is even.\nt ri(n)  =  tri(n - 1) + t r i(n -2) + tri(n + 1), if n is odd.\nFor example:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n       = 2 + 3 + 3 = 8 \nYou are given a non-negative integer number n, you have to a return a vector of the \nfirst n + 1 numbers of the Tribonacci sequence.\nExamples:\ntri(3) = {1, 3, 2, 8}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> tri(int n){\n", "canonical_solution": "    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(tri(3) , {1, 3, 2, 8}));\n    assert (issame(tri(4) , {1, 3, 2, 8, 3}));\n    assert (issame(tri(5) , {1, 3, 2, 8, 3, 15}));\n    assert (issame(tri(6) , {1, 3, 2, 8, 3, 15, 4}));\n    assert (issame(tri(7) , {1, 3, 2, 8, 3, 15, 4, 24}));\n    assert (issame(tri(8) , {1, 3, 2, 8, 3, 15, 4, 24, 5}));\n    assert (issame(tri(9) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35}));\n    assert (issame(tri(20) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11}));\n    assert (issame(tri(0) , {1}));\n    assert (issame(tri(1) , {1, 3}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(tri(3) , {1, 3, 2, 8}));\n}\n", "entry_point": "tri", "seed": 1, "perturbed": true, "gc": "/*\nEveryonek nows  Fibon a cci se quence, i t was studied deeplyby mathematicia n s in \nthe last coup le centuries. However, what peopl e  don't know isTribonacci sequence.\nTribonacci sequenc eis defined by the recu rrence:\ntri(1) =3\ntri(n) = 1 + n/ 2, if n is even.\nt ri(n)  =  tri(n - 1) + t r i(n -2) + tri(n + 1), if n is odd.\nFor example:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n       = 2 + 3 + 3 = 8 \nYou are given a non-negative integer number n, you have to a return a vector of the \nfirst n + 1 numbers of the Tribonacci sequence.\nExamples:\ntri(3) = {1, 3, 2, 8}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> tri(int n){\n    vector<int> v;\n    v.push_back(1);\n    v.push_back(3);\n    v.push_back(2);\n    for(int i = 3; i <= n; i++){\n        v.push_back(v[i - 1] + v[i - 2] + v[i - 3]);\n    }\n    return v;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> v = tri(n);\n    for(int i = 0; i < v.size(); i++){\n        printf(\"%d \", v[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/131", "prompt": "/*\nGiven a po siti ve int e ger n,  return t he product of the odd  digits.\nReturn 0 if all digits are  even.\nFor example:\ndigits(1)  == 1\ndigits(4)  == 0\ndigits(235) == 15\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint digits(int n){\n", "canonical_solution": "    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digits(5) == 5);\n    assert (digits(54) == 5);\n    assert (digits(120) ==1);\n    assert (digits(5014) == 5);\n    assert (digits(98765) == 315);\n    assert (digits(5576543) == 2625);\n    assert (digits(2468) == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digits(1) == 1);\n    assert (digits(4) == 0);\n    assert (digits(235) ==15);\n}\n", "entry_point": "digits", "seed": 1, "perturbed": true, "gc": "/*\nGiven a po siti ve int e ger n,  return t he product of the odd  digits.\nReturn 0 if all digits are  even.\nFor example:\ndigits(1)  == 1\ndigits(4)  == 0\ndigits(235) == 15\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint digits(int n){\n    int i=0;\n    while(n>0){\n        i+=n%10;\n        n/=10;\n    }\n    return i;\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n)!=EOF){\n        int odd=0;\n        int even=0;\n        int i=0;\n        while(n>0){\n            if(digits(n)%2==1){\n                odd++;\n            }\n            else{\n                even++;\n            }\n            n/=10;\n        }\n        if(odd==0 && even==0){\n            printf(\"0\\n\");\n        }\n        else{\n            printf(\"%d\\n\",odd*even);\n        }\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/132", "prompt": "/*\nCreate af unct ion th a t take s a strin g as input which cont ains only squar e  brackets.\nThe func tion should return tr ue if and on l y if there is a  valid sub s equence of brackets\nwhere at  l east one bracket in th e subsequence isnested.\n\nis_neste d(\"[[]]\")  true\nis_ neste d(\"[]]]]]]][[[[[]\" )   false\nis_nested(\"[][]\")  false\nis_ne sted(\"[]\")  false\nis_nested (\"[[][]]\")  true\nis_nes ted(\"[[]][[\") true\n*/\n#includ e<stdio.h>\n#include<string>\nus ing namespace std;\nbool is_nes ted (string str){\n", "canonical_solution": "    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_nested(\"[[]]\") == true);\n    assert (is_nested(\"[]]]]]]][[[[[]\") == false);\n    assert (is_nested(\"[][]\") == false);\n    assert (is_nested((\"[]\")) == false);\n    assert (is_nested(\"[[[[]]]]\") == true);\n    assert (is_nested(\"[]]]]]]]]]]\") == false);\n    assert (is_nested(\"[][][[]]\") == true);\n    assert (is_nested(\"[[]\") == false);\n    assert (is_nested(\"[]]\") == false);\n    assert (is_nested(\"[[]][[\") == true);\n    assert (is_nested(\"[[][]]\") == true);\n    assert (is_nested(\"\") == false);\n    assert (is_nested(\"[[[[[[[[\") == false);\n    assert (is_nested(\"]]]]]]]]\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_nested(\"[[]]\") == true);\n    assert (is_nested(\"[]]]]]]][[[[[]\") == false);\n    assert (is_nested(\"[][]\") == false);\n    assert (is_nested(\"[]\") == false);\n    assert (is_nested(\"[[]][[\") == true);\n    assert (is_nested(\"[[][]]\") == true);\n}\n", "entry_point": "is_nested", "seed": 1, "perturbed": true, "gc": "/*\nCreate af unct ion th a t take s a strin g as input which cont ains only squar e  brackets.\nThe func tion should return tr ue if and on l y if there is a  valid sub s equence of brackets\nwhere at  l east one bracket in th e subsequence isnested.\n\nis_neste d(\"[[]]\")  true\nis_ neste d(\"[]]]]]]][[[[[]\" )   false\nis_nested(\"[][]\")  false\nis_ne sted(\"[]\")  false\nis_nested (\"[[][]]\")  true\nis_nes ted(\"[[]][[\") true\n*/\n#includ e<stdio.h>\n#include<string>\nus ing namespace std;\nbool is_nes ted (string str){\n\tint i=0,j=0,k=0;\n\tbool flag=false;\n\twhile(i<str.length()){\n\t\tif(str[i]=='['){\n\t\t\tj=i;\n\t\t\tk=i;\n\t\t\twhile(str[k]!=']'){\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tif(str[k+1]=='['){\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn flag;\n}\nbool is_nested(string str){\n\tint i=0,j=0,k=0;\n\tbool flag=false;\n\twhile(i<str.length()){\n\t\tif(str[i]=='['){\n\t\t\tj=i;\n\t\t\tk=i;\n\t\t\twhile(str[k]!=']'){\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tif(str[k+1]=='['){\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn flag;\n}\nbool is_neste(string str){\n\tint i=0,j=0,k=0;\n\tbool flag=false;\n\twhile(i<str.length()){\n\t\tif(str[i]=='['){\n\t\t\tj=i;\n\t\t\tk=i;\n\t\t\twhile(str[k]!=']'){\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tif(str[k+1]=='['){\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn flag;\n}\nint main(){\n\tstring str;\n\tcin>>str;\n\tif(is_nested(str)){\n\t\tcout<<\"true\";\n\t}\n\telse{\n\t\tcout<<\"false\";\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/133", "prompt": "/*\nYou are gi vena vect o r of n umbers.\nY ou need to return the  sum of squared numbers in the give n vector,\nround eachelement int h e vector to the  upper int ( Ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\n\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<float> lst){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3})==14);\n    assert (sum_squares({1.0,2,3})==14);\n    assert (sum_squares({1,3,5,7})==84);\n    assert (sum_squares({1.4,4.2,0})==29);\n    assert (sum_squares({-2.4,1,1})==6);\n    assert (sum_squares({100,1,15,2})==10230);\n    assert (sum_squares({10000,10000})==200000000);\n    assert (sum_squares({-1.4,4.6,6.3})==75);\n    assert (sum_squares({-1.4,17.9,18.9,19.9})==1086);\n    assert (sum_squares({0})==0);\n    assert (sum_squares({-1})==1);\n    assert (sum_squares({-1,1,0})==2);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3})==14);\n    assert (sum_squares({1,4,9})==98);\n    assert (sum_squares({1,3,5,7})==84);\n    assert (sum_squares({1.4,4.2,0})==29);\n    assert (sum_squares({-2.4,1,1})==6);\n}\n", "entry_point": "sum_squares", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena vect o r of n umbers.\nY ou need to return the  sum of squared numbers in the give n vector,\nround eachelement int h e vector to the  upper int ( Ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\n\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for(int i=0;i<lst.size();i++){\n        sum+=pow(lst[i],2);\n    }\n    return sum;\n}\nint main(){\n    vector<float> lst;\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        float x;\n        scanf(\"%f\",&x);\n        lst.push_back(x);\n    }\n    int sum=sum_squares(lst);\n    printf(\"%d\",sum);\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/134", "prompt": "/*\nCreate af unct ion th a t retu rns trueif the last character \nof a given str i ng is an alphabetic al character and is n ot\na part of a word, and fal se otherwi s e.\nNote: \"word\" is a group o fcharacters separated b y space.\n\nExamples:\ncheck_if_last_char_is_a_letter(\"apple pie\")  false\ncheck_if_last_char_is_a_letter(\"apple pi e\")  true\ncheck_if_last_char_is_a_letter(\"apple pi e \")  false\ncheck_if_last_char_is_a_letter(\"\")  false \n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool check_if_last_char_is_a_letter(string txt){\n", "canonical_solution": "    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_if_last_char_is_a_letter(\"apple\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e\") == true);\n    assert (check_if_last_char_is_a_letter(\"eeeee\") == false);\n    assert (check_if_last_char_is_a_letter(\"A\") == true);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie \") == false);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie 1\") == false);\n    assert (check_if_last_char_is_a_letter(\"\") == false);\n    assert (check_if_last_char_is_a_letter(\"eeeee e \") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pie\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e \") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_if_last_char_is_a_letter(\"apple pi e\") == true);\n    assert (check_if_last_char_is_a_letter(\"\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pie\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e \") == false);\n}\n", "entry_point": "check_if_last_char_is_a_letter", "seed": 1, "perturbed": true, "gc": "/*\nCreate af unct ion th a t retu rns trueif the last character \nof a given str i ng is an alphabetic al character and is n ot\na part of a word, and fal se otherwi s e.\nNote: \"word\" is a group o fcharacters separated b y space.\n\nExamples:\ncheck_if_last_char_is_a_letter(\"apple pie\")  false\ncheck_if_last_char_is_a_letter(\"apple pi e\")  true\ncheck_if_last_char_is_a_letter(\"apple pi e \")  false\ncheck_if_last_char_is_a_letter(\"\")  false \n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool check_if_last_char_is_a_letter(string txt){\n\tif(txt.length()==0)\n\t\treturn false;\n\tint i=txt.length()-1;\n\twhile(i>=0){\n\t\tif(!isalpha(txt[i]))\n\t\t\treturn false;\n\t\ti--;\n\t}\n\treturn true;\n}\nint main(){\n\tstring txt;\n\twhile(getline(cin,txt)){\n\t\tif(check_if_last_char_is_a_letter(txt))\n\t\t\tprintf(\"%s is a letter\\n\",txt.c_str());\n\t\telse\n\t\t\tprintf(\"%s is not a letter\\n\",txt.c_str());\n\t}\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/135", "prompt": "/*\nCreate af unct ion wh i ch ret urns thelargest index of an e lement which\nis not greater than or  equal to the element  immediately preceding it. I f\nno suche lement exists then return -1 .The given vector willnot contain\nduplicate values.\n\nExamples:\ncan_arrange({1,2,4,3,5}) = 3\ncan_arrange({1,2,3}) = -1\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint can_arrange(vector<int> arr){\n", "canonical_solution": "    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (can_arrange({1,2,4,3,5})==3);\n    assert (can_arrange({1,2,4,5})==-1);\n    assert (can_arrange({1,4,2,5,6,7,8,9,10})==2);\n    assert (can_arrange({4,8,5,7,3})==4);\n    assert (can_arrange({})==-1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (can_arrange({1,2,4,3,5})==3);\n    assert (can_arrange({1,2,3})==-1);\n}\n", "entry_point": "can_arrange", "seed": 1, "perturbed": true, "gc": "/*\nCreate af unct ion wh i ch ret urns thelargest index of an e lement which\nis not greater than or  equal to the element  immediately preceding it. I f\nno suche lement exists then return -1.The given vector willnot contain\nduplicate values.\n\nExamples:\ncan_arrange({1,2,4,3,5}) = 3\ncan_arrange({1,2,3}) = -1\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint can_arrange(vector<int> arr){\n\tint i=0,j=0,k=0;\n\tfor(i=0;i<arr.size();i++){\n\t\tif(arr[i]>=arr[i-1]){\n\t\t\tk=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(k==0)\n\t\treturn -1;\n\tfor(j=i-1;j>=0;j--){\n\t\tif(arr[j]<=arr[k-1]){\n\t\t\tk=j;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn k;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> arr(n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&arr[i]);\n\t}\n\tint k=can_arrange(arr);\n\tif(k==-1)\n\t\tprintf(\"-1\");\n\telse\n\t\tprintf(\"%d\",k+1);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/136", "prompt": "/*\nCreate af unct ion th a t retu rns a vec tor (a, b), where \"a\"  is\nthe largest of negative integer s, and \"b\" is the sma llest\nof pos i tive integers i n a vector . \nIf there is no negative orpo sitive integers, retur n them as 0.\n\nExamples:\nlargest_smallest_integers({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers({}) == {0,0}\nlargest_smallest_integers({0}) == {0,0}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> largest_smallest_integers(vector<int> lst){\n", "canonical_solution": "    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7}) , {0, 1}));\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7, 0}) , {0, 1}));\n    assert (issame(largest_smallest_integers({1, 3, 2, 4, 5, 6, -2}) , {-2, 1}));\n    assert (issame(largest_smallest_integers({4, 5, 3, 6, 2, 7, -7}) , {-7, 2}));\n    assert (issame(largest_smallest_integers({7, 3, 8, 4, 9, 2, 5, -9}) , {-9, 2}));\n    assert (issame(largest_smallest_integers({}) , {0, 0}));\n    assert (issame(largest_smallest_integers({0}) , {0, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6, 0}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, 1}) , {-3, 1}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, -100, 1}) , {-3, 1}));\n\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7}) , {0, 1}));\n    assert (issame(largest_smallest_integers({}) , {0, 0}));\n    assert (issame(largest_smallest_integers({0}) , {0, 0}));\n}\n", "entry_point": "largest_smallest_integers", "seed": 1, "perturbed": true, "gc": "/*\nCreate af unct ion th a t retu rns a vec tor (a, b), where \"a\"  is\nthe largest of negative integer s, and \"b\" is the sma llest\nof pos i tive integers i n a vector. \nIf there is no negative orpo sitive integers, retur n them as 0.\n\nExamples:\nlargest_smallest_integers({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers({}) == {0,0}\nlargest_smallest_integers({0}) == {0,0}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> largest_smallest_integers(vector<int> lst){\n\tvector<int> ret;\n\tint a = 0;\n\tint b = 0;\n\tfor(int i = 0; i < lst.size(); i++){\n\t\tif(lst[i] < 0){\n\t\t\tif(a < 0){\n\t\t\t\ta = lst[i];\n\t\t\t}else{\n\t\t\t\tif(lst[i] > a){\n\t\t\t\t\ta = lst[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(b < 0){\n\t\t\t\tb = lst[i];\n\t\t\t}else{\n\t\t\t\tif(lst[i] < b){\n\t\t\t\t\tb = lst[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(a < 0){\n\t\tret.push_back(0);\n\t}else{\n\t\tret.push_back(a);\n\t}\n\tif(b < 0){\n\t\tret.push_back(0);\n\t}else{\n\t\tret.push_back(b);\n\t}\n\treturn ret;\n}\nint main(){\n\tvector<int> lst = {2, 4, 1, 3, 5, 7};\n\tvector<int> ret = largest_smallest_integers(lst);\n\tfor(int i = 0; i < ret.size(); i++){\n\t\tprintf(\"%d \", ret[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/137", "prompt": "/*\nCreate af unct ion th a t take s integer s, floats, or strings  representing\nr e al numbers, and ret urns thelarger varia ble in itsg i ven variable ty pe.\nReturn \"None\" if the values are equ al .\nNote: If a real numb er is represented as a string, the floating point migh tbe. or ,\n\ncompare_on e (1, 2.5)  2.5\ncompare_one(1, \"2,3\")  \" 2,3\"compare_one(\"5,1\", \"6\")   \"6\"\ncompare_one(\"1\",1)  \"None\"\n*/ \n#include<stdio.h >\n#include<string>\n#include<al gorithm>\n#include<boost/any.hp p>using namespace std;\nboost::any comp are_one(boo st::any a,boost:: any b){\n", "canonical_solution": "    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (boost::any_cast<int>(compare_one(1, 2)) == 2);\n    assert (boost::any_cast<double>(compare_one(1, 2.5))== 2.5);\n    assert (boost::any_cast<int>(compare_one(2, 3)) == 3);\n    assert (boost::any_cast<int>(compare_one(5, 6)) == 6);\n    assert (boost::any_cast<string>(compare_one(1, string(\"2,3\")))== \"2,3\");\n    assert (boost::any_cast<string>(compare_one(string(\"5,1\"), string(\"6\"))) == \"6\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), string(\"2\"))) == \"2\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), 1)) == \"None\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (boost::any_cast<double>(compare_one(1, 2.5))== 2.5);\n    assert (boost::any_cast<string>(compare_one(1, string(\"2,3\")))== \"2,3\");\n    assert (boost::any_cast<string>(compare_one(string(\"5,1\"), string(\"6\"))) == \"6\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), 1)) == \"None\");\n}\n", "entry_point": "compare_one", "seed": 1, "perturbed": true, "gc": "/*\nCreate af unct ion th a t take s integer s, floats, or strings  representing\nr e al numbers, and ret urns thelarger varia ble in itsg i ven variable ty pe.\nReturn \"None\" if the values are equ al.\nNote: If a real numb er is represented as a string, the floating point migh tbe. or,\n\ncompare_on e (1, 2.5)  2.5\ncompare_one(1, \"2,3\")  \" 2,3\"compare_one(\"5,1\", \"6\")   \"6\"\ncompare_one(\"1\",1)  \"None\"\n*/ \n#include<stdio.h >\n#include<string>\n#include<al gorithm>\n#include<boost/any.hp p>using namespace std;\nboost::any comp are_one(boo st::any a,boost:: any b){\n\tif(a.type()==b.type()){\n\t\tif(a.type()==typeid(int)){\n\t\t\treturn a.cast<int>()>b.cast<int>();\n\t\t}\n\t\tif(a.type()==typeid(float)){\n\t\t\treturn a.cast<float>()>b.cast<float>();\n\t\t}\n\t\tif(a.type()==typeid(string)){\n\t\t\treturn a.cast<string>()>b.cast<string>();\n\t\t}\n\t}\n\treturn \"None\";\n}\nint main(){\n\tint a,b;\n\tfloat c,d;\n\tstring e,f;\n\tscanf(\"%d%d%f%s%f\",&a,&b,&c,&e,&d);\n\tif(a>b){\n\t\tprintf(\"%d\",a);\n\t}\n\telse{\n\t\tprintf(\"%d\",b);\n\t}\n\tif(c>d){\n\t\tprintf(\"%f\",c);\n\t}\n\telse{\n\t\tprintf(\"%f\",d);\n\t}\n\tif(e==\"\"){\n\t\tprintf(\"None\");\n\t}\n\telse{\n\t\tprintf(\"%s\",e.c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/138", "prompt": "/*\nEvaluatew heth er the givennumber ncan be written as the  sum of exactly 4 positive even num bers\nExample\nis_equal_to_sum_even(4) == false\nis_equal_to_sum_even(6) == false\nis_equal_to_sum_even(8) == true\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_equal_to_sum_even(int n){\n", "canonical_solution": "    if (n%2==0 and n>=8) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_equal_to_sum_even(4) == false);\n    assert (is_equal_to_sum_even(6) == false);\n    assert (is_equal_to_sum_even(8) == true);\n    assert (is_equal_to_sum_even(10) == true);\n    assert (is_equal_to_sum_even(11) == false);\n    assert (is_equal_to_sum_even(12) == true);\n    assert (is_equal_to_sum_even(13) == false);\n    assert (is_equal_to_sum_even(16) == true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_equal_to_sum_even(4) == false);\n    assert (is_equal_to_sum_even(6) == false);\n    assert (is_equal_to_sum_even(8) == true);\n}\n", "entry_point": "is_equal_to_sum_even", "seed": 1, "perturbed": true, "gc": "/*\nEvaluatew heth er the givennumber ncan be written as the  sum of exactly 4 positive even num bers\nExample\nis_equal_to_sum_even(4) == false\nis_equal_to_sum_even(6) == false\nis_equal_to_sum_even(8) == true\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_equal_to_sum_even(int n){\n\tint sum = 0;\n\twhile(n > 0){\n\t\tsum += n;\n\t\tn = n/2;\n\t}\n\tif(sum%2 == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)==1){\n\t\tif(is_equal_to_sum_even(n))\n\t\t\tprintf(\"%d is equal to the sum of exactly 4 positive even numbers\\n\",n);\n\t\telse\n\t\t\tprintf(\"%d is not equal to the sum of exactly 4 positive even numbers\\n\",n);\n\t}\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/139", "prompt": "/*\nThe Brazil ianfactor i al isdefined a s:\nbrazilian_factoria l(n) = n! * (n- 1 )! * (n-2)! * ... *  1!\nwhere n > 0\n\nForexample:\n>>> special_factorial(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n*/\n#include<stdio.h>\nusing namespace std;\nlong long special_factorial(int n){\n", "canonical_solution": "    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (special_factorial(4) == 288);\n    assert (special_factorial(5) == 34560);\n    assert (special_factorial(7) == 125411328000);\n    assert (special_factorial(1) == 1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (special_factorial(4) == 288);\n}\n", "entry_point": "special_factorial", "seed": 1, "perturbed": true, "gc": "/*\nThe Brazil ianfactor i al isdefined a s:\nbrazilian_factoria l(n) = n! * (n- 1 )! * (n-2)! *... *  1!\nwhere n > 0\n\nForexample:\n>>> special_factorial(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n*/\n#include<stdio.h>\nusing namespace std;\nlong long special_factorial(int n){\n    long long factorial = 1;\n    for(int i = 1; i <= n; i++){\n        factorial *= i;\n    }\n    return factorial;\n}\n\nint main(){\n    int n;\n    printf(\"Enter the number of factorial: \");\n    scanf(\"%d\", &n);\n    printf(\"The special factorial of %d is: %lld\\n\", n, special_factorial(n));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/14", "prompt": "/*\nReturn vec torof all prefix es from s hortest to longest of  the input stri n g\n>>> all_prefixes(\"abc\")\n{\"a\", \"ab\", \"abc\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> all_prefixes(string str){\n", "canonical_solution": "    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(all_prefixes(\"\"),{}));\n    assert (issame(all_prefixes(\"asdfgh\") ,{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"}));\n     assert (issame(all_prefixes(\"WWW\") ,{\"W\", \"WW\", \"WWW\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(all_prefixes(\"abc\"),{\"a\",\"ab\",\"abc\"}));\n}\n", "entry_point": "all_prefixes", "seed": 1, "perturbed": true, "gc": "/*\nReturn vec torof all prefix es from s hortest to longest of  the input stri n g\n>>> all_prefixes(\"abc\")\n{\"a\", \"ab\", \"abc\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> all_prefixes(string str){\n\tvector<string> res;\n\tint len = str.length();\n\tfor(int i = 0; i < len; i++){\n\t\tstring temp = str.substr(0, i+1);\n\t\tif(temp.length() > res.size()){\n\t\t\tres.push_back(temp);\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tstring str = \"abc\";\n\tvector<string> res = all_prefixes(str);\n\tfor(int i = 0; i < res.size(); i++){\n\t\tprintf(\"%s\\n\", res[i].c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/140", "prompt": "/*\nGiven a st ring  text, replac e all spa ces in it with unders cores, \nand ifa  string has more th an 2 consecutive spac es, \nthen re p lace all consec utive spac e s with - \n\nfix_spaces(\"Example\") == \"Example\"\nfix_spaces(\"Example 1\") == \"Example_1\"\nfix_spaces(\" Example 2\") == \"_Example_2\"\nfix_spaces(\" Example   3\") == \"_Example-3\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring fix_spaces(string text){\n", "canonical_solution": "    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fix_spaces(\"Example\") == \"Example\");\n    assert (fix_spaces(\"Mudasir Hanif \") == \"Mudasir_Hanif_\");\n    assert (fix_spaces(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\");\n    assert (fix_spaces(\"Exa   mple\") == \"Exa-mple\");\n    assert (fix_spaces(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\");\n}\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fix_spaces(\"Example\") == \"Example\");\n    assert (fix_spaces(\"Example 1\") == \"Example_1\");\n    assert (fix_spaces(\" Example 2\") == \"_Example_2\");\n    assert (fix_spaces(\" Example   3\") == \"_Example-3\");\n}\n", "entry_point": "fix_spaces", "seed": 1, "perturbed": true, "gc": "/*\nGiven a st ring  text, replac e all spa ces in it with unders cores, \nand ifa  string has more th an 2 consecutive spac es, \nthen re p lace all consec utive spac e s with - \n\nfix_spaces(\"Example\") == \"Example\"\nfix_spaces(\"Example 1\") == \"Example_1\"\nfix_spaces(\" Example 2\") == \"_Example_2\"\nfix_spaces(\" Example   3\") == \"_Example-3\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring fix_spaces(string text){\n\tint i=0;\n\tint j=0;\n\tint len=text.length();\n\twhile(i<len){\n\t\tif(text[i]==' '){\n\t\t\ttext[j]=text[i];\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\telse{\n\t\t\ttext[j]=text[i];\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t}\n\tif(j<len){\n\t\ttext[j]=text[i];\n\t\tj++;\n\t}\n\treturn text;\n}\nint main(){\n\tstring text=\"Example\";\n\tcout<<\"Original: \"<<text<<endl;\n\tcout<<\"Fixed: \"<<fix_spaces(text)<<endl;\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/141", "prompt": "/*\nCreate af unct ion wh i ch tak es a stri ng representing a fil e's name, and r e turns\n\"Yes\" if thethe file's name is va lid, and ret u rns \"No\" otherw ise.\nA fil e 's name is considered to beva lid if and only if all  the following conditions \nare met :\n- There should not  be m ore than three dig i ts ('0'-'9') in the file's name.\n- The f ile's name contains exactlyone dot \".\"\n-The substr ingbefore the  dot should not b e empty, and it startswith aletter from \nthe latin alphape t ( 'a'-'z' and 'A'-'Z').\n- The substrin g after the  dot should be on e of these: {'txt\", \"exe\", \"dll\" }\nExamples:\nfile_name_check(\"example.txt\") => \"Yes\"\nfile_name_check(\"1example.dll\")  => \"No\" // (the name should start with a latin alphapet letter)\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring file_name_check(string file_name){\n", "canonical_solution": "    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (file_name_check(\"example.txt\") == \"Yes\");\n    assert (file_name_check(\"1example.dll\") == \"No\");\n    assert (file_name_check(\"s1sdf3.asd\") == \"No\");\n    assert (file_name_check(\"K.dll\") == \"Yes\");\n    assert (file_name_check(\"MY16FILE3.exe\") == \"Yes\");\n    assert (file_name_check(\"His12FILE94.exe\") == \"No\");\n    assert (file_name_check(\"_Y.txt\") == \"No\");\n    assert (file_name_check(\"?aREYA.exe\") == \"No\");\n    assert (file_name_check(\"/this_is_valid.dll\") == \"No\");\n    assert (file_name_check(\"this_is_valid.wow\") == \"No\");\n    assert (file_name_check(\"this_is_valid.txt\") == \"Yes\");\n    assert (file_name_check(\"this_is_valid.txtexe\") == \"No\");\n    assert (file_name_check(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert (file_name_check(\"@this1_is6_valid.exe\") == \"No\");\n    assert (file_name_check(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert (file_name_check(\"all.exe.txt\") == \"No\");\n    assert (file_name_check(\"I563_No.exe\") == \"Yes\");\n    assert (file_name_check(\"Is3youfault.txt\") == \"Yes\");\n    assert (file_name_check(\"no_one#knows.dll\") == \"Yes\");\n    assert (file_name_check(\"1I563_Yes3.exe\") == \"No\");\n    assert (file_name_check(\"I563_Yes3.txtt\") == \"No\");\n    assert (file_name_check(\"final..txt\") == \"No\");\n    assert (file_name_check(\"final132\") == \"No\");\n    assert (file_name_check(\"_f4indsartal132.\") == \"No\");\n    assert (file_name_check(\".txt\") == \"No\");\n    assert (file_name_check(\"s.\") == \"No\");\n}\n", "declaration": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (file_name_check(\"example.txt\") == \"Yes\");\n    assert (file_name_check(\"1example.dll\") == \"No\");\n}\n", "entry_point": "file_name_check", "seed": 1, "perturbed": true, "gc": "/*\nCreate af unct ion wh i ch tak es a stri ng representing a fil e's name, and r e turns\n\"Yes\" if thethe file's name is va lid, and ret u rns \"No\" otherw ise.\nA fil e's name is considered to beva lid if and only if all  the following conditions \nare met :\n- There should not  be m ore than three dig i ts ('0'-'9') in the file's name.\n- The f ile's name contains exactlyone dot \".\"\n-The substr ingbefore the  dot should not b e empty, and it startswith aletter from \nthe latin alphape t ( 'a'-'z' and 'A'-'Z').\n- The substrin g after the  dot should be on e of these: {'txt\", \"exe\", \"dll\" }\nExamples:\nfile_name_check(\"example.txt\") => \"Yes\"\nfile_name_check(\"1example.dll\")  => \"No\" // (the name should start with a latin alphapet letter)\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring file_name_check(string file_name){\n\tstring file_name_check = \"\";\n\tif(file_name.find(\".\")!= string::npos){\n\t\tfile_name_check = \"Yes\";\n\t}\n\telse{\n\t\tfile_name_check = \"No\";\n\t}\n\treturn file_name_check;\n}\nint main(){\n\tstring file_name = \"example.txt\";\n\tcout<<file_name_check(file_name)<<endl;\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/142", "prompt": "/*\n\"\nThis fun ctio n will take a  vector o f integers. For all e ntries in the v e ctor, the functionshall square the inte ger entry if its index is a\nmultipleo f 3 and will cube the intege rentry if its index isa multiple of 4 and not a multiple of 3. Thefunctionwillnot \nchange the en t ries in the vector whose indexes are not  a multiple of 3 or 4. The f unction shallthen retur n the sum of a ll entries. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<int> lst){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3}) == 6);\n    assert (sum_squares({1,4,9}) == 14);\n    assert (sum_squares({}) == 0);\n    assert (sum_squares({1,1,1,1,1,1,1,1,1}) == 9);\n    assert (sum_squares({-1,-1,-1,-1,-1,-1,-1,-1,-1}) == -3);\n    assert (sum_squares({0}) == 0);\n    assert (sum_squares({-1,-5,2,-1,-5}) == -126);\n    assert (sum_squares({-56,-99,1,0,-2}) == 3030);\n    assert (sum_squares({-1,0,0,0,0,0,0,0,-1}) == 0);\n    assert (sum_squares({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}) == -14196);\n    assert (sum_squares({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}) == -1448);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3}) == 6);\n    assert (sum_squares({}) == 0);\n    assert (sum_squares({-1,-5,2,-1,-5}) == -126);\n}\n", "entry_point": "sum_squares", "seed": 1, "perturbed": true, "gc": "/*\n\"\nThis fun ctio n will take a  vector o f integers. For all e ntries in the v e ctor, the functionshall square the inte ger entry if its index is a\nmultipleo f 3 and will cube the intege rentry if its index isa multiple of 4 and not a multiple of 3. Thefunctionwillnot \nchange the en t ries in the vector whose indexes are not  a multiple of 3 or 4. The f unction shallthen retur n the sum of a ll entries. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<int> lst){\n\tint sum = 0;\n\tfor(int i = 0; i < lst.size(); i++){\n\t\tif(i%3 == 0){\n\t\t\tsum += lst[i]*lst[i];\n\t\t}\n\t\tif(i%4 == 0){\n\t\t\tsum += lst[i]*lst[i]*lst[i];\n\t\t}\n\t}\n\treturn sum;\n}\nint main(){\n\tvector<int> lst;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i = 0; i < n; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tlst.push_back(x);\n\t}\n\tprintf(\"%d\\n\",sum_squares(lst));\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/143", "prompt": "/*\nYou are gi vena stri n g repr esentinga sentence,\nthe sente nce contains so m e words separated b y a space,\nand you ha ve to return a string that c ontains th e  words from the original sen te nce,\nwhose lengths are  prime numbers,\nthe order of the w ords in the new stri ng sh ould be the same a s  the original one.\n\nExample 1:\n    Input: sentence = \"This is a test\"\n    Output: \"is\"\n\nExample 2:\n    Input: sentence = \"lets go for swimming\"\n    Output: \"go for\"\n\nConstraints:\n    * 1 <= len(sentence) <= 100\n    * sentence contains only letters\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring words_in_sentence(string sentence){\n", "canonical_solution": "    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (words_in_sentence(\"This is a test\") == \"is\");\n    assert (words_in_sentence(\"lets go for swimming\") == \"go for\");\n    assert (words_in_sentence(\"there is no place available here\") == \"there is no place\");\n    assert (words_in_sentence(\"Hi I am Hussein\") == \"Hi am Hussein\");\n    assert (words_in_sentence(\"go for it\") == \"go for it\");\n    assert (words_in_sentence(\"here\") == \"\");\n    assert (words_in_sentence(\"here is\") == \"is\");\n}\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (words_in_sentence(\"This is a test\") == \"is\");\n    assert (words_in_sentence(\"lets go for swimming\") == \"go for\");\n}\n", "entry_point": "words_in_sentence", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena stri n g repr esentinga sentence,\nthe sente nce contains so m e words separated b y a space,\nand you ha ve to return a string that c ontains th e  words from the original sen te nce,\nwhose lengths are  prime numbers,\nthe order of the w ords in the new stri ng sh ould be the same a s  the original one.\n\nExample 1:\n    Input: sentence = \"This is a test\"\n    Output: \"is\"\n\nExample 2:\n    Input: sentence = \"lets go for swimming\"\n    Output: \"go for\"\n\nConstraints:\n    * 1 <= len(sentence) <= 100\n    * sentence contains only letters\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring words_in_sentence(string sentence){\n    string word;\n    int i = 0;\n    int j = 0;\n    int len = sentence.length();\n    int prime = 0;\n    while(i < len){\n        if(sentence[i] ==''){\n            word = sentence.substr(j, i - j);\n            prime = 1;\n            for(int k = 0; k < word.length(); k++){\n                if(word[k] ==''){\n                    prime = 0;\n                    break;\n                }\n            }\n            if(prime == 1){\n                j = i + 1;\n            }\n        }\n        i++;\n    }\n    word = sentence.substr(j, i - j);\n    return word;\n}\nint main(){\n    string sentence;\n    while(cin >> sentence){\n        string word = words_in_sentence(sentence);\n        cout << word << endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/144", "prompt": "/*\nYour taskis t o impl e ment a  function  that will simplify t he expression\nx * n. The function r eturns true if x * nevaluates to a whole numberand falseo therwise. Both xand n, arest ring representation of  a fraction, andhave the followin g format,\n<numerator >/<de nominator> where b o th numerator and denominator are positiv ewhole numbers.\n\nYou can as sume that x, and n are v alid fractions , and do not have zero as denominator.\nsimplif y(\"1/5\", \"5/1\") = true\nsimplif y(\" 1/6\", \"2/1\") = false\nsimplify(\"7/10\" , \"10/2\") =  false\n*/\n#includ e<stdio.h>\n#include<string>\nusin g name space std;bool simplify(string x ,string n){\n", "canonical_solution": "    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/6\", \"2/1\") == false);\n    assert (simplify(\"5/1\", \"3/1\") == true);\n    assert (simplify(\"7/10\", \"10/2\") == false);\n    assert (simplify(\"2/10\", \"50/10\") == true);\n    assert (simplify(\"7/2\", \"4/2\") == true);\n    assert (simplify(\"11/6\", \"6/1\") == true);\n    assert (simplify(\"2/3\", \"5/2\") == false);\n    assert (simplify(\"5/2\", \"3/5\") == false);\n    assert (simplify(\"2/4\", \"8/4\") == true);\n    assert (simplify(\"2/4\", \"4/2\") == true);\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/5\", \"1/5\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/6\", \"2/1\") == false);\n    assert (simplify(\"7/10\", \"10/2\") == false);\n}\n", "entry_point": "simplify", "seed": 1, "perturbed": true, "gc": "/*\nYour taskis t o impl e ment a  function  that will simplify t he expression\nx * n. The function r eturns true if x * nevaluates to a whole numberand falseo therwise. Both xand n, arest ring representation of  a fraction, andhave the followin g format,\n<numerator >/<de nominator> where b o th numerator and denominator are positiv ewhole numbers.\n\nYou can as sume that x, and n are v alid fractions, and do not have zero as denominator.\nsimplif y(\"1/5\", \"5/1\") = true\nsimplif y(\" 1/6\", \"2/1\") = false\nsimplify(\"7/10\", \"10/2\") =  false\n*/\n#includ e<stdio.h>\n#include<string>\nusin g name space std;bool simplify(string x,string n){\n\tint xi = stoi(x);\n\tint ni = stoi(n);\n\tif(xi == 0)return false;\n\tif(ni == 0)return true;\n\tif(xi == ni)return true;\n\tif(xi > ni)return false;\n\tint xi1 = xi;\n\tint ni1 = ni;\n\tint xi2 = xi;\n\tint ni2 = ni;\n\tint xi3 = xi;\n\tint ni3 = ni;\n\tint xi4 = xi;\n\tint ni4 = ni;\n\tint xi5 = xi;\n\tint ni5 = ni;\n\tint xi6 = xi;\n\tint ni6 = ni;\n\tint xi7 = xi;\n\tint ni7 = ni;\n\tint xi8 = xi;\n\tint ni8 = ni;\n\tint xi9 = xi;\n\tint ni9 = ni;\n\tint xi10 = xi;\n\tint ni10 = ni;\n\tint xi11 = xi;\n\tint ni11 = ni;\n\tint xi12 = xi;\n\tint ni12 = ni;\n\tint xi13 = xi;\n\tint ni13 = ni;\n\tint xi14 = xi;\n\tint ni14 = ni;\n\tint xi15 = xi;\n\tint ni15 = ni;\n\tint xi16 = xi;\n\tint ni16 = ni;\n\tint xi17 = xi;\n\tint ni17 = ni;\n\tint xi18 = xi;\n\tint ni18 = ni;\n\tint xi19 = xi;\n\tint ni19 = ni;\n\tint xi20 = xi;\n\tint ni20 = ni;\n\tint xi21 = xi;\n\tint ni21 = ni;\n\tint xi22 = xi;\n\tint ni22 = ni;\n\tint xi23 = xi;\n\tint ni23 = ni;\n\tint xi24 = xi;\n\tint ni24 = ni;\n\tint xi25 = xi;\n\tint ni25 = ni;\n\tint xi26 = xi;\n\tint ni26 = ni;\n\tint xi27 = xi;\n\tint ni27 = ni;\n\tint xi28 = xi;\n\tint ni28 = ni;\n\tint xi29 = xi;\n\tint ni29 = ni;\n\tint xi30 = xi;\n\tint ni30 = ni;\n\tint xi31 = xi;\n\tint ni31 = ni;\n\tint xi32 = xi;\n\tint ni32 = ni;\n\tint xi33 = xi;\n\tint ni33 = ni;\n\tint xi34 = xi;\n\tint ni34 = ni;\n\tint xi35 = xi;\n\tint ni35 = ni;\n\tint xi36 = xi;\n\tint ni36 = ni;\n\tint xi37 = xi;\n\tint ni37 = ni;\n\tint xi38 = xi;\n\tint ni38 = ni;\n\tint xi39 = xi;\n\tint ni39 = ni;\n\tint xi40 = xi;\n\tint ni40 = ni;\n\tint xi41 = xi;\n\tint ni41 = ni;\n\tint xi42 = xi;\n\tint ni42 = ni;\n\tint xi43 = xi;\n\tint ni43 = ni;\n\tint xi44 = xi;\n\tint ni44 = ni;\n\tint xi45 = xi;\n\tint ni45 = ni;\n\tint xi46 = xi;\n\tint ni46 = ni;\n\tint xi47 = xi;\n\tint ni47 = ni;\n\tint xi48 = xi;\n\tint ni48 = ni;\n\tint xi49 = xi;\n\tint ni49 = ni;\n\tint xi50 = xi;\n\tint ni50 = ni;\n\tint xi51 = xi;\n\tint ni51 = ni;\n\tint xi52 = xi;\n\tint ni52 = ni;\n\tint xi53 = xi;\n\tint ni53 = ni;\n\tint xi54 = xi;\n\tint ni54 = ni;\n\tint xi55 = xi;\n\tint ni55 = ni;\n\tint xi56 = xi;\n\tint ni56 = ni;\n\tint xi57 = xi;\n\tint ni57 = ni;\n\tint xi58 = xi;\n\tint ni58 = ni;\n\tint xi59 = xi;\n\tint ni59 = ni;\n\tint xi60 = xi;\n\tint ni60 = ni;\n\tint xi61 = xi;\n\tint ni61 = ni;\n\tint xi62 = xi;\n\tint ni62 = ni;\n\tint xi63 = xi;\n\tint ni63 = ni;\n\tint xi64 = xi;\n\tint ni64 = ni;\n\tint xi65 = xi;\n\tint ni65 = ni;\n\tint xi66 = xi;\n\tint ni66 = ni;\n\tint xi67 = xi;\n\tint ni67 = ni;\n\tint xi68 = xi;\n\tint ni68 = ni;\n\tint xi69 = xi;\n\tint ni69 = ni;\n\tint xi70 = xi;\n\tint ni70", "passed": 0, "run_status": 2}
{"task_id": "CPP/145", "prompt": "/*\nWrite a fu ncti on whi c h sort s the giv en vector of integers \nin ascending o r der according to th e sum oftheir digits .\nNote: ift h ere are several  items wit h  similar sum of their digits ,order them based on th eir index in original vector.\n\nFor example:\n>>> order_by_points({1, 11, -1, -11, -12}) == {-1, -11, 1, -12, 11}\n>>> order_by_points({}) == {}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> order_by_points(vector<int> nums){\n", "canonical_solution": "    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11}));\n    assert (issame(order_by_points({1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46}) , {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n    assert (issame(order_by_points({}) , {}));\n    assert (issame(order_by_points({1, -11, -32, 43, 54, -98, 2, -3}) , {-3, -32, -98, -11, 1, 2, 43, 54}));\n    assert (issame(order_by_points({1,2,3,4,5,6,7,8,9,10,11}) , {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n    assert (issame(order_by_points({0,6,6,-76,-21,23,4}) , {-76, -21, 0, 4, 23, 6, 6}));\n    \n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11}));\n    assert (issame(order_by_points({}) , {}));\n}\n", "entry_point": "order_by_points", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on whi c h sort s the giv en vector of integers \nin ascending o r der according to th e sum oftheir digits.\nNote: ift h ere are several  items wit h  similar sum of their digits,order them based on th eir index in original vector.\n\nFor example:\n>>> order_by_points({1, 11, -1, -11, -12}) == {-1, -11, 1, -12, 11}\n>>> order_by_points({}) == {}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> order_by_points(vector<int> nums){\n\tint sum = 0;\n\tfor(int i = 0; i < nums.size(); i++){\n\t\tsum += nums[i];\n\t}\n\tvector<int> res;\n\tfor(int i = 0; i < nums.size(); i++){\n\t\tres.push_back(nums[i]);\n\t}\n\tfor(int i = 0; i < res.size(); i++){\n\t\tif(sum - res[i] == 0){\n\t\t\tres.erase(res.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tvector<int> nums;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++){\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\tnums.push_back(num);\n\t}\n\tvector<int> res = order_by_points(nums);\n\tfor(int i = 0; i < res.size(); i++){\n\t\tprintf(\"%d \", res[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/146", "prompt": "/*\nWrite a fu ncti on tha t  takes  a vector  of numbers as inputand returns \nth e  number of elements  in the vector that a re greatert h an 10and both\nfirst and last digits of anumber areod d (1, 3, 5, 7, 9).\nFor example:\nspecialFilter({15, -73, 14, -15}) => 1 \nspecialFilter({33, -2, -3, 45, 21, 109}) => 2\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint specialFilter(vector<int> nums){\n", "canonical_solution": "    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (specialFilter({5, -2, 1, -5}) == 0  );\n    assert (specialFilter({15, -73, 14, -15}) == 1);\n    assert (specialFilter({33, -2, -3, 45, 21, 109}) == 2);\n    assert (specialFilter({43, -12, 93, 125, 121, 109}) == 4);\n    assert (specialFilter({71, -2, -33, 75, 21, 19}) == 3);\n    assert (specialFilter({1}) == 0              );\n    assert (specialFilter({}) == 0                   );\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (specialFilter({15, -73, 14, -15}) == 1);\n    assert (specialFilter({33, -2, -3, 45, 21, 109}) == 2);\n}\n", "entry_point": "specialFilter", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on tha t  takes  a vector  of numbers as inputand returns \nth e  number of elements  in the vector that a re greatert h an 10and both\nfirst and last digits of anumber areod d (1, 3, 5, 7, 9).\nFor example:\nspecialFilter({15, -73, 14, -15}) => 1 \nspecialFilter({33, -2, -3, 45, 21, 109}) => 2\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint specialFilter(vector<int> nums){\n\tint count = 0;\n\tint first = nums[0];\n\tint last = nums[nums.size() - 1];\n\tfor(int i = 0; i < nums.size(); i++){\n\t\tif(nums[i] > first && nums[i] < last){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> nums;\n\tfor(int i = 0; i < n; i++){\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\tnums.push_back(num);\n\t}\n\tprintf(\"%d\", specialFilter(nums));\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/147", "prompt": "/*\nYou are gi vena posi t ive in teger n.You have to create an  integer vector a of length n.\n   For eachi (1  i  n ), the value of a{i} = i * i  - i + 1.   Return the number of trip le s (a{i}, a{j}, a{k}) o f a where i < j < k, \nand a[i] + a [j] + a[k]is a mult ipleof 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint get_matrix_triples(int n){\n", "canonical_solution": "    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_matrix_triples(5) == 1);\n    assert (get_matrix_triples(6) == 4);\n    assert (get_matrix_triples(10) == 36);\n    assert (get_matrix_triples(100) == 53361);\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_matrix_triples(5) == 1);\n}\n", "entry_point": "get_matrix_triples", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena posi t ive in teger n.You have to create an  integer vector a of length n.\n   For eachi (1  i  n ), the value of a{i} = i * i  - i + 1.   Return the number of trip le s (a{i}, a{j}, a{k}) o f a where i < j < k, \nand a[i] + a [j] + a[k]is a mult ipleof 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint get_matrix_triples(int n){\n    vector<int> a(n);\n    for(int i = 0; i < n; i++){\n        a[i] = i * i - i + 1;\n    }\n    int count = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j < n; j++){\n            for(int k = j + 1; k < n; k++){\n                if(a[i] + a[j] + a[k] == 3 * n){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    printf(\"%d\\n\", get_matrix_triples(n));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/148", "prompt": "/*\nThere areeigh t plan e ts inour solar  system: the closerst  to the Sun \nis Mercury, the next o ne is Venus, then Ear th, Mars, Ju p iter,Saturn, Uranus, Ne p tune.\nWrite a function thatta kes two planet names a s strings planet1 and planet2. \nTh e functionshould re turna vector containin g  all planets whose orbits are \nlocated b etween the orbit of planet1and the orbitof planet2 , sorted by \nt he proximity to t he sun. \nThe function should r eturn an empty vector if plane t1or planet2\nare not correct planet na mes. \nExamples\nbf(\"Jupiter\", \"Neptune\") ==> {\"Saturn\", \"Uranus\"}\nbf(\"Earth\", \"Mercury\") ==> {\"Venus\"}\nbf(\"Mercury\", \"Uranus\") ==> {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> bf(string planet1,string planet2){\n", "canonical_solution": "    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(bf(\"Jupiter\", \"Neptune\") , {\"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Mercury\") , {\"Venus\",}));\n    assert (issame(bf(\"Mercury\", \"Uranus\") , {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}));\n    assert (issame(bf(\"Neptune\", \"Venus\") , {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Earth\") , {}));\n    assert (issame(bf(\"Mars\", \"Earth\") , {}));\n    assert (issame(bf(\"Jupiter\", \"Makemake\") , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(bf(\"Jupiter\", \"Neptune\") , {\"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Mercury\") , {\"Venus\",}));\n    assert (issame(bf(\"Mercury\", \"Uranus\") , {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}));\n}\n", "entry_point": "bf", "seed": 1, "perturbed": true, "gc": "/*\nThere areeigh t plan e ts inour solar  system: the closerst  to the Sun \nis Mercury, the next o ne is Venus, then Ear th, Mars, Ju p iter,Saturn, Uranus, Ne p tune.\nWrite a function thatta kes two planet names a s strings planet1 and planet2. \nTh e functionshould re turna vector containin g  all planets whose orbits are \nlocated b etween the orbit of planet1and the orbitof planet2, sorted by \nt he proximity to t he sun. \nThe function should r eturn an empty vector if plane t1or planet2\nare not correct planet na mes. \nExamples\nbf(\"Jupiter\", \"Neptune\") ==> {\"Saturn\", \"Uranus\"}\nbf(\"Earth\", \"Mercury\") ==> {\"Venus\"}\nbf(\"Mercury\", \"Uranus\") ==> {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> bf(string planet1,string planet2){\n\tvector<string> result;\n\tif(planet1==\"Earth\"){\n\t\tif(planet2==\"Mercury\"){\n\t\t\tresult.push_back(\"Venus\");\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t}\n\t\telse if(planet2==\"Jupiter\"){\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t}\n\t\telse if(planet2==\"Saturn\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t}\n\t\telse if(planet2==\"Uranus\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t}\n\t\telse if(planet2==\"Mars\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t}\n\t\telse if(planet2==\"Jupiter\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t}\n\t}\n\telse if(planet1==\"Jupiter\"){\n\t\tif(planet2==\"Mercury\"){\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t}\n\t\telse if(planet2==\"Saturn\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t}\n\t\telse if(planet2==\"Uranus\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t}\n\t\telse if(planet2==\"Mars\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t}\n\t\telse if(planet2==\"Jupiter\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t}\n\t}\n\telse if(planet1==\"Saturn\"){\n\t\tif(planet2==\"Earth\"){\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t}\n\t\telse if(planet2==\"Jupiter\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t}\n\t\telse if(planet2==\"Uranus\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t}\n\t\telse if(planet2==\"Mars\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t}\n\t\telse if(planet2==\"Jupiter\"){\n\t\t\tresult.push_back(\"Earth\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t}\n\t}\n\telse if(planet1==\"Uranus\"){\n\t\tif(planet2==\"Earth\"){\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t\tresult.push_back(\"Saturn\");\n\t\t\tresult.push_back(\"Uranus\");\n\t\t\tresult.push_back(\"Mars\");\n\t\t\tresult.push_back(\"Jupiter\");\n\t\t}\n\t\telse if", "passed": 0, "run_status": 2}
{"task_id": "CPP/149", "prompt": "/*\nWrite a fu ncti on tha t  accep ts a vect or of strings as a pa rameter,\ndelete s  the strings that h ave odd lengths fromit,\nand retu r ns the resulted  vector wi t h a sorted order,\nThe vector  i s always a vector of s trings and nevera vector of numbe rs,\nand itmay conta in du plicates.\nThe orde r  of the vector should be ascending by le ngthof each word, and you\ns hould return the vectorsorted by that  rule.\nIf two wor ds have the same length, sortthe vector alphabetically.\nThe  fu nction should return a vector of str ings in sor ted order.\nYou ma y assume that all words will hav e thesame length.\nFor example:\nassert vector_sort({\"aa\", \"a\", \"aaa\"}) => {\"aa\"}\nassert vector_sort({\"ab\", \"a\", \"aaa\", \"cd\"}) => {\"ab\", \"cd\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> sorted_list_sum(vector<string> lst){\n", "canonical_solution": "    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) , {\"aa\"}));\n    assert (issame(sorted_list_sum({\"school\", \"AI\", \"asdf\", \"b\"}) , {\"AI\", \"asdf\", \"school\"}));\n    assert (issame(sorted_list_sum({\"d\", \"b\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"d\", \"dcba\", \"abcd\", \"a\"}) , {\"abcd\", \"dcba\"}));\n    assert (issame(sorted_list_sum({\"AI\", \"ai\", \"au\"}) , {\"AI\", \"ai\", \"au\"}));\n    assert (issame(sorted_list_sum({\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"aaaa\", \"bbbb\", \"dd\", \"cc\"}) , {\"cc\", \"dd\", \"aaaa\", \"bbbb\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) , {\"aa\"}));\n    assert (issame(sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) , {\"ab\", \"cd\"}));\n}\n", "entry_point": "sorted_list_sum", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on tha t  accep ts a vect or of strings as a pa rameter,\ndelete s  the strings that h ave odd lengths fromit,\nand retu r ns the resulted  vector wi t h a sorted order,\nThe vector  i s always a vector of s trings and nevera vector of numbe rs,\nand itmay conta in du plicates.\nThe orde r  of the vector should be ascending by le ngthof each word, and you\ns hould return the vectorsorted by that  rule.\nIf two wor ds have the same length, sortthe vector alphabetically.\nThe  fu nction should return a vector of str ings in sor ted order.\nYou ma y assume that all words will hav e thesame length.\nFor example:\nassert vector_sort({\"aa\", \"a\", \"aaa\"}) => {\"aa\"}\nassert vector_sort({\"ab\", \"a\", \"aaa\", \"cd\"}) => {\"ab\", \"cd\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> sorted_list_sum(vector<string> lst){\n\tvector<string> res;\n\tfor(int i=0;i<lst.size();i++){\n\t\tint sum=0;\n\t\tfor(int j=0;j<lst.size();j++){\n\t\t\tif(i!=j){\n\t\t\t\tsum+=lst[j].size();\n\t\t\t}\n\t\t}\n\t\tres.push_back(lst[i]);\n\t}\n\treturn res;\n}\nint main(){\n\tvector<string> lst;\n\tlst.push_back(\"aa\");\n\tlst.push_back(\"a\");\n\tlst.push_back(\"aaa\");\n\tlst.push_back(\"ab\");\n\tlst.push_back(\"abcd\");\n\tlst.push_back(\"abcdef\");\n\tlst.push_back(\"abcdefg\");\n\tlst.push_back(\"abcdefgh\");\n\tlst.push_back(\"abcdefghi\");\n\tlst.push_back(\"abcdefghij\");\n\tlst.push_back(\"abcdefghijk\");\n\tlst.push_back(\"abcdefghijkl\");\n\tlst.push_back(\"abcdefghijklm\");\n\tlst.push_back(\"abcdefghijklmn\");\n\tlst.push_back(\"abcdefghijklmnop\");\n\tlst.push_back(\"abcdefghijklmnopq\");\n\tlst.push_back(\"abcdefghijklmnopqr\");\n\tlst.push_back(\"abcdefghijklmnopqrst\");\n\tlst.push_back(\"abcdefghijklmnopqrstu\");\n\tlst.push_back(\"abcdefghijklmnopqrstuv\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvw\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwx\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzzzzzzzzzzz\");\n\tlst.push_back(\"abcdefghijklmnopqrstuvwxzzzzzzzzzzzzzzzzzzzzzzzzzzz\");\n\tlst.", "passed": 0, "run_status": 1}
{"task_id": "CPP/15", "prompt": "/*\nReturn as trin g cont a iningspace-del imited numbers starti ng from 0 upton  inclusive.\n>>> string_sequence(0)\n\"0\"\n>>> string_sequence(5)\n\"0 1 2 3 4 5\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring string_sequence(int n){\n", "canonical_solution": "    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_sequence(0) == \"0\");\n    assert (string_sequence(3) == \"0 1 2 3\");\n     assert (string_sequence(10) == \"0 1 2 3 4 5 6 7 8 9 10\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_sequence(0) == \"0\");\n    assert (string_sequence(5) == \"0 1 2 3 4 5\");\n}\n", "entry_point": "string_sequence", "seed": 1, "perturbed": true, "gc": "/*\nReturn as trin g cont a iningspace-del imited numbers starti ng from 0 upton  inclusive.\n>>> string_sequence(0)\n\"0\"\n>>> string_sequence(5)\n\"0 1 2 3 4 5\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring string_sequence(int n){\n\tstring s;\n\tfor(int i=0;i<n;i++){\n\t\ts+=to_string(i);\n\t\ts+=\" \";\n\t}\n\treturn s;\n}\nint main(){\n\tint n;\n\tprintf(\"Enter the number of elements in the sequence: \");\n\tscanf(\"%d\",&n);\n\tprintf(\"%s\",string_sequence(n).c_str());\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/150", "prompt": "/*\nA simplep rogr am whi c h shou ld return  the value of x if nis \na prime num b er and should retur n the value of y othe rwise.\n\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5\n\n*/\n#include<stdio.h>\nusing namespace std;\nint x_or_y(int n,int x,int y){\n", "canonical_solution": "    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (x_or_y(7, 34, 12) == 34);\n    assert (x_or_y(15, 8, 5) == 5);\n    assert (x_or_y(3, 33, 5212) == 33);\n    assert (x_or_y(1259, 3, 52) == 3);\n    assert (x_or_y(7919, -1, 12) == -1);\n    assert (x_or_y(3609, 1245, 583) == 583);\n    assert (x_or_y(91, 56, 129) == 129);\n    assert (x_or_y(6, 34, 1234) == 1234);\n    assert (x_or_y(1, 2, 0) == 0);\n    assert (x_or_y(2, 2, 0) == 2);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (x_or_y(7, 34, 12) == 34);\n    assert (x_or_y(15, 8, 5) == 5);\n}\n", "entry_point": "x_or_y", "seed": 1, "perturbed": true, "gc": "/*\nA simplep rogr am whi c h shou ld return  the value of x if nis \na prime num b er and should retur n the value of y othe rwise.\n\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5\n\n*/\n#include<stdio.h>\nusing namespace std;\nint x_or_y(int n,int x,int y){\n\tint i,j,k;\n\tfor(i=1;i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tif(n%j==0){\n\t\t\t\t\tfor(k=1;k<=n;k++){\n\t\t\t\t\t\tif(n%k==0){\n\t\t\t\t\t\t\tif(x==i && y==j && k==n){\n\t\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint n,x,y;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tx=x_or_y(n,x,y);\n\t\tif(x==0){\n\t\t\tprintf(\"No solution\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",x);\n\t\t}\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/151", "prompt": "/*\nGiven a ve ctor  of nu m bers,return th e sum of squares of t he numbers\nin t h e vector that are o dd. Ignore numbers th at are negat i ve ornot integ ers.\n\ndoub l e_the_difference({1, 3, 2, 0 })  == 1 + 9 + 0 + 0 = 10 \ndouble_the_difference({-1, -2, 0} ) == 0\ndouble_the_di ffere nce({9, -2}) == 81 double_the_difference({0}) == 0  \n\nIf th einput vector is empty, ret urn 0.\n*/\n#include<stdio .h>#include<m ath.h>\n#include<v ector>\nusing namespacestd;\nlo ng long double_the_difference( vec tor<float> lst){\n", "canonical_solution": "    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (double_the_difference({}) == 0);\n    assert (double_the_difference({5, 4}) == 25);\n    assert (double_the_difference({0.1, 0.2, 0.3}) == 0 );\n    assert (double_the_difference({-10, -20, -30}) == 0 );\n    assert (double_the_difference({-1, -2, 8}) == 0);\n    assert (double_the_difference({0.2, 3, 5}) == 34);\n    \n    \n    long long odd_sum=0;\n    vector<float> lst={};\n\n    for (int i=-99;i<100;i+=2)\n    {\n        lst.push_back(i+0.0);\n        if (i>0 and i%2==1) odd_sum+=i*i;\n    }\n  \n    assert (double_the_difference(lst) == odd_sum );\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (double_the_difference({1, 3, 2, 0}) == 10);\n    assert (double_the_difference({-1, -2, 0}) == 0);\n    assert (double_the_difference({9, -2}) == 81 );\n    assert (double_the_difference({0}) == 0  );\n}\n", "entry_point": "double_the_difference", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ve ctor  of nu m bers,return th e sum of squares of t he numbers\nin t h e vector that are o dd. Ignore numbers th at are negat i ve ornot integ ers.\n\ndoub l e_the_difference({1, 3, 2, 0 })  == 1 + 9 + 0 + 0 = 10 \ndouble_the_difference({-1, -2, 0} ) == 0\ndouble_the_di ffere nce({9, -2}) == 81 double_the_difference({0}) == 0  \n\nIf th einput vector is empty, ret urn 0.\n*/\n#include<stdio.h>#include<m ath.h>\n#include<v ector>\nusing namespacestd;\nlo ng long double_the_difference( vec tor<float> lst){\n\tlong double sum = 0;\n\tfor(int i = 0; i < lst.size(); i++){\n\t\tif(lst[i]!= 0){\n\t\t\tsum += lst[i] * lst[i];\n\t\t}\n\t}\n\treturn sum;\n}\nlo ng long double_the_difference( vec tor<long double> lst){\n\tlong double sum = 0;\n\tfor(int i = 0; i < lst.size(); i++){\n\t\tif(lst[i]!= 0){\n\t\t\tsum += lst[i] * lst[i];\n\t\t}\n\t}\n\treturn sum;\n}\n\nlo ng long double_the_difference( vec tor<long double> lst, vec tor2){\n\tlong double sum = 0;\n\tfor(int i = 0; i < lst.size(); i++){\n\t\tif(lst[i]!= 0){\n\t\t\tsum += lst[i] * lst[i];\n\t\t}\n\t}\n\tfor(int i = 0; i < tor2.size(); i++){\n\t\tif(tor2[i]!= 0){\n\t\t\tsum += tor2[i] * tor2[i];\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tvec tor(10);\n\ttor[0] = 1;\n\ttor[1] = 3;\n\ttor[2] = 2;\n\ttor[3] = 0;\n\ttor[4] = 0;\n\ttor[5] = 0;\n\ttor[6] = 0;\n\ttor[7] = 0;\n\ttor[8] = 0;\n\ttor[9] = 0;\n\tprintf(\"%Lg\\n\", double_the_difference(tor));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/152", "prompt": "/*\nI think we  all  remem b er tha t feeling  when the result of s ome long-awaite d \nevent is finally k nown. The feelings an d thoughtsy o u have at thatmoment are definitely worthnoting down  a nd comparing.\nYour tas k is to determine if a person corr ectly guessed the re sults  of a number of ma t ches.You are given two vectors of score sand guessesof equal lengt h, where eachindex show s amatch. \nRe turn a vector ofthe same length denoting how f ar off each guess was. If they  ha ve guessed correctly,\nthe value is 0 , and if no t, the value is t he absolute difference between t he gue ss and thescore.\n\n\nexample:\n\ncompare({1,2,3,4,5,1},{1,2,3,4,2,-2}) -> {0,0,0,0,3,3}\ncompare({0,5,0,0,0,4},{4,1,1,0,0,-2}) -> {4,4,1,0,0,6}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<int> compare(vector<int> game,vector<int> guess){\n", "canonical_solution": "    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,5,0,0,0,4},{4,1,1,0,0,-2}),{4,4,1,0,0,6}));\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,0,0,0,0,0},{0,0,0,0,0,0}),{0,0,0,0,0,0}));\n    assert (issame(compare({1,2,3},{-1,-2,-3}),{2,4,6}));\n    assert (issame(compare({1,2,3,5},{-1,2,3,4}),{2,0,0,1}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,5,0,0,0,4},{4,1,1,0,0,-2}),{4,4,1,0,0,6}));\n}\n", "entry_point": "compare", "seed": 1, "perturbed": true, "gc": "/*\nI think we  all  remem b er tha t feeling  when the result of s ome long-awaite d \nevent is finally k nown. The feelings an d thoughtsy o u have at thatmoment are definitely worthnoting down  a nd comparing.\nYour tas k is to determine if a person corr ectly guessed the re sults  of a number of ma t ches.You are given two vectors of score sand guessesof equal lengt h, where eachindex show s amatch. \nRe turn a vector ofthe same length denoting how f ar off each guess was. If they  ha ve guessed correctly,\nthe value is 0, and if no t, the value is t he absolute difference between t he gue ss and thescore.\n\n\nexample:\n\ncompare({1,2,3,4,5,1},{1,2,3,4,2,-2}) -> {0,0,0,0,3,3}\ncompare({0,5,0,0,0,4},{4,1,1,0,0,-2}) -> {4,4,1,0,0,6}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<int> compare(vector<int> game,vector<int> guess){\n\tint i,j,k,l,m,n,t,s,g,d;\n\tvector<int> ans;\n\tfor(i=0;i<game.size();i++){\n\t\tif(game[i]==guess[i]){\n\t\t\tans.push_back(0);\n\t\t}\n\t\telse{\n\t\t\tans.push_back(abs(game[i]-guess[i]));\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tint t,n,i,j,k,l,m,t1,t2,s,g,d;\n\tvector<int> game,guess;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&game[i]);\n\t\t}\n\t\tscanf(\"%d\",&t1);\n\t\twhile(t1--){\n\t\t\tscanf(\"%d\",&s);\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tscanf(\"%d\",&g);\n\t\t\t\tguess.push_back(g);\n\t\t\t}\n\t\t\tscanf(\"%d\",&t2);\n\t\t\twhile(t2--){\n\t\t\t\tscanf(\"%d\",&d);\n\t\t\t\tguess.push_back(d);\n\t\t\t}\n\t\t\tsort(guess.begin(),guess.end());\n\t\t\tsort(game.begin(),game.end());\n\t\t\tvector<int> ans=compare(game,guess);\n\t\t\tfor(i=0;i<ans.size();i++){\n\t\t\t\tprintf(\"%d \",ans[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/153", "prompt": "/*\nYou willb e gi ven th e  nameof a clas s (a string) and a ve ctor of extensi o ns.\nThe extensionsare to be used to loa d additional classes to theclass. The strength of the extension is  a s follows: Let CAP bethe number of the uppercase\nletter s in the extension's  name , and let SM be th e  number of lowercaseletters \nin the ext ension's name, the strengthis given by the fraction  CAP - SM. \nYo u should find the strongest extension and retur n a string in this \nformat: Cl ass Name.StrongestExtensionName.\nIf ther e are two o r more extensions  with the same strength, you sho uld\nch oose the one that comes first inthe vector.\nFor example, if you are given \"Slices\" as the class and a vector of the\nextensions: {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"} then you should\nreturn \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension \n(its strength is -1).\nExample:\nfor Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring Strongest_Extension(string class_name,vector<string> extensions){\n", "canonical_solution": "    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (Strongest_Extension(\"Watashi\", {\"tEN\", \"niNE\", \"eIGHt8OKe\"}) == \"Watashi.eIGHt8OKe\");\n    assert (Strongest_Extension(\"Boku123\", {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}) == \"Boku123.YEs.WeCaNe\");\n    assert (Strongest_Extension(\"__YESIMHERE\", {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}) == \"__YESIMHERE.NuLl__\");\n    assert (Strongest_Extension(\"K\", {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}) == \"K.TAR\");\n    assert (Strongest_Extension(\"__HAHA\", {\"Tab\", \"123\", \"781345\", \"-_-\"}) == \"__HAHA.123\");\n    assert (Strongest_Extension(\"YameRore\", {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}) == \"YameRore.okIWILL123\");\n    assert (Strongest_Extension(\"finNNalLLly\", {\"Die\", \"NowW\", \"Wow\", \"WoW\"}) == \"finNNalLLly.WoW\");\n    assert (Strongest_Extension(\"_\", {\"Bb\", \"91245\"}) == \"_.Bb\");\n    assert (Strongest_Extension(\"Sp\", {\"671235\", \"Bb\"}) == \"Sp.671235\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\");\n}\n", "entry_point": "Strongest_Extension", "seed": 1, "perturbed": true, "gc": "/*\nYou willb e gi ven th e  nameof a clas s (a string) and a ve ctor of extensi o ns.\nThe extensionsare to be used to loa d additional classes to theclass. The strength of the extension is  a s follows: Let CAP bethe number of the uppercase\nletter s in the extension's  name, and let SM be th e  number of lowercaseletters \nin the ext ension's name, the strengthis given by the fraction  CAP - SM. \nYo u should find the strongest extension and retur n a string in this \nformat: Cl ass Name.StrongestExtensionName.\nIf ther e are two o r more extensions  with the same strength, you sho uld\nch oose the one that comes first inthe vector.\nFor example, if you are given \"Slices\" as the class and a vector of the\nextensions: {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"} then you should\nreturn \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension \n(its strength is -1).\nExample:\nfor Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring Strongest_Extension(string class_name,vector<string> extensions){\n\tint cap=0;\n\tint sm=0;\n\tfor(int i=0;i<class_name.length();i++){\n\t\tif(class_name[i]>='A'&&class_name[i]<='Z'){\n\t\t\tcap++;\n\t\t}\n\t\telse if(class_name[i]>='a'&&class_name[i]<='z'){\n\t\t\tsm++;\n\t\t}\n\t}\n\tint strength=cap-sm;\n\tfor(int i=0;i<extensions.size();i++){\n\t\tif(strength<extensions[i].length()){\n\t\t\tstrength=extensions[i].length();\n\t\t}\n\t}\n\tstring output=\"\";\n\tfor(int i=0;i<extensions.size();i++){\n\t\tif(strength==extensions[i].length()){\n\t\t\toutput+=extensions[i];\n\t\t\toutput+=\".\";\n\t\t\toutput+=class_name;\n\t\t\treturn output;\n\t\t}\n\t}\n\treturn class_name;\n}\nint main(){\n\tstring class_name=\"Slices\";\n\tvector<string> extensions;\n\textensions.push_back(\"SErviNGSliCes\");\n\textensions.push_back(\"Cheese\");\n\textensions.push_back(\"StuFfed\");\n\tcout<<Strongest_Extension(class_name,extensions);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/154", "prompt": "/*\nYou are gi ven2 word s . Youneed to r eturn true if the sec ond word or any of its rotations is  a substring in the f irst word\ncy c pattern_check(\" abcd\",\"abd \" ) => false\ncycpattern_check( \"h ello\",\"ell\") => true\nc ycpattern_check(\"whassup\",\"psus\")=> false\ncycpattern_ check (\"abab\",\"baa\") =>t rue\ncycpattern_check(\"efef\",\"eeff\") => f alsecycpattern_check(\"himen ss\",'simen\") => true\n\n*/ \n#include<stdi o.h>\n#include<str ing>\nusing namespace std;\nbool  cycpattern_check(string a,str ing  b){\n", "canonical_solution": "    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert  (cycpattern_check(\"xyzw\",\"xyw\") == false );\n    assert  (cycpattern_check(\"yello\",\"ell\") == true );\n    assert  (cycpattern_check(\"whattup\",\"ptut\") == false );\n    assert  (cycpattern_check(\"efef\",\"fee\") == true );\n    assert  (cycpattern_check(\"abab\",\"aabb\") == false );\n    assert  (cycpattern_check(\"winemtt\",\"tinem\") == true );\n}\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert  (cycpattern_check(\"abcd\",\"abd\") == false );\n    assert  (cycpattern_check(\"hello\",\"ell\") == true );\n    assert  (cycpattern_check(\"whassup\",\"psus\") == false );\n    assert  (cycpattern_check(\"abab\",\"baa\") == true );\n    assert  (cycpattern_check(\"efef\",\"eeff\") == false );\n    assert  (cycpattern_check(\"himenss\",\"simen\") == true );\n}\n", "entry_point": "cycpattern_check", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi ven2 word s. Youneed to r eturn true if the sec ond word or any of its rotations is  a substring in the f irst word\ncy c pattern_check(\" abcd\",\"abd \" ) => false\ncycpattern_check( \"h ello\",\"ell\") => true\nc ycpattern_check(\"whassup\",\"psus\")=> false\ncycpattern_ check (\"abab\",\"baa\") =>t rue\ncycpattern_check(\"efef\",\"eeff\") => f alsecycpattern_check(\"himen ss\",'simen\") => true\n\n*/ \n#include<stdi o.h>\n#include<str ing>\nusing namespace std;\nbool  cycpattern_check(string a,str ing  b){\n\tint i=0,j=0;\n\twhile(i<a.size()&&j<b.size()){\n\t\tif(a[i]==b[j]){\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse{\n\t\t\tif(j==b.size()-1){\n\t\t\t\tj=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\tif(i==a.size()&&j==b.size()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nbool cycpattern_check(string a,string b){\n\tint i=0,j=0;\n\twhile(i<a.size()&&j<b.size()){\n\t\tif(a[i]==b[j]){\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse{\n\t\t\tif(j==b.size()-1){\n\t\t\t\tj=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\tif(i==a.size()&&j==b.size()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nbool cycpattern_check(string a,string b,string c){\n\tint i=0,j=0,k=0;\n\twhile(i<a.size()&&j<b.size()&&k<c.size()){\n\t\tif(a[i]==b[j]&&c[k]==b[j]){\n\t\t\ti++;\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t\telse{\n\t\t\tif(j==b.size()-1){\n\t\t\t\tj=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif(k==c.size()-1){\n\t\t\t\tk=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\tif(i==a.size()&&j==b.size()&&k==c.size()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nbool cycpattern_check(string a,string b,string c,string d){\n\tint i=0,j=0,k=0,l=0;\n\twhile(i<a.size()&&j<b.size()&&k<c.size()&&l<d.size()){\n\t\tif(a[i]==b[j]&&c[k]==b[j]&&d[l]==b[j]){\n\t\t\ti++;\n\t\t\tj++;\n\t\t\tk++;\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tif(j==b.size()-1){\n\t\t\t\tj=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif(k==c.size()-1){\n\t\t\t\tk=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tif(l==d.size()-1){\n\t\t\t\tl=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t}\n\tif(i==a.size()&&j==b.size()&&k==c.size()&&l==d.size()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nbool cycpattern_check(string a,string b,string c,string d,string e){\n\tint i=0,j=0,k=0,l=0,m=0;\n\twhile(i<a.size()&&j<b.size()&&k<c.size()&&l<d.size()&&m<e.size()){\n\t\tif(a[i]==b[j]&&c[k]==b[j]&&d[l]==b[j]&&e[m]==b[j]){\n\t\t\ti++;\n\t\t\tj++;\n\t\t\tk++;\n\t\t\tl++;\n\t\t\tm++;\n\t\t}\n\t\telse{\n\t\t\tif(j==b.size()-1){\n\t\t\t\tj=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif(k==c.size()-1){\n\t\t\t\tk=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tif(l==d.size()-1){\n\t\t\t\tl=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(m==e.size()-1){\n\t\t\t\tm=0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t}\n\tif(i==a.size()&&j==b.size()&&k==c.size()&&l==d.size()&&m==e.size()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nint main(){\n\tstring a=\"h ello\",b=\"ell\";\n\tstring c=\"whassup\",d=\"psus\";\n\tstring e=\"himen ss\",f=\"simen\";\n\tcout<<cycpattern_check(a,b);\n\tcout<<cycpattern_check(a,c);\n\tcout<<cycpattern_check(a,d);\n\tcout<<cycpattern_check(a,e);\n\tcout<<cycpattern_check(a,f);\n\tcout<<cycpattern_check(a,b,c);\n\tcout<<cycpattern_check(a,b,d);\n\tcout<<cy", "passed": 0, "run_status": 2}
{"task_id": "CPP/155", "prompt": "/*\nGiven ani nteg er. re t urn avector th at has the number ofeven and odd di g its respectively.\n\n Example:\n    even_odd_count(-12) ==> {1, 1}\n    even_odd_count(123) ==> {1, 2}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\nvector<int> even_odd_count(int num){\n", "canonical_solution": "    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_count(7) , {0, 1}));\n    assert (issame(even_odd_count(-78) , {1, 1}));\n    assert (issame(even_odd_count(3452) , {2, 2}));\n    assert (issame(even_odd_count(346211) , {3, 3}));\n    assert (issame(even_odd_count(-345821) , {3, 3}));\n    assert (issame(even_odd_count(-2) , {1, 0}));\n    assert (issame(even_odd_count(-45347) , {2, 3}));\n    assert (issame(even_odd_count(0) , {1, 0}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_count(-12) , {1, 1}));\n    assert (issame(even_odd_count(123) , {1, 2}));\n}\n", "entry_point": "even_odd_count", "seed": 1, "perturbed": true, "gc": "/*\nGiven ani nteg er. re t urn avector th at has the number ofeven and odd di g its respectively.\n\n Example:\n    even_odd_count(-12) ==> {1, 1}\n    even_odd_count(123) ==> {1, 2}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\nvector<int> even_odd_count(int num){\n    vector<int> even_odd;\n    int count = 0;\n    while(num > 0){\n        if(num % 2 == 0){\n            count++;\n        }\n        else{\n            count--;\n        }\n        num = num / 2;\n    }\n    return even_odd;\n}\nint main(){\n    int num;\n    while(cin >> num){\n        vector<int> even_odd = even_odd_count(num);\n        for(int i = 0; i < even_odd.size(); i++){\n            cout << even_odd[i] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/156", "prompt": "/*\nGiven a po siti ve int e ger, o btain its  roman numeral equiva lent as a strin g ,\nand return it inlowercase.\nRestrictio ns: 1 <= num <= 1000\n\nExampl es:\n>>> int_to_mini_roman(19) == \"xix\"\n>>> int_to_mini_roman(152) == \"clii\"\n>>> int_to_mini_roman(426) == \"cdxxvi\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring int_to_mini_romank(int number){\n", "canonical_solution": "    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (int_to_mini_romank(19) == \"xix\");\n    assert (int_to_mini_romank(152) == \"clii\");\n    assert (int_to_mini_romank(251) == \"ccli\");\n    assert (int_to_mini_romank(426) == \"cdxxvi\");\n    assert (int_to_mini_romank(500) == \"d\");\n    assert (int_to_mini_romank(1) == \"i\");\n    assert (int_to_mini_romank(4) == \"iv\");\n    assert (int_to_mini_romank(43) == \"xliii\");\n    assert (int_to_mini_romank(90) == \"xc\");\n    assert (int_to_mini_romank(94) == \"xciv\");\n    assert (int_to_mini_romank(532) == \"dxxxii\");\n    assert (int_to_mini_romank(900) == \"cm\");\n    assert (int_to_mini_romank(994) == \"cmxciv\");\n    assert (int_to_mini_romank(1000) == \"m\");\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (int_to_mini_romank(19) == \"xix\");\n    assert (int_to_mini_romank(152) == \"clii\");\n    assert (int_to_mini_romank(426) == \"cdxxvi\");\n}\n", "entry_point": "int_to_mini_romank", "seed": 1, "perturbed": true, "gc": "/*\nGiven a po siti ve int e ger, o btain its  roman numeral equiva lent as a strin g,\nand return it inlowercase.\nRestrictio ns: 1 <= num <= 1000\n\nExampl es:\n>>> int_to_mini_roman(19) == \"xix\"\n>>> int_to_mini_roman(152) == \"clii\"\n>>> int_to_mini_roman(426) == \"cdxxvi\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring int_to_mini_romank(int number){\n    vector<string> v;\n    v.push_back(\"M\");\n    v.push_back(\"CM\");\n    v.push_back(\"D\");\n    v.push_back(\"CD\");\n    v.push_back(\"C\");\n    v.push_back(\"XC\");\n    v.push_back(\"L\");\n    v.push_back(\"XL\");\n    v.push_back(\"X\");\n    v.push_back(\"IX\");\n    v.push_back(\"V\");\n    v.push_back(\"IV\");\n    v.push_back(\"I\");\n    v.push_back(\"\");\n    string s = \"\";\n    while(number > 0){\n        int i = number % 10;\n        s = v[i] + s;\n        number = number / 10;\n    }\n    return s;\n}\nint main(){\n    int number;\n    while(cin >> number){\n        cout << int_to_mini_romank(number) << endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/157", "prompt": "/*\nGiven theleng ths of the th ree sides  of a triangle. Retur n true if the t h ree\nsides form a ri ght-angled triangle,false otherw i se.\nAright-ang led triang l e is a triangle in which one  a ngle is right angle or  \n90 degree.\nExample:\nright_angle_triangle(3, 4, 5) == true\nright_angle_triangle(1, 2, 3) == false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool right_angle_triangle(float a,float b,float c){\n", "canonical_solution": "    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (right_angle_triangle(3, 4, 5) == true);\n    assert (right_angle_triangle(1, 2, 3) == false);\n    assert (right_angle_triangle(10, 6, 8) == true);\n    assert (right_angle_triangle(2, 2, 2) == false);\n    assert (right_angle_triangle(7, 24, 25) == true);\n    assert (right_angle_triangle(10, 5, 7) == false);\n    assert (right_angle_triangle(5, 12, 13) == true);\n    assert (right_angle_triangle(15, 8, 17) == true);\n    assert (right_angle_triangle(48, 55, 73) == true);\n    assert (right_angle_triangle(1, 1, 1) == false);\n    assert (right_angle_triangle(2, 2, 10) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (right_angle_triangle(3, 4, 5) == true);\n    assert (right_angle_triangle(1, 2, 3) == false);\n}\n", "entry_point": "right_angle_triangle", "seed": 1, "perturbed": true, "gc": "/*\nGiven theleng ths of the th ree sides  of a triangle. Retur n true if the t h ree\nsides form a ri ght-angled triangle,false otherw i se.\nAright-ang led triang l e is a triangle in which one  a ngle is right angle or  \n90 degree.\nExample:\nright_angle_triangle(3, 4, 5) == true\nright_angle_triangle(1, 2, 3) == false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool right_angle_triangle(float a,float b,float c){\n    float s = (a+b+c)/2;\n    float area = sqrt(s*(s-a)*(s-b)*(s-c));\n    if(area == 0)\n        return false;\n    float ab = sqrt(a*a+b*b);\n    float ac = sqrt(a*a+c*c);\n    float bc = sqrt(b*b+c*c);\n    float s1 = (ab+ac+bc)/2;\n    float s2 = (ab+ac-bc)/2;\n    float s3 = (ac+bc-ab)/2;\n    float s4 = (ac-bc+ab)/2;\n    float s5 = (bc-ac+ab)/2;\n    float s6 = (bc+ac-ab)/2;\n    float s7 = (ac+bc-ab)/2;\n    float s8 = (bc+ac-ab)/2;\n    float s9 = (ac-bc+ab)/2;\n    float s10 = (bc-ac+ab)/2;\n    float s11 = (bc+ac-ab)/2;\n    float s12 = (ac-bc+ab)/2;\n    float s13 = (bc-ac+ab)/2;\n    float s14 = (ac-bc+ab)/2;\n    float s15 = (bc-ac+ab)/2;\n    float s16 = (ac-bc+ab)/2;\n    float s17 = (bc-ac+ab)/2;\n    float s18 = (ac-bc+ab)/2;\n    float s19 = (bc-ac+ab)/2;\n    float s20 = (ac-bc+ab)/2;\n    float s21 = (bc-ac+ab)/2;\n    float s22 = (ac-bc+ab)/2;\n    float s23 = (bc-ac+ab)/2;\n    float s24 = (ac-bc+ab)/2;\n    float s25 = (bc-ac+ab)/2;\n    float s26 = (ac-bc+ab)/2;\n    float s27 = (bc-ac+ab)/2;\n    float s28 = (ac-bc+ab)/2;\n    float s29 = (bc-ac+ab)/2;\n    float s30 = (ac-bc+ab)/2;\n    float s31 = (bc-ac+ab)/2;\n    float s32 = (ac-bc+ab)/2;\n    float s33 = (bc-ac+ab)/2;\n    float s34 = (ac-bc+ab)/2;\n    float s35 = (bc-ac+ab)/2;\n    float s36 = (ac-bc+ab)/2;\n    float s37 = (bc-ac+ab)/2;\n    float s38 = (ac-bc+ab)/2;\n    float s39 = (bc-ac+ab)/2;\n    float s40 = (ac-bc+ab)/2;\n    float s41 = (bc-ac+ab)/2;\n    float s42 = (ac-bc+ab)/2;\n    float s43 = (bc-ac+ab)/2;\n    float s44 = (ac-bc+ab)/2;\n    float s45 = (bc-ac+ab)/2;\n    float s46 = (ac-bc+ab)/2;\n    float s47 = (bc-ac+ab)/2;\n    float s48 = (ac-bc+ab)/2;\n    float s49 = (bc-ac+ab)/2;\n    float s50 = (ac-bc+ab)/2;\n    float s51 = (bc-ac+ab)/2;\n    float s52 = (ac-bc+ab)/2;\n    float s53 = (bc-ac+ab)/2;\n    float s54 = (ac-bc+ab)/2;\n    float s55 = (bc-ac+ab)/2;\n    float s56 = (ac-bc+ab)/2;\n    float s57 = (bc-ac+ab)/2;\n    float s58 = (ac-bc+ab)/2;\n    float s59 = (bc-ac+ab)/2;\n    float s60 = (ac-bc+ab)/2;\n    float s61 = (bc-ac+ab)/2;\n    float s62 = (ac-bc+ab)/2;\n    float s63 = (bc-ac+ab)/2;\n    float s64 = (ac-bc+ab)/2;\n    float s65 = (bc-ac+ab)/2;\n    float s66 = (ac-bc+ab)/2;\n    float s67 = (bc-ac+ab)/2;\n    float s68 = (ac-bc+ab)/2;\n    float s69 = (bc-ac+ab)/2;\n    float s70 = (ac-bc+ab)/2;\n    float s71 = (bc-ac+ab)/2;\n    float s72 = (ac-bc+ab)/2;\n    float s73 = (bc-ac+ab)/2;\n    float s74 = (ac-bc+ab)/2;\n    float s75 = (bc-ac+ab)/2;\n    float s76 = (ac-bc+ab)/2;\n    float s77 = (bc-ac+ab)/2;\n    float s78 = (ac-bc+ab)/2;\n    float s79 = (bc-ac+ab)/2;\n    float s80 = (ac-bc+ab)/2;\n    float s81 = (bc-ac+ab)/2;\n    float s82 = (ac-bc+ab)/2;\n    float s83 = (bc-ac+ab)/2;\n    float s84 = (ac-bc+ab)/2;\n    float s85 = (bc-ac+ab)/2;\n    float s86 = (", "passed": 0, "run_status": 2}
{"task_id": "CPP/158", "prompt": "/*\nWrite a fu ncti on tha t  accep ts a vect or of strings.\nThe ve ctor contains d i fferent words. Retu rn the word with maxi mum numbero f  unique charact ers. If mu l tiple strings have maximum n um ber of unique\ncharacte rs, return the one which comes fir st in lexicographica lord er.\n\nfind_max({\"na m e\", \"of\", 'string\"})== 'string\"\nfind_ma x({\"name\", \"enam\", \"game\"})== \"enam\"\nfind_max({\"aaa aaaa\", \"bb\" ,\" cc\"}) == \"aaaaaaa \"\n*/\n#include<stdio.h>#includ e<vector>\n#include<string>\n#in clu de<algorithm>\nusing namespace std;\ns tring find_ max(vector<string > words){\n", "canonical_solution": "    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert ((find_max({\"name\", \"of\", \"string\"}) == \"string\"));\n    assert ((find_max({\"name\", \"enam\", \"game\"}) == \"enam\"));\n    assert ((find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\"));\n    assert ((find_max({\"abc\", \"cba\"}) == \"abc\"));\n    assert ((find_max({\"play\", \"this\", \"game\", \"of\",\"footbott\"}) == \"footbott\"));\n    assert ((find_max({\"we\", \"are\", \"gonna\", \"rock\"}) == \"gonna\"));\n    assert ((find_max({\"we\", \"are\", \"a\", \"mad\", \"nation\"}) == \"nation\"));\n    assert ((find_max({\"this\", \"is\", \"a\", \"prrk\"}) == \"this\"));\n    assert ((find_max({\"b\"}) == \"b\"));\n    assert ((find_max({\"play\", \"play\", \"play\"}) == \"play\"));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert ((find_max({\"name\", \"of\", \"string\"}) == \"string\"));\n    assert ((find_max({\"name\", \"enam\", \"game\"}) == \"enam\"));\n    assert ((find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\"));\n}\n", "entry_point": "find_max", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on tha t  accep ts a vect or of strings.\nThe ve ctor contains d i fferent words. Retu rn the word with maxi mum numbero f  unique charact ers. If mu l tiple strings have maximum n um ber of unique\ncharacte rs, return the one which comes fir st in lexicographica lord er.\n\nfind_max({\"na m e\", \"of\",'string\"})=='string\"\nfind_ma x({\"name\", \"enam\", \"game\"})== \"enam\"\nfind_max({\"aaa aaaa\", \"bb\",\" cc\"}) == \"aaaaaaa \"\n*/\n#include<stdio.h>#includ e<vector>\n#include<string>\n#in clu de<algorithm>\nusing namespace std;\ns tring find_ max(vector<string > words){\n\tint max = 0;\n\tstring max_word = \"\";\n\tfor(int i = 0; i < words.size(); i++){\n\t\tfor(int j = 0; j < words[i].size(); j++){\n\t\t\tif(words[i][j] > max){\n\t\t\t\tmax = words[i][j];\n\t\t\t\tmax_word = words[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn max_word;\n}\nint main(){\n\tvector<string> words;\n\twords.push_back(\"na m e\");\n\twords.push_back(\"of\");\n\twords.push_back(\"string\");\n\twords.push_back(\"aaa aaaa\");\n\twords.push_back(\"bb\");\n\twords.push_back(\"cc\");\n\tcout<<find_max(words);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/159", "prompt": "/*\nYou\"re ah ungr y rabb i t, and  you alre ady have eaten a cert ain number of c a rrots,\nbut now youneed to eat more carr ots to compl e te the day's me als.\nyou s h ould return a vector of { to ta l number of eaten carr ots after your meals,\n                            the n umber of carrots l e ft after your meals }\nif there are not e nough remaining carrots, you  will eat allremainingcarrots, but w ill still be hung ry.\n\nExample:\n* eat(5, 6, 10) -> {11, 4}\n* eat(4, 8, 9) -> {12, 1}\n* eat(1, 10, 10) -> {11, 0}\n* eat(2, 11, 5) -> {7, 0}\n\nVariables:\n@number : integer\n    the number of carrots that you have eaten.\n@need : integer\n    the number of carrots that you need to eat.\n@remaining : integer\n    the number of remaining carrots thet exist in stock\n\nConstrain:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nHave fun :)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> eat(int number,int need,int remaining){\n", "canonical_solution": "    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(eat(5, 6, 10) , {11, 4}));\n    assert (issame(eat(4, 8, 9) , {12, 1}));\n    assert (issame(eat(1, 10, 10) , {11, 0}));\n    assert (issame(eat(2, 11, 5) , {7, 0}));\n    \n    assert (issame(eat(4, 5, 7) , {9, 2}));\n    assert (issame(eat(4, 5, 1) , {5, 0}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(eat(5, 6, 10) , {11, 4}));\n    assert (issame(eat(4, 8, 9) , {12, 1}));\n    assert (issame(eat(1, 10, 10) , {11, 0}));\n    assert (issame(eat(2, 11, 5) , {7, 0}));\n}\n", "entry_point": "eat", "seed": 1, "perturbed": true, "gc": "/*\nYou\"re ah ungr y rabb i t, and  you alre ady have eaten a cert ain number of c a rrots,\nbut now youneed to eat more carr ots to compl e te the day's me als.\nyou s h ould return a vector of { to ta l number of eaten carr ots after your meals,\n                            the n umber of carrots l e ft after your meals }\nif there are not e nough remaining carrots, you  will eat allremainingcarrots, but w ill still be hung ry.\n\nExample:\n* eat(5, 6, 10) -> {11, 4}\n* eat(4, 8, 9) -> {12, 1}\n* eat(1, 10, 10) -> {11, 0}\n* eat(2, 11, 5) -> {7, 0}\n\nVariables:\n@number : integer\n    the number of carrots that you have eaten.\n@need : integer\n    the number of carrots that you need to eat.\n@remaining : integer\n    the number of remaining carrots thet exist in stock\n\nConstrain:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nHave fun :)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> eat(int number,int need,int remaining){\n    vector<int> result;\n    int i = 0;\n    while(i < number){\n        result.push_back(number - i);\n        i++;\n    }\n    if(remaining < need){\n        result.push_back(need - remaining);\n    }\n    return result;\n}\nint main(){\n    int number,need,remaining;\n    scanf(\"%d %d %d\",&number,&need,&remaining);\n    vector<int> result = eat(number,need,remaining);\n    for(int i = 0;i < result.size();i++){\n        printf(\"%d \",result[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/16", "prompt": "/*\nGiven a st ring , find out ho w many di stinct characters (re gardless of cas e ) does it consist o f\n>>> count_distinct_characters(\"xyzXYZ\")\n3\n>>> count_distinct_characters(\"Jerry\")\n4\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint count_distinct_characters(string str){ \n", "canonical_solution": "    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_distinct_characters(\"\") == 0);\n    assert (count_distinct_characters(\"abcde\") == 5);\n    assert (count_distinct_characters(\"abcdecadeCADE\") == 5);\n    assert (count_distinct_characters(\"aaaaAAAAaaaa\") == 1);\n    assert (count_distinct_characters(\"Jerry jERRY JeRRRY\") == 5);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_distinct_characters(\"xyzXYZ\") == 3);\n    assert (count_distinct_characters(\"Jerry\") == 4);\n}\n", "entry_point": "count_distinct_characters", "seed": 1, "perturbed": true, "gc": "/*\nGiven a st ring, find out ho w many di stinct characters (re gardless of cas e ) does it consist o f\n>>> count_distinct_characters(\"xyzXYZ\")\n3\n>>> count_distinct_characters(\"Jerry\")\n4\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint count_distinct_characters(string str){ \n    int count = 0;\n    for(int i = 0; i < str.size(); i++){\n        for(int j = i+1; j < str.size(); j++){\n            if(str[i] == str[j]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}\nint main(){\n    string str;\n    cin>>str;\n    int count = count_distinct_characters(str);\n    cout<<count;\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/160", "prompt": "/*\nGiven twovect ors op e rator,  and oper and. The first vector  has basic alge b ra operations, and\nthe second vector is  a vector of integers. Use t he two giv e n vectors to build the algeb ri c \nexpression and retu rn the evaluation of this expressi on.\n\nThe basic algeb ra op erations:\nAddition ( + )\nSubtraction (- ) \nMultiplication  ( *) \nFloordivision ( //) \nExponentiation ( ** )  \n\nExample:\noperator{\"+\", \"*\", \"-\"}\nvector = {2, 3, 4, 5}\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nNote:\n    The length of operator vector is equal to the length of operand vector minus one.\n    Operand is a vector of of non-negative integers.\n    Operator vector has at least one operator, and operand vector has at least two operands.\n\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n", "canonical_solution": "    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (do_algebra({\"**\", \"*\", \"+\"}, {2, 3, 4, 5}) == 37);\n    assert (do_algebra({\"+\", \"*\", \"-\"}, {2, 3, 4, 5}) == 9);\n    assert (do_algebra({\"//\", \"*\"}, {7, 3, 4}) == 8);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n", "example_test": "", "entry_point": "do_algebra", "seed": 1, "perturbed": true, "gc": "/*\nGiven twovect ors op e rator,  and oper and. The first vector  has basic alge b ra operations, and\nthe second vector is  a vector of integers. Use t he two giv e n vectors to build the algeb ri c \nexpression and retu rn the evaluation of this expressi on.\n\nThe basic algeb ra op erations:\nAddition ( + )\nSubtraction (- ) \nMultiplication  ( *) \nFloordivision ( //) \nExponentiation ( ** )  \n\nExample:\noperator{\"+\", \"*\", \"-\"}\nvector = {2, 3, 4, 5}\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nNote:\n    The length of operator vector is equal to the length of operand vector minus one.\n    Operand is a vector of of non-negative integers.\n    Operator vector has at least one operator, and operand vector has at least two operands.\n\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    int result = 0;\n    for(int i = 0; i < operato.size(); i++){\n        if(operato[i][0] == '+'){\n            result += operand[i];\n        }\n        if(operato[i][0] == '-'){\n            result -= operand[i];\n        }\n        if(operato[i][0] == '*'){\n            result *= operand[i];\n        }\n        if(operato[i][0] == '/'){\n            result /= operand[i];\n        }\n        if(operato[i][0] == '**'){\n            result = pow(result, operand[i]);\n        }\n    }\n    return result;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<string> operato(n);\n    vector<int> operand(n);\n    for(int i = 0; i < n; i++){\n        cin >> operato[i];\n    }\n    for(int i = 0; i < n; i++){\n        cin >> operand[i];\n    }\n    int result = do_algebra(operato, operand);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/161", "prompt": "/*\nYou are gi vena stri n g s.\ni f s[i] is  a letter, reverse it s case from low e r to upper or viseversa, \notherwise kee p it as iti s .\nIf the string  containsn o letters, reverse the strin g. \nThe function should r eturn the resulted string.\nExamples\nsolve(\"1234\") = \"4321\"\nsolve(\"ab\") = \"AB\"\nsolve(\"#a@C\") = \"#A@c\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(string s){\n", "canonical_solution": "    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(\"AsDf\") == \"aSdF\");\n    assert (solve(\"1234\") == \"4321\");\n    assert (solve(\"ab\") == \"AB\");\n    assert (solve(\"#a@C\") == \"#A@c\");\n    assert (solve(\"#AsdfW^45\") == \"#aSDFw^45\");\n    assert (solve(\"#6@2\") == \"2@6#\");\n    assert (solve(\"#$a^D\") == \"#$A^d\");\n    assert (solve(\"#ccc\") == \"#CCC\");\n}\n", "declaration": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(\"1234\") == \"4321\");\n    assert (solve(\"ab\") == \"AB\");\n    assert (solve(\"#a@C\") == \"#A@c\");\n}\n", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena stri n g s.\ni f s[i] is  a letter, reverse it s case from low e r to upper or viseversa, \notherwise kee p it as iti s.\nIf the string  containsn o letters, reverse the strin g. \nThe function should r eturn the resulted string.\nExamples\nsolve(\"1234\") = \"4321\"\nsolve(\"ab\") = \"AB\"\nsolve(\"#a@C\") = \"#A@c\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(string s){\n    int len = s.length();\n    string result = \"\";\n    for(int i = 0; i < len; i++){\n        if(s[i] >= 'a' && s[i] <= 'z'){\n            result += (char)(s[i] - 'a' + 'A');\n        }else if(s[i] >= 'A' && s[i] <= 'Z'){\n            result += (char)(s[i] - 'A' + 'a');\n        }else{\n            result += s[i];\n        }\n    }\n    return result;\n}\nint main(){\n    string s = \"1234\";\n    printf(\"%s\\n\", solve(s).c_str());\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/162", "prompt": "/*\nGiven a st ring  'text \" , retu rn its md 5 hash equivalent str ing.\nIf 'text\"i s an empty string,return None.\n\n>>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n*/\n#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\nstring string_to_md5(string text){\n", "canonical_solution": "    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert (string_to_md5(\"\") == \"None\");\n    assert (string_to_md5(\"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert (string_to_md5(\"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n", "declaration": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\");\n}\n", "entry_point": "string_to_md5", "seed": 1, "perturbed": true, "gc": "/*\nGiven a st ring  'text \", retu rn its md 5 hash equivalent str ing.\nIf 'text\"i s an empty string,return None.\n\n>>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n*/\n#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\nstring string_to_md5(string text){\n    if(text.empty()){\n        return \"\";\n    }\n    MD5((unsigned char *)text.c_str(),text.size(),(unsigned char *)text.c_str());\n    return text;\n}\n\nint main(){\n    string text = \"Hello world\";\n    printf(\"%s\\n\",string_to_md5(text).c_str());\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/163", "prompt": "/*\nGiven twoposi tive i n tegers  a and b,  return the even digi ts between a\nan d  b, in ascending or der.\n\nFor example:\ngenerate_integers(2, 8) => {2, 4, 6, 8}\ngenerate_integers(8, 2) => {2, 4, 6, 8}\ngenerate_integers(10, 14) => {}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> generate_integers(int a,int b){\n", "canonical_solution": "    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(generate_integers(2, 10) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(10, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(132, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(17,89) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(generate_integers(2, 8) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(8, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(10,14) , {}));\n}\n", "entry_point": "generate_integers", "seed": 1, "perturbed": true, "gc": "/*\nGiven twoposi tive i n tegers  a and b,  return the even digi ts between a\nan d  b, in ascending or der.\n\nFor example:\ngenerate_integers(2, 8) => {2, 4, 6, 8}\ngenerate_integers(8, 2) => {2, 4, 6, 8}\ngenerate_integers(10, 14) => {}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> generate_integers(int a,int b){\n\tvector<int> v;\n\tif(a>b){\n\t\tint t=a;\n\t\ta=b;\n\t\tb=t;\n\t}\n\tfor(int i=a;i<=b;i++){\n\t\tv.push_back(i);\n\t}\n\treturn v;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tvector<int> v=generate_integers(a,b);\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i%2==0)\n\t\t\tprintf(\"%d \",v[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/17", "prompt": "/*\nInput tot hisfuncti o n is a  string r epresenting musical n otes in a speci a l ASCII format.\nYou r task is to parse th is string an d  return vectorof integer s  corresponding to how many b ea ts does each\nnot last. \n\nHere is a legend:\n\"o\" - whole no te, lasts four beats \n\"o|\"  - half note, last s  two beats\n\".|\" - quater note, lasts one  beat\n\n>>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_music(string music_string){ \n", "canonical_solution": "    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_music(\"\") , {}));\n     assert (issame(parse_music(\"o o o o\") ,{4, 4, 4, 4}));\n      assert (issame(parse_music(\".| .| .| .|\") , {1, 1, 1, 1}));\n assert (issame(parse_music(\"o| o| .| .| o o o o\") , {2, 2, 1, 1, 4, 4, 4, 4}));\n  assert (issame(parse_music(\"o| .| o| .| o o| o o|\") , {2, 1, 2, 1, 4, 2, 4, 2}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_music(\"o o| .| o| o| .| .| .| .| o o\") , {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}));\n}\n", "entry_point": "parse_music", "seed": 1, "perturbed": true, "gc": "/*\nInput tot hisfuncti o n is a  string r epresenting musical n otes in a speci a l ASCII format.\nYou r task is to parse th is string an d  return vectorof integer s  corresponding to how many b ea ts does each\nnot last. \n\nHere is a legend:\n\"o\" - whole no te, lasts four beats \n\"o|\"  - half note, last s  two beats\n\".|\" - quater note, lasts one  beat\n\n>>> parse_music(\"o o|.| o| o|.|.|.|.| o o\")\n{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_music(string music_string){ \n\tvector<int> result;\n\tint i = 0;\n\tint j = 0;\n\twhile(i < music_string.length()){\n\t\tif(music_string[i] == 'o'){\n\t\t\tresult.push_back(4);\n\t\t\ti++;\n\t\t}\n\t\telse if(music_string[i] == '|'){\n\t\t\tresult.push_back(2);\n\t\t\ti++;\n\t\t}\n\t\telse if(music_string[i] == '.'){\n\t\t\tresult.push_back(1);\n\t\t\ti++;\n\t\t}\n\t\telse{\n\t\t\tresult.push_back(0);\n\t\t\ti++;\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tstring music_string;\n\tcin >> music_string;\n\tvector<int> result = parse_music(music_string);\n\tfor(int i = 0; i < result.size(); i++){\n\t\tcout << result[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/18", "prompt": "/*\nFind howm anytimesa  given  substrin g can be found in the  original strin g . Count overlapingcases.\n>>> how_many_times(\"\", \"a\")\n0\n>>> how_many_times(\"aaa\", \"a\")\n3\n>>> how_many_times(\"aaaa\", \"aa\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint how_many_times(string str,string substring){\n", "canonical_solution": "    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (how_many_times(\"\", \"x\") == 0);\n    assert (how_many_times(\"xyxyxyx\", \"x\") == 4);\n     assert (how_many_times(\"cacacacac\", \"cac\") == 4);\n    assert (how_many_times(\"john doe\", \"john\") == 1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (how_many_times(\"\", \"a\") == 0);\n    assert (how_many_times(\"aaa\", \"a\") == 3);\n    assert (how_many_times(\"aaaa\", \"aa\") == 3);\n}\n", "entry_point": "how_many_times", "seed": 1, "perturbed": true, "gc": "/*\nFind howm anytimesa  given  substrin g can be found in the  original strin g. Count overlapingcases.\n>>> how_many_times(\"\", \"a\")\n0\n>>> how_many_times(\"aaa\", \"a\")\n3\n>>> how_many_times(\"aaaa\", \"aa\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint how_many_times(string str,string substring){\n    int count=0;\n    int i=0;\n    int j=0;\n    while(i<str.size()){\n        j=0;\n        while(j<substring.size()){\n            if(str[i]==substring[j]){\n                count++;\n                i++;\n                j++;\n            }\n            else{\n                j=0;\n            }\n        }\n        i++;\n    }\n    return count;\n}\nint main(){\n    string str=\"abcdefg\";\n    string substr=\"def\";\n    cout<<how_many_times(str,substr)<<endl;\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "CPP/19", "prompt": "/*\nInput isa  spa ce-del i mitedstring of  numberals from \"zero \" to \"nine\".\nVa l id choices are \"zer o\", \"one\", 'two\", 'th ree\", \"four\" ,  \"five\", 'six\",  'seven\",\" eight\" and \"nine\".\nReturn th estring with numbers so rted from smallest to largest\n>>> sort_numbers('three one five\")\n\"one three five\"\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nstring sort_numbers(string numbers){\n", "canonical_solution": "    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sort_numbers(\"\") == \"\");\n    assert (sort_numbers(\"three\") == \"three\");\n    assert (sort_numbers(\"three five nine\") == \"three five nine\");\n     assert (sort_numbers(\"five zero four seven nine eight\") == \"zero four five seven eight nine\");\n      assert (sort_numbers(\"six five four three two one zero\") == \"zero one two three four five six\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sort_numbers(\"three one five\") == \"one three five\");\n}\n", "entry_point": "sort_numbers", "seed": 1, "perturbed": true, "gc": "/*\nInput isa  spa ce-del i mitedstring of  numberals from \"zero \" to \"nine\".\nVa l id choices are \"zer o\", \"one\", 'two\", 'th ree\", \"four\",  \"five\",'six\", 'seven\",\" eight\" and \"nine\".\nReturn th estring with numbers so rted from smallest to largest\n>>> sort_numbers('three one five\")\n\"one three five\"\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nstring sort_numbers(string numbers){\n    map<char,int> m;\n    int i=0;\n    for(i=0;i<numbers.length();i++){\n        if(m.find(numbers[i])==m.end()){\n            m[numbers[i]]=1;\n        }\n        else{\n            m[numbers[i]]++;\n        }\n    }\n    string result=\"\";\n    for(i=0;i<numbers.length();i++){\n        if(m[numbers[i]]==1){\n            result+=numbers[i];\n            m[numbers[i]]--;\n        }\n    }\n    return result;\n}\nint main(){\n    string numbers;\n    cout<<\"Enter the string of numbers from 0 to 9: \";\n    cin>>numbers;\n    cout<<\"The sorted string is: \"<<sort_numbers(numbers)<<endl;\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/2", "prompt": "/*\nGiven a po siti ve flo a ting p oint numb er, it can be decompo sed into\nand in t eger part (largestinteger smaller thangiven number )  and decimals\n( leftover p a rt always smaller than 1).\nRe turn the decimal partof the number.\n>>> truncate_number(3.5)\n0.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat truncate_number(float number){\n", "canonical_solution": "    return number-int(number);\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n assert (truncate_number(3.5) == 0.5); \n assert (abs(truncate_number(1.33) - 0.33) < 1e-4);\n  assert (abs(truncate_number(123.456) - 0.456) < 1e-4);\n}", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n assert (truncate_number(3.5) == 0.5); \n}\n", "entry_point": "truncate_number", "seed": 1, "perturbed": true, "gc": "/*\nGiven a po siti ve flo a ting p oint numb er, it can be decompo sed into\nand in t eger part (largestinteger smaller thangiven number )  and decimals\n( leftover p a rt always smaller than 1).\nRe turn the decimal partof the number.\n>>> truncate_number(3.5)\n0.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat truncate_number(float number){\n\tfloat decimal_part=0;\n\tfloat integer_part=0;\n\tfloat remainder=0;\n\tint i=0;\n\tint j=0;\n\tint k=0;\n\tint n=0;\n\tint m=0;\n\tint p=0;\n\tint q=0;\n\tint r=0;\n\tint s=0;\n\tint t=0;\n\tint u=0;\n\tint v=0;\n\tint w=0;\n\tint x=0;\n\tint y=0;\n\tint z=0;\n\tint a=0;\n\tint b=0;\n\tint c=0;\n\tint d=0;\n\tint e=0;\n\tint f=0;\n\tint g=0;\n\tint h=0;\n\tint i1=0;\n\tint i2=0;\n\tint i3=0;\n\tint i4=0;\n\tint i5=0;\n\tint i6=0;\n\tint i7=0;\n\tint i8=0;\n\tint i9=0;\n\tint i10=0;\n\tint i11=0;\n\tint i12=0;\n\tint i13=0;\n\tint i14=0;\n\tint i15=0;\n\tint i16=0;\n\tint i17=0;\n\tint i18=0;\n\tint i19=0;\n\tint i20=0;\n\tint i21=0;\n\tint i22=0;\n\tint i23=0;\n\tint i24=0;\n\tint i25=0;\n\tint i26=0;\n\tint i27=0;\n\tint i28=0;\n\tint i29=0;\n\tint i30=0;\n\tint i31=0;\n\tint i32=0;\n\tint i33=0;\n\tint i34=0;\n\tint i35=0;\n\tint i36=0;\n\tint i37=0;\n\tint i38=0;\n\tint i39=0;\n\tint i40=0;\n\tint i41=0;\n\tint i42=0;\n\tint i43=0;\n\tint i44=0;\n\tint i45=0;\n\tint i46=0;\n\tint i47=0;\n\tint i48=0;\n\tint i49=0;\n\tint i50=0;\n\tint i51=0;\n\tint i52=0;\n\tint i53=0;\n\tint i54=0;\n\tint i55=0;\n\tint i56=0;\n\tint i57=0;\n\tint i58=0;\n\tint i59=0;\n\tint i60=0;\n\tint i61=0;\n\tint i62=0;\n\tint i63=0;\n\tint i64=0;\n\tint i65=0;\n\tint i66=0;\n\tint i67=0;\n\tint i68=0;\n\tint i69=0;\n\tint i70=0;\n\tint i71=0;\n\tint i72=0;\n\tint i73=0;\n\tint i74=0;\n\tint i75=0;\n\tint i76=0;\n\tint i77=0;\n\tint i78=0;\n\tint i79=0;\n\tint i80=0;\n\tint i81=0;\n\tint i82=0;\n\tint i83=0;\n\tint i84=0;\n\tint i85=0;\n\tint i86=0;\n\tint i87=0;\n\tint i88=0;\n\tint i89=0;\n\tint i90=0;\n\tint i91=0;\n\tint i92=0;\n\tint i93=0;\n\tint i94=0;\n\tint i95=0;\n\tint i96=0;\n\tint i97=0;\n\tint i98=0;\n\tint i99=0;\n\tint i100=0;\n\tint i101=0;\n\tint i102=0;\n\tint i103=0;\n\tint i104=0;\n\tint i105=0;\n\tint i106=0;\n\tint i107=0;\n\tint i108=0;\n\tint i109=0;\n\tint i110=0;\n\tint i111=0;\n\tint i112=0;\n\tint i113=0;\n\tint i114=0;\n\tint i115=0;\n\tint i116=0;\n\tint i117=0;\n\tint i118=0;\n\tint i119=0;\n\tint i120=0;\n\tint i121=0;\n\tint i122=0;\n\tint i123=0;\n\tint i124=0;\n\tint i125=0;\n\tint i126=0;\n\tint i127=0;\n\tint i128=0;\n\tint i129=0;\n\tint i130=0;\n\tint i131=0;\n\tint i132=0;\n\tint i133=0;\n\tint i134=0;\n\tint i135=0;\n\tint i136=0;\n\tint i137=0;\n\tint i138=0;\n\tint i139=0;\n\tint i140=0;\n\tint i141=0;\n\tint i142=0;\n\tint i143=0;\n\tint i144=0;\n\tint i145=0;\n\tint i146=0;\n\tint i147=0;\n\tint i148=0;\n\tint i149=0;\n\tint i150=0;\n\tint i151=0;\n\tint i152=0;\n\tint i153=0;\n\tint", "passed": 0, "run_status": 2}
{"task_id": "CPP/20", "prompt": "/*\nFrom a sup plie d vect o r of n umbers (o f length at least two ) select and re t urn two that are th e closest to each\noth er and retur n  themin order(smaller n u mber, larger number).\n>>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> find_closest_elements(vector<float> numbers){\n", "canonical_solution": "    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(find_closest_elements({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}) , {3.9, 4.0}));\n    assert (issame(find_closest_elements({1.0, 2.0, 5.9, 4.0, 5.0}) , {5.0, 5.9} ));\n    assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}) ,{2.0, 2.2}));\n     assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}) ,{2.0, 2.0}));\n      assert (issame(find_closest_elements({1.1, 2.2, 3.1, 4.1, 5.1}) , {2.2, 3.1}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}) ,{2.0, 2.2}));\n     assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}) ,{2.0, 2.0}));\n}\n", "entry_point": "find_closest_elements", "seed": 1, "perturbed": true, "gc": "/*\nFrom a sup plie d vect o r of n umbers (o f length at least two ) select and re t urn two that are th e closest to each\noth er and retur n  themin order(smaller n u mber, larger number).\n>>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> closest_elements;\n    float min_distance = numbers[0] + numbers[1];\n    for(int i = 0; i < numbers.size(); i++){\n        for(int j = 0; j < numbers.size(); j++){\n            if(i!= j){\n                float distance = abs(numbers[i] - numbers[j]);\n                if(distance < min_distance){\n                    min_distance = distance;\n                    closest_elements.clear();\n                    closest_elements.push_back(numbers[i]);\n                    closest_elements.push_back(numbers[j]);\n                }\n            }\n        }\n    }\n    return closest_elements;\n}\n\nint main(){\n    vector<float> numbers;\n    numbers.push_back(1.0);\n    numbers.push_back(2.0);\n    numbers.push_back(3.0);\n    numbers.push_back(4.0);\n    numbers.push_back(5.0);\n    numbers.push_back(2.2);\n    vector<float> closest_elements = find_closest_elements(numbers);\n    for(int i = 0; i < closest_elements.size(); i++){\n        printf(\"%f\\n\", closest_elements[i]);\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/21", "prompt": "/*\nGiven vect or o f numb e rs (of  at least  two elements), apply  a linear trans f orm to that vector, \nsuch that the smalle st number wi l l become 0 andthe larges t  will become 1\n>>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> rescale_to_unit(vector<float> numbers){ \n", "canonical_solution": "    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(rescale_to_unit({2.0, 49.9}) , {0.0, 1.0}));\n     assert (issame(rescale_to_unit({100.0, 49.9}) ,{1.0, 0.0})); \n     assert (issame(rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0}) , {0.0, 0.25, 0.5, 0.75, 1.0}));\n    assert (issame(rescale_to_unit({2.0, 1.0, 5.0, 3.0, 4.0}) , {0.25, 0.0, 1.0, 0.5, 0.75}));\n     assert (issame(rescale_to_unit({12.0, 11.0, 15.0, 13.0, 14.0}) ,{0.25, 0.0, 1.0, 0.5, 0.75}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0}) , {0.0, 0.25, 0.5, 0.75, 1.0}));\n}\n", "entry_point": "rescale_to_unit", "seed": 1, "perturbed": true, "gc": "/*\nGiven vect or o f numb e rs (of  at least  two elements), apply  a linear trans f orm to that vector, \nsuch that the smalle st number wi l l become 0 andthe larges t  will become 1\n>>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> rescale_to_unit(vector<float> numbers){ \n\tfloat sum = 0;\n\tfor(int i=0;i<numbers.size();i++){\n\t\tsum += numbers[i];\n\t}\n\tfloat scale = 1/sum;\n\tfor(int i=0;i<numbers.size();i++){\n\t\tnumbers[i] *= scale;\n\t}\n\treturn numbers;\n}\nint main(){\n\tvector<float> numbers;\n\tnumbers.push_back(1.0);\n\tnumbers.push_back(2.0);\n\tnumbers.push_back(3.0);\n\tnumbers.push_back(4.0);\n\tnumbers.push_back(5.0);\n\tvector<float> result = rescale_to_unit(numbers);\n\tfor(int i=0;i<result.size();i++){\n\t\tprintf(\"%f\\n\",result[i]);\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/22", "prompt": "/*\nFilter giv en v ectoro f anypython va lues only for integer s\n>>> filter_integers({\"a\", 3.14, 5})\n{5}\n>>> filter_integers({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\nvector<int> filter_integers(list_any values){\n", "canonical_solution": "    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_integers({}),{}));\n\n    assert (issame(filter_integers({4,  {},23.2, 9, string(\"adasd\")}) ,{4, 9}));\n    assert (issame(filter_integers({3, 'c', 3, 3, 'a', 'b'}) ,{3, 3, 3}));\n}", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_integers({string(\"a\"), 3.14, 5}),{5}));\n    assert (issame(filter_integers({1, 2, 3, string(\"abc\"), {}, {}}),{1,2,3}));\n}\n", "entry_point": "filter_integers", "seed": 1, "perturbed": true, "gc": "/*\nFilter giv en v ectoro f anypython va lues only for integer s\n>>> filter_integers({\"a\", 3.14, 5})\n{5}\n>>> filter_integers({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\nvector<int> filter_integers(list_any values){\n\tvector<int> ret;\n\tfor(list_any::iterator it = values.begin(); it!= values.end(); it++){\n\t\tboost::any& value = *it;\n\t\tif(boost::any_cast<int>(value)){\n\t\t\tret.push_back(boost::any_cast<int>(value));\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tlist_any values;\n\tvalues.push_back(1);\n\tvalues.push_back(2);\n\tvalues.push_back(3);\n\tvalues.push_back(4);\n\tvalues.push_back(5);\n\tvalues.push_back(6);\n\tvalues.push_back(7);\n\tvalues.push_back(8);\n\tvalues.push_back(9);\n\tvalues.push_back(10);\n\tvalues.push_back(11);\n\tvalues.push_back(12);\n\tvalues.push_back(13);\n\tvalues.push_back(14);\n\tvalues.push_back(15);\n\tvalues.push_back(16);\n\tvalues.push_back(17);\n\tvalues.push_back(18);\n\tvalues.push_back(19);\n\tvalues.push_back(20);\n\tvalues.push_back(21);\n\tvalues.push_back(22);\n\tvalues.push_back(23);\n\tvalues.push_back(24);\n\tvalues.push_back(25);\n\tvalues.push_back(26);\n\tvalues.push_back(27);\n\tvalues.push_back(28);\n\tvalues.push_back(29);\n\tvalues.push_back(30);\n\tvalues.push_back(31);\n\tvalues.push_back(32);\n\tvalues.push_back(33);\n\tvalues.push_back(34);\n\tvalues.push_back(35);\n\tvalues.push_back(36);\n\tvalues.push_back(37);\n\tvalues.push_back(38);\n\tvalues.push_back(39);\n\tvalues.push_back(40);\n\tvalues.push_back(41);\n\tvalues.push_back(42);\n\tvalues.push_back(43);\n\tvalues.push_back(44);\n\tvalues.push_back(45);\n\tvalues.push_back(46);\n\tvalues.push_back(47);\n\tvalues.push_back(48);\n\tvalues.push_back(49);\n\tvalues.push_back(50);\n\tvalues.push_back(51);\n\tvalues.push_back(52);\n\tvalues.push_back(53);\n\tvalues.push_back(54);\n\tvalues.push_back(55);\n\tvalues.push_back(56);\n\tvalues.push_back(57);\n\tvalues.push_back(58);\n\tvalues.push_back(59);\n\tvalues.push_back(60);\n\tvalues.push_back(61);\n\tvalues.push_back(62);\n\tvalues.push_back(63);\n\tvalues.push_back(64);\n\tvalues.push_back(65);\n\tvalues.push_back(66);\n\tvalues.push_back(67);\n\tvalues.push_back(68);\n\tvalues.push_back(69);\n\tvalues.push_back(70);\n\tvalues.push_back(71);\n\tvalues.push_back(72);\n\tvalues.push_back(73);\n\tvalues.push_back(74);\n\tvalues.push_back(75);\n\tvalues.push_back(76);\n\tvalues.push_back(77);\n\tvalues.push_back(78);\n\tvalues.push_back(79);\n\tvalues.push_back(80);\n\tvalues.push_back(81);\n\tvalues.push_back(82);\n\tvalues.push_back(83);\n\tvalues.push_back(84);\n\tvalues.push_back(85);\n\tvalues.push_back(86);\n\tvalues.push_back(87);\n\tvalues.push_back(88);\n\tvalues.push_back(89);\n\tvalues.push_back(90);\n\tvalues.push_back(91);\n\tvalues.push_back(92);\n\tvalues.push_back(93);\n\tvalues.push_back(94);\n\tvalues.push_back(95);\n\tvalues.push_back(96);\n\tvalues.push_back(97);\n\tvalues.push_back(98);\n\tvalues.push_back(99);\n\tvalues.push_back(100);\n\tvalues.push_back(101);\n\tvalues.push_back(102);\n\tvalues.push_back(103);\n\tvalues.push_back(104);\n\tvalues.push_back(105);\n\tvalues.push_back(106);\n\tvalues.push_back(107);\n\tvalues.push_back(108);\n\tvalues.push_back(109);\n\tvalues.push_back(110);\n\tvalues.push_back(111);\n\tvalues.push_back(112);\n\tvalues.push_back(113);\n\tvalues.push_back(114);\n\tvalues.push_back(115);\n\tvalues.push_back(116);\n\tvalues.push_back(117);\n\tvalues.push_back(118);\n\tvalues.push_back(119);\n\tvalues.push_back(120);\n\tvalues.push_back(121);\n\tvalues.push_back(122);\n\tvalues.push_back(123);\n\tvalues.push_back(124);\n\tvalues.push_back(125);\n\tvalues.push_back(126);\n\tvalues.push_back(127);\n\tvalues.push_back(128);\n\tvalues.push_back(129);\n", "passed": 0, "run_status": 4}
{"task_id": "CPP/23", "prompt": "/*\nReturn len gthof giv e n stri ng\n>>> strlen(\"\")\n0\n>>> strlen(\"abc\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint strlen(string str){\n", "canonical_solution": "    return str.length();\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (strlen(\"\") == 0);\n    assert (strlen(\"x\") == 1);\n     assert (strlen(\"asdasnakj\") == 9);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (strlen(\"\") == 0);\n    assert (strlen(\"abc\") == 3);\n}\n", "entry_point": "strlen", "seed": 1, "perturbed": true, "gc": "/*\nReturn len gthof giv e n stri ng\n>>> strlen(\"\")\n0\n>>> strlen(\"abc\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint strlen(string str){\n    int i=0;\n    while(str[i]!='\\0'){\n        i++;\n    }\n    return i;\n}\nint main(){\n    string str;\n    cin>>str;\n    int len=strlen(str);\n    cout<<len;\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/24", "prompt": "/*\nFor a give n nu mber n ,  findthe large st number that divide s n evenly, sma l ler than n\n>>> largest_divisor(15)\n5\n*/\n#include<stdio.h>\nusing namespace std;\nint largest_divisor(int n){\n", "canonical_solution": "    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_divisor(3) == 1);\n    assert (largest_divisor(7) == 1);\n    assert (largest_divisor(10) == 5);\n    assert (largest_divisor(100) == 50);\n    assert (largest_divisor(49) == 7);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_divisor(15) == 5);\n}\n", "entry_point": "largest_divisor", "seed": 1, "perturbed": true, "gc": "/*\nFor a give n nu mber n,  findthe large st number that divide s n evenly, sma l ler than n\n>>> largest_divisor(15)\n5\n*/\n#include<stdio.h>\nusing namespace std;\nint largest_divisor(int n){\n    int i,j,k,l,m,n,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,", "passed": 0, "run_status": 2}
{"task_id": "CPP/25", "prompt": "/*\nReturn vec torof pri m e fact ors of gi ven integer in the or der from smalle s t to largest.\nEachof the factors should  be vectored number of times  correspon d ing to how many times it app ea res in factorization.Input number should be equal to th e product of all fac tors\n>>> factorize(8)\n{2, 2, 2}\n>>> factorize(25)\n{5, 5}\n>>> factorize(70)\n{2, 5, 7}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> factorize(int n){\n", "canonical_solution": "    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(factorize(2) , {2}));\n    assert (issame(factorize(4) , {2, 2}));\n    assert (issame(factorize(8) , {2, 2, 2}));\n     assert (issame(factorize(3 * 19) , {3, 19}));\n    assert (issame(factorize(3 * 19 * 3 * 19) , {3, 3, 19, 19})); \n    assert (issame(factorize(3 * 19 * 3 * 19 * 3 * 19) , {3, 3, 3, 19, 19, 19})); \n    assert (issame(factorize(3 * 19 * 19 * 19) , {3, 19, 19, 19})); \n    assert (issame(factorize(3 * 2 * 3) , {2, 3, 3}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(factorize(8) , {2, 2, 2}));\n     assert (issame(factorize(25) , {5,5}));\n    assert (issame(factorize(70) , {2,5,7})); \n}\n", "entry_point": "factorize", "seed": 1, "perturbed": true, "gc": "/*\nReturn vec torof pri m e fact ors of gi ven integer in the or der from smalle s t to largest.\nEachof the factors should  be vectored number of times  correspon d ing to how many times it app ea res in factorization.Input number should be equal to th e product of all fac tors\n>>> factorize(8)\n{2, 2, 2}\n>>> factorize(25)\n{5, 5}\n>>> factorize(70)\n{2, 5, 7}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> factorize(int n){\n    vector<int> res;\n    int i;\n    for(i=2;i<=n/2;i++){\n        if(n%i==0){\n            while(n%i==0){\n                res.push_back(i);\n                n/=i;\n            }\n        }\n    }\n    if(n>1){\n        res.push_back(n);\n    }\n    return res;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> res=factorize(n);\n    for(int i=0;i<res.size();i++){\n        printf(\"%d\",res[i]);\n        if(i!=res.size()-1)\n            printf(\"*\");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/26", "prompt": "/*\nFrom a vec torof int e gers,remove al l elements that occur  more than once . \nKeep order of elem ents left the same as  in the inpu t .\n>>> remove_duplicates({1, 2, 3, 2, 4})\n{1, 3, 4}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> remove_duplicates(vector<int> numbers){\n", "canonical_solution": "    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(remove_duplicates({}) , {}));\n     assert (issame(remove_duplicates({1, 2, 3, 4}) , {1, 2, 3, 4}));\n      assert (issame(remove_duplicates({1, 2, 3, 2, 4, 3, 5}) , {1, 4, 5}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(remove_duplicates({1, 2, 3, 2,4}) , {1,  3, 4}));\n}\n", "entry_point": "remove_duplicates", "seed": 1, "perturbed": true, "gc": "/*\nFrom a vec torof int e gers,remove al l elements that occur  more than once. \nKeep order of elem ents left the same as  in the inpu t.\n>>> remove_duplicates({1, 2, 3, 2, 4})\n{1, 3, 4}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> remove_duplicates(vector<int> numbers){\n\tvector<int> res;\n\tfor(int i=0;i<numbers.size();i++){\n\t\tif(find(res.begin(),res.end(),numbers[i])==res.end()){\n\t\t\tres.push_back(numbers[i]);\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tvector<int> numbers={1, 2, 3, 2, 4};\n\tvector<int> res=remove_duplicates(numbers);\n\tfor(int i=0;i<res.size();i++){\n\t\tprintf(\"%d \",res[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/27", "prompt": "/*\nFor a give n st ring,f lip lo wercase c haracters to uppercas e and uppercase to lowercase.\n>>> flip_case(\"Hello\")\n\"hELLO\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring filp_case(string str){\n", "canonical_solution": "    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (filp_case(\"\") == \"\");\n    assert (filp_case(\"Hello!\") == \"hELLO!\");\n    assert (filp_case(\"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (filp_case(\"Hello\") == \"hELLO\");\n}\n", "entry_point": "filp_case", "seed": 1, "perturbed": true, "gc": "/*\nFor a give n st ring,f lip lo wercase c haracters to uppercas e and uppercase to lowercase.\n>>> flip_case(\"Hello\")\n\"hELLO\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring filp_case(string str){\n    string str1 = \"\";\n    for(int i = 0; i < str.length(); i++){\n        if(str[i] >= 'a' && str[i] <= 'z'){\n            str1 += (char)(str[i] + 'A' - 'a');\n        }\n        else{\n            str1 += str[i];\n        }\n    }\n    return str1;\n}\nint main(){\n    string str = \"Hello\";\n    printf(\"%s\\n\",filp_case(str));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/28", "prompt": "/*\nConcatenat e ve ctor o f  strin gs into a  single string\n>>> concatenate({})\n\"\"\n>>> concatenate({\"a\", \"b\", \"c\"})\n\"abc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring concatenate(vector<string> strings){\n", "canonical_solution": "    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (concatenate({}) == \"\");\n     assert (concatenate({\"x\", \"y\", \"z\"}) == \"xyz\");\n    assert (concatenate({\"x\", \"y\", \"z\", \"w\", \"k\"}) == \"xyzwk\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (concatenate({}) == \"\");\n    assert (concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n}\n", "entry_point": "concatenate", "seed": 1, "perturbed": true, "gc": "/*\nConcatenat e ve ctor o f  strin gs into a  single string\n>>> concatenate({})\n\"\"\n>>> concatenate({\"a\", \"b\", \"c\"})\n\"abc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring concatenate(vector<string> strings){\n    string result = \"\";\n    for(int i = 0; i < strings.size(); i++){\n        result += strings[i];\n    }\n    return result;\n}\nint main(){\n    vector<string> strings;\n    strings.push_back(\"a\");\n    strings.push_back(\"b\");\n    strings.push_back(\"c\");\n    cout << concatenate(strings) << endl;\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/29", "prompt": "/*\nFilter aninpu t vect o r of s trings on ly for ones that star t with a givenp refix.\n>>> filter_by_prefix({}, \"a\")\n{}\n>>> filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n", "canonical_solution": "    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_prefix({}, \"john\") , {}));\n    assert (issame(filter_by_prefix({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\") , {\"xxx\", \"xxxAAA\", \"xxx\"}));\n\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_prefix({}, \"a\") , {}));\n    assert (issame(filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\") , {\"abc\", \"array\"}));\n}\n", "entry_point": "filter_by_prefix", "seed": 1, "perturbed": true, "gc": "/*\nFilter aninpu t vect o r of s trings on ly for ones that star t with a givenp refix.\n>>> filter_by_prefix({}, \"a\")\n{}\n>>> filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> result;\n    for(int i=0; i<strings.size(); i++){\n        if(strings[i].find(prefix) == 0){\n            result.push_back(strings[i]);\n        }\n    }\n    return result;\n}\nint main(){\n    vector<string> strings;\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    strings.push_back(\"a\");\n    strings.push_back(\"ab\");\n    strings.push_back(\"abc\");\n    strings.push_back(\"bcd\");\n    strings.push_back(\"cde\");", "passed": 1, "run_status": 0}
{"task_id": "CPP/3", "prompt": "/*\nYou\"re giv en a  vecto r  of de posit and  withdrawal operation s on a bank acc o unt that starts wit h\nzero balance. Yourtask is tod e tect if at anypoint theb alance of account falls belo wzero, and\nat that poin t function should return true. Oth erwise it should ret urn f alse.\n>>> below_zero({1, 2, 3})\nfalse\n>>> below_zero({1, 2, -4, 5})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_zero(vector<int> operations){\n", "canonical_solution": "    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_zero({}) == false);\n    assert (below_zero({1, 2, -3, 1, 2, -3}) == false);\n    assert (below_zero({1, 2, -4, 5, 6}) == true);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -4}) == false);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -5}) == true);\n    assert (below_zero({1, -2, 2, -2, 5, -5, 4, -4}) == true);\n}", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_zero({1, 2, 3}) == false);\n    assert (below_zero({1, 2, -4, 5}) == true);\n}\n", "entry_point": "below_zero", "seed": 1, "perturbed": true, "gc": "/*\nYou\"re giv en a  vecto r  of de posit and  withdrawal operation s on a bank acc o unt that starts wit h\nzero balance. Yourtask is tod e tect if at anypoint theb alance of account falls belo wzero, and\nat that poin t function should return true. Oth erwise it should ret urn f alse.\n>>> below_zero({1, 2, 3})\nfalse\n>>> below_zero({1, 2, -4, 5})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_zero(vector<int> operations){\n\tint sum = 0;\n\tfor(int i = 0; i < operations.size(); i++){\n\t\tsum += operations[i];\n\t}\n\tif(sum < 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> operations(n);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &operations[i]);\n\t}\n\tprintf(\"%d\\n\", below_zero(operations));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/30", "prompt": "/*\nReturn onl y po sitive number s in thevector.\n>>> get_positive({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> get_positive(vector<float> l){\n", "canonical_solution": "    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_positive({-1, -2, 4, 5, 6}) , {4, 5, 6} ));\n    assert (issame(get_positive({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}) , {5, 3, 2, 3, 3, 9, 123, 1}));\n     assert (issame(get_positive({-1, -2}) , {} ));\n     assert (issame(get_positive({}) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_positive({-1, 2, -4, 5, 6}) , {2, 5, 6} ));\n    assert (issame(get_positive({5, 3, -5, 2, -3,3, 9, 0, 123, 1, -10}) , {5, 3, 2,  3, 9, 123, 1}));\n}\n", "entry_point": "get_positive", "seed": 1, "perturbed": true, "gc": "/*\nReturn onl y po sitive number s in thevector.\n>>> get_positive({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> get_positive(vector<float> l){\n\tvector<float> r;\n\tfor(int i=0;i<l.size();i++){\n\t\tif(l[i]>0){\n\t\t\tr.push_back(l[i]);\n\t\t}\n\t}\n\treturn r;\n}\nint main(){\n\tvector<float> v;\n\tv.push_back(-1);\n\tv.push_back(2);\n\tv.push_back(-4);\n\tv.push_back(5);\n\tv.push_back(6);\n\tvector<float> r=get_positive(v);\n\tfor(int i=0;i<r.size();i++){\n\t\tprintf(\"%f \",r[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/31", "prompt": "/*\nReturn tru e if  a giv e n numb er is pri me, and false otherwi se.\n>>> is_prime(6)\nfalse\n>>> is_prime(101)\ntrue\n>>> is_prime(11)\ntrue\n>>> is_prime(13441)\ntrue\n>>> is_prime(61)\ntrue\n>>> is_prime(4)\nfalse\n>>> is_prime(1)\nfalse\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_prime(long long n){\n", "canonical_solution": "    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_prime(6) == false);\n    assert (is_prime(101) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(13441) == true);\n    assert (is_prime(61) == true);\n    assert (is_prime(4) == false);\n    assert (is_prime(1) == false);\n    assert (is_prime(5) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(17) == true);\n    assert (is_prime(5 * 17) == false);\n    assert (is_prime(11 * 7) == false);\n    assert (is_prime(13441 * 19) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_prime(6) == false);\n    assert (is_prime(101) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(13441) == true);\n    assert (is_prime(61) == true);\n    assert (is_prime(4) == false);\n    assert (is_prime(1) == false);\n}\n", "entry_point": "is_prime", "seed": 1, "perturbed": true, "gc": "/*\nReturn tru e if  a giv e n numb er is pri me, and false otherwi se.\n>>> is_prime(6)\nfalse\n>>> is_prime(101)\ntrue\n>>> is_prime(11)\ntrue\n>>> is_prime(13441)\ntrue\n>>> is_prime(61)\ntrue\n>>> is_prime(4)\nfalse\n>>> is_prime(1)\nfalse\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_prime(long long n){\n    if(n<=1)\n        return false;\n    if(n<=3)\n        return true;\n    if(n%2==0)\n        return false;\n    long long i=3;\n    while(i*i<=n)\n    {\n        if(n%i==0)\n            return false;\n        i+=2;\n    }\n    return true;\n}\nint main(){\n    long long n;\n    while(scanf(\"%lld\",&n)!=EOF){\n        if(is_prime(n))\n            printf(\"%lld is prime\\n\",n);\n        else\n            printf(\"%lld is not prime\\n\",n);\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/32", "prompt": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluatespoly nomial with c oefficien ts xs at point x. ret urn xs[0] + xs[ 1 ] * x + xs[1] * x^2  + .... xs[n] * x^n     */\n   d o uble sum=0;\n   int i;\n  for (i=0;i<xs.size();i++)\n  {\n        sum+=xs[i]* pow(x,i);\n    }\n   return sum;\n}double find_zero(ve ctor< double> xs){\n    / * \n    xs are coefficients of a polynomial .find_zero find x such that  poly(x) = 0.find_zeroreturns only o nly zero point, e ven if there are many.\n    Mo reover, find_zero only takes l ist  xs having even number of coefficien ts and larg est non zero coef ficient as it guarantees a solut ion.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n", "canonical_solution": "    double ans=0;\n    double value;\n    value=poly(xs,ans);\n    while (abs(value)>1e-6)\n    {\n        double driv=0;\n        for (int i=1;i<xs.size();i++)\n        {\n            driv+=xs[i]*pow(ans,i-1)*i;\n        }\n        ans=ans-value/driv;\n        value=poly(xs,ans);\n    }\n    return ans;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n   \n    double solution;\n    int ncoeff;\n    for (int i=0;i<100;i++)\n    {\n        ncoeff = 2 * (1+rand()%4);\n        vector<double> coeffs = {};\n        for (int j=0;j<ncoeff;j++)\n        {\n            double coeff = -10+rand()%21;\n            if (coeff == 0) coeff = 1;\n            coeffs.push_back(coeff);\n        }\n        \n        solution = find_zero(coeffs);\n        assert (abs(poly(coeffs, solution))< 1e-3);\n    }\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\ndouble poly(vector<double> xs, double x){\n    double sum=0;\n    int i;\n    for (i=0;i<xs.size();i++)\n    {\n        sum+=xs[i]*pow(x,i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (find_zero({1,2})+0.5<1e-4);\n    assert (find_zero({-6,11,-6,1})-1<1e-4);\n}\n", "entry_point": "for", "seed": 1, "perturbed": true, "gc": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluatespoly nomial with c oefficien ts xs at point x. ret urn xs[0] + xs[ 1 ] * x + xs[1] * x^2  +.... xs[n] * x^n     */\n   d o uble sum=0;\n   int i;\n  for (i=0;i<xs.size();i++)\n  {\n        sum+=xs[i]* pow(x,i);\n    }\n   return sum;\n}double find_zero(ve ctor< double> xs){\n    / * \n    xs are coefficients of a polynomial.find_zero find x such that  poly(x) = 0.find_zeroreturns only o nly zero point, e ven if there are many.\n    Mo reover, find_zero only takes l ist  xs having even number of coefficien ts and larg est non zero coef ficient as it guarantees a solut ion.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    int i;\n    double x, x_next;\n    double x_min = 0;\n    double x_max = 1;\n    double x_mid = 0.5;\n    double x_mid_next = 0.5;\n    double x_mid_next_next = 0.5;\n    double x_mid_next_next_next = 0.5;\n    double x_mid_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0.5;\n    double x_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_", "passed": 0, "run_status": 2}
{"task_id": "CPP/33", "prompt": "/*\nThis funct iontakesa  vecto r l and r eturns a vector l' su ch that\nl' is i d entical to l in the  indicies that are no t divisibleb y three, whileits values at the indicies that are div is ible by three are equa l\nto the values of the correspondi ng indicies of l, bu tsor ted.\n>>> sort_third({1, 2, 3})\n{1, 2, 3}\n>>> sort_third({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_third(vector<int> l){\n", "canonical_solution": "    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_third({1, 2, 3}) , sort_third({1, 2, 3})));\n    assert (issame(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert (issame(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2}) , {2, 6, 3, 4, 8, 9, 5}));\n    assert (issame(sort_third({5, 8, 3, 4, 6, 9, 2}) , {2, 8, 3, 4, 6, 9, 5}));\n    assert (issame(sort_third({5, 6, 9, 4, 8, 3, 2}) , {2, 6, 9, 4, 8, 3, 5}));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2, 1}) , {2, 6, 3, 4, 8, 9, 5, 1}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_third({1, 2, 3}) , {1, 2, 3}));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2}) , {2, 6, 3, 4, 8, 9, 5}));\n}\n", "entry_point": "sort_third", "seed": 1, "perturbed": true, "gc": "/*\nThis funct iontakesa  vecto r l and r eturns a vector l' su ch that\nl' is i d entical to l in the  indicies that are no t divisibleb y three, whileits values at the indicies that are div is ible by three are equa l\nto the values of the correspondi ng indicies of l, bu tsor ted.\n>>> sort_third({1, 2, 3})\n{1, 2, 3}\n>>> sort_third({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_third(vector<int> l){\n\tvector<int> r;\n\tint i, j, k;\n\tfor(i=0;i<l.size();i++){\n\t\tfor(j=i+1;j<l.size();j++){\n\t\t\tfor(k=j+1;k<l.size();k++){\n\t\t\t\tif(l[i]%3==0 && l[j]%3==0 && l[k]%3==0){\n\t\t\t\t\tr.push_back(l[i]);\n\t\t\t\t\tr.push_back(l[j]);\n\t\t\t\t\tr.push_back(l[k]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\nint main(){\n\tint n, i;\n\tvector<int> l;\n\tscanf(\"%d\", &n);\n\tfor(i=0;i<n;i++){\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tl.push_back(a);\n\t}\n\tsort(l.begin(), l.end());\n\tvector<int> r = sort_third(l);\n\tfor(i=0;i<r.size();i++){\n\t\tprintf(\"%d \", r[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/34", "prompt": "/*\nReturn sor tedunique elemen ts in a v ector\n>>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{0, 2, 3, 5, 9, 123}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> unique(vector<int> l){\n", "canonical_solution": "    vector<int> out={};\n    for (int i=0;i<l.size();i++)\n        if (find(out.begin(),out.end(),l[i])==out.end())\n            out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique({5, 3, 5, 2, 3, 3, 9, 0, 123}) , {0, 2, 3, 5, 9, 123}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique(vector<int> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique({5, 3, 5, 2, 3, 3, 9, 0, 123}) , {0, 2, 3, 5, 9, 123}));\n}\n", "entry_point": "unique", "seed": 1, "perturbed": true, "gc": "/*\nReturn sor tedunique elemen ts in a v ector\n>>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{0, 2, 3, 5, 9, 123}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> unique(vector<int> l){\n\tvector<int> r;\n\tfor(int i=0;i<l.size();i++){\n\t\tif(find(r.begin(),r.end(),l[i])==r.end()){\n\t\t\tr.push_back(l[i]);\n\t\t}\n\t}\n\treturn r;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> v;\n\tfor(int i=0;i<n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tv.push_back(x);\n\t}\n\tvector<int> u=unique(v);\n\tfor(int i=0;i<u.size();i++){\n\t\tprintf(\"%d \",u[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/35", "prompt": "/*\nReturn max imum  eleme n t in t he vector .\n>>> max_element({1, 2, 3})\n3\n>>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat max_element(vector<float> l){\n", "canonical_solution": "  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(max_element({1, 2, 3})- 3)<1e-4);\n    assert (abs(max_element({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10})- 124)<1e-4);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(max_element({1, 2, 3})- 3)<1e-4);\n    assert (abs(max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})- 123)<1e-4);\n}\n", "entry_point": "max_element", "seed": 1, "perturbed": true, "gc": "/*\nReturn max imum  eleme n t in t he vector.\n>>> max_element({1, 2, 3})\n3\n>>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat max_element(vector<float> l){\n    float max=l[0];\n    for(int i=1;i<l.size();i++){\n        if(l[i]>max){\n            max=l[i];\n        }\n    }\n    return max;\n}\nint main(){\n    vector<float> v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(3);\n    v.push_back(4);\n    v.push_back(5);\n    v.push_back(6);\n    v.push_back(7);\n    v.push_back(8);\n    v.push_back(9);\n    v.push_back(10);\n    v.push_back(11);\n    v.push_back(12);\n    v.push_back(13);\n    v.push_back(14);\n    v.push_back(15);\n    v.push_back(16);\n    v.push_back(17);\n    v.push_back(18);\n    v.push_back(19);\n    v.push_back(20);\n    v.push_back(21);\n    v.push_back(22);\n    v.push_back(23);\n    v.push_back(24);\n    v.push_back(25);\n    v.push_back(26);\n    v.push_back(27);\n    v.push_back(28);\n    v.push_back(29);\n    v.push_back(30);\n    v.push_back(31);\n    v.push_back(32);\n    v.push_back(33);\n    v.push_back(34);\n    v.push_back(35);\n    v.push_back(36);\n    v.push_back(37);\n    v.push_back(38);\n    v.push_back(39);\n    v.push_back(40);\n    v.push_back(41);\n    v.push_back(42);\n    v.push_back(43);\n    v.push_back(44);\n    v.push_back(45);\n    v.push_back(46);\n    v.push_back(47);\n    v.push_back(48);\n    v.push_back(49);\n    v.push_back(50);\n    v.push_back(51);\n    v.push_back(52);\n    v.push_back(53);\n    v.push_back(54);\n    v.push_back(55);\n    v.push_back(56);\n    v.push_back(57);\n    v.push_back(58);\n    v.push_back(59);\n    v.push_back(60);\n    v.push_back(61);\n    v.push_back(62);\n    v.push_back(63);\n    v.push_back(64);\n    v.push_back(65);\n    v.push_back(66);\n    v.push_back(67);\n    v.push_back(68);\n    v.push_back(69);\n    v.push_back(70);\n    v.push_back(71);\n    v.push_back(72);\n    v.push_back(73);\n    v.push_back(74);\n    v.push_back(75);\n    v.push_back(76);\n    v.push_back(77);\n    v.push_back(78);\n    v.push_back(79);\n    v.push_back(80);\n    v.push_back(81);\n    v.push_back(82);\n    v.push_back(83);\n    v.push_back(84);\n    v.push_back(85);\n    v.push_back(86);\n    v.push_back(87);\n    v.push_back(88);\n    v.push_back(89);\n    v.push_back(90);\n    v.push_back(91);\n    v.push_back(92);\n    v.push_back(93);\n    v.push_back(94);\n    v.push_back(95);\n    v.push_back(96);\n    v.push_back(97);\n    v.push_back(98);\n    v.push_back(99);\n    v.push_back(100);\n    v.push_back(101);\n    v.push_back(102);\n    v.push_back(103);\n    v.push_back(104);\n    v.push_back(105);\n    v.push_back(106);\n    v.push_back(107);\n    v.push_back(108);\n    v.push_back(109);\n    v.push_back(110);\n    v.push_back(111);\n    v.push_back(112);\n    v.push_back(113);\n    v.push_back(114);\n    v.push_back(115);\n    v.push_back(116);\n    v.push_back(117);\n    v.push_back(118);\n    v.push_back(119);\n    v.push_back(120);\n    v.push_back(121);\n    v.push_back(122);\n    v.push_back(123);\n    v.push_back(124);\n    v.push_back(125);\n    v.push_back(126);\n    v.push_back(127);\n    v.push_back(128);\n    v.push_back(129);\n    v.push_back(130);\n    v.push_back(131);\n    v.push_back(132);\n    v.push_back(133);\n    v.push_back(134);\n    v.push_back(135);\n    v.push_back(136);", "passed": 1, "run_status": 0}
{"task_id": "CPP/36", "prompt": "/*\nReturn the  num ber of timesthe digit  7 appears in integer s less than n w h ich are divisible b y 11 or 13.\n>>> fizz_buzz(50)\n0\n>>> fizz_buzz(78)\n2\n>>> fizz_buzz(79)\n3\n*/\n#include<stdio.h>\nusing namespace std;\nint fizz_buzz(int n){\n", "canonical_solution": "    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fizz_buzz(50) == 0);\n    assert (fizz_buzz(78) == 2);\n    assert (fizz_buzz(79) == 3);\n    assert (fizz_buzz(100) == 3);\n    assert (fizz_buzz(200) == 6);\n    assert (fizz_buzz(4000) == 192);\n    assert (fizz_buzz(10000) == 639);\n    assert (fizz_buzz(100000) == 8026);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fizz_buzz(50) == 0);\n    assert (fizz_buzz(78) == 2);\n    assert (fizz_buzz(79) == 3);\n}\n", "entry_point": "fizz_buzz", "seed": 1, "perturbed": true, "gc": "/*\nReturn the  num ber of timesthe digit  7 appears in integer s less than n w h ich are divisible b y 11 or 13.\n>>> fizz_buzz(50)\n0\n>>> fizz_buzz(78)\n2\n>>> fizz_buzz(79)\n3\n*/\n#include<stdio.h>\nusing namespace std;\nint fizz_buzz(int n){\n\tint i,j,k,l,m,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19,n20,n21,n22,n23,n24,n25,n26,n27,n28,n29,n30,n31,n32,n33,n34,n35,n36,n37,n38,n39,n40,n41,n42,n43,n44,n45,n46,n47,n48,n49,n50;\n\tn1=n2=n3=n4=n5=n6=n7=n8=n9=n10=n11=n12=n13=n14=n15=n16=n17=n18=n19=n20=n21=n22=n23=n24=n25=n26=n27=n28=n29=n30=n31=n32=n33=n34=n35=n36=n37=n38=n39=n40=n41=n42=n43=n44=n45=n46=n47=n48=n49=n50=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(i%3==0){\n\t\t\tn1++;\n\t\t}\n\t\tif(i%5==0){\n\t\t\tn2++;\n\t\t}\n\t\tif(i%7==0){\n\t\t\tn3++;\n\t\t}\n\t\tif(i%11==0){\n\t\t\tn4++;\n\t\t}\n\t\tif(i%13==0){\n\t\t\tn5++;\n\t\t}\n\t\tif(i%17==0){\n\t\t\tn6++;\n\t\t}\n\t\tif(i%19==0){\n\t\t\tn7++;\n\t\t}\n\t\tif(i%23==0){\n\t\t\tn8++;\n\t\t}\n\t\tif(i%29==0){\n\t\t\tn9++;\n\t\t}\n\t\tif(i%31==0){\n\t\t\tn10++;\n\t\t}\n\t\tif(i%37==0){\n\t\t\tn11++;\n\t\t}\n\t\tif(i%41==0){\n\t\t\tn12++;\n\t\t}\n\t\tif(i%43==0){\n\t\t\tn13++;\n\t\t}\n\t\tif(i%47==0){\n\t\t\tn14++;\n\t\t}\n\t\tif(i%53==0){\n\t\t\tn15++;\n\t\t}\n\t\tif(i%59==0){\n\t\t\tn16++;\n\t\t}\n\t\tif(i%61==0){\n\t\t\tn17++;\n\t\t}\n\t\tif(i%67==0){\n\t\t\tn18++;\n\t\t}\n\t\tif(i%71==0){\n\t\t\tn19++;\n\t\t}\n\t\tif(i%73==0){\n\t\t\tn20++;\n\t\t}\n\t\tif(i%79==0){\n\t\t\tn21++;\n\t\t}\n\t\tif(i%83==0){\n\t\t\tn22++;\n\t\t}\n\t\tif(i%89==0){\n\t\t\tn23++;\n\t\t}\n\t\tif(i%97==0){\n\t\t\tn24++;\n\t\t}\n\t\tif(i%101==0){\n\t\t\tn25++;\n\t\t}\n\t\tif(i%103==0){\n\t\t\tn26++;\n\t\t}\n\t\tif(i%107==0){\n\t\t\tn27++;\n\t\t}\n\t\tif(i%109==0){\n\t\t\tn28++;\n\t\t}\n\t\tif(i%113==0){\n\t\t\tn29++;\n\t\t}\n\t\tif(i%121==0){\n\t\t\tn30++;\n\t\t}\n\t\tif(i%127==0){\n\t\t\tn31++;\n\t\t}\n\t\tif(i%131==0){\n\t\t\tn32++;\n\t\t}\n\t\tif(i%137==0){\n\t\t\tn33++;\n\t\t}\n\t\tif(i%139==0){\n\t\t\tn34++;\n\t\t}\n\t\tif(i%143==0){\n\t\t\tn35++;\n\t\t}\n\t\tif(i%149==0){\n\t\t\tn36++;\n\t\t}\n\t\tif(i%151==0){\n\t\t\tn37++;\n\t\t}\n\t\tif(i%157==0){\n\t\t\tn38++;\n\t\t}\n\t\tif(i%163==0){\n\t\t\tn39++;\n\t\t}\n\t\tif(i%167==0){\n\t\t\tn40++;\n\t\t}\n\t\tif(i%173==0){\n\t\t\tn41++;\n\t\t}\n\t\tif(i%179==0){\n\t\t\tn42++;\n\t\t}\n\t\tif(i%181==0){\n\t\t\tn43++;\n\t\t}\n\t\tif(i%187==0){\n\t\t\tn44++;\n\t\t}\n\t\tif(i%191==0){\n\t\t\tn45++;\n\t\t}\n\t\tif(i%193==0){\n\t\t\tn46++;\n\t\t}\n\t\tif(i%197==0){\n\t\t\tn47++;\n\t\t}\n\t\tif(i%199==0){\n\t\t\tn48++;\n\t\t}\n\t\tif(i%201==0){\n\t\t\tn49++;\n\t\t}\n\t\tif(i%207==0){\n\t\t\tn50++;\n\t\t}\n\t}\n\treturn n1+n2+n3+n4+n5+n6+n7+n8+n9+n10+n11+n12+n13+n14+n15+n16+n17+n18+n19+n20+n21+n22+n23+n24+n25+n26+n27+n28+n29+n30+n31+n32+n33+n34+n35+n36+n37+n38+n39+n40+n41+n42+n43+n44+n45+n46+n47+n48+n49+n50;\n}\nint main(){\n\tint n;\n\tprintf(\"Enter the number: \");\n\tscanf(\"%d\",&n);\n\tprintf(\"The number of 7s in %d is %d\\n\",", "passed": 0, "run_status": 1}
{"task_id": "CPP/37", "prompt": "/*\nThis funct iontakesa  vecto r l and r eturns a vector l' su ch that\nl' is i d entical to l in the  odd indicies, whileits valuesa t  the even indic ies are eq u al\nto the valuesof the even  i ndicies of l, but sort ed.\n>>> sort_even({1, 2, 3})\n{1, 2, 3}\n>>> sort_even({5, 6, 3, 4})\n{3, 6, 5, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_even(vector<float> l){\n", "canonical_solution": "    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_even({1, 2, 3}), {1, 2, 3}));\n    assert (issame(sort_even({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}));\n    assert (issame(sort_even({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_even({1, 2, 3}), {1, 2, 3}));\n    assert (issame(sort_even({5, 6,3,4}) , {3,6,5,4}));\n}\n", "entry_point": "sort_even", "seed": 1, "perturbed": true, "gc": "/*\nThis funct iontakesa  vecto r l and r eturns a vector l' su ch that\nl' is i d entical to l in the  odd indicies, whileits valuesa t  the even indic ies are eq u al\nto the valuesof the even  i ndicies of l, but sort ed.\n>>> sort_even({1, 2, 3})\n{1, 2, 3}\n>>> sort_even({5, 6, 3, 4})\n{3, 6, 5, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_even(vector<float> l){\n\tvector<float> r;\n\tfor(int i=0;i<l.size();i++){\n\t\tif(i%2==0){\n\t\t\tr.push_back(l[i]);\n\t\t}\n\t\telse{\n\t\t\tr.push_back(l[i]);\n\t\t}\n\t}\n\treturn r;\n}\nint main(){\n\tvector<float> l={1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\tvector<float> r=sort_even(l);\n\tfor(int i=0;i<r.size();i++){\n\t\tprintf(\"%f\\n\",r[i]);\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/38", "prompt": "#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\n\nstring decode_cyclic(string s){ \n    /*\n    takes asi nput  strin g  encod ed with e ncode_cyclic function . Returns decod e d string. \n    */\n", "canonical_solution": "    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x[2]+x.substr(0,2);\n        output=output+x;\n    }\n    return output;\n\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_cyclic(str);\n        assert (decode_cyclic(encoded_str) == str);\n    }\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encode_cyclic(string s){ \n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\n\nstring decode_cyclic(string s){ \n   int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n", "example_test": "", "entry_point": "decode_cyclic", "seed": 1, "perturbed": true, "gc": "#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\n\nstring decode_cyclic(string s){ \n    /*\n    takes asi nput  strin g  encod ed with e ncode_cyclic function. Returns decod e d string. \n    */\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\nint main(){\n    string s=\"abcdefghijklmnopqrstuvwxyz\";\n    string t=\"abcdefghijklmnopqrstuvwxyz\";\n    string u=\"abcdefghijklmnopqrstuvwxyz\";\n    string v=\"abcdefghijklmnopqrstuvwxyz\";\n    string w=\"abcdefghijklmnopqrstuvwxyz\";\n    string x=\"abcdefghijklmnopqrstuvwxyz\";\n    string y=\"abcdefghijklmnopqrstuvwxyz\";\n    string z=\"abcdefghijklmnopqrstuvwxyz\";\n    string a=\"abcdefghijklmnopqrstuvwxyz\";\n    string b=\"abcdefghijklmnopqrstuvwxyz\";\n    string c=\"abcdefghijklmnopqrstuvwxyz\";\n    string d=\"abcdefghijklmnopqrstuvwxyz\";\n    string e=\"abcdefghijklmnopqrstuvwxyz\";\n    string f=\"abcdefghijklmnopqrstuvwxyz\";\n    string g=\"abcdefghijklmnopqrstuvwxyz\";\n    string h=\"abcdefghijklmnopqrstuvwxyz\";\n    string i=\"abcdefghijklmnopqrstuvwxyz\";\n    string j=\"abcdefghijklmnopqrstuvwxyz\";\n    string k=\"abcdefghijklmnopqrstuvwxyz\";\n    string l=\"abcdefghijklmnopqrstuvwxyz\";\n    string m=\"abcdefghijklmnopqrstuvwxyz\";\n    string n=\"abcdefghijklmnopqrstuvwxyz\";\n    string o=\"abcdefghijklmnopqrstuvwxyz\";\n    string p=\"abcdefghijklmnopqrstuvwxyz\";\n    string q=\"abcdefghijklmnopqrstuvwxyz\";\n    string r=\"abcdefghijklmnopqrstuvwxyz\";\n    string s1=\"abcdefghijklmnopqrstuvwxyz\";\n    string s2=\"abcdefghijklmnopqrstuvwxyz\";\n    string s3=\"abcdefghijklmnopqrstuvwxyz\";\n    string s4=\"abcdefghijklmnopqrstuvwxyz\";\n    string s5=\"abcdefghijklmnopqrstuvwxyz\";\n    string s6=\"abcdefghijklmnopqrstuvwxyz\";\n    string s7=\"abcdefghijklmnopqrstuvwxyz\";\n    string s8=\"abcdefghijklmnopqrstuvwxyz\";\n    string s9=\"abcdefghijklmnopqrstuvwxyz\";\n    string s10=\"abcdefghijklmnopqrstuvwxyz\";\n    string s11=\"abcdefghijklmnopqrstuvwxyz\";\n    string s12=\"abcdefghijklmnopqrstuvwxyz\";\n    string s13=\"abcdefghijklmnopqrstuvwxyz\";\n    string s14=\"abcdefghijklmnopqrstuvwxyz\";\n    string s15=\"abcdefghijklmnopqrstuvwxyz\";\n    string s16=\"abcdefghijklmnopqrstuvwxyz\";\n    string s17=\"abcdefghijklmnopqrstuvwxyz\";\n    string s18=\"abcdefghijklmnopqrstuvwxyz\";\n    string s19=\"abcdefghijklmnopqrstuvwxyz\";\n    string s20=\"abcdefghijklmnopqrstuvwxyz\";\n    string s21=\"abcdefghijklmnopqrstuvwxyz\";\n    string s22=\"abcdefghijklmnopqrstuvwxyz\";\n    string s23=\"abcdefghijklmnopqrstuvwxyz\";\n    string s24=\"abcdefghijklmnopqrstuvwxyz\";\n    string s25=\"abcdefghijklmnopqrstuvwxyz\";\n    string s26=\"abcdefghijklmnopqrstuvwxyz\";\n    string s27=\"abcdefghijklmnopqrstuvwxyz\";\n    string s28=\"abcdefghijklmnopqrstuvwxyz\";\n    string s29=\"abcdefghijklmnopqrstuvwxyz\";\n    string s30=\"abcdefghijklmnopqrstuvwxyz\";\n    string s31=\"abcdefghijklmnopqrstuvwxyz\";\n    ", "passed": 0, "run_status": 1}
{"task_id": "CPP/39", "prompt": "/*\nprime_fibretu rns n- t h numb er that i s a Fibonacci numberand it's also p r ime.\n>>> prime_fib(1)\n2\n>>> prime_fib(2)\n3\n>>> prime_fib(3)\n5\n>>> prime_fib(4)\n13\n>>> prime_fib(5)\n89\n*/\n#include<stdio.h>\nusing namespace std;\nint prime_fib(int n){\n", "canonical_solution": "    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_fib(1) == 2);\n    assert (prime_fib(2) == 3);\n    assert (prime_fib(3) == 5);\n    assert (prime_fib(4) == 13);\n    assert (prime_fib(5) == 89);\n    assert (prime_fib(6) == 233);\n    assert (prime_fib(7) == 1597);\n    assert (prime_fib(8) == 28657);\n    assert (prime_fib(9) == 514229);\n    assert (prime_fib(10) == 433494437);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_fib(1) == 2);\n    assert (prime_fib(2) == 3);\n    assert (prime_fib(3) == 5);\n    assert (prime_fib(4) == 13);\n    assert (prime_fib(5) == 89);\n}\n", "entry_point": "prime_fib", "seed": 1, "perturbed": true, "gc": "/*\nprime_fibretu rns n- t h numb er that i s a Fibonacci numberand it's also p r ime.\n>>> prime_fib(1)\n2\n>>> prime_fib(2)\n3\n>>> prime_fib(3)\n5\n>>> prime_fib(4)\n13\n>>> prime_fib(5)\n89\n*/\n#include<stdio.h>\nusing namespace std;\nint prime_fib(int n){\n    int i,j,k,fib[n+1];\n    fib[0]=1;\n    fib[1]=2;\n    for(i=2;i<=n;i++){\n        fib[i]=fib[i-1]+fib[i-2];\n    }\n    for(i=2;i<=n;i++){\n        for(j=i+i;j<=n;j+=i){\n            k=fib[j]-fib[i-1];\n            if(k==0)\n                break;\n        }\n        if(k==0)\n            return i;\n    }\n    return -1;\n}\nint main(){\n    int n;\n    printf(\"Enter the number of fibonacci numbers you want to find: \");\n    scanf(\"%d\",&n);\n    printf(\"The %dth fibonacci number is %d\\n\",n,prime_fib(n));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/4", "prompt": "/*\nFor a give n ve ctor o f  input  numbers,  calculate Mean Absol ute Deviation\na r ound the mean of th is dataset.\nMean Abso lute Deviati o n is the averag e absolute difference between each\nelem en t and a centerpoint (m ean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n1.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat mean_absolute_deviation(vector<float> numbers){\n", "canonical_solution": "    float sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0}) - 2.0/3.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0, 5.0}) - 6.0/5.0) < 1e-4);\n}", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n}\n", "entry_point": "mean_absolute_deviation", "seed": 1, "perturbed": true, "gc": "/*\nFor a give n ve ctor o f  input  numbers,  calculate Mean Absol ute Deviation\na r ound the mean of th is dataset.\nMean Abso lute Deviati o n is the averag e absolute difference between each\nelem en t and a centerpoint (m ean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n1.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat mean_absolute_deviation(vector<float> numbers){\n\tfloat mean = 0;\n\tfloat sum = 0;\n\tfor(int i = 0; i < numbers.size(); i++){\n\t\tmean += numbers[i];\n\t}\n\tmean /= numbers.size();\n\tfor(int i = 0; i < numbers.size(); i++){\n\t\tsum += pow(numbers[i] - mean, 2);\n\t}\n\tsum /= numbers.size();\n\treturn sqrt(sum);\n}\n\nint main(){\n\tvector<float> numbers;\n\tfloat mean = 0;\n\tfloat sum = 0;\n\tfloat mad = 0;\n\tint n = 0;\n\tprintf(\"Enter the number of elements: \");\n\tscanf(\"%d\", &n);\n\tprintf(\"Enter the elements: \");\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%f\", &numbers[i]);\n\t}\n\tmean = mean_absolute_deviation(numbers);\n\tprintf(\"The mean of the dataset is: %f\\n\", mean);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/40", "prompt": "/*\ntriples_su m_to _zerot akes a  vector o f integers as an inpu t.\nit returns t r ue if there are thr ee distinct elementsin the vecto r  thatsum to ze ro, and fa l se otherwise.\n\n>>> triples_sum_to_zero({1, 3, 5, 0})\nfalse\n>>> triples_sum_to_zero({1, 3, -2, 1})\ntrue\n>>> triples_sum_to_zero({1, 2, 3, 7})\nfalse\n>>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\ntrue\n>>> triples_sum_to_zero({1})\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool triples_sum_to_zero(vector<int> l){\n", "canonical_solution": "    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -1}) == false);\n    assert (triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert (triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (triples_sum_to_zero({1, 2, 5, 7}) == false);\n    assert (triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert (triples_sum_to_zero({1}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -100}) == false);\n    assert (triples_sum_to_zero({100, 3, 5, -100}) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert (triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n}\n", "entry_point": "triples_sum_to_zero", "seed": 1, "perturbed": true, "gc": "/*\ntriples_su m_to _zerot akes a  vector o f integers as an inpu t.\nit returns t r ue if there are thr ee distinct elementsin the vecto r  thatsum to ze ro, and fa l se otherwise.\n\n>>> triples_sum_to_zero({1, 3, 5, 0})\nfalse\n>>> triples_sum_to_zero({1, 3, -2, 1})\ntrue\n>>> triples_sum_to_zero({1, 2, 3, 7})\nfalse\n>>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\ntrue\n>>> triples_sum_to_zero({1})\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool triples_sum_to_zero(vector<int> l){\n    int sum = 0;\n    for(int i = 0; i < l.size(); i++){\n        sum += l[i];\n    }\n    if(sum == 0){\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n\nint main(){\n    int t;\n    scanf(\"%d\", &t);\n    while(t--){\n        int n;\n        scanf(\"%d\", &n);\n        vector<int> l(n);\n        for(int i = 0; i < n; i++){\n            scanf(\"%d\", &l[i]);\n        }\n        if(triples_sum_to_zero(l)){\n            printf(\"true\\n\");\n        }\n        else{\n            printf(\"false\\n\");\n        }\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/41", "prompt": "/*\nImagine aroad  that' s  a per fectly st raight infinitely lon g line.\nn carsa re driving left toright;  simultaneousl y, a differe n t setof n cars \nare drivi n g right to left.  The two s et s of cars start out be ing very far from\neach other.  All cars movein the sa me sp eed.  Two cars are said to collide\nwhena car that's moving  left to right hits a car th at's moving right to lef t.\nHowever, th e cars are infini tely sturdy and strong; as a r esult, they continue moving\nin  th eir trajectory as if they did not co llide.\n\nThi s function output s the number of such collisions. \n*/\n#i nclude<stdio.h>\nusing namespace s td;\nint car_race_collision(intn){\n", "canonical_solution": "    return n*n;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (car_race_collision(2) == 4);\n    assert (car_race_collision(3) == 9);\n    assert (car_race_collision(4) == 16);\n    assert (car_race_collision(8) == 64);\n    assert (car_race_collision(10) == 100);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n", "example_test": "", "entry_point": "car_race_collision", "seed": 1, "perturbed": true, "gc": "/*\nImagine aroad  that' s  a per fectly st raight infinitely lon g line.\nn carsa re driving left toright;  simultaneousl y, a differe n t setof n cars \nare drivi n g right to left.  The two s et s of cars start out be ing very far from\neach other.  All cars movein the sa me sp eed.  Two cars are said to collide\nwhena car that's moving  left to right hits a car th at's moving right to lef t.\nHowever, th e cars are infini tely sturdy and strong; as a r esult, they continue moving\nin  th eir trajectory as if they did not co llide.\n\nThi s function output s the number of such collisions. \n*/\n#i nclude<stdio.h>\nusing namespace s td;\nint car_race_collision(intn){\n\tintn n = 0;\n\tintn i = 0;\n\tintn j = 0;\n\tintn k = 0;\n\tintn m = 0;\n\tintn n1 = 0;\n\tintn n2 = 0;\n\tintn n3 = 0;\n\tintn n4 = 0;\n\tintn n5 = 0;\n\tintn n6 = 0;\n\tintn n7 = 0;\n\tintn n8 = 0;\n\tintn n9 = 0;\n\tintn n10 = 0;\n\tintn n11 = 0;\n\tintn n12 = 0;\n\tintn n13 = 0;\n\tintn n14 = 0;\n\tintn n15 = 0;\n\tintn n16 = 0;\n\tintn n17 = 0;\n\tintn n18 = 0;\n\tintn n19 = 0;\n\tintn n20 = 0;\n\tintn n21 = 0;\n\tintn n22 = 0;\n\tintn n23 = 0;\n\tintn n24 = 0;\n\tintn n25 = 0;\n\tintn n26 = 0;\n\tintn n27 = 0;\n\tintn n28 = 0;\n\tintn n29 = 0;\n\tintn n30 = 0;\n\tintn n31 = 0;\n\tintn n32 = 0;\n\tintn n33 = 0;\n\tintn n34 = 0;\n\tintn n35 = 0;\n\tintn n36 = 0;\n\tintn n37 = 0;\n\tintn n38 = 0;\n\tintn n39 = 0;\n\tintn n40 = 0;\n\tintn n41 = 0;\n\tintn n42 = 0;\n\tintn n43 = 0;\n\tintn n44 = 0;\n\tintn n45 = 0;\n\tintn n46 = 0;\n\tintn n47 = 0;\n\tintn n48 = 0;\n\tintn n49 = 0;\n\tintn n50 = 0;\n\tintn n51 = 0;\n\tintn n52 = 0;\n\tintn n53 = 0;\n\tintn n54 = 0;\n\tintn n55 = 0;\n\tintn n56 = 0;\n\tintn n57 = 0;\n\tintn n58 = 0;\n\tintn n59 = 0;\n\tintn n60 = 0;\n\tintn n61 = 0;\n\tintn n62 = 0;\n\tintn n63 = 0;\n\tintn n64 = 0;\n\tintn n65 = 0;\n\tintn n66 = 0;\n\tintn n67 = 0;\n\tintn n68 = 0;\n\tintn n69 = 0;\n\tintn n70 = 0;\n\tintn n71 = 0;\n\tintn n72 = 0;\n\tintn n73 = 0;\n\tintn n74 = 0;\n\tintn n75 = 0;\n\tintn n76 = 0;\n\tintn n77 = 0;\n\tintn n78 = 0;\n\tintn n79 = 0;\n\tintn n80 = 0;\n\tintn n81 = 0;\n\tintn n82 = 0;\n\tintn n83 = 0;\n\tintn n84 = 0;\n\tintn n85 = 0;\n\tintn n86 = 0;\n\tintn n87 = 0;\n\tintn n88 = 0;\n\tintn n89 = 0;\n\tintn n90 = 0;\n\tintn n91 = 0;\n\tintn n92 = 0;\n\tintn n93 = 0;\n\tintn n94 = 0;\n\tintn n95 = 0;\n\tintn n96 = 0;\n\tintn n97 = 0;\n\tintn n98 = 0;\n\tintn n99 = 0;\n\tintn n100 = 0;\n\tintn n101 = 0;\n\tintn n102 = 0;\n\tintn n103 = 0;\n\tintn n104 = 0;\n\tintn n105 = 0;\n\tintn n106 = 0;\n\tintn n107 = 0;\n\tintn n108 = 0;\n\tintn n109 = 0;\n\tintn n110 = 0;\n\tintn n111 = 0;\n\tintn n112 = 0;\n\tintn n113 = 0;\n\tintn n114 = 0;\n\tintn n115 = 0;\n\tintn n116 = 0;\n\tintn n117 = 0;\n\tintn n118 = 0;\n\tintn n119 = 0;\n\tintn n120 = 0;\n\tintn n121 = 0;\n\tintn n122 = 0;\n\tintn n123 = 0;\n\tintn n124 = 0;\n\tintn n125 = 0;\n\tintn n126 = 0;\n\tintn n127 = 0;\n\tintn n128 = 0;\n\tintn n129 = 0;\n\tintn n130 = 0;\n\tintn n131 = 0;\n\tintn n132 = 0;\n\tintn n133 = 0;\n\tintn n134 = 0;\n\tintn n135 = 0;\n\tintn n136 = 0;\n\tintn n137 = 0;\n\tintn n138 = 0;\n\tintn n139 = 0;\n\tintn n140 = 0;\n\tintn n141 = 0;\n\tintn n142 = 0;\n\tintn n143 = 0;\n", "passed": 0, "run_status": 2}
{"task_id": "CPP/42", "prompt": "/*\nReturn vec torwith e l ements  incremen ted by 1.\n>>> incr_vector({1, 2, 3})\n{2, 3, 4}\n>>> incr_vector({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> incr_list(vector<int> l){\n", "canonical_solution": "    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(incr_list({}) , {}));\n    assert (issame(incr_list({3, 2, 1}) , {4, 3, 2}));\n    assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(incr_list({1, 2, 3}) , {2, 3, 4}));\n    assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n}\n", "entry_point": "incr_list", "seed": 1, "perturbed": true, "gc": "/*\nReturn vec torwith e l ements  incremen ted by 1.\n>>> incr_vector({1, 2, 3})\n{2, 3, 4}\n>>> incr_vector({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> incr_list(vector<int> l){\n    vector<int> r;\n    for(int i=0;i<l.size();i++){\n        r.push_back(l[i]+1);\n    }\n    return r;\n}\nvector<int> incr_vector(vector<int> l){\n    vector<int> r;\n    for(int i=0;i<l.size();i++){\n        r.push_back(l[i]+1);\n    }\n    return r;\n}\nint main(){\n    vector<int> l;\n    l.push_back(1);\n    l.push_back(2);\n    l.push_back(3);\n    l.push_back(4);\n    l.push_back(5);\n    l.push_back(6);\n    l.push_back(7);\n    l.push_back(8);\n    l.push_back(9);\n    l.push_back(10);\n    l.push_back(11);\n    l.push_back(12);\n    l.push_back(13);\n    l.push_back(14);\n    l.push_back(15);\n    l.push_back(16);\n    l.push_back(17);\n    l.push_back(18);\n    l.push_back(19);\n    l.push_back(20);\n    l.push_back(21);\n    l.push_back(22);\n    l.push_back(23);\n    l.push_back(24);\n    l.push_back(25);\n    l.push_back(26);\n    l.push_back(27);\n    l.push_back(28);\n    l.push_back(29);\n    l.push_back(30);\n    l.push_back(31);\n    l.push_back(32);\n    l.push_back(33);\n    l.push_back(34);\n    l.push_back(35);\n    l.push_back(36);\n    l.push_back(37);\n    l.push_back(38);\n    l.push_back(39);\n    l.push_back(40);\n    l.push_back(41);\n    l.push_back(42);\n    l.push_back(43);\n    l.push_back(44);\n    l.push_back(45);\n    l.push_back(46);\n    l.push_back(47);\n    l.push_back(48);\n    l.push_back(49);\n    l.push_back(50);\n    l.push_back(51);\n    l.push_back(52);\n    l.push_back(53);\n    l.push_back(54);\n    l.push_back(55);\n    l.push_back(56);\n    l.push_back(57);\n    l.push_back(58);\n    l.push_back(59);\n    l.push_back(60);\n    l.push_back(61);\n    l.push_back(62);\n    l.push_back(63);\n    l.push_back(64);\n    l.push_back(65);\n    l.push_back(66);\n    l.push_back(67);\n    l.push_back(68);\n    l.push_back(69);\n    l.push_back(70);\n    l.push_back(71);\n    l.push_back(72);\n    l.push_back(73);\n    l.push_back(74);\n    l.push_back(75);\n    l.push_back(76);\n    l.push_back(77);\n    l.push_back(78);\n    l.push_back(79);\n    l.push_back(80);\n    l.push_back(81);\n    l.push_back(82);\n    l.push_back(83);\n    l.push_back(84);\n    l.push_back(85);\n    l.push_back(86);\n    l.push_back(87);\n    l.push_back(88);\n    l.push_back(89);\n    l.push_back(90);\n    l.push_back(91);\n    l.push_back(92);\n    l.push_back(93);\n    l.push_back(94);\n    l.push_back(95);\n    l.push_back(96);\n    l.push_back(97);\n    l.push_back(98);\n    l.push_back(99);\n    l.push_back(100);\n    l.push_back(101);\n    l.push_back(102);\n    l.push_back(103);\n    l.push_back(104);\n    l.push_back(105);\n    l.push_back(106);\n    l.push_back(107);\n    l.push_back(108);\n    l.push_back(109);\n    l.push_back(110);\n    l.push_back(111);\n    l.push_back(112);\n    l.push_back(113);\n    l.push_back(114);\n    l.push_back(115);\n    l.push_back(116);\n    l.push_back(117);\n    l.push_back(118);\n    l.push_back(119);\n    l.push_back(120);\n    l.push_back(121);\n    l.push_back(122);\n    l.push_back(123);\n    l.push_back(124);\n    l.push_back(125);\n    l.push_back(126);\n    l.push_back(127);\n    l.push_back(128);\n    l.push_", "passed": 1, "run_status": 0}
{"task_id": "CPP/43", "prompt": "/*\npairs_sum_ to_z ero ta k es a v ector ofintegers as an input. \nit returns tru e  if there are two d istinct elements in t he vector th a t\nsumto zero,and falseo therwise.\n>>> pairs_sum_to_zero({1, 3, 5, 0})\nfalse\n>>> pairs_sum_to_zero({1, 3, -2, 1})\nfalse\n>>> pairs_sum_to_zero({1, 2, 3, 7})\nfalse\n>>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\ntrue\n>>> pairs_sum_to_zero({1})\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool pairs_sum_to_zero(vector<int> l){\n", "canonical_solution": "    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert (pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert (pairs_sum_to_zero({1}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 30}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 31}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 30}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 31}) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert (pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n}\n", "entry_point": "pairs_sum_to_zero", "seed": 1, "perturbed": true, "gc": "/*\npairs_sum_ to_z ero ta k es a v ector ofintegers as an input. \nit returns tru e  if there are two d istinct elements in t he vector th a t\nsumto zero,and falseo therwise.\n>>> pairs_sum_to_zero({1, 3, 5, 0})\nfalse\n>>> pairs_sum_to_zero({1, 3, -2, 1})\nfalse\n>>> pairs_sum_to_zero({1, 2, 3, 7})\nfalse\n>>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\ntrue\n>>> pairs_sum_to_zero({1})\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool pairs_sum_to_zero(vector<int> l){\n\tint sum = 0;\n\tfor(int i = 0; i < l.size(); i++){\n\t\tsum += l[i];\n\t}\n\tif(sum == 0){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nint main(){\n\tvector<int> l;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tl.push_back(x);\n\t}\n\tif(pairs_sum_to_zero(l)){\n\t\tprintf(\"true\");\n\t}\n\telse{\n\t\tprintf(\"false\");\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/44", "prompt": "/*\nChange num eric al bas e  of in put numbe r x to base.\nreturn s tring represent a tion after the conv ersion.\nbase numbersare less tha n  10.\n>>> change_base(8, 3)\n\"22\"\n>>> change_base(8, 2)\n\"1000\"\n>>> change_base(7, 2)\n\"111\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring change_base(int x,int base){\n", "canonical_solution": "    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (change_base(8, 3) == \"22\");\n    assert (change_base(9, 3) == \"100\");\n    assert (change_base(234, 2) == \"11101010\");\n    assert (change_base(16, 2) == \"10000\");\n    assert (change_base(8, 2) == \"1000\");\n    assert (change_base(7, 2) == \"111\");\n    for (int x=2;x<8;x++)\n        assert (change_base(x, x + 1) == to_string(x));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (change_base(8, 3) == \"22\");\n    assert (change_base(8, 2) == \"1000\");\n    assert (change_base(7, 2) == \"111\");\n}\n", "entry_point": "change_base", "seed": 1, "perturbed": true, "gc": "/*\nChange num eric al bas e  of in put numbe r x to base.\nreturn s tring represent a tion after the conv ersion.\nbase numbersare less tha n  10.\n>>> change_base(8, 3)\n\"22\"\n>>> change_base(8, 2)\n\"1000\"\n>>> change_base(7, 2)\n\"111\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring change_base(int x,int base){\n    string s;\n    while(x>0){\n        s=s+((char)(x%base+'0'));\n        x=x/base;\n    }\n    return s;\n}\nint main(){\n    int n,base;\n    while(cin>>n>>base){\n        cout<<change_base(n,base)<<endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/45", "prompt": "/*\nGiven leng th o f a si d e andhigh retu rn area for a triangl e.\n>>> triangle_area(5, 3)\n7.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat triangle_area(float a,float h){\n", "canonical_solution": "return (a*h)*0.5;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(5, 3) - 7.5)<1e-4);\n    assert (abs(triangle_area(2, 2) - 2.0)<1e-4);\n    assert (abs(triangle_area(10, 8) - 40.0)<1e-4);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(5, 3) - 7.5)<1e-4);\n}\n", "entry_point": "triangle_area", "seed": 1, "perturbed": true, "gc": "/*\nGiven leng th o f a si d e andhigh retu rn area for a triangl e.\n>>> triangle_area(5, 3)\n7.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat triangle_area(float a,float h){\n\tfloat s = a*h/2;\n\treturn sqrt(s*(s-a)*(s-h)*(s-a-h));\n}\nint main(){\n\tfloat a,h;\n\tprintf(\"Enter the length of the side of the triangle : \");\n\tscanf(\"%f\",&a);\n\tprintf(\"Enter the height of the triangle : \");\n\tscanf(\"%f\",&h);\n\tprintf(\"The area of the triangle is %f\\n\",triangle_area(a,h));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/46", "prompt": "/*\nThe Fib4n umbe r sequ e nce is  a sequen ce similar to the Fib bonacci sequnec e  that's defined asfollows:fib4(0) -> 0 \nfib4(1) ->0 \nfib4(2) -> 2\nf ib4(3) ->0 \nfib4(n) -> fib4(n-1) + fib4 (n -2) + fib4(n-3) + fib4 (n-4).\nPlease write a function toefficiently computethe n -th element of the fib4 number sequence.  Do not use recurs ion.\n>>> fib4(5)\n4\n>>> fib4(6)\n8\n>>> fib4(7)\n14\n*/\n#include<stdio.h>\nusing namespace std;\nint fib4(int n){\n", "canonical_solution": "    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib4(5) == 4);\n    assert (fib4(8) == 28);\n    assert (fib4(10) == 104);\n    assert (fib4(12) == 386);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib4(5) == 4);\n    assert (fib4(6) == 8);\n    assert (fib4(7) == 14);\n}\n", "entry_point": "fib4", "seed": 1, "perturbed": true, "gc": "/*\nThe Fib4n umbe r sequ e nce is  a sequen ce similar to the Fib bonacci sequnec e  that's defined asfollows:fib4(0) -> 0 \nfib4(1) ->0 \nfib4(2) -> 2\nf ib4(3) ->0 \nfib4(n) -> fib4(n-1) + fib4 (n -2) + fib4(n-3) + fib4 (n-4).\nPlease write a function toefficiently computethe n -th element of the fib4 number sequence.  Do not use recurs ion.\n>>> fib4(5)\n4\n>>> fib4(6)\n8\n>>> fib4(7)\n14\n*/\n#include<stdio.h>\nusing namespace std;\nint fib4(int n){\n\tif(n==0)\n\t\treturn 0;\n\tif(n==1)\n\t\treturn 1;\n\tif(n==2)\n\t\treturn 2;\n\tint a=fib4(n-1);\n\tint b=fib4(n-2);\n\tint c=fib4(n-3);\n\tint d=fib4(n-4);\n\treturn a+b+c+d;\n}\nint main(){\n\tint n;\n\tprintf(\"Enter the number of element to be computed\\n\");\n\tscanf(\"%d\",&n);\n\tprintf(\"The fibonacci number for %d is %d\\n\",n,fib4(n));\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/47", "prompt": "/*\nReturn med ianof ele m ents i n the vec tor l.\n>>> median({3, 1, 2, 4, 5})\n3\n>>> median({-10, 4, 6, 1000, 10, 20})\n15.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nfloat median(vector<float> l){\n", "canonical_solution": "    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(median({3, 1, 2, 4, 5}) - 3)<1e-4);\n    assert (abs(median({-10, 4, 6, 1000, 10, 20}) -8.0)<1e-4);\n    assert (abs(median({5}) - 5)<1e-4);\n    assert (abs(median({6, 5}) - 5.5)<1e-4);\n    assert (abs(median({8, 1, 3, 9, 9, 2, 7}) - 7)<1e-4 );\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(median({3, 1, 2, 4, 5}) - 3)<1e-4);\n    assert (abs(median({-10, 4, 6, 1000, 10, 20}) -8.0)<1e-4);\n}\n", "entry_point": "median", "seed": 1, "perturbed": true, "gc": "/*\nReturn med ianof ele m ents i n the vec tor l.\n>>> median({3, 1, 2, 4, 5})\n3\n>>> median({-10, 4, 6, 1000, 10, 20})\n15.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nfloat median(vector<float> l){\n    int n = l.size();\n    float m = 0;\n    float m1 = 0;\n    float m2 = 0;\n    for(int i = 0; i < n; i++){\n        m1 = m;\n        m = m + l[i];\n        if(i == n/2){\n            m2 = m;\n        }\n    }\n    return (m1 + m2)/2;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<float> l;\n    for(int i = 0; i < n; i++){\n        float x;\n        scanf(\"%f\", &x);\n        l.push_back(x);\n    }\n    printf(\"%.2f\\n\", median(l));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/48", "prompt": "/*\nChecks ifgive n stri n g is a  palindro me\n>>> is_palindrome(\"\")\ntrue\n>>> is_palindrome(\"aba\")\ntrue\n>>> is_palindrome(\"aaaaa\")\ntrue\n>>> is_palindrome(\"zbcd\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string text){\n", "canonical_solution": "    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_palindrome(\"\") == true);\n    assert (is_palindrome(\"aba\") == true);\n    assert (is_palindrome(\"aaaaa\") == true);\n    assert (is_palindrome(\"zbcd\") == false);\n    assert (is_palindrome(\"xywyx\") == true);\n    assert (is_palindrome(\"xywyz\") == false);\n    assert (is_palindrome(\"xywzx\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_palindrome(\"\") == true);\n    assert (is_palindrome(\"aba\") == true);\n    assert (is_palindrome(\"aaaaa\") == true);\n    assert (is_palindrome(\"zbcd\") == false);\n}\n", "entry_point": "is_palindrome", "seed": 1, "perturbed": true, "gc": "/*\nChecks ifgive n stri n g is a  palindro me\n>>> is_palindrome(\"\")\ntrue\n>>> is_palindrome(\"aba\")\ntrue\n>>> is_palindrome(\"aaaaa\")\ntrue\n>>> is_palindrome(\"zbcd\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string text){\n\tint i=0,j=text.length()-1;\n\twhile(i<j){\n\t\tif(text[i]!=text[j])\n\t\t\treturn false;\n\t\ti++;\n\t\tj--;\n\t}\n\treturn true;\n}\nint main(){\n\tstring text;\n\tgetline(cin,text);\n\tcout<<is_palindrome(text)<<endl;\n\treturn 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/49", "prompt": "/*\nReturn 2^n  mod ulo p( be awa re of num erics).\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n*/\n#include<stdio.h>\nusing namespace std;\nint modp(int n,int p){\n", "canonical_solution": "    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (modp(3, 5) == 3);\n    assert (modp(1101, 101) == 2);\n    assert (modp(0, 101) == 1);\n    assert (modp(3, 11) == 8);\n    assert (modp(100, 101) == 1);\n    assert (modp(30, 5) == 4);\n    assert (modp(31, 5) == 3);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (modp(3, 5) == 3);\n    assert (modp(1101, 101) == 2);\n    assert (modp(0, 101) == 1);\n    assert (modp(3, 11) == 8);\n    assert (modp(100, 101) == 1);\n}\n", "entry_point": "modp", "seed": 1, "perturbed": true, "gc": "/*\nReturn 2^n  mod ulo p( be awa re of num erics).\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n*/\n#include<stdio.h>\nusing namespace std;\nint modp(int n,int p){\n    int i=1,j=0;\n    while(n>0){\n        i*=2;\n        if(n%2==1)\n            i+=p;\n        n/=2;\n    }\n    return i;\n}\nint main(){\n    int n,p;\n    while(scanf(\"%d %d\",&n,&p)!=EOF){\n        printf(\"%d\\n\",modp(n,p));\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/5", "prompt": "/*\nInsert an umbe r \"del i meter\"  betweenevery two consecutive  elements of in p ut vector `numbers\" \n>>> intersperse({}, 4)\n{}\n>>> intersperse({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n", "canonical_solution": "    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(intersperse({}, 7), {}));\n    \n    assert (issame(intersperse({5, 6, 3, 2}, 8),{5, 8, 6, 8, 3, 8, 2}));\n    assert (issame(intersperse({2, 2, 2}, 2),{2, 2, 2, 2, 2}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(intersperse({}, 4), {}));\n    assert (issame(intersperse({1, 2, 3}, 4),{1, 4, 2, 4, 3}));\n}\n", "entry_point": "intersperse", "seed": 1, "perturbed": true, "gc": "/*\nInsert an umbe r \"del i meter\"  betweenevery two consecutive  elements of in p ut vector `numbers\" \n>>> intersperse({}, 4)\n{}\n>>> intersperse({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> result;\n    int i = 0;\n    int j = 0;\n    while(i < numbers.size()){\n        if(j == 0){\n            result.push_back(numbers[i]);\n            j++;\n        }\n        else{\n            result.push_back(numbers[i]);\n            result.push_back(delimeter);\n            j = 0;\n        }\n        i++;\n    }\n    return result;\n}\nint main(){\n    vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    vector<int> result = intersperse(numbers, 4);\n    for(int i = 0; i < result.size(); i++){\n        printf(\"%d \", result[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/50", "prompt": "#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encode_shift(string s){\n    // returns en code d stri n g by s hifting e very character by 5 i n the alphabet.     string out;\n   int i;\n   for (i=0; i<s.length() ; i++)\n   {\n       int w= ( (int)s[i]+5-(int)'a')%26+(in t) 'a';   \n        out=ou t+(char)w;\n    }    return out;\n} string decode_shift (stri ng s){\n    // take s  as input string encoded with encode_shi ft function. Returns decoded  string.\n", "canonical_solution": "    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+21-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_shift(str);\n        assert (decode_shift(encoded_str) == str);\n    }\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encode_shift(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nstring decode_shift(string s){\n", "example_test": "", "entry_point": "encode_shift", "seed": 1, "perturbed": true, "gc": "#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encode_shift(string s){\n    // returns en code d stri n g by s hifting e very character by 5 i n the alphabet.     string out;\n   int i;\n   for (i=0; i<s.length() ; i++)\n   {\n       int w= ( (int)s[i]+5-(int)'a')%26+(in t) 'a';   \n        out=ou t+(char)w;\n    }    return out;\n} string decode_shift (stri ng s){\n    // take s  as input string encoded with encode_shi ft function. Returns decoded  string.\n    int i;\n    string out;\n    for (i=0; i<s.length() ; i++)\n    {\n        int w= ( (int)s[i]-5+(int)'a')%26;\n        out=ou t+(char)w;\n    }    return out;\n}\nint main()\n{\n    string s;\n    string out;\n    int t;\n    cin>>t;\n    while(t--){\n        cin>>s;\n        out=encode_shift(s);\n        cout<<decode_shift(out)<<endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/51", "prompt": "/*\nremove_vow elsis a f u nction  that tak es string and returns  string without vowels.\n>>> remove_vowels(\"\")\n\"\"\n>>> remove_vowels(\"abcdef\\nghijklm\")\n\"bcdf\\nghjklm\"\n>>> remove_vowels(\"abcdef\")\n\"bcdf\"\n>>> remove_vowels(\"aaaaa\")\n\"\"\n>>> remove_vowels(\"aaBAA\")\n\"B\"\n>>> remove_vowels(\"zbcd\")\n\"zbcd\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring remove_vowels(string text){\n", "canonical_solution": "    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (remove_vowels(\"\") == \"\");\n    assert (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n    assert (remove_vowels(\"fedcba\") == \"fdcb\");\n    assert (remove_vowels(\"eeeee\") == \"\");\n    assert (remove_vowels(\"acBAA\") == \"cB\");\n    assert (remove_vowels(\"EcBOO\") == \"cB\");\n    assert (remove_vowels(\"ybcd\") == \"ybcd\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (remove_vowels(\"\") == \"\");\n    assert (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n    assert (remove_vowels(\"abcdef\") == \"bcdf\");\n    assert (remove_vowels(\"aaaaa\") == \"\");\n    assert (remove_vowels(\"aaBAA\") == \"B\");\n    assert (remove_vowels(\"zbcd\") == \"zbcd\");\n}\n", "entry_point": "remove_vowels", "seed": 1, "perturbed": true, "gc": "/*\nremove_vow elsis a f u nction  that tak es string and returns  string without vowels.\n>>> remove_vowels(\"\")\n\"\"\n>>> remove_vowels(\"abcdef\\nghijklm\")\n\"bcdf\\nghjklm\"\n>>> remove_vowels(\"abcdef\")\n\"bcdf\"\n>>> remove_vowels(\"aaaaa\")\n\"\"\n>>> remove_vowels(\"aaBAA\")\n\"B\"\n>>> remove_vowels(\"zbcd\")\n\"zbcd\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring remove_vowels(string text){\n    string vowels = \"aeiouAEIOU\";\n    for(int i=0;i<text.length();i++){\n        if(vowels.find(text[i])!=string::npos){\n            text.erase(i,1);\n            i--;\n        }\n    }\n    return text;\n}\nint main(){\n    string text;\n    cin>>text;\n    cout<<remove_vowels(text)<<endl;\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/52", "prompt": "/*\nReturn tru e if  all n u mbersin the ve ctor l are below thre shold t.\n>>> below_threshold({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold({1, 20, 4, 10}, 5)\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_threshold(vector<int>l, int t){\n", "canonical_solution": "    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_threshold({1, 2, 4, 10}, 100));\n    assert (not(below_threshold({1, 20, 4, 10}, 5)));\n    assert (below_threshold({1, 20, 4, 10}, 21));\n    assert (below_threshold({1, 20, 4, 10}, 22));\n    assert (below_threshold({1, 8, 4, 10}, 11));\n    assert (not(below_threshold({1, 8, 4, 10}, 10)));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_threshold({1, 2, 4, 10}, 100));\n    assert (not(below_threshold({1, 20, 4, 10}, 5)));\n}\n", "entry_point": "below_threshold", "seed": 1, "perturbed": true, "gc": "/*\nReturn tru e if  all n u mbersin the ve ctor l are below thre shold t.\n>>> below_threshold({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold({1, 20, 4, 10}, 5)\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_threshold(vector<int>l, int t){\n    int i;\n    for(i=0;i<l.size();i++){\n        if(l[i]>t)\n            return false;\n    }\n    return true;\n}\nint main(){\n    int n, t;\n    scanf(\"%d\", &n);\n    vector<int>l;\n    for(int i=0;i<n;i++){\n        int a;\n        scanf(\"%d\", &a);\n        l.push_back(a);\n    }\n    scanf(\"%d\", &t);\n    if(below_threshold(l, t))\n        printf(\"true\\n\");\n    else\n        printf(\"false\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/53", "prompt": "/*\nAdd two nu mber s x an d  y\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12\n*/\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\nint add(int x,int y){\n", "canonical_solution": "    return x+y;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add(0, 1) == 1);\n    assert (add(1, 0) == 1);\n    assert (add(2, 3) == 5);\n    assert (add(5, 7) == 12);\n    assert (add(7, 5) == 12);\n    for (int i=0;i<100;i+=1)\n    {\n        int x=rand()%1000;\n        int y=rand()%1000;\n        assert (add(x, y) == x + y);\n    }\n}\n", "declaration": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add(2, 3) == 5);\n    assert (add(5, 7) == 12);\n}\n", "entry_point": "add", "seed": 1, "perturbed": true, "gc": "/*\nAdd two nu mber s x an d  y\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12\n*/\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n    int x,y;\n    printf(\"Enter two number:\");\n    scanf(\"%d%d\",&x,&y);\n    printf(\"%d\",add(x,y));\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/54", "prompt": "/*\nCheck ift wo w ords h a ve the  same cha racters.\n>>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\ntrue\n>>> same_chars(\"abcd\", \"dddddddabc\")\ntrue\n>>> same_chars(\"dddddddabc\", \"abcd\")\ntrue\n>>> same_chars(\"eabcd\", \"dddddddabc\")\nfalse\n>>> same_chars(\"abcd\", \"dddddddabce\")\nfalse\n>>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nbool same_chars(string s0,string s1){\n", "canonical_solution": "    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert (same_chars(\"abcd\", \"dddddddabc\") == true);\n    assert (same_chars(\"dddddddabc\", \"abcd\") == true);\n    assert (same_chars(\"eabcd\", \"dddddddabc\") == false);\n    assert (same_chars(\"abcd\", \"dddddddabcf\") == false);\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert (same_chars(\"aabb\", \"aaccc\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert (same_chars(\"abcd\", \"dddddddabc\") == true);\n    assert (same_chars(\"dddddddabc\", \"abcd\") == true);\n    assert (same_chars(\"eabcd\", \"dddddddabc\") == false);\n    assert (same_chars(\"abcd\", \"dddddddabcf\") == false);\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n}\n", "entry_point": "same_chars", "seed": 1, "perturbed": true, "gc": "/*\nCheck ift wo w ords h a ve the  same cha racters.\n>>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\ntrue\n>>> same_chars(\"abcd\", \"dddddddabc\")\ntrue\n>>> same_chars(\"dddddddabc\", \"abcd\")\ntrue\n>>> same_chars(\"eabcd\", \"dddddddabc\")\nfalse\n>>> same_chars(\"abcd\", \"dddddddabce\")\nfalse\n>>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nbool same_chars(string s0,string s1){\n    int i=0;\n    int j=0;\n    while(i<s0.size()&&j<s1.size()){\n        if(s0[i]==s1[j]){\n            i++;\n            j++;\n        }\n        else{\n            if(i==s0.size()-1){\n                return false;\n            }\n            else{\n                i++;\n            }\n        }\n    }\n    return true;\n}\nint main(){\n    string s0,s1;\n    while(cin>>s0>>s1){\n        if(same_chars(s0,s1)){\n            cout<<\"true\"<<endl;\n        }\n        else{\n            cout<<\"false\"<<endl;\n        }\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/55", "prompt": "/*\nReturn n-t h Fi bonacc i  numbe r.\n>>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21\n*/\n#include<stdio.h>\nusing namespace std;\nint fib(int n){\n", "canonical_solution": "    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib(10) == 55);\n    assert (fib(1) == 1);\n    assert (fib(8) == 21);\n    assert (fib(11) == 89);\n    assert (fib(12) == 144);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib(10) == 55);\n    assert (fib(1) == 1);\n    assert (fib(8) == 21);\n}\n", "entry_point": "fib", "seed": 1, "perturbed": true, "gc": "/*\nReturn n-t h Fi bonacc i  numbe r.\n>>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21\n*/\n#include<stdio.h>\nusing namespace std;\nint fib(int n){\n    if(n==1)\n        return 1;\n    if(n==2)\n        return 1;\n    return fib(n-1)+fib(n-2);\n}\nint main(){\n    int n;\n    printf(\"Enter n: \");\n    scanf(\"%d\",&n);\n    printf(\"fib(%d) = %d\\n\",n,fib(n));\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/56", "prompt": "/*\nbracketsi s astring of '<'  and '>'. \nreturn true if every  opening bracke t  has a correspondin g closing bracket.\n\n>>> correct_bracketing(\"<\")\nfalse\n>>> correct_bracketing(\"<>\")\ntrue\n>>> correct_bracketing(\"<<><>>\")\ntrue\n>>> correct_bracketing(\"><<>\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n", "canonical_solution": "    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"<>\"));\n    assert (correct_bracketing(\"<<><>>\"));\n    assert (correct_bracketing(\"<><><<><>><>\"));\n    assert (correct_bracketing(\"<><><<<><><>><>><<><><<>>>\"));\n    assert (not (correct_bracketing(\"<<<><>>>>\")));\n    assert (not (correct_bracketing(\"><<>\")));\n    assert (not (correct_bracketing(\"<\")));\n    assert (not (correct_bracketing(\"<<<<\")));\n    assert (not (correct_bracketing(\">\")));\n    assert (not (correct_bracketing(\"<<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>><<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>>><>\")));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"<>\"));\n    assert (correct_bracketing(\"<<><>>\"));\n    assert (not (correct_bracketing(\"><<>\")));\n    assert (not (correct_bracketing(\"<\")));\n}\n", "entry_point": "correct_bracketing", "seed": 1, "perturbed": true, "gc": "/*\nbracketsi s astring of '<'  and '>'. \nreturn true if every  opening bracke t  has a correspondin g closing bracket.\n\n>>> correct_bracketing(\"<\")\nfalse\n>>> correct_bracketing(\"<>\")\ntrue\n>>> correct_bracketing(\"<<><>>\")\ntrue\n>>> correct_bracketing(\"><<>\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n    int i = 0;\n    int j = 0;\n    while(i < brackets.size()){\n        if(brackets[i] == '<'){\n            j = i;\n            while(j < brackets.size() && brackets[j]!= '>'){\n                j++;\n            }\n            if(j == brackets.size()){\n                return false;\n            }\n            else{\n                i = j + 1;\n            }\n        }\n        i++;\n    }\n    return true;\n}\nint main(){\n    string brackets = \"<>\";\n    if(correct_bracketing(brackets)){\n        printf(\"true\");\n    }\n    else{\n        printf(\"false\");\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/57", "prompt": "/*\nReturn tru e is  vecto r  eleme nts are m onotonically increasi ng or decreasin g .\n>>> monotonic({1, 2, 4, 20})\ntrue\n>>> monotonic({1, 20, 4, 10})\nfalse\n>>> monotonic({4, 1, 0, -10})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool monotonic(vector<float> l){\n", "canonical_solution": "    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (monotonic({1, 2, 4, 10}) == true);\n    assert (monotonic({1, 2, 4, 20}) == true);\n    assert (monotonic({1, 20, 4, 10}) == false);\n    assert (monotonic({4, 1, 0, -10}) == true);\n    assert (monotonic({4, 1, 1, 0}) == true);\n    assert (monotonic({1, 2, 3, 2, 5, 60}) == false);\n    assert (monotonic({1, 2, 3, 4, 5, 60}) == true);\n    assert (monotonic({9, 9, 9, 9}) == true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (monotonic({1, 2, 4, 10}) == true);\n    assert (monotonic({1, 20, 4, 10}) == false);\n    assert (monotonic({4, 1, 0, -10}) == true);\n}\n", "entry_point": "monotonic", "seed": 1, "perturbed": true, "gc": "/*\nReturn tru e is  vecto r  eleme nts are m onotonically increasi ng or decreasin g.\n>>> monotonic({1, 2, 4, 20})\ntrue\n>>> monotonic({1, 20, 4, 10})\nfalse\n>>> monotonic({4, 1, 0, -10})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool monotonic(vector<float> l){\n    int i = 0;\n    while(i<l.size()-1){\n        if(l[i]>l[i+1])\n            return false;\n        i++;\n    }\n    return true;\n}\nint main(){\n    vector<float> l;\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        float x;\n        scanf(\"%f\",&x);\n        l.push_back(x);\n    }\n    printf(\"%d\",monotonic(l));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/58", "prompt": "/*\nReturn sor tedunique common  elements  for two vectors.\n>>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n{1, 5, 653}\n>>> common({5, 3, 2, 8}, {3, 2})\n{2, 3}\n\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> common(vector<int> l1,vector<int> l2){\n", "canonical_solution": "    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}) , {1, 5, 653}));\n    assert (issame(common({5, 3, 2, 8}, {3, 2}) , {2, 3}));\n    assert (issame(common({4, 3, 2, 8}, {3, 2, 4}) , {2, 3, 4}));\n    assert (issame(common({4, 3, 2, 8}, {}) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}) , {1, 5, 653}));\n    assert (issame(common({5, 3, 2, 8}, {3, 2}) , {2, 3}));\n}\n", "entry_point": "common", "seed": 1, "perturbed": true, "gc": "/*\nReturn sor tedunique common  elements  for two vectors.\n>>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n{1, 5, 653}\n>>> common({5, 3, 2, 8}, {3, 2})\n{2, 3}\n\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> r;\n    sort(l1.begin(),l1.end());\n    sort(l2.begin(),l2.end());\n    int i=0,j=0;\n    while(i<l1.size() && j<l2.size()){\n        if(l1[i]==l2[j]){\n            r.push_back(l1[i]);\n            i++;\n            j++;\n        }\n        else if(l1[i]<l2[j]){\n            i++;\n        }\n        else{\n            j++;\n        }\n    }\n    return r;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> v1(n),v2(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&v1[i]);\n    }\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&v2[i]);\n    }\n    vector<int> r=common(v1,v2);\n    for(int i=0;i<r.size();i++){\n        printf(\"%d \",r[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/59", "prompt": "/*\nReturn the  lar gest p r ime fa ctor of n . Assume n > 1 and is  not a prime.\n>>> largest_prime_factor(13195)\n29\n>>> largest_prime_factor(2048)\n2\n*/\n#include<stdio.h>\nusing namespace std;\nint largest_prime_factor(int n){\n", "canonical_solution": "    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_prime_factor(15) == 5);\n    assert (largest_prime_factor(27) == 3);\n    assert (largest_prime_factor(63) == 7);\n    assert (largest_prime_factor(330) == 11);\n    assert (largest_prime_factor(13195) == 29);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_prime_factor(2048) == 2);\n    assert (largest_prime_factor(13195) == 29);\n}\n", "entry_point": "largest_prime_factor", "seed": 1, "perturbed": true, "gc": "/*\nReturn the  lar gest p r ime fa ctor of n. Assume n > 1 and is  not a prime.\n>>> largest_prime_factor(13195)\n29\n>>> largest_prime_factor(2048)\n2\n*/\n#include<stdio.h>\nusing namespace std;\nint largest_prime_factor(int n){\n    int i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i", "passed": 0, "run_status": 2}
{"task_id": "CPP/6", "prompt": "/*\nInput tot hisfuncti o n is a  string r epresented multiple g roups for neste d  parentheses separa ted by spaces.\nFor ea ch of the gr o up, output thedeepest le v el of nesting ofparentheses .E.g. (()()) has maximu m two levels of nesting while ((() )) has three.\n\n>>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n{2, 3, 1, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_nested_parens(string paren_string){\n", "canonical_solution": "    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_nested_parens(\"(()()) ((())) () ((())()())\"),{2, 3, 1, 3}));\n     assert (issame(parse_nested_parens(\"() (()) ((())) (((())))\") , {1, 2, 3, 4}));\n    assert (issame(parse_nested_parens(\"(()(())((())))\") ,{4}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_nested_parens(\"(()()) ((())) () ((())()())\"),{2, 3, 1, 3}));\n}\n", "entry_point": "parse_nested_parens", "seed": 1, "perturbed": true, "gc": "/*\nInput tot hisfuncti o n is a  string r epresented multiple g roups for neste d  parentheses separa ted by spaces.\nFor ea ch of the gr o up, output thedeepest le v el of nesting ofparentheses.E.g. (()()) has maximu m two levels of nesting while ((() )) has three.\n\n>>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n{2, 3, 1, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_nested_parens(string paren_string){\n\tvector<int> result;\n\tint level = 0;\n\tint i = 0;\n\tint j = 0;\n\twhile(i < paren_string.size()){\n\t\tif(paren_string[i] == '('){\n\t\t\tlevel++;\n\t\t}\n\t\telse if(paren_string[i] == ')'){\n\t\t\tlevel--;\n\t\t}\n\t\tif(level == 0){\n\t\t\tresult.push_back(j);\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n\treturn result;\n}\nint main(){\n\tstring paren_string = \"((())) ((())) () ((())())\";\n\tvector<int> result = parse_nested_parens(paren_string);\n\tfor(int i = 0; i < result.size(); i++){\n\t\tprintf(\"%d \", result[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/60", "prompt": "/*\nsum_to_ni s afuncti o n that  sums num bers from 1 to n.\n>>> sum_to_n(30)\n465\n>>> sum_to_n(100)\n5050\n>>> sum_to_n(5)\n15\n>>> sum_to_n(10)\n55\n>>> sum_to_n(1)\n1\n*/\n#include<stdio.h>\nusing namespace std;\nint sum_to_n(int n){\n", "canonical_solution": "    return n*(n+1)/2;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_to_n(1) == 1);\n    assert (sum_to_n(6) == 21);\n    assert (sum_to_n(11) == 66);\n    assert (sum_to_n(30) == 465);\n    assert (sum_to_n(100) == 5050);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_to_n(1) == 1);\n    assert (sum_to_n(5) == 15);\n    assert (sum_to_n(10) == 55);\n    assert (sum_to_n(30) == 465);\n    assert (sum_to_n(100) == 5050);\n}\n", "entry_point": "sum_to_n", "seed": 1, "perturbed": true, "gc": "/*\nsum_to_ni s afuncti o n that  sums num bers from 1 to n.\n>>> sum_to_n(30)\n465\n>>> sum_to_n(100)\n5050\n>>> sum_to_n(5)\n15\n>>> sum_to_n(10)\n55\n>>> sum_to_n(1)\n1\n*/\n#include<stdio.h>\nusing namespace std;\nint sum_to_n(int n){\n    int sum=0;\n    for(int i=1;i<=n;i++){\n        sum+=i;\n    }\n    return sum;\n}\nint main(){\n    int n;\n    printf(\"Enter the number: \");\n    scanf(\"%d\",&n);\n    printf(\"Sum of %d to %d is %d\\n\",1,n,sum_to_n(n));\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/61", "prompt": "/*\nbracketsi s astring of '('  and ')'. \nreturn true if every  opening bracke t  has a correspondin g closing bracket.\n\n>>> correct_bracketing(\"(\")\nfalse\n>>> correct_bracketing(\"()\")\ntrue\n>>> correct_bracketing(\"(()())\")\ntrue\n>>> correct_bracketing(\")(()\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n", "canonical_solution": "    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"()\"));\n    assert (correct_bracketing(\"(()())\"));\n    assert (correct_bracketing(\"()()(()())()\"));\n    assert (correct_bracketing(\"()()((()()())())(()()(()))\"));\n    assert (not (correct_bracketing(\"((()())))\")));\n    assert (not (correct_bracketing(\")(()\")));\n    assert (not (correct_bracketing(\"(\")));\n    assert (not (correct_bracketing(\"((((\")));\n    assert (not (correct_bracketing(\")\")));\n    assert (not (correct_bracketing(\"(()\")));\n    assert (not (correct_bracketing(\"()()(()())())(()\")));\n    assert (not (correct_bracketing(\"()()(()())()))()\")));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"()\"));\n    assert (correct_bracketing(\"(()())\"));\n    assert (not (correct_bracketing(\")(()\")));\n    assert (not (correct_bracketing(\"(\")));\n}\n", "entry_point": "correct_bracketing", "seed": 1, "perturbed": true, "gc": "/*\nbracketsi s astring of '('  and ')'. \nreturn true if every  opening bracke t  has a correspondin g closing bracket.\n\n>>> correct_bracketing(\"(\")\nfalse\n>>> correct_bracketing(\"()\")\ntrue\n>>> correct_bracketing(\"(()())\")\ntrue\n>>> correct_bracketing(\")(()\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n    int i=0;\n    int j=0;\n    while(i<brackets.size()){\n        if(brackets[i]=='('){\n            j=i;\n            while(j<brackets.size() && brackets[j]!=')'){\n                j++;\n            }\n            if(j==brackets.size()){\n                return false;\n            }\n            i=j+1;\n        }\n        i++;\n    }\n    return true;\n}\n\nint main(){\n    string brackets;\n    while(cin>>brackets){\n        if(correct_bracketing(brackets)){\n            cout<<\"true\"<<endl;\n        }\n        else{\n            cout<<\"false\"<<endl;\n        }\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/62", "prompt": "/*\nxs represe nt c oeffic i ents o f a polyn omial.\nxs{0} + xs{1}* x + xs{2} * x ^ 2 + ....\n Return de rivativeof this poly nomial in th e  sameform.\n>>> derivative({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative({1, 2, 3})\n{2, 6}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> derivative(vector<float> xs){\n", "canonical_solution": "    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(derivative({3, 1, 2, 4, 5}) , {1, 4, 12, 20}));\n    assert (issame(derivative({1, 2, 3}) , {2, 6}));\n    assert (issame(derivative({3, 2, 1}) , {2, 2}));\n    assert (issame(derivative({3, 2, 1, 0, 4}) , {2, 2, 0, 16}));\n    assert (issame(derivative({1}) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(derivative({3, 1, 2, 4, 5}) , {1, 4, 12, 20}));\n    assert (issame(derivative({1, 2, 3}) , {2, 6}));\n}\n", "entry_point": "derivative", "seed": 1, "perturbed": true, "gc": "/*\nxs represe nt c oeffic i ents o f a polyn omial.\nxs{0} + xs{1}* x + xs{2} * x ^ 2 +....\n Return de rivativeof this poly nomial in th e  sameform.\n>>> derivative({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative({1, 2, 3})\n{2, 6}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> derivative(vector<float> xs){\n\tvector<float> d(xs.size(),0);\n\tfor(int i=0;i<xs.size();i++){\n\t\td[i]=xs[i+1]-xs[i];\n\t}\n\treturn d;\n}\nint main(){\n\tvector<float> xs;\n\tfloat x;\n\twhile(scanf(\"%f\",&x)==1){\n\t\txs.push_back(x);\n\t}\n\tvector<float> d=derivative(xs);\n\tfor(int i=0;i<d.size();i++){\n\t\tprintf(\"%f \",d[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/63", "prompt": "/*\nThe FibFib  num ber se q uenceis a sequ ence similar to the F ibbonacci sequn e ce that's defined a s follows:\nfibfib(0)== 0\nfibfib( 1 ) == 0\nfibfib(2 ) == 1\nfib f ib(n) == fibfib(n-1) + fibfi b( n-2) + fibfib(n-3).\nPl ease write a function to efficient ly computethe n-theleme nt of the fibfib n u mber sequence.\n>>> fibfib(1)\n0\n>>> fibfib(5)\n4\n>>> fibfib(8)\n24\n*/\n#include<stdio.h>\nusing namespace std;\nint fibfib(int n){\n", "canonical_solution": "    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fibfib(2) == 1);\n    assert (fibfib(1) == 0);\n    assert (fibfib(5) == 4);\n    assert (fibfib(8) == 24);\n    assert (fibfib(10) == 81);\n    assert (fibfib(12) == 274);\n    assert (fibfib(14) == 927);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fibfib(1) == 0);\n    assert (fibfib(5) == 4);\n    assert (fibfib(8) == 24);\n}\n", "entry_point": "fibfib", "seed": 1, "perturbed": true, "gc": "/*\nThe FibFib  num ber se q uenceis a sequ ence similar to the F ibbonacci sequn e ce that's defined a s follows:\nfibfib(0)== 0\nfibfib( 1 ) == 0\nfibfib(2 ) == 1\nfib f ib(n) == fibfib(n-1) + fibfi b( n-2) + fibfib(n-3).\nPl ease write a function to efficient ly computethe n-theleme nt of the fibfib n u mber sequence.\n>>> fibfib(1)\n0\n>>> fibfib(5)\n4\n>>> fibfib(8)\n24\n*/\n#include<stdio.h>\nusing namespace std;\nint fibfib(int n){\n    int a = 0, b = 1, c = 0;\n    for(int i = 0; i < n; i++){\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\nint main(){\n    int n;\n    printf(\"Enter the number of terms: \");\n    scanf(\"%d\", &n);\n    printf(\"The %d-th term of fibfib(%d) is: %d\\n\", n, n, fibfib(n));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/64", "prompt": "/*\nWrite a fu ncti on vow e ls_cou nt whichtakes a string repres enting a word a s  input and returnsthe number of vowelsin the strin g . Vowels in thi s case are 'a', 'e', 'i', 'o', 'u'. \nHe re , 'y' is also a vowel,  but only when it is at the end of the givenword.\nExa mple:  \n>>> vowels_count(\"abcde\") \n2 \n>>> vowels_count(\"ACEDY\") \n3\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint vowels_count(string s){\n", "canonical_solution": "    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (vowels_count(\"abcde\") == 2);\n    assert (vowels_count(\"Alone\") == 3);\n    assert (vowels_count(\"key\") == 2);\n    assert (vowels_count(\"bye\") == 1);\n    assert (vowels_count(\"keY\") == 2);\n    assert (vowels_count(\"bYe\") == 1);\n    assert (vowels_count(\"ACEDY\") == 3);\n   \n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (vowels_count(\"abcde\") == 2);\n    assert (vowels_count(\"ACEDY\") == 3);\n}\n", "entry_point": "vowels_count", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on vow e ls_cou nt whichtakes a string repres enting a word a s  input and returnsthe number of vowelsin the strin g. Vowels in thi s case are 'a', 'e', 'i', 'o', 'u'. \nHe re, 'y' is also a vowel,  but only when it is at the end of the givenword.\nExa mple:  \n>>> vowels_count(\"abcde\") \n2 \n>>> vowels_count(\"ACEDY\") \n3\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint vowels_count(string s){\n    int count=0;\n    for(int i=0;i<s.length();i++){\n        if(s[i]=='a' || s[i]=='e' || s[i]=='i' || s[i]=='o' || s[i]=='u')\n            count++;\n        if(s[i]=='y' && i==s.length()-1)\n            count++;\n    }\n    return count;\n}\nint main(){\n    string s;\n    cin>>s;\n    int count=vowels_count(s);\n    cout<<count;\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/65", "prompt": "/*\nCirculars hift  the d i gits o f the int eger x, shift the dig its right by sh i ft\nand return the r esult asa string.\nIf  shift > num b er ofdigits, r eturn digi t s reversed.\n>>> circular_shift(12, 1)\n\"21\"\n>>> circular_shift(12, 2)\n\"12\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring circular_shift(int x,int shift){\n", "canonical_solution": "    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (circular_shift(100, 2) == \"001\");\n    assert (circular_shift(12, 2) == \"12\");\n    assert (circular_shift(97, 8) == \"79\");\n    assert (circular_shift(12, 1) == \"21\");\n    assert (circular_shift(11, 101) == \"11\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (circular_shift(12, 2) == \"12\");\n    assert (circular_shift(12, 1) == \"21\");\n}\n", "entry_point": "circular_shift", "seed": 1, "perturbed": true, "gc": "/*\nCirculars hift  the d i gits o f the int eger x, shift the dig its right by sh i ft\nand return the r esult asa string.\nIf  shift > num b er ofdigits, r eturn digi t s reversed.\n>>> circular_shift(12, 1)\n\"21\"\n>>> circular_shift(12, 2)\n\"12\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring circular_shift(int x,int shift){\n    string s = to_string(x);\n    int len = s.length();\n    if(shift >= len){\n        string rev = \"\";\n        for(int i = 0; i < len; i++){\n            rev = rev + s[len - i - 1];\n        }\n        return rev;\n    }\n    else{\n        string rev = \"\";\n        for(int i = 0; i < len - shift; i++){\n            rev = rev + s[i];\n        }\n        for(int i = 0; i < shift; i++){\n            rev = rev + s[len - i - 1];\n        }\n        return rev;\n    }\n}\nint main(){\n    int x,shift;\n    while(scanf(\"%d %d\",&x,&shift)!= EOF){\n        printf(\"%s\\n\",circular_shift(x,shift).c_str());\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/66", "prompt": "/*\nTask\nWrite  a f unctio n  thattakes a s tring as input and re turns the sum o f  the upper characte rs only's\nASCII codes .\n\nExamples:\n    digitSum(\"\") => 0\n    digitSum(\"abAB\") => 131\n    digitSum(\"abcCd\") => 67\n    digitSum(\"helloE\") => 69\n    digitSum(\"woArBld\") => 131\n    digitSum(\"aAaaaXa\") => 153\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint digitSum(string s){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digitSum(\"\") == 0);\n    assert (digitSum(\"abAB\") == 131);\n    assert (digitSum(\"abcCd\") == 67);\n    assert (digitSum(\"helloE\") == 69);\n    assert (digitSum(\"woArBld\") == 131);\n    assert (digitSum(\"aAaaaXa\") == 153);\n    assert (digitSum(\" How are yOu?\") == 151);\n    assert (digitSum(\"You arE Very Smart\") == 327);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digitSum(\"\") == 0);\n    assert (digitSum(\"abAB\") == 131);\n    assert (digitSum(\"abcCd\") == 67);\n    assert (digitSum(\"helloE\") == 69);\n    assert (digitSum(\"woArBld\") == 131);\n    assert (digitSum(\"aAaaaXa\") == 153);\n}\n", "entry_point": "digitSum", "seed": 1, "perturbed": true, "gc": "/*\nTask\nWrite  a f unctio n  thattakes a s tring as input and re turns the sum o f  the upper characte rs only's\nASCII codes.\n\nExamples:\n    digitSum(\"\") => 0\n    digitSum(\"abAB\") => 131\n    digitSum(\"abcCd\") => 67\n    digitSum(\"helloE\") => 69\n    digitSum(\"woArBld\") => 131\n    digitSum(\"aAaaaXa\") => 153\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint digitSum(string s){\n    int sum = 0;\n    for(int i = 0; i < s.length(); i++){\n        sum += s[i] - '0';\n    }\n    return sum;\n}\nint main(){\n    string s;\n    while(cin >> s){\n        cout << digitSum(s) << endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/67", "prompt": "/*\nIn this ta sk,you wi l l be g iven a st ring that representsa number of app l es and oranges \ntha t are distributed ina basket off ruit this baske t contains \napples, oranges, and mangofr uits. Given the string  that representsthe total numberof \nthe oranges andapple s and an integer t h at represent the total number of the fru itsin the basket return th e number of the mango fr uits in the ba sket.\nfor example:\nfruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\nfruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\nfruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\nfruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint fruit_distribution(string s,int n){\n", "canonical_solution": "    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fruit_distribution(\"5 apples and 6 oranges\",19) == 8);\n    assert (fruit_distribution(\"5 apples and 6 oranges\",21) == 10);\n    assert (fruit_distribution(\"0 apples and 1 oranges\",3) == 2);\n    assert (fruit_distribution(\"1 apples and 0 oranges\",3) == 2);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",100) == 95);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",5) == 0);\n    assert (fruit_distribution(\"1 apples and 100 oranges\",120) == 19);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fruit_distribution(\"5 apples and 6 oranges\",19) == 8);\n    assert (fruit_distribution(\"0 apples and 1 oranges\",3) == 2);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",100) == 95);\n    assert (fruit_distribution(\"1 apples and 100 oranges\",120) == 19);\n}\n", "entry_point": "fruit_distribution", "seed": 1, "perturbed": true, "gc": "/*\nIn this ta sk,you wi l l be g iven a st ring that representsa number of app l es and oranges \ntha t are distributed ina basket off ruit this baske t contains \napples, oranges, and mangofr uits. Given the string  that representsthe total numberof \nthe oranges andapple s and an integer t h at represent the total number of the fru itsin the basket return th e number of the mango fr uits in the ba sket.\nfor example:\nfruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\nfruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\nfruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\nfruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint fruit_distribution(string s,int n){\n\tint i,j,k,l,m,t,flag=0;\n\tint a[n],b[n],c[n],d[n],e[n];\n\tint count=0;\n\tfor(i=0;i<n;i++){\n\t\ta[i]=0;\n\t\tb[i]=0;\n\t\tc[i]=0;\n\t\td[i]=0;\n\t\te[i]=0;\n\t}\n\tfor(i=0;i<s.length();i++){\n\t\tif(s[i]=='a'){\n\t\t\ta[count]=1;\n\t\t\tcount++;\n\t\t}\n\t\telse if(s[i]=='o'){\n\t\t\tb[count]=1;\n\t\t\tcount++;\n\t\t}\n\t\telse if(s[i]=='m'){\n\t\t\tc[count]=1;\n\t\t\tcount++;\n\t\t}\n\t\telse if(s[i]=='f'){\n\t\t\td[count]=1;\n\t\t\tcount++;\n\t\t}\n\t\telse if(s[i]=='u'){\n\t\t\te[count]=1;\n\t\t\tcount++;\n\t\t}\n\t}\n\tfor(i=0;i<count;i++){\n\t\tfor(j=0;j<count;j++){\n\t\t\tfor(k=0;k<count;k++){\n\t\t\t\tfor(l=0;l<count;l++){\n\t\t\t\t\tfor(m=0;m<count;m++){\n\t\t\t\t\t\tif(a[i]==1&&b[j]==1&&c[k]==1&&d[l]==1&&e[m]==1){\n\t\t\t\t\t\t\tt=a[i]+b[j]+c[k]+d[l]+e[m];\n\t\t\t\t\t\t\tif(t==n){\n\t\t\t\t\t\t\t\tflag=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(flag==1){\n\t\treturn n;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\nint main(){\n\tstring s;\n\tint t;\n\tcin>>s;\n\tcin>>t;\n\tint n=fruit_distribution(s,t);\n\tif(n==0){\n\t\tcout<<\"No Mango\"<<endl;\n\t}\n\telse{\n\t\tcout<<n<<endl;\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/68", "prompt": "/*\nGiven a ve ctor  repre s enting  a branch  of a tree that has n on-negative int e ger nodes\nyour task  is to pluck one of t he nodes and return it.\nTheplucked no d e should be the node with th esmallest even value.\nI f multiple nodeswith the same sma llest evenvalue are  foun d return the nodet hat has smallest index.\n\nThe plucked nod eshould be returned in a ve ctor, { smalest_value, i ts index },\nIf  there are no eve n values or the given vector i s empty, return {}.\n\nExample 1:\n    Input: {4,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: {1,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: {}\n    Output: {}\n\nExample 4:\n    Input: {5, 0, 3, 0, 4, 2}\n    Output: {0, 1}\n    Explanation: 0 is the smallest value, but  there are two zeros,\n                 so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> pluck(vector<int> arr){\n", "canonical_solution": "    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(pluck({4,2,3}) , {2, 1}));\n    assert (issame(pluck({1,2,3}) , {2, 1}));\n    assert (issame(pluck({}) , {}));\n    assert (issame(pluck({5, 0, 3, 0, 4, 2}) , {0, 1}));\n    assert (issame(pluck({1, 2, 3, 0, 5, 3}) , {0, 3}));\n    assert (issame(pluck({5, 4, 8, 4 ,8}) , {4, 1}));\n    assert (issame(pluck({7, 6, 7, 1}) , {6, 1}));\n    assert (issame(pluck({7, 9, 7, 1}) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(pluck({4,2,3}) , {2, 1}));\n    assert (issame(pluck({1,2,3}) , {2, 1}));\n    assert (issame(pluck({}) , {}));\n    assert (issame(pluck({5, 0, 3, 0, 4, 2}) , {0, 1}));\n}\n", "entry_point": "pluck", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ve ctor  repre s enting  a branch  of a tree that has n on-negative int e ger nodes\nyour task  is to pluck one of t he nodes and return it.\nTheplucked no d e should be the node with th esmallest even value.\nI f multiple nodeswith the same sma llest evenvalue are  foun d return the nodet hat has smallest index.\n\nThe plucked nod eshould be returned in a ve ctor, { smalest_value, i ts index },\nIf  there are no eve n values or the given vector i s empty, return {}.\n\nExample 1:\n    Input: {4,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: {1,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: {}\n    Output: {}\n\nExample 4:\n    Input: {5, 0, 3, 0, 4, 2}\n    Output: {0, 1}\n    Explanation: 0 is the smallest value, but  there are two zeros,\n                 so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> pluck(vector<int> arr){\n    vector<int> res;\n    if(arr.empty()){\n        return res;\n    }\n    int min_index = 0;\n    int min_value = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i] < min_value){\n            min_index = i;\n            min_value = arr[i];\n        }\n    }\n    res.push_back(min_value);\n    res.push_back(min_index);\n    return res;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> arr(n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\",&arr[i]);\n    }\n    vector<int> res = pluck(arr);\n    for(int i = 0; i < res.size(); i++){\n        printf(\"%d \",res[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/69", "prompt": "/*\nYou are gi vena non- e mpty v ector ofpositive integers. Re turn the greate s t integer that is g reater than \nzero, an d has a freq u ency greater th an or equa l  to the value ofthe integer  i tself. \nThe frequencyof an integer isthe number of tim es it appears in the  vect or.\nIf no such a v a lue exist, return -1.\nExamples:\n    search({4, 1, 2, 2, 3, 1}) == 2\n    search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3\n    search({5, 5, 4, 4, 4}) == -1\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint search(vector<int> lst){\n", "canonical_solution": "    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (search({5, 5, 5, 5, 1}) == 1);\n    assert (search({4, 1, 4, 1, 4, 4}) == 4);\n    assert (search({3, 3}) == -1);\n    assert (search({8, 8, 8, 8, 8, 8, 8, 8}) == 8);\n    assert (search({2, 3, 3, 2, 2}) == 2);\n    assert (search({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}) == 1);\n    assert (search({3, 2, 8, 2}) == 2);\n    assert (search({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}) == 1);\n    assert (search({8, 8, 3, 6, 5, 6, 4}) == -1);\n    assert (search({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}) == 1);\n    assert (search({1, 9, 10, 1, 3}) == 1);\n    assert (search({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}) == 5);\n    assert (search({1}) == 1);\n    assert (search({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}) == 4);\n    assert (search({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}) == 2);\n    assert (search({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}) == 1);\n    assert (search({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}) == 4);\n    assert (search({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}) == 4);\n    assert (search({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}) == 2);\n    assert (search({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}) == -1);\n    assert (search({10}) == -1);\n    assert (search({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}) == 2);\n    assert (search({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}) == 1);\n    assert (search({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}) == 1);\n    assert (search({3, 10, 10, 9, 2}) == -1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (search({4, 1, 2, 2, 3, 1}) == 2);\n    assert (search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert (search({5, 5, 4, 4, 4}) == -1);\n}\n", "entry_point": "search", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena non- e mpty v ector ofpositive integers. Re turn the greate s t integer that is g reater than \nzero, an d has a freq u ency greater th an or equa l  to the value ofthe integer  i tself. \nThe frequencyof an integer isthe number of tim es it appears in the  vect or.\nIf no such a v a lue exist, return -1.\nExamples:\n    search({4, 1, 2, 2, 3, 1}) == 2\n    search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3\n    search({5, 5, 4, 4, 4}) == -1\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint search(vector<int> lst){\n\tint i,j,k,n,temp;\n\tfor(i=0;i<lst.size();i++){\n\t\tfor(j=i+1;j<lst.size();j++){\n\t\t\tif(lst[i]>lst[j]){\n\t\t\t\tk=i;\n\t\t\t\tn=j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tk=j;\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\ttemp=lst[k];\n\t\t\tlst[k]=lst[n];\n\t\t\tlst[n]=temp;\n\t\t}\n\t}\n\tfor(i=0;i<lst.size();i++){\n\t\tif(lst[i]>0){\n\t\t\treturn lst[i];\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\tint n,i,j,k,l,m,temp;\n\tvector<int> lst;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tlst.clear();\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&lst[i]);\n\t\t}\n\t\tprintf(\"%d\\n\",search(lst));\n\t}\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/7", "prompt": "/*\nFilter aninpu t vect o r of s trings on ly for ones that cont ain given subst r ing\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n", "canonical_solution": "    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_substring({}, \"john\"),{}));\n     assert (issame(filter_by_substring({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), {\"xxx\", \"xxxAAA\", \"xxx\"}));\n    assert (issame(filter_by_substring({\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"),{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"}));\n     assert (issame(filter_by_substring({\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\") ,{\"grunt\", \"prune\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_substring({}, \"a\"),{}));\n     assert (issame(filter_by_substring({\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\"), {\"abc\", \"bacd\", \"array\"}));\n}\n", "entry_point": "filter_by_substring", "seed": 1, "perturbed": true, "gc": "/*\nFilter aninpu t vect o r of s trings on ly for ones that cont ain given subst r ing\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> result;\n    for(int i=0; i<strings.size(); i++){\n        if(strings[i].find(substring)!= string::npos){\n            result.push_back(strings[i]);\n        }\n    }\n    return result;\n}\nint main(){\n    vector<string> strings;\n    strings.push_back(\"abc\");\n    strings.push_back(\"bacd\");\n    strings.push_back(\"cde\");\n    strings.push_back(\"vector\");\n    cout<<filter_by_substring(strings, \"a\")<<endl;\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/70", "prompt": "/*\nGiven vect or o f inte g ers, r eturn vec tor in strange order. \nStrange sortin g , is when you start  with the minimum val ue,\nthen max i mum of the rema ining inte g ers, then minimum and so on. \n\nExamples:\nstrange_sort_vector({1, 2, 3, 4}) == {1, 4, 2, 3}\nstrange_sort_vector({5, 5, 5, 5}) == {5, 5, 5, 5}\nstrange_sort_vector({}) == {}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> strange_sort_list(vector<int> lst){\n", "canonical_solution": "    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(strange_sort_list({1, 2, 3, 4}) , {1, 4, 2, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9}) , {5, 9, 6, 8, 7}));\n    assert (issame(strange_sort_list({1, 2, 3, 4, 5}) , {1, 5, 2, 4, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9, 1}) , {1, 9, 5, 8, 6, 7}));\n    assert (issame(strange_sort_list({5, 5, 5, 5}) , {5, 5, 5, 5}));\n    assert (issame(strange_sort_list({}) , {}));\n    assert (issame(strange_sort_list({1,2,3,4,5,6,7,8}) , {1, 8, 2, 7, 3, 6, 4, 5}));\n    assert (issame(strange_sort_list({0,2,2,2,5,5,-5,-5}) , {-5, 5, -5, 5, 0, 2, 2, 2}));\n    assert (issame(strange_sort_list({111111}) , {111111}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(strange_sort_list({1, 2, 3, 4}) , {1, 4, 2, 3}));\n    assert (issame(strange_sort_list({5, 5, 5, 5}) , {5, 5, 5, 5}));\n    assert (issame(strange_sort_list({}) , {}));\n}\n", "entry_point": "strange_sort_list", "seed": 1, "perturbed": true, "gc": "/*\nGiven vect or o f inte g ers, r eturn vec tor in strange order. \nStrange sortin g, is when you start  with the minimum val ue,\nthen max i mum of the rema ining inte g ers, then minimum and so on. \n\nExamples:\nstrange_sort_vector({1, 2, 3, 4}) == {1, 4, 2, 3}\nstrange_sort_vector({5, 5, 5, 5}) == {5, 5, 5, 5}\nstrange_sort_vector({}) == {}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> strange_sort_list(vector<int> lst){\n\tvector<int> res;\n\tint min = lst[0];\n\tint max = lst[0];\n\tfor(int i = 1; i < lst.size(); i++){\n\t\tif(lst[i] < min){\n\t\t\tmin = lst[i];\n\t\t}\n\t\tif(lst[i] > max){\n\t\t\tmax = lst[i];\n\t\t}\n\t}\n\tfor(int i = 0; i < lst.size(); i++){\n\t\tif(lst[i] == min){\n\t\t\tres.push_back(lst[i]);\n\t\t\tlst[i] = lst[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if(lst[i] == max){\n\t\t\tres.push_back(lst[i]);\n\t\t\tlst[i] = lst[i+1];\n\t\t\ti++;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> lst;\n\tfor(int i = 0; i < n; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tlst.push_back(x);\n\t}\n\tvector<int> res = strange_sort_list(lst);\n\tfor(int i = 0; i < res.size(); i++){\n\t\tprintf(\"%d \", res[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/71", "prompt": "/*\nGiven theleng ths of the th ree sides  of a triangle. Retur n the area of\nt h e triangle roundedto 2 decimal points i f the threes ides form a val id triangl e . \nOtherwise return -1\nThree  s ides make a valid tria ngle when the sum of any two sides is greater \nthan th ethi rd side.\nExample:\ntriangle_area(3, 4, 5) == 6.00\ntriangle_area(1, 2, 10) == -1\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat triangle_area(float a,float b,float c){\n", "canonical_solution": "    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(3, 4, 5)-6.00)<0.01);\n    assert (abs(triangle_area(1, 2, 10) +1)<0.01);\n    assert (abs(triangle_area(4, 8, 5) -8.18)<0.01);\n    assert (abs(triangle_area(2, 2, 2) -1.73)<0.01);\n    assert (abs(triangle_area(1, 2, 3) +1)<0.01);\n    assert (abs(triangle_area(10, 5, 7) - 16.25)<0.01);\n    assert (abs(triangle_area(2, 6, 3) +1)<0.01);\n    assert (abs(triangle_area(1, 1, 1) -0.43)<0.01);\n    assert (abs(triangle_area(2, 2, 10) +1)<0.01);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(3, 4, 5)-6.00)<0.01);\n    assert (abs(triangle_area(1, 2, 10) +1)<0.01);\n}\n", "entry_point": "triangle_area", "seed": 1, "perturbed": true, "gc": "/*\nGiven theleng ths of the th ree sides  of a triangle. Retur n the area of\nt h e triangle roundedto 2 decimal points i f the threes ides form a val id triangl e. \nOtherwise return -1\nThree  s ides make a valid tria ngle when the sum of any two sides is greater \nthan th ethi rd side.\nExample:\ntriangle_area(3, 4, 5) == 6.00\ntriangle_area(1, 2, 10) == -1\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat triangle_area(float a,float b,float c){\n    float s1,s2,s3;\n    s1=a+b;\n    s2=b+c;\n    s3=c+a;\n    if(s1>s2&&s1>s3)\n        return (s1*s1/2);\n    else if(s2>s1&&s2>s3)\n        return (s2*s2/2);\n    else if(s3>s1&&s3>s2)\n        return (s3*s3/2);\n    else\n        return -1;\n}\nint main(){\n    float a,b,c;\n    while(scanf(\"%f%f%f\",&a,&b,&c)!=EOF){\n        printf(\"%.2f\\n\",triangle_area(a,b,c));\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/72", "prompt": "/*\nWrite a fu ncti on tha t  retur ns true i f the object q will f ly, and false o t herwise.\nThe object  q will fly if it's b alanced (iti s a palindromic  vector) a n d the sum of itselements is  l ess than or equal themaximum possibleweight w.\n\nExample:\nwill_it_fly({1, 2}, 5)  false \n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n\nwill_it_fly({3, 2, 3}, 1)  false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n\nwill_it_fly({3, 2, 3}, 9)  true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n\nwill_it_fly({3}, 5)  true\n// 3 is less than the maximum possible weight, and it's balanced.\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool will_it_fly(vector<int> q,int w){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (will_it_fly({3, 2, 3}, 9)==true);\n    assert (will_it_fly({1, 2}, 5) == false);\n    assert (will_it_fly({3}, 5) == true);\n    assert (will_it_fly({3, 2, 3}, 1) == false);\n    assert (will_it_fly({1, 2, 3}, 6) ==false);\n    assert (will_it_fly({5}, 5) == true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (will_it_fly({3, 2, 3}, 9)==true);\n    assert (will_it_fly({1, 2}, 5) == false);\n    assert (will_it_fly({3}, 5) == true);\n    assert (will_it_fly({3, 2, 3}, 1) == false);\n}\n", "entry_point": "will_it_fly", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on tha t  retur ns true i f the object q will f ly, and false o t herwise.\nThe object  q will fly if it's b alanced (iti s a palindromic  vector) a n d the sum of itselements is  l ess than or equal themaximum possibleweight w.\n\nExample:\nwill_it_fly({1, 2}, 5)  false \n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n\nwill_it_fly({3, 2, 3}, 1)  false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n\nwill_it_fly({3, 2, 3}, 9)  true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n\nwill_it_fly({3}, 5)  true\n// 3 is less than the maximum possible weight, and it's balanced.\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool will_it_fly(vector<int> q,int w){\n\tint sum=0;\n\tfor(int i=0;i<q.size();i++){\n\t\tsum+=q[i];\n\t}\n\tif(sum>=w){\n\t\tfor(int i=0;i<q.size();i++){\n\t\t\tprintf(\"%d \",q[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> q;\n\tfor(int i=0;i<n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tq.push_back(x);\n\t}\n\tint w;\n\tscanf(\"%d\",&w);\n\tbool ans=will_it_fly(q,w);\n\tif(ans){\n\t\tprintf(\"true\\n\");\n\t}\n\telse{\n\t\tprintf(\"false\\n\");\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/73", "prompt": "/*\nGiven a ve ctor  arr o f  integ ers, find  the minimum number o f elements that need to be changedto make the vector pa lindromic.A palindromic vec tor is a v e ctor that\nis read the same b ac kwards and forwards. I n one change, you can change one e lement to any othereleme nt.\n\nFor example:\nsmallest_change({1,2,3,5,4,7,9,6}) == 4\nsmallest_change({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change({1, 2, 3, 2, 1}) == 0\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint smallest_change(vector<int> arr){\n", "canonical_solution": "    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (smallest_change({1,2,3,5,4,7,9,6}) == 4);\n    assert (smallest_change({1, 2, 3, 4, 3, 2, 2}) == 1);\n    assert (smallest_change({1, 4, 2}) == 1);\n    assert (smallest_change({1, 4, 4, 2}) == 1);\n    assert (smallest_change({1, 2, 3, 2, 1}) == 0);\n    assert (smallest_change({3, 1, 1, 3}) == 0);\n    assert (smallest_change({1}) == 0);\n    assert (smallest_change({0, 1}) == 1);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (smallest_change({1,2,3,5,4,7,9,6}) == 4);\n    assert (smallest_change({1, 2, 3, 4, 3, 2, 2}) == 1);\n    assert (smallest_change({1, 2, 3, 2, 1}) == 0);\n    assert (smallest_change({3, 1, 1, 3}) == 0);\n}\n", "entry_point": "smallest_change", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ve ctor  arr o f  integ ers, find  the minimum number o f elements that need to be changedto make the vector pa lindromic.A palindromic vec tor is a v e ctor that\nis read the same b ac kwards and forwards. I n one change, you can change one e lement to any othereleme nt.\n\nFor example:\nsmallest_change({1,2,3,5,4,7,9,6}) == 4\nsmallest_change({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change({1, 2, 3, 2, 1}) == 0\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint smallest_change(vector<int> arr){\n    int n = arr.size();\n    int i,j,k;\n    for(i=0;i<n-1;i++){\n        for(j=i+1;j<n;j++){\n            if(arr[i]==arr[j]){\n                k = j-i;\n                if(k<=1){\n                    return k;\n                }\n                else{\n                    return smallest_change(arr);\n                }\n            }\n        }\n    }\n    return 0;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> arr(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&arr[i]);\n    }\n    printf(\"%d\\n\",smallest_change(arr));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/74", "prompt": "/*\nWrite a fu ncti on tha t  accep ts two ve ctors of strings andreturns the vec t or that has \ntotalnumber of chars in th e all string s  of the vectorless thant he other vector.\nif the two  v ectors have the same n umber of chars, return the first v ector.\n\nExamples\ntotal_match({}, {})  {}\ntotal_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"})  {\"hI\", \"Hi\"}\ntotal_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"})  {\"hi\", \"admin\"}\ntotal_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"})  {\"hI\", \"hi\", \"hi\"}\ntotal_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"})  {\"4\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n", "canonical_solution": "    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(total_match({}, {}) , {}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\"}) , {\"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hii\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({}, {\"this\"}) , {}));\n    assert (issame(total_match({\"this\"}, {}) , {}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(total_match({}, {}) , {}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n}\n", "entry_point": "total_match", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on tha t  accep ts two ve ctors of strings andreturns the vec t or that has \ntotalnumber of chars in th e all string s  of the vectorless thant he other vector.\nif the two  v ectors have the same n umber of chars, return the first v ector.\n\nExamples\ntotal_match({}, {})  {}\ntotal_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"})  {\"hI\", \"Hi\"}\ntotal_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"})  {\"hi\", \"admin\"}\ntotal_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"})  {\"hI\", \"hi\", \"hi\"}\ntotal_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"})  {\"4\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n\tint l1 = lst1.size();\n\tint l2 = lst2.size();\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint m = 0;\n\tint n = 0;\n\tint total = 0;\n\tvector<string> res;\n\twhile(i < l1 && j < l2){\n\t\tif(lst1[i] == lst2[j]){\n\t\t\ttotal++;\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse if(lst1[i] < lst2[j]){\n\t\t\ti++;\n\t\t}\n\t\telse{\n\t\t\tj++;\n\t\t}\n\t}\n\twhile(i < l1){\n\t\tres.push_back(lst1[i]);\n\t\ti++;\n\t}\n\twhile(j < l2){\n\t\tres.push_back(lst2[j]);\n\t\tj++;\n\t}\n\treturn res;\n}\nint main(){\n\tvector<string> lst1 = {\"hi\", \"admin\"};\n\tvector<string> lst2 = {\"hI\", \"Hi\"};\n\tvector<string> res = total_match(lst1,lst2);\n\tfor(int i = 0; i < res.size(); i++){\n\t\tprintf(\"%s\\n\",res[i].c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/75", "prompt": "/*\nWrite a fu ncti on tha t  retur ns true i f the given number is  the multiplica t ion of 3 prime numb ers\nand false otherwi se.\nKnowingt hat (a) is less  then 100.  \nExample:\nis_multiply_prime(30) == true\n30 = 2 * 3 * 5\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_multiply_prime(int a){\n", "canonical_solution": "    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_multiply_prime(5) == false);\n    assert (is_multiply_prime(30) == true);\n    assert (is_multiply_prime(8) == true);\n    assert (is_multiply_prime(10) == false);\n    assert (is_multiply_prime(125) == true);\n    assert (is_multiply_prime(3 * 5 * 7) == true);\n    assert (is_multiply_prime(3 * 6 * 7) == false);\n    assert (is_multiply_prime(9 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 13 * 7) == true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_multiply_prime(30) == true);\n}\n", "entry_point": "is_multiply_prime", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on tha t  retur ns true i f the given number is  the multiplica t ion of 3 prime numb ers\nand false otherwi se.\nKnowingt hat (a) is less  then 100.  \nExample:\nis_multiply_prime(30) == true\n30 = 2 * 3 * 5\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_multiply_prime(int a){\n\tint i,j;\n\tfor(i=2;i<=a/2;i++){\n\t\tif(a%i==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a)==1){\n\t\tif(is_multiply_prime(a))\n\t\t\tprintf(\"%d = 2 * 3 * 5\\n\",a);\n\t\telse\n\t\t\tprintf(\"%d is not a prime number\\n\",a);\n\t}\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/76", "prompt": "/*\nYour taskis t o writ e  a fun ction tha t returns true if a n umber x is a si m ple\npower of n andfalse inother cases. \nx is a simp l e power of n if  n**int=x\nFor example:\nis_simple_power(1, 4) => true\nis_simple_power(2, 2) => true\nis_simple_power(8, 2) => true\nis_simple_power(3, 2) => false\nis_simple_power(3, 1) => false\nis_simple_power(5, 3) => false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool is_simple_power(int x,int n){\n", "canonical_solution": "    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_simple_power(1, 4)== true);\n    assert (is_simple_power(2, 2)==true);\n    assert (is_simple_power(8, 2)==true);\n    assert (is_simple_power(3, 2)==false);\n    assert (is_simple_power(3, 1)==false);\n    assert (is_simple_power(5, 3)==false);\n    assert (is_simple_power(16, 2)== true);\n    assert (is_simple_power(143214, 16)== false);\n    assert (is_simple_power(4, 2)==true);\n    assert (is_simple_power(9, 3)==true);\n    assert (is_simple_power(16, 4)==true);\n    assert (is_simple_power(24, 2)==false);\n    assert (is_simple_power(128, 4)==false);\n    assert (is_simple_power(12, 6)==false);\n    assert (is_simple_power(1, 1)==true);\n    assert (is_simple_power(1, 12)==true);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_simple_power(1, 4)== true);\n    assert (is_simple_power(2, 2)==true);\n    assert (is_simple_power(8, 2)==true);\n    assert (is_simple_power(3, 2)==false);\n    assert (is_simple_power(3, 1)==false);\n    assert (is_simple_power(5, 3)==false);\n}\n", "entry_point": "is_simple_power", "seed": 1, "perturbed": true, "gc": "/*\nYour taskis t o writ e  a fun ction tha t returns true if a n umber x is a si m ple\npower of n andfalse inother cases. \nx is a simp l e power of n if  n**int=x\nFor example:\nis_simple_power(1, 4) => true\nis_simple_power(2, 2) => true\nis_simple_power(8, 2) => true\nis_simple_power(3, 2) => false\nis_simple_power(3, 1) => false\nis_simple_power(5, 3) => false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool is_simple_power(int x,int n){\n\tif(x==1)\n\t\treturn true;\n\tif(x==n)\n\t\treturn true;\n\tif(x%n==0)\n\t\treturn false;\n\treturn is_simple_power(x/n,n);\n}\nint main(){\n\tint n;\n\tprintf(\"Enter a number n: \");\n\tscanf(\"%d\",&n);\n\tprintf(\"%d is a simple power of %d\\n\",n,n);\n\tif(is_simple_power(n,n))\n\t\tprintf(\"%d is a simple power of %d\\n\",n,n);\n\telse\n\t\tprintf(\"%d is not a simple power of %d\\n\",n,n);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/77", "prompt": "/*\nWrite a fu ncti on tha t  takes  an integ er a and returns true  \nif this ingeg e r is a cube of some  integernumber.\nNote : you may as s ume the input i s always v a lid.\nExamples:\niscube(1) ==> true\niscube(2) ==> false\niscube(-1) ==> true\niscube(64) ==> true\niscube(0) ==> true\niscube(180) ==> false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool iscuber(int a){\n", "canonical_solution": "    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (iscuber(1) == true);\n    assert (iscuber(2) == false);\n    assert (iscuber(-1) == true);\n    assert (iscuber(64) == true);\n    assert (iscuber(180) == false);\n    assert (iscuber(1000) == true);\n    assert (iscuber(0) == true);\n    assert (iscuber(1729) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (iscuber(1) == true);\n    assert (iscuber(2) == false);\n    assert (iscuber(-1) == true);\n    assert (iscuber(64) == true);\n    assert (iscuber(180) == false);\n    assert (iscuber(0) == true);\n}\n", "entry_point": "iscuber", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on tha t  takes  an integ er a and returns true  \nif this ingeg e r is a cube of some  integernumber.\nNote : you may as s ume the input i s always v a lid.\nExamples:\niscube(1) ==> true\niscube(2) ==> false\niscube(-1) ==> true\niscube(64) ==> true\niscube(0) ==> true\niscube(180) ==> false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool iscuber(int a){\n\tint i;\n\tfor(i=1;i<=a;i++){\n\t\tif(a%i==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a)==1){\n\t\tif(iscuber(a))\n\t\t\tprintf(\"%d is a cube of some integer\\n\",a);\n\t\telse\n\t\t\tprintf(\"%d is not a cube of some integer\\n\",a);\n\t}\n\treturn 0;\n}<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/78", "prompt": "/*\nYou haveb eentasked to wri te a func tion that receives \na  hexadecimal nu m ber as a string and  counts the number of  hexadecimal \ndigits that ar e primes ( p rime number, or a prime, isanatural number \ngreate r than 1 that isnot a product oftwo smaller naturalnumbe rs).\nHexadecimal d i gits are 0, 1, 2, 3,4, 5, 6, 7, 8, 9, A ,B,C, D, E,F.\nPrime numbe rs are 2, 3, 5, 7, 11, 1 3, 17,...\nSo y ou have to determ ine a number of the followingdigits: 2, 3, 5, 7, \nB (=decim al11), D (=decimal 13).\nNote: you mayassume theinput is always c orrect or empty string, \nand sym bols A ,B,C,D,E,Fare always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint hex_key(string num){\n", "canonical_solution": "    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (hex_key(\"AB\") == 1      );\n    assert (hex_key(\"1077E\") == 2 );\n    assert (hex_key(\"ABED1A33\") == 4     );\n    assert (hex_key(\"2020\") == 2 );\n    assert (hex_key(\"123456789ABCDEF0\") == 6      );\n    assert (hex_key(\"112233445566778899AABBCCDDEEFF00\") == 12 );\n    assert (hex_key(\"\") == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (hex_key(\"AB\") == 1      );\n    assert (hex_key(\"1077E\") == 2 );\n    assert (hex_key(\"ABED1A33\") == 4     );\n    assert (hex_key(\"2020\") == 2 );\n    assert (hex_key(\"123456789ABCDEF0\") == 6      );\n}\n", "entry_point": "hex_key", "seed": 1, "perturbed": true, "gc": "/*\nYou haveb eentasked to wri te a func tion that receives \na  hexadecimal nu m ber as a string and  counts the number of  hexadecimal \ndigits that ar e primes ( p rime number, or a prime, isanatural number \ngreate r than 1 that isnot a product oftwo smaller naturalnumbe rs).\nHexadecimal d i gits are 0, 1, 2, 3,4, 5, 6, 7, 8, 9, A,B,C, D, E,F.\nPrime numbe rs are 2, 3, 5, 7, 11, 1 3, 17,...\nSo y ou have to determ ine a number of the followingdigits: 2, 3, 5, 7, \nB (=decim al11), D (=decimal 13).\nNote: you mayassume theinput is always c orrect or empty string, \nand sym bols A,B,C,D,E,Fare always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint hex_key(string num){\n\tint i=0;\n\tint j=0;\n\tint count=0;\n\tfor(i=0;i<num.length();i++){\n\t\tif(num[i]>='A'&&num[i]<='F'){\n\t\t\tcount++;\n\t\t}\n\t\telse if(num[i]>='0'&&num[i]<='9'){\n\t\t\tcount++;\n\t\t}\n\t\telse if(num[i]>='a'&&num[i]<='f'){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main(){\n\tstring num;\n\twhile(cin>>num){\n\t\tint count=0;\n\t\tfor(int i=0;i<num.length();i++){\n\t\t\tif(num[i]>='A'&&num[i]<='F'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse if(num[i]>='0'&&num[i]<='9'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse if(num[i]>='a'&&num[i]<='f'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/79", "prompt": "/*\nYou willb e gi ven an umberin decima l form and your taskis to convert i t  to\nbinary format.The function should r eturn a stri n g, with each ch aracter re p resenting a binary\nnumber. E ac h character in the str ing will be '0' or '1'.\n\nThere wil l be an extra couple  of c haracters \"db\" att he beginning and at the end of the strin g.\nThe extra characters arethere to helpwith the f ormat.\n\nExamples:\ndecimal_to_binary(15)   // returns \"db1111db\"\ndecimal_to_binary(32)   // returns \"db100000db\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring decimal_to_binary(int decimal){\n", "canonical_solution": "    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (decimal_to_binary(0) == \"db0db\");\n    assert (decimal_to_binary(32) == \"db100000db\");\n    assert (decimal_to_binary(103) == \"db1100111db\");\n    assert (decimal_to_binary(15) == \"db1111db\");\n\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (decimal_to_binary(32) == \"db100000db\");\n    assert (decimal_to_binary(15) == \"db1111db\");\n}\n", "entry_point": "decimal_to_binary", "seed": 1, "perturbed": true, "gc": "/*\nYou willb e gi ven an umberin decima l form and your taskis to convert i t  to\nbinary format.The function should r eturn a stri n g, with each ch aracter re p resenting a binary\nnumber. E ac h character in the str ing will be '0' or '1'.\n\nThere wil l be an extra couple  of c haracters \"db\" att he beginning and at the end of the strin g.\nThe extra characters arethere to helpwith the f ormat.\n\nExamples:\ndecimal_to_binary(15)   // returns \"db1111db\"\ndecimal_to_binary(32)   // returns \"db100000db\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring decimal_to_binary(int decimal){\n\tstring binary;\n\tint i,j;\n\tfor(i=0;i<32;i++){\n\t\tbinary.insert(0,'0');\n\t}\n\tfor(i=0;i<32;i++){\n\t\tbinary[i]=decimal%2+'0';\n\t\tdecimal/=2;\n\t}\n\tbinary.insert(0,'d');\n\tbinary.insert(0,'b');\n\treturn binary;\n}\nint main(){\n\tint decimal;\n\tcin>>decimal;\n\tcout<<decimal_to_binary(decimal);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/8", "prompt": "/*\nFor a give n ve ctor o f  integ ers, retu rn a vector consistin g of a sum anda  product of all the  integers in a vector .\nEmpty sums houldbe equalto 0 and e m pty product should be equalto  1.\n>>> sum_product({})\n(0, 1)\n>>> sum_product({1, 2, 3, 4})\n(10, 24)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> sum_product(vector<int> numbers){\n", "canonical_solution": "    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sum_product({}) ,{0, 1}));\n    assert (issame(sum_product({1, 1, 1}), {3, 1}));\n    assert (issame(sum_product({100, 0}),{100, 0}));\n     assert (issame(sum_product({3, 5, 7}) , {3 + 5 + 7, 3 * 5 * 7}));\n      assert (issame(sum_product({10}) ,{10, 10}));\n}\n\n\n", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sum_product({}) ,{0, 1}));\n    assert (issame(sum_product({1, 2, 3,4}), {10, 24}));\n}\n", "entry_point": "sum_product", "seed": 1, "perturbed": true, "gc": "/*\nFor a give n ve ctor o f  integ ers, retu rn a vector consistin g of a sum anda  product of all the  integers in a vector.\nEmpty sums houldbe equalto 0 and e m pty product should be equalto  1.\n>>> sum_product({})\n(0, 1)\n>>> sum_product({1, 2, 3, 4})\n(10, 24)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> sum_product(vector<int> numbers){\n    vector<int> sum(numbers.size(), 0);\n    vector<int> product(numbers.size(), 1);\n    for(int i=0; i<numbers.size(); i++){\n        sum[i] = sum[i-1] + numbers[i];\n        product[i] = product[i-1] * numbers[i];\n    }\n    return (vector<int>{sum[numbers.size()-1], product[numbers.size()-1]});\n}\nint main(){\n    vector<int> numbers = {1, 2, 3, 4};\n    vector<int> sum_product = sum_product(numbers);\n    printf(\"%d %d\\n\", sum_product[0], sum_product[1]);\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/80", "prompt": "/*\nYou are gi vena stri n g s.\nY our taskis to check if the st ring is happy o r  not.\nA string is h appy if its length is  at least 3a nd every 3 cons ecutive le t ters are distinct\nFor example:\nis_happy(\"a\") => false\nis_happy(\"aa\") => false\nis_happy(\"abcd\") => true\nis_happy(\"aabb\") => false\nis_happy(\"adb\") => true\nis_happy(\"xyy\") => false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_happy(string s){\n", "canonical_solution": "    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_happy(\"a\") == false );\n    assert (is_happy(\"aa\") == false );\n    assert (is_happy(\"abcd\") == true );\n    assert (is_happy(\"aabb\") == false );\n    assert (is_happy(\"adb\") == true );\n    assert (is_happy(\"xyy\") == false );\n    assert (is_happy(\"iopaxpoi\") == true );\n    assert (is_happy(\"iopaxioi\") == false );\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_happy(\"a\") == false );\n    assert (is_happy(\"aa\") == false );\n    assert (is_happy(\"abcd\") == true );\n    assert (is_happy(\"aabb\") == false );\n    assert (is_happy(\"adb\") == true );\n    assert (is_happy(\"xyy\") == false );\n}\n", "entry_point": "is_happy", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena stri n g s.\nY our taskis to check if the st ring is happy o r  not.\nA string is h appy if its length is  at least 3a nd every 3 cons ecutive le t ters are distinct\nFor example:\nis_happy(\"a\") => false\nis_happy(\"aa\") => false\nis_happy(\"abcd\") => true\nis_happy(\"aabb\") => false\nis_happy(\"adb\") => true\nis_happy(\"xyy\") => false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_happy(string s){\n    int len = s.length();\n    if(len < 3)\n        return false;\n    int count[26] = {0};\n    for(int i = 0; i < len; i++){\n        count[s[i] - 'a']++;\n    }\n    for(int i = 0; i < len; i++){\n        if(count[s[i] - 'a']!= 3)\n            return false;\n    }\n    return true;\n}\nint main(){\n    string s;\n    while(cin >> s){\n        if(is_happy(s))\n            cout << \"happy\" << endl;\n        else\n            cout << \"unhappy\" << endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/81", "prompt": "/*\nIt is thelast  weeko f thesemesterand the teacher has t o give the grad e s\nto students. Theteacher has been maki ng her owna l gorithm for gra ding.\nTheo nly problem is, she has lost  t he code she used for g rading.\nShe has given you a vector of GPAs for some st udent s and you have tow rite a function that can output a vecto rofletter grades using the  following table:\n        GPA       |     Letter grade         4.0               A +\n        > 3.7               A\n        > 3.3                A- \n       > 3.0                 B +\n        > 2.7                B  \n       > 2.3               B-\n       > 2.0                C+\n     > 1.7               C\n       > 1.3           C-\n       > 1.0               D+       > 0. 7             D \n        > 0.0              D-\n         0.0                E\n\n\nExample:\ngrade_equation({4.0, 3, 1.7, 2, 3.5}) ==> {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> numerical_letter_grade(vector<float> grades){\n", "canonical_solution": "    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(numerical_letter_grade({4.0, 3, 1.7, 2, 3.5}) , {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}));\n    assert (issame(numerical_letter_grade({1.2}) , {\"D+\"}));\n    assert (issame(numerical_letter_grade({0.5}) , {\"D-\"}));\n    assert (issame(numerical_letter_grade({0.0}) , {\"E\"}));\n    assert (issame(numerical_letter_grade({1, 0.3, 1.5, 2.8, 3.3}) , {\"D\", \"D-\", \"C-\", \"B\", \"B+\"}));\n    assert (issame(numerical_letter_grade({0, 0.7}) , {\"E\", \"D-\"}));\n    \n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(numerical_letter_grade({4.0, 3, 1.7, 2, 3.5}) , {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}));\n}\n", "entry_point": "numerical_letter_grade", "seed": 1, "perturbed": true, "gc": "/*\nIt is thelast  weeko f thesemesterand the teacher has t o give the grad e s\nto students. Theteacher has been maki ng her owna l gorithm for gra ding.\nTheo nly problem is, she has lost  t he code she used for g rading.\nShe has given you a vector of GPAs for some st udent s and you have tow rite a function that can output a vecto rofletter grades using the  following table:\n        GPA       |     Letter grade         4.0               A +\n        > 3.7               A\n        > 3.3                A- \n       > 3.0                 B +\n        > 2.7                B  \n       > 2.3               B-\n       > 2.0                C+\n     > 1.7               C\n       > 1.3           C-\n       > 1.0               D+       > 0. 7             D \n        > 0.0              D-\n         0.0                E\n\n\nExample:\ngrade_equation({4.0, 3, 1.7, 2, 3.5}) ==> {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> numerical_letter_grade(vector<float> grades){\n\tvector<string> letter_grades;\n\tfloat sum = 0;\n\tfor(int i = 0; i < grades.size(); i++){\n\t\tsum += grades[i];\n\t}\n\tif(sum >= 4.0){\n\t\tletter_grades.push_back(\"A+\");\n\t}\n\tif(sum >= 3.7){\n\t\tletter_grades.push_back(\"A\");\n\t}\n\tif(sum >= 3.3){\n\t\tletter_grades.push_back(\"A-\");\n\t}\n\tif(sum >= 3.0){\n\t\tletter_grades.push_back(\"B+\");\n\t}\n\tif(sum >= 2.7){\n\t\tletter_grades.push_back(\"B\");\n\t}\n\tif(sum >= 2.3){\n\t\tletter_grades.push_back(\"B-\");\n\t}\n\tif(sum >= 2.0){\n\t\tletter_grades.push_back(\"C+\");\n\t}\n\tif(sum >= 1.7){\n\t\tletter_grades.push_back(\"C\");\n\t}\n\tif(sum >= 1.3){\n\t\tletter_grades.push_back(\"C-\");\n\t}\n\tif(sum >= 1.0){\n\t\tletter_grades.push_back(\"D+\");\n\t}\n\tif(sum >= 0.7){\n\t\tletter_grades.push_back(\"D\");\n\t}\n\tif(sum >= 0.3){\n\t\tletter_grades.push_back(\"D-\");\n\t}\n\tif(sum >= 0.0){\n\t\tletter_grades.push_back(\"E\");\n\t}\n\treturn letter_grades;\n}\nint main(){\n\tvector<float> grades;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++){\n\t\tfloat grade;\n\t\tscanf(\"%f\", &grade);\n\t\tgrades.push_back(grade);\n\t}\n\tvector<string> letter_grades = numerical_letter_grade(grades);\n\tfor(int i = 0; i < grades.size(); i++){\n\t\tprintf(\"%s\\n\", letter_grades[i].c_str());\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/82", "prompt": "/*\nWrite a fu ncti on tha t  takes  a string  and returns true ifthe string\nleng t h is a prime number  or false otherwise\nExamples\nprime_length(\"Hello\") == true\nprime_length(\"abcdcba\") == true\nprime_length(\"kittens\") == true\nprime_length(\"orange\") == false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool prime_length(string str){\n", "canonical_solution": "    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_length(\"Hello\") == true);\n    assert (prime_length(\"abcdcba\") == true);\n    assert (prime_length(\"kittens\") == true);\n    assert (prime_length(\"orange\") == false);\n    assert (prime_length(\"wow\") == true);\n    assert (prime_length(\"world\") == true);\n    assert (prime_length(\"MadaM\") == true);\n    assert (prime_length(\"Wow\") == true);\n    assert (prime_length(\"\") == false);\n    assert (prime_length(\"HI\") == true);\n    assert (prime_length(\"go\") == true);\n    assert (prime_length(\"gogo\") == false);\n    assert (prime_length(\"aaaaaaaaaaaaaaa\") == false);\n    assert (prime_length(\"Madam\") == true);\n    assert (prime_length(\"M\") == false);\n    assert (prime_length(\"0\") == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_length(\"Hello\") == true);\n    assert (prime_length(\"abcdcba\") == true);\n    assert (prime_length(\"kittens\") == true);\n    assert (prime_length(\"orange\") == false);\n}\n", "entry_point": "prime_length", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on tha t  takes  a string  and returns true ifthe string\nleng t h is a prime number  or false otherwise\nExamples\nprime_length(\"Hello\") == true\nprime_length(\"abcdcba\") == true\nprime_length(\"kittens\") == true\nprime_length(\"orange\") == false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool prime_length(string str){\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint l = 0;\n\tint m = 0;\n\tint n = 0;\n\tint p = 0;\n\tint q = 0;\n\tint r = 0;\n\tint s = 0;\n\tint t = 0;\n\tint u = 0;\n\tint v = 0;\n\tint w = 0;\n\tint x = 0;\n\tint y = 0;\n\tint z = 0;\n\tint a = 0;\n\tint b = 0;\n\tint c = 0;\n\tint d = 0;\n\tint e = 0;\n\tint f = 0;\n\tint g = 0;\n\tint h = 0;\n\tint i1 = 0;\n\tint i2 = 0;\n\tint i3 = 0;\n\tint i4 = 0;\n\tint i5 = 0;\n\tint i6 = 0;\n\tint i7 = 0;\n\tint i8 = 0;\n\tint i9 = 0;\n\tint i10 = 0;\n\tint i11 = 0;\n\tint i12 = 0;\n\tint i13 = 0;\n\tint i14 = 0;\n\tint i15 = 0;\n\tint i16 = 0;\n\tint i17 = 0;\n\tint i18 = 0;\n\tint i19 = 0;\n\tint i20 = 0;\n\tint i21 = 0;\n\tint i22 = 0;\n\tint i23 = 0;\n\tint i24 = 0;\n\tint i25 = 0;\n\tint i26 = 0;\n\tint i27 = 0;\n\tint i28 = 0;\n\tint i29 = 0;\n\tint i30 = 0;\n\tint i31 = 0;\n\tint i32 = 0;\n\tint i33 = 0;\n\tint i34 = 0;\n\tint i35 = 0;\n\tint i36 = 0;\n\tint i37 = 0;\n\tint i38 = 0;\n\tint i39 = 0;\n\tint i40 = 0;\n\tint i41 = 0;\n\tint i42 = 0;\n\tint i43 = 0;\n\tint i44 = 0;\n\tint i45 = 0;\n\tint i46 = 0;\n\tint i47 = 0;\n\tint i48 = 0;\n\tint i49 = 0;\n\tint i50 = 0;\n\tint i51 = 0;\n\tint i52 = 0;\n\tint i53 = 0;\n\tint i54 = 0;\n\tint i55 = 0;\n\tint i56 = 0;\n\tint i57 = 0;\n\tint i58 = 0;\n\tint i59 = 0;\n\tint i60 = 0;\n\tint i61 = 0;\n\tint i62 = 0;\n\tint i63 = 0;\n\tint i64 = 0;\n\tint i65 = 0;\n\tint i66 = 0;\n\tint i67 = 0;\n\tint i68 = 0;\n\tint i69 = 0;\n\tint i70 = 0;\n\tint i71 = 0;\n\tint i72 = 0;\n\tint i73 = 0;\n\tint i74 = 0;\n\tint i75 = 0;\n\tint i76 = 0;\n\tint i77 = 0;\n\tint i78 = 0;\n\tint i79 = 0;\n\tint i80 = 0;\n\tint i81 = 0;\n\tint i82 = 0;\n\tint i83 = 0;\n\tint i84 = 0;\n\tint i85 = 0;\n\tint i86 = 0;\n\tint i87 = 0;\n\tint i88 = 0;\n\tint i89 = 0;\n\tint i90 = 0;\n\tint i91 = 0;\n\tint i92 = 0;\n\tint i93 = 0;\n\tint i94 = 0;\n\tint i95 = 0;\n\tint i96 = 0;\n\tint i97 = 0;\n\tint i98 = 0;\n\tint i99 = 0;\n\tint i100 = 0;\n\tint i101 = 0;\n\tint i102 = 0;\n\tint i103 = 0;\n\tint i104 = 0;\n\tint i105 = 0;\n\tint i106 = 0;\n\tint i107 = 0;\n\tint i108 = 0;\n\tint i109 = 0;\n\tint i110 = 0;\n\tint i111 = 0;\n\tint i112 = 0;\n\tint i113 = 0;\n\tint i114 = 0;\n\tint i115 = 0;\n\tint i116 = 0;\n\tint i117 = 0;\n\tint i118 = 0;\n\tint i119 = 0;\n\tint i120 = 0;\n\tint i121 = 0;\n\tint i122 = 0;\n\tint i123 = 0;\n\tint i124 = 0;\n\tint i125 = 0;\n\tint i126 = 0;\n\tint i127 = 0;\n\tint i128 = 0;\n\tint i129 = 0;\n\tint i130 = 0;\n\tint i131 = 0;\n\tint i132 = 0;\n\tint i133 = 0;\n\tint i134 = 0;\n\tint i135 = 0;\n\tint i136 = 0;\n\tint i137 = 0;\n\tint i138 = 0;\n\tint i139 = 0;\n\tint i140 = 0;\n\tint i141 = 0;\n\tint i142 = 0;\n\tint i143 = 0;\n\tint i144 = 0;\n\tint i145 = 0;\n\tint i146 = 0;\n\tint i147 = 0;\n\tint i148 = 0;\n\tint i149 = 0;\n\tint i150 = 0;\n\tint i151 = 0;\n\tint i152 = 0;\n\tint i153 = 0;\n\tint i154 = 0;\n\tint i155 = 0;\n\tint i156 = 0;\n\tint", "passed": 0, "run_status": 2}
{"task_id": "CPP/83", "prompt": "/*\nGiven a po siti ve int e ger n,  return t he count of the numbe rs of n-digit\np o sitive integers tha t start or end with 1 .\n*/\n#includ e <stdio.h>\nusing  namespace std;\nint starts_one_ends(int  n ){\n", "canonical_solution": "    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (starts_one_ends(1) == 1);\n    assert (starts_one_ends(2) == 18);\n    assert (starts_one_ends(3) == 180);\n    assert (starts_one_ends(4) == 1800);\n    assert (starts_one_ends(5) == 18000);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n", "example_test": "", "entry_point": "starts_one_ends", "seed": 1, "perturbed": true, "gc": "/*\nGiven a po siti ve int e ger n,  return t he count of the numbe rs of n-digit\np o sitive integers tha t start or end with 1.\n*/\n#includ e <stdio.h>\nusing  namespace std;\nint starts_one_ends(int  n ){\n\tint count = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(i%10 == 1){\n\t\t\tcount++;\n\t\t}\n\t\tif(i%10 == 9){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tprintf(\"%d\",starts_one_ends(n));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/84", "prompt": "/*\nGiven a po siti ve int e ger N,  return t he total sum of its d igits in binary . \n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N integer\n         Constraints: 0  N  10000.\nOutput:\n     a string of binary number\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(int N){\n", "canonical_solution": "    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(1000) == \"1\");\n    assert (solve(150) == \"110\");\n    assert (solve(147) == \"1100\");\n    assert (solve(333) == \"1001\");\n    assert (solve(963) == \"10010\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n", "example_test": "", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*\nGiven a po siti ve int e ger N,  return t he total sum of its d igits in binary. \n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N integer\n         Constraints: 0  N  10000.\nOutput:\n     a string of binary number\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(int N){\n    string s = \"\";\n    while(N > 0){\n        s = (char)(N%2 + '0') + s;\n        N = N/2;\n    }\n    return s;\n}\nint main(){\n    int N;\n    cin>>N;\n    cout<<solve(N);\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/85", "prompt": "/*\nGiven a no n-em pty ve c tor of  integers  lst. add the even el ements that are at odd indices..\n\n\nExamples:\n    add({4, 2, 6, 7}) ==> 2 \n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add(vector<int> lst){\n", "canonical_solution": "    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add({4, 88}) == 88);\n    assert (add({4, 5, 6, 7, 2, 122}) == 122);\n    assert (add({4, 0, 6, 7}) == 0);\n    assert (add({4, 4, 6, 8}) == 12);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add({4, 2, 6, 7}) == 2);\n}\n", "entry_point": "add", "seed": 1, "perturbed": true, "gc": "/*\nGiven a no n-em pty ve c tor of  integers  lst. add the even el ements that are at odd indices..\n\n\nExamples:\n    add({4, 2, 6, 7}) ==> 2 \n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add(vector<int> lst){\n    int sum = 0;\n    for(int i=0;i<lst.size();i++){\n        sum += lst[i];\n        if(i%2 == 1){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\nint main(){\n    vector<int> lst;\n    int n;\n    while(scanf(\"%d\", &n)!= EOF){\n        lst.clear();\n        for(int i=0;i<n;i++){\n            int x;\n            scanf(\"%d\", &x);\n            lst.push_back(x);\n        }\n        printf(\"%d\\n\", add(lst));\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/86", "prompt": "/*\nWrite a fu ncti on tha t  takes  a string  and returns an order ed version of i t .\nOrdered version o f string, is a string  where allw o rds (separatedby space)a re replaced by anew word wh er e all the characters a rranged in\nascending order based o n ascii value.\nNote:  Youshould keep the or d er ofwords and blank spaces in the sent ence.\n\nFor example:\nanti_shuffle(\"Hi\") returns \"Hi\"\nanti_shuffle(\"hello\") returns \"ehllo\"\nanti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring anti_shuffle(string s){\n", "canonical_solution": "    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (anti_shuffle(\"Hi\") == \"Hi\");\n    assert (anti_shuffle(\"hello\") == \"ehllo\");\n    assert (anti_shuffle(\"number\") == \"bemnru\");\n    assert (anti_shuffle(\"abcd\") == \"abcd\");\n    assert (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\");\n    assert (anti_shuffle(\"\") == \"\");\n    assert (anti_shuffle(\"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (anti_shuffle(\"Hi\") == \"Hi\");\n    assert (anti_shuffle(\"hello\") == \"ehllo\");\n    assert (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\");\n}\n", "entry_point": "anti_shuffle", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on tha t  takes  a string  and returns an order ed version of i t.\nOrdered version o f string, is a string  where allw o rds (separatedby space)a re replaced by anew word wh er e all the characters a rranged in\nascending order based o n ascii value.\nNote:  Youshould keep the or d er ofwords and blank spaces in the sent ence.\n\nFor example:\nanti_shuffle(\"Hi\") returns \"Hi\"\nanti_shuffle(\"hello\") returns \"ehllo\"\nanti_shuffle(\"Hello World!!!\") returns \"Hello!!!Wdlor\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring anti_shuffle(string s){\n    string temp;\n    int i=0;\n    int j=0;\n    while(i<s.length()){\n        if(s[i]!=' '){\n            temp+=s[i];\n            i++;\n        }\n        else{\n            while(j<s.length() && s[j]==' '){\n                j++;\n            }\n            if(j<s.length()){\n                temp+=s[j];\n                j++;\n            }\n            i++;\n        }\n    }\n    return temp;\n}\nint main(){\n    string s;\n    cin>>s;\n    cout<<anti_shuffle(s);\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/87", "prompt": "/*\nYou are gi vena 2 di m ension al data,as a nested vectors,which is simila r  to matrix, however , unlikematrices,\nea ch row mayc o ntaina differe nt numbero f columns.\nGivenlst, and in te ger x, find integers x  in the vector,\nand return vectorof vectors, {{x1, y1 }, {x 2, y2} ...} such t h at\neach vector is a coordinate - {row, c olumns}, starting with 0.\nSo rt coordinates initially  byrows in as cending order.\nAl so, sort coordinates of the ro w by columns in descending ord er. \n\nExamples:\nget_row({\n  {1,2,3,4,5,6},\n  {1,2,3,4,1,6},\n  {1,2,3,4,5,1}\n}, 1) == {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nget_row({}, 1) == {}\nget_row({{}, {1}, {1, 2, 3}}, 3) == {{2, 2}}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n", "canonical_solution": "    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}}, 1) , {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6}}, 2) , {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,1,3,4,5,6},\n        {1,2,1,4,5,6},\n        {1,2,3,1,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}\n    }, 1) , {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}}));\n    assert (issame(get_row({}, 1) , {}));\n    assert (issame(get_row({{1}}, 2) , {}));\n    assert (issame(get_row({{}, {1}, {1, 2, 3}}, 3) , {{2, 2}}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}}, 1) , {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}));\n    assert (issame(get_row({}, 1) , {}));\n    assert (issame(get_row({{}, {1}, {1, 2, 3}}, 3) , {{2, 2}}));\n}\n", "entry_point": "get_row", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena 2 di m ension al data,as a nested vectors,which is simila r  to matrix, however, unlikematrices,\nea ch row mayc o ntaina differe nt numbero f columns.\nGivenlst, and in te ger x, find integers x  in the vector,\nand return vectorof vectors, {{x1, y1 }, {x 2, y2}...} such t h at\neach vector is a coordinate - {row, c olumns}, starting with 0.\nSo rt coordinates initially  byrows in as cending order.\nAl so, sort coordinates of the ro w by columns in descending ord er. \n\nExamples:\nget_row({\n  {1,2,3,4,5,6},\n  {1,2,3,4,1,6},\n  {1,2,3,4,5,1}\n}, 1) == {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nget_row({}, 1) == {}\nget_row({{}, {1}, {1, 2, 3}}, 3) == {{2, 2}}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n\tvector<vector<int>> res;\n\tfor(int i = 0; i < lst.size(); i++){\n\t\tvector<int> row;\n\t\tfor(int j = 0; j < lst[i].size(); j++){\n\t\t\trow.push_back(lst[i][j]);\n\t\t}\n\t\tres.push_back(row);\n\t}\n\treturn res;\n}\nint main(){\n\tvector<vector<int>> lst = {\n\t\t{1,2,3,4,5,6},\n\t\t{1,2,3,4,1,6},\n\t\t{1,2,3,4,5,1}\n\t};\n\tvector<vector<int>> res = get_row(lst, 1);\n\tfor(int i = 0; i < res.size(); i++){\n\t\tfor(int j = 0; j < res[i].size(); j++){\n\t\t\tprintf(\"%d \", res[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/88", "prompt": "/*\nGiven a ve ctor  of no n -negat ive integ ers, return a copy of  the given vect o r after sorting,\nyo u will sort the given  vector ina s cending order i f the sum( first index value, last inde xvalue) is odd,\nor sort  it in descending order if the sum ( first index value,  last  index value) is e v en.\n\nNote:\n* don't change the given vect or.\n\nExamples:\n* sort_vector({}) => {}\n* sort_vector({5}) => {5}\n* sort_vector({2, 4, 3, 0, 1, 5}) => {0, 1, 2, 3, 4, 5}\n* sort_vector({2, 4, 3, 0, 1, 5, 6}) => {6, 5, 4, 3, 2, 1, 0}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_array(vector<int> array){\n", "canonical_solution": "    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({5}) , {5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5}) , {0, 1, 2, 3, 4, 5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5, 6}) , {6, 5, 4, 3, 2, 1, 0}));\n    assert (issame(sort_array({2, 1}) , {1, 2}));\n    assert (issame(sort_array({15, 42, 87, 32 ,11, 0}) , {0, 11, 15, 32, 42, 87}));\n    assert (issame(sort_array({21, 14, 23, 11}) , {23, 21, 14, 11}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({5}) , {5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5}) , {0, 1, 2, 3, 4, 5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5, 6}) , {6, 5, 4, 3, 2, 1, 0}));\n}\n", "entry_point": "sort_array", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ve ctor  of no n -negat ive integ ers, return a copy of  the given vect o r after sorting,\nyo u will sort the given  vector ina s cending order i f the sum( first index value, last inde xvalue) is odd,\nor sort  it in descending order if the sum ( first index value,  last  index value) is e v en.\n\nNote:\n* don't change the given vect or.\n\nExamples:\n* sort_vector({}) => {}\n* sort_vector({5}) => {5}\n* sort_vector({2, 4, 3, 0, 1, 5}) => {0, 1, 2, 3, 4, 5}\n* sort_vector({2, 4, 3, 0, 1, 5, 6}) => {6, 5, 4, 3, 2, 1, 0}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_array(vector<int> array){\n\tint i,j,k;\n\tvector<int> result;\n\tfor(i=0;i<array.size();i++){\n\t\tfor(j=i+1;j<array.size();j++){\n\t\t\tif(array[i]+array[j]%2==0){\n\t\t\t\tresult.push_back(array[i]);\n\t\t\t\tresult.push_back(array[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(array[i]+array[j]%2==1){\n\t\t\t\tresult.push_back(array[j]);\n\t\t\t\tresult.push_back(array[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tint n;\n\tvector<int> array;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tarray.push_back(a);\n\t}\n\tvector<int> result=sort_array(array);\n\tfor(int i=0;i<result.size();i++){\n\t\tprintf(\"%d \",result[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/89", "prompt": "/*\nCreate af unct ion en c rypt t hat takes  a string as an argum ent and\nreturns a string encryptedwith thealphabet bei ng rotated.The alphabet sh ould be ro t ated in a mannersuch that t he  letters \nshift down b y two multipliedto two places.\nFor example:\nencrypt(\"hi\") returns \"lm\"\nencrypt(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt(\"gf\") returns \"kj\"\nencrypt(\"et\") returns \"ix\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encrypt(string s){\n", "canonical_solution": "    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encrypt(\"hi\") == \"lm\");\n    assert (encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n    assert (encrypt(\"gf\") == \"kj\");\n    assert (encrypt(\"et\") == \"ix\");\n    assert (encrypt(\"faewfawefaewg\")==\"jeiajeaijeiak\");\n    assert (encrypt(\"hellomyfriend\")==\"lippsqcjvmirh\");\n    assert (encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n    assert (encrypt(\"a\")==\"e\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encrypt(\"hi\") == \"lm\");\n    assert (encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n    assert (encrypt(\"gf\") == \"kj\");\n    assert (encrypt(\"et\") == \"ix\");\n}\n", "entry_point": "encrypt", "seed": 1, "perturbed": true, "gc": "/*\nCreate af unct ion en c rypt t hat takes  a string as an argum ent and\nreturns a string encryptedwith thealphabet bei ng rotated.The alphabet sh ould be ro t ated in a mannersuch that t he  letters \nshift down b y two multipliedto two places.\nFor example:\nencrypt(\"hi\") returns \"lm\"\nencrypt(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt(\"gf\") returns \"kj\"\nencrypt(\"et\") returns \"ix\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encrypt(string s){\n\tstring a = \"\";\n\tfor(int i=0;i<s.length();i++){\n\t\ta = a + s[i];\n\t}\n\tint n = a.length();\n\tint m = n/2;\n\tint k = n%2;\n\tstring c = \"\";\n\tfor(int i=0;i<m;i++){\n\t\tc = c + a[i];\n\t}\n\tif(k == 0){\n\t\tc = c + a[n-1];\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tc = c + a[i+m];\n\t}\n\treturn c;\n}\nint main(){\n\tstring s = \"\";\n\tstring c = \"\";\n\twhile(cin>>s){\n\t\tc = encrypt(s);\n\t\tcout<<c<<endl;\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/9", "prompt": "/*\nFrom a giv en v ectoro f inte gers, gen erate a vector of rol ling maximum el e ment found until gi ven moment\nin the seq uence.\n>>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> rolling_max(vector<int> numbers){\n", "canonical_solution": "    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(rolling_max({}),{}));\n    assert (issame(rolling_max({1, 2, 3, 4}) , {1, 2, 3, 4}));\n     assert (issame(rolling_max({4, 3, 2, 1}),{4, 4, 4, 4}));\n      assert (issame(rolling_max({3, 2, 3, 100, 3}) ,{3, 3, 3, 100, 100}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(rolling_max({1, 2, 3, 2, 3, 4, 2}),{1, 2, 3, 3, 3, 4, 4}));\n}\n", "entry_point": "rolling_max", "seed": 1, "perturbed": true, "gc": "/*\nFrom a giv en v ectoro f inte gers, gen erate a vector of rol ling maximum el e ment found until gi ven moment\nin the seq uence.\n>>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> result;\n    int max_element = numbers[0];\n    int index = 0;\n    for(int i = 1; i < numbers.size(); i++){\n        if(numbers[i] > max_element){\n            max_element = numbers[i];\n            index = i;\n        }\n    }\n    for(int i = 0; i < index; i++){\n        result.push_back(numbers[i]);\n    }\n    for(int i = index + 1; i < numbers.size(); i++){\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n\nint main(){\n    vector<int> numbers = {1, 2, 3, 2, 3, 4, 2};\n    vector<int> result = rolling_max(numbers);\n    for(int i = 0; i < result.size(); i++){\n        printf(\"%d \", result[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "CPP/90", "prompt": "/*\nYou are gi vena vect o r of i ntegers.Write a function next _smallest() tha t  returns the 2nd sm allest element of the  vector.\nRet u rn None if ther e is no su c h element.\n\nnext_smallest({1 ,2, 3, 4, 5}) == 2\nnext _smallest({5, 1,4, 3, 2}) == 2\nne xt_smallest({}) == N one\nn ext_smallest({1, 1 } ) == None\n*/\n#include<stdio.h>\n#include< vector>\n#include<algorithm>using namespace std;\nint  next_smallest (vector<int> lst) {\n", "canonical_solution": "    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert (next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert (next_smallest({}) == -1);\n    assert (next_smallest({1, 1}) == -1);\n    assert (next_smallest({1,1,1,1,0}) == 1);\n    assert (next_smallest({-35, 34, 12, -45}) == -35);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert (next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert (next_smallest({}) == -1);\n    assert (next_smallest({1, 1}) == -1);\n}\n", "entry_point": "next_smallest", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena vect o r of i ntegers.Write a function next _smallest() tha t  returns the 2nd sm allest element of the  vector.\nRet u rn None if ther e is no su c h element.\n\nnext_smallest({1,2, 3, 4, 5}) == 2\nnext _smallest({5, 1,4, 3, 2}) == 2\nne xt_smallest({}) == N one\nn ext_smallest({1, 1 } ) == None\n*/\n#include<stdio.h>\n#include< vector>\n#include<algorithm>using namespace std;\nint  next_smallest (vector<int> lst) {\n\tint i = 0;\n\tint j = lst.size() - 1;\n\twhile(i < j) {\n\t\tint mid = (i + j) / 2;\n\t\tif(lst[mid] < lst[i]) {\n\t\t\tj = mid;\n\t\t} else {\n\t\t\ti = mid + 1;\n\t\t}\n\t}\n\treturn lst[i];\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> lst(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &lst[i]);\n\t}\n\tprintf(\"%d\\n\", next_smallest(lst));\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/91", "prompt": "/*\nYou'll begive n a st r ing of  words, a nd your task is to co unt the numbero f boredoms. A bored om is a sentence that  starts with the word \"I\".\nS entences a r e delimited by '.', '?' or ' !' .\n\nFor example:\n>>> is_bored(\"Hello world\")\n0\n>>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n1\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint is_bored(string S){\n", "canonical_solution": "    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_bored(\"Hello world\") == 0);\n    assert (is_bored(\"Is the sky blue?\") == 0);\n    assert (is_bored(\"I love It !\") == 1);\n    assert (is_bored(\"bIt\") == 0);\n    assert (is_bored(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert (is_bored(\"You and I are going for a walk\") == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_bored(\"Hello world\") == 0);\n    assert (is_bored(\"The sky is blue. The sun is shining. I love this weather\") == 1);\n}\n", "entry_point": "is_bored", "seed": 1, "perturbed": true, "gc": "/*\nYou'll begive n a st r ing of  words, a nd your task is to co unt the numbero f boredoms. A bored om is a sentence that  starts with the word \"I\".\nS entences a r e delimited by '.', '?' or '!'.\n\nFor example:\n>>> is_bored(\"Hello world\")\n0\n>>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n1\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint is_bored(string S){\n    int i=0,j=0,k=0;\n    while(i<S.length()){\n        if(S[i]==' ')\n            i++;\n        else if(S[i]=='.' || S[i]=='?' || S[i]=='!'){\n            i++;\n            j=i;\n            while(S[j]!=''&& S[j]!='.' && S[j]!='?' && S[j]!='!')\n                j++;\n            if(S[j]==' ')\n                j++;\n            k=j;\n            while(S[k]!=''&& S[k]!='.' && S[k]!='?' && S[k]!='!')\n                k++;\n            if(S[k]==' ')\n                k++;\n            if(S[i]=='.' && S[j]=='.' && S[k]=='.')\n                return 1;\n        }\n        i++;\n    }\n    return 0;\n}\nint main(){\n    string S;\n    while(getline(cin,S)){\n        cout<<is_bored(S)<<endl;\n    }\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "CPP/92", "prompt": "/*\nCreate af unct ion th a t take s 3 numbe rs.\nReturns true if o ne of the numbe r s is equal to the s um of the other two,and all numb e rs are integers .\nReturnsf alse in any other cases.\n\nExamples\nany_int(5, 2, 7)  true\n\nany_int(3, 2, 2)  false\n\nany_int(3, -2, 1)  true\n\nany_int(3.6, -2.2, 2)  false\n\n\n\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool any_int(float a,float b,float c){\n", "canonical_solution": "    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (any_int(2, 3, 1)==true);\n    assert (any_int(2.5, 2, 3)==false);\n    assert (any_int(1.5, 5, 3.5)==false);\n    assert (any_int(2, 6, 2)==false);\n    assert (any_int(4, 2, 2)==true);\n    assert (any_int(2.2, 2.2, 2.2)==false);\n    assert (any_int(-4, 6, 2)==true);\n    assert (any_int(2,1,1)==true);\n    assert (any_int(3,4,7)==true);\n    assert (any_int(3.01,4,7)==false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (any_int(5, 2, 7)==true);\n    assert (any_int(3, 2, 2)==false);\n    assert (any_int(3, -2, 1)==true);\n    assert (any_int(3.6, -2.2, 2)==false);\n}\n", "entry_point": "any_int", "seed": 1, "perturbed": true, "gc": "/*\nCreate af unct ion th a t take s 3 numbe rs.\nReturns true if o ne of the numbe r s is equal to the s um of the other two,and all numb e rs are integers.\nReturnsf alse in any other cases.\n\nExamples\nany_int(5, 2, 7)  true\n\nany_int(3, 2, 2)  false\n\nany_int(3, -2, 1)  true\n\nany_int(3.6, -2.2, 2)  false\n\n\n\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool any_int(float a,float b,float c){\n\tif(a==b&&a==c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a==(int)b&&(int)a==(int)c)\n\t\treturn true;\n\tif(a==b&&a==c&&(int)a", "passed": 0, "run_status": 2}
{"task_id": "CPP/93", "prompt": "/*\nWrite a fu ncti on tha t  takes  a messag e, and encodes in suc h a \nway that i t  swaps case of allletters,replaces all  vowels int he message with  the lette r  that appears 2 places ahead  o f that \nvowel in the e nglish alphabet.\nAssume only lett ers. \n\nExamples:\n>>> encode('test\")\n\"TGST\"\n>>> encode(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring encode(string message){\n", "canonical_solution": "    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encode(\"TEST\") == \"tgst\");\n    assert (encode(\"Mudasir\") == \"mWDCSKR\");\n    assert (encode(\"YES\") == \"ygs\");\n    assert (encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n    assert (encode(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\");\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encode(\"test\") == \"TGST\");\n    assert (encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n}\n", "entry_point": "encode", "seed": 1, "perturbed": true, "gc": "/*\nWrite a fu ncti on tha t  takes  a messag e, and encodes in suc h a \nway that i t  swaps case of allletters,replaces all  vowels int he message with  the lette r  that appears 2 places ahead  o f that \nvowel in the e nglish alphabet.\nAssume only lett ers. \n\nExamples:\n>>> encode('test\")\n\"TGST\"\n>>> encode(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring encode(string message){\n    string result=\"\";\n    for(int i=0;i<message.length();i++){\n        if(message[i]>='a' && message[i]<='z'){\n            result+=message[i]+message[i+1];\n            i++;\n        }\n        else if(message[i]>='A' && message[i]<='Z'){\n            result+=message[i]+message[i+1];\n            i++;\n        }\n        else if(message[i]>='0' && message[i]<='9'){\n            result+=message[i]+message[i+1];\n            i++;\n        }\n        else if(message[i]==' '){\n            result+=\" \";\n        }\n        else{\n            result+=message[i];\n        }\n    }\n    return result;\n}\nint main(){\n    string message;\n    cin>>message;\n    cout<<encode(message)<<endl;\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/94", "prompt": "/*\nYou are gi vena vect o r of i ntegers.You need to find thelargest prime v a lue and return thesum of its digits.\n\nExamples:\nFor lst = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3} the output should be 10\nFor lst = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1} the output should be 25\nFor lst = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3} the output should be 13\nFor lst = {0,724,32,71,99,32,6,0,5,91,83,0,5,6} the output should be 11\nFor lst = {0,81,12,3,1,21} the output should be 3\nFor lst = {0,8,1,2,1,7} the output should be 7\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint skjkasdkd(vector<int> lst){\n", "canonical_solution": "    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) == 10);\n    assert (skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) == 25);\n    assert (skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) == 13);\n    assert (skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) == 11);\n    assert (skjkasdkd({0,81,12,3,1,21}) == 3);\n    assert (skjkasdkd({0,8,1,2,1,7}) == 7);\n    assert (skjkasdkd({8191}) == 19);\n    assert (skjkasdkd({8191, 123456, 127, 7}) == 19);\n    assert (skjkasdkd({127, 97, 8192}) == 10);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\n#undef NDEBUG\n#include<assert.h>\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) == 10);\n    assert (skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) == 25);\n    assert (skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) == 13);\n    assert (skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) == 11);\n    assert (skjkasdkd({0,81,12,3,1,21}) == 3);\n    assert (skjkasdkd({0,8,1,2,1,7}) == 7);\n}\n", "entry_point": "skjkasdkd", "seed": 1, "perturbed": true, "gc": "/*\nYou are gi vena vect o r of i ntegers.You need to find thelargest prime v a lue and return thesum of its digits.\n\nExamples:\nFor lst = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3} the output should be 10\nFor lst = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1} the output should be 25\nFor lst = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3} the output should be 13\nFor lst = {0,724,32,71,99,32,6,0,5,91,83,0,5,6} the output should be 11\nFor lst = {0,81,12,3,1,21} the output should be 3\nFor lst = {0,8,1,2,1,7} the output should be 7\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint skjkasdkd(vector<int> lst){\n\tint sum=0;\n\tfor(int i=0;i<lst.size();i++){\n\t\tsum+=lst[i];\n\t}\n\treturn sum;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> lst;\n\tfor(int i=0;i<n;i++){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tlst.push_back(a);\n\t}\n\tint ans=skjkasdkd(lst);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/95", "prompt": "/*\nGiven a ma p, r eturnt rue if  all keys  are strings in lower  \ncase or all k e ys are strings in u pper case, else retur n false.\nThe function should  return fa l se is the given map is empty .\nExamples:\ncheck_map_case({{\"a\",\"apple\"}, {\"b\",\"banana\"}}) should return true.\ncheck_map_case({{\"a\",\"apple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) should return false.\ncheck_map_case({{\"a\",\"apple\"}, {\"8\",\"banana\"}, {\"a\",\"apple\"}}) should return false.\ncheck_map_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) should return false.\ncheck_map_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) should return true.\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nbool check_dict_case(map<string,string> dict){\n", "canonical_solution": "    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"b\",\"banana\"}}) == true);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}}) == false);\n    assert (check_dict_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false);\n    assert (check_dict_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) == true  );\n    assert (check_dict_case({{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"} }) == true  );\n    assert (check_dict_case({}) == false);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"b\",\"banana\"}}) == true);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}}) == false);\n    assert (check_dict_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false);\n    assert (check_dict_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) == true  );\n}\n", "entry_point": "check_dict_case", "seed": 1, "perturbed": true, "gc": "/*\nGiven a ma p, r eturnt rue if  all keys  are strings in lower  \ncase or all k e ys are strings in u pper case, else retur n false.\nThe function should  return fa l se is the given map is empty.\nExamples:\ncheck_map_case({{\"a\",\"apple\"}, {\"b\",\"banana\"}}) should return true.\ncheck_map_case({{\"a\",\"apple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) should return false.\ncheck_map_case({{\"a\",\"apple\"}, {\"8\",\"banana\"}, {\"a\",\"apple\"}}) should return false.\ncheck_map_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) should return false.\ncheck_map_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) should return true.\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nbool check_dict_case(map<string,string> dict){\n\tfor(auto it=dict.begin();it!=dict.end();it++){\n\t\tif(it->second.length()>1){\n\t\t\tif(it->second[0]>='A'&&it->second[0]<='Z'){\n\t\t\t\tit->second[0]+=32;\n\t\t\t}\n\t\t\tif(it->second[it->second.length()-1]>='A'&&it->second[it->second.length()-1]<='Z'){\n\t\t\t\tit->second[it->second.length()-1]+=32;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto it=dict.begin();it!=dict.end();it++){\n\t\tif(it->second.length()>1){\n\t\t\tif(it->second[0]>='a'&&it->second[0]<='z'){\n\t\t\t\tit->second[0]+=32;\n\t\t\t}\n\t\t\tif(it->second[it->second.length()-1]>='a'&&it->second[it->second.length()-1]<='z'){\n\t\t\t\tit->second[it->second.length()-1]+=32;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto it=dict.begin();it!=dict.end();it++){\n\t\tif(it->second.length()>1){\n\t\t\tif(it->second[0]>='0'&&it->second[0]<='9'){\n\t\t\t\tit->second[0]+=32;\n\t\t\t}\n\t\t\tif(it->second[it->second.length()-1]>='0'&&it->second[it->second.length()-1]<='9'){\n\t\t\t\tit->second[it->second.length()-1]+=32;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto it=dict.begin();it!=dict.end();it++){\n\t\tif(it->second.length()>1){\n\t\t\tif(it->second[0]>='0'&&it->second[0]<='9'){\n\t\t\t\tit->second[0]+=32;\n\t\t\t}\n\t\t\tif(it->second[it->second.length()-1]>='0'&&it->second[it->second.length()-1]<='9'){\n\t\t\t\tit->second[it->second.length()-1]+=32;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto it=dict.begin();it!=dict.end();it++){\n\t\tif(it->second.length()>1){\n\t\t\tif(it->second[0]>='0'&&it->second[0]<='9'){\n\t\t\t\tit->second[0]+=32;\n\t\t\t}\n\t\t\tif(it->second[it->second.length()-1]>='0'&&it->second[it->second.length()-1]<='9'){\n\t\t\t\tit->second[it->second.length()-1]+=32;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto it=dict.begin();it!=dict.end();it++){\n\t\tif(it->second.length()>1){\n\t\t\tif(it->second[0]>='0'&&it->second[0]<='9'){\n\t\t\t\tit->second[0]+=32;\n\t\t\t}\n\t\t\tif(it->second[it->second.length()-1]>='0'&&it->second[it->second.length()-1]<='9'){\n\t\t\t\tit->second[it->second.length()-1]+=32;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto it=dict.begin();it!=dict.end();it++){\n\t\tif(it->second.length()>1){\n\t\t\tif(it->second[0]>='0'&&it->second[0]<='9'){\n\t\t\t\tit->second[0]+=32;\n\t\t\t}\n\t\t\tif(it->second[it->second.length()-1]>='0'&&it->second[it->second.length()-1]<='9'){\n\t\t\t\tit->second[it->second.length()-1]+=32;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto it=dict.begin();it!=dict.end();it++){\n\t\tif(it->second.length()>1){\n\t\t\tif(it->second[0]>='0'&&it->second[0]<='9'){\n\t\t\t\tit->second[0]+=32;\n\t\t\t}\n\t\t\tif(it->second[it->second.length()-1]>='0'&&it->second[it->second.length()-1]<='9'){\n\t\t\t\tit->second[it->second.length()-1]+=32;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto it=dict.begin();it!=dict.end();it++){\n\t\tif(it->second.length()>1){\n\t\t\tif(it->second[0]>='0'&&it->second[0]<='9'){\n\t\t\t\tit->second[0]+=32;\n\t\t\t}\n\t\t\tif(it->second[it->second.length()-1]>='0'&&it->second[it->second.length()-1]<='9'){\n\t\t\t\tit->second[it->second.length()-1]+=32;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto it=dict.begin();it!=dict.end();it++){\n\t\tif", "passed": 0, "run_status": 2}
{"task_id": "CPP/96", "prompt": "/*\nImplementa fu nction that t akes an n on-negative integer a nd returns a ve c tor of the first nintegersthat are pri me numbersa n d less than n.\nfor example:\ncount_up_to(5) => {2,3}\ncount_up_to(11) => {2,3,5,7}\ncount_up_to(0) => {}\ncount_up_to(20) => {2,3,5,7,11,13,17,19}\ncount_up_to(1) => {}\ncount_up_to(18) => {2,3,5,7,11,13,17}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> count_up_to(int n){\n", "canonical_solution": "    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(count_up_to(5) , {2,3}));\n    assert (issame(count_up_to(6) , {2,3,5}));\n    assert (issame(count_up_to(7) , {2,3,5}));\n    assert (issame(count_up_to(10) , {2,3,5,7}));\n    assert (issame(count_up_to(0) , {}));\n    assert (issame(count_up_to(22) , {2,3,5,7,11,13,17,19}));\n    assert (issame(count_up_to(1) , {}));\n    assert (issame(count_up_to(18) , {2,3,5,7,11,13,17}));\n    assert (issame(count_up_to(47) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}));\n    assert (issame(count_up_to(101) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}));\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(count_up_to(5) , {2,3}));\n    assert (issame(count_up_to(11) , {2,3,5,7}));\n    assert (issame(count_up_to(0) , {}));\n    assert (issame(count_up_to(20) , {2,3,5,7,11,13,17,19}));\n    assert (issame(count_up_to(1) , {}));\n    assert (issame(count_up_to(18) , {2,3,5,7,11,13,17}));\n}\n", "entry_point": "count_up_to", "seed": 1, "perturbed": true, "gc": "/*\nImplementa fu nction that t akes an n on-negative integer a nd returns a ve c tor of the first nintegersthat are pri me numbersa n d less than n.\nfor example:\ncount_up_to(5) => {2,3}\ncount_up_to(11) => {2,3,5,7}\ncount_up_to(0) => {}\ncount_up_to(20) => {2,3,5,7,11,13,17,19}\ncount_up_to(1) => {}\ncount_up_to(18) => {2,3,5,7,11,13,17}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> count_up_to(int n){\n    vector<int> v;\n    for(int i=0;i<n;i++){\n        v.push_back(i);\n    }\n    return v;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> v = count_up_to(n);\n    for(int i=0;i<v.size();i++){\n        printf(\"%d \",v[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/97", "prompt": "/*\nCompletet he f unctio n  thattakes two  integers and returns  \nthe product o f  their unit digits. \nAssume the input isalways valid . \nExamples:\nmultiply(148, 412) should return 16.\nmultiply(19, 28) should return 72.\nmultiply(2020, 1851) should return 0.\nmultiply(14,-15) should return 20.\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nint multiply(int a,int b){\n", "canonical_solution": "    return (abs(a)%10)*(abs(b)%10);\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (multiply(148, 412) == 16                   );\n    assert (multiply(19, 28) == 72       );\n    assert (multiply(2020, 1851) == 0);\n    assert (multiply(14,-15) == 20   );\n    assert (multiply(76, 67) == 42    );\n    assert (multiply(17, 27) == 49    );\n    assert (multiply(0, 1) == 0);\n    assert (multiply(0, 0) == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (multiply(148, 412) == 16                   );\n    assert (multiply(19, 28) == 72       );\n    assert (multiply(2020, 1851) == 0);\n    assert (multiply(14,-15) == 20   );\n}\n", "entry_point": "multiply", "seed": 1, "perturbed": true, "gc": "/*\nCompletet he f unctio n  thattakes two  integers and returns  \nthe product o f  their unit digits. \nAssume the input isalways valid. \nExamples:\nmultiply(148, 412) should return 16.\nmultiply(19, 28) should return 72.\nmultiply(2020, 1851) should return 0.\nmultiply(14,-15) should return 20.\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nint multiply(int a,int b){\n    int i,j,k,temp,temp1,temp2;\n    temp=a;\n    temp1=b;\n    temp2=0;\n    for(i=0;i<=9;i++){\n        temp=temp*10;\n        temp1=temp1*10;\n        temp2=temp2+temp*temp1;\n    }\n    return temp2;\n}\nint main(){\n    int a,b;\n    printf(\"Enter the first number\\n\");\n    scanf(\"%d\",&a);\n    printf(\"Enter the second number\\n\");\n    scanf(\"%d\",&b);\n    printf(\"The product of %d and %d is %d\\n\",a,b,multiply(a,b));\n    return 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/98", "prompt": "/*\nGiven a st ring  s, co u nt the  number o f uppercase vowels in  even indices.\n\nFor example:\ncount_upper(\"aBCdEf\") returns 1\ncount_upper(\"abcdefg\") returns 0\ncount_upper(\"dBBE\") returns 0\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint count_upper(string s){\n", "canonical_solution": "    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_upper(\"aBCdEf\")  == 1);\n    assert (count_upper(\"abcdefg\") == 0);\n    assert (count_upper(\"dBBE\") == 0);\n    assert (count_upper(\"B\")  == 0);\n    assert (count_upper(\"U\")  == 1);\n    assert (count_upper(\"\") == 0);\n    assert (count_upper(\"EEEE\") == 2);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_upper(\"aBCdEf\")  == 1);\n    assert (count_upper(\"abcdefg\") == 0);\n    assert (count_upper(\"dBBE\") == 0);\n}\n", "entry_point": "count_upper", "seed": 1, "perturbed": true, "gc": "/*\nGiven a st ring  s, co u nt the  number o f uppercase vowels in  even indices.\n\nFor example:\ncount_upper(\"aBCdEf\") returns 1\ncount_upper(\"abcdefg\") returns 0\ncount_upper(\"dBBE\") returns 0\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint count_upper(string s){\n\tint count = 0;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(isupper(s[i])){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main(){\n\tstring s;\n\twhile(cin >> s){\n\t\tcout << count_upper(s) << endl;\n\t}\n\treturn 0;\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "CPP/99", "prompt": "/*\nCreate af unct ion th a t take s a value  (string) representin g a number\nandr eturns the closestinteger to it. If the  number ise q uidistant\nfromtwo intege r s, round it awayfrom zero.\nE xamples\n>>> closest_integer(\"10\")\n10\n>>> closest_integer(\"15.3\")\n15\n\nNote:\nRounding away from zero means that if the given number is equidistant\nfrom two integers, the one you should return is the one that is the\nfarthest from zero. For example closest_integer(\"14.5\") should\nreturn 15 and closest_integer(\"-14.5\") should return -15.\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nint closest_integer(string value){\n", "canonical_solution": "    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (closest_integer(\"10\") == 10);\n    assert (closest_integer(\"14.5\") == 15);\n    assert (closest_integer(\"-15.5\") == -16);\n    assert (closest_integer(\"15.3\") == 15);\n    assert (closest_integer(\"0\") == 0);\n}\n", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (closest_integer(\"10\") == 10);\n    assert (closest_integer(\"15.3\") == 15);\n}\n", "entry_point": "closest_integer", "seed": 1, "perturbed": true, "gc": "/*\nCreate af unct ion th a t take s a value  (string) representin g a number\nandr eturns the closestinteger to it. If the  number ise q uidistant\nfromtwo intege r s, round it awayfrom zero.\nE xamples\n>>> closest_integer(\"10\")\n10\n>>> closest_integer(\"15.3\")\n15\n\nNote:\nRounding away from zero means that if the given number is equidistant\nfrom two integers, the one you should return is the one that is the\nfarthest from zero. For example closest_integer(\"14.5\") should\nreturn 15 and closest_integer(\"-14.5\") should return -15.\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nint closest_integer(string value){\n\tint i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b", "passed": 0, "run_status": 2}
